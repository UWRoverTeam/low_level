ARM GAS  /tmp/ccVWLGiI.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"bno055.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.bno055_init,"ax",%progbits
  19              		.align	2
  20              		.global	bno055_init
  21              		.thumb
  22              		.thumb_func
  24              	bno055_init:
  25              	.LFB0:
  26              		.file 1 "Src/bno055.c"
   1:Src/bno055.c  **** /*
   2:Src/bno055.c  **** *
   3:Src/bno055.c  **** ****************************************************************************
   4:Src/bno055.c  **** * Copyright (C) 2015 - 2016 Bosch Sensortec GmbH
   5:Src/bno055.c  **** *
   6:Src/bno055.c  **** * File : bno055.c
   7:Src/bno055.c  **** *
   8:Src/bno055.c  **** * Date : 2016/03/14
   9:Src/bno055.c  **** *
  10:Src/bno055.c  **** * Revision : 2.0.3 $
  11:Src/bno055.c  **** *
  12:Src/bno055.c  **** * Usage: Sensor Driver file for BNO055 sensor
  13:Src/bno055.c  **** *
  14:Src/bno055.c  **** ****************************************************************************
  15:Src/bno055.c  **** * \section License
  16:Src/bno055.c  **** *
  17:Src/bno055.c  **** * Redistribution and use in source and binary forms, with or without
  18:Src/bno055.c  **** * modification, are permitted provided that the following conditions are met:
  19:Src/bno055.c  **** *
  20:Src/bno055.c  **** *   Redistributions of source code must retain the above copyright
  21:Src/bno055.c  **** *   notice, this list of conditions and the following disclaimer.
  22:Src/bno055.c  **** *
  23:Src/bno055.c  **** *   Redistributions in binary form must reproduce the above copyright
  24:Src/bno055.c  **** *   notice, this list of conditions and the following disclaimer in the
  25:Src/bno055.c  **** *   documentation and/or other materials provided with the distribution.
  26:Src/bno055.c  **** *
  27:Src/bno055.c  **** *   Neither the name of the copyright holder nor the names of the
  28:Src/bno055.c  **** *   contributors may be used to endorse or promote products derived from
  29:Src/bno055.c  **** *   this software without specific prior written permission.
  30:Src/bno055.c  **** *
  31:Src/bno055.c  **** * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
  32:Src/bno055.c  **** * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
ARM GAS  /tmp/ccVWLGiI.s 			page 2


  33:Src/bno055.c  **** * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  34:Src/bno055.c  **** * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  35:Src/bno055.c  **** * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
  36:Src/bno055.c  **** * OR CONTRIBUTORS BE LIABLE FOR ANY
  37:Src/bno055.c  **** * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  38:Src/bno055.c  **** * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
  39:Src/bno055.c  **** * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  40:Src/bno055.c  **** * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  41:Src/bno055.c  **** * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  42:Src/bno055.c  **** * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  43:Src/bno055.c  **** * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  44:Src/bno055.c  **** * ANY WAY OUT OF THE USE OF THIS
  45:Src/bno055.c  **** * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
  46:Src/bno055.c  **** *
  47:Src/bno055.c  **** * The information provided is believed to be accurate and reliable.
  48:Src/bno055.c  **** * The copyright holder assumes no responsibility
  49:Src/bno055.c  **** * for the consequences of use
  50:Src/bno055.c  **** * of such information nor for any infringement of patents or
  51:Src/bno055.c  **** * other rights of third parties which may result from its use.
  52:Src/bno055.c  **** * No license is granted by implication or otherwise under any patent or
  53:Src/bno055.c  **** * patent rights of the copyright holder.
  54:Src/bno055.c  **** **************************************************************************/
  55:Src/bno055.c  **** 
  56:Src/bno055.c  **** /*********************************************************/
  57:Src/bno055.c  **** /*				INCLUDES	*/
  58:Src/bno055.c  **** /*******************************************************/
  59:Src/bno055.c  **** #include "bno055.h"
  60:Src/bno055.c  **** /*! file <BNO055 >
  61:Src/bno055.c  ****     brief <Sensor driver for BNO055> */
  62:Src/bno055.c  **** /*	STRUCTURE DEFINITIONS	*/
  63:Src/bno055.c  **** static struct bno055_t *p_bno055;
  64:Src/bno055.c  **** /*	 LOCAL FUNCTIONS	*/
  65:Src/bno055.c  **** /*!
  66:Src/bno055.c  ****  *	@brief
  67:Src/bno055.c  ****  *	This API is used for initialize
  68:Src/bno055.c  ****  *	bus read, bus write function pointers,device
  69:Src/bno055.c  ****  *	address,accel revision id, gyro revision id
  70:Src/bno055.c  ****  *	mag revision id, software revision id, boot loader
  71:Src/bno055.c  ****  *	revision id and page id
  72:Src/bno055.c  ****  *
  73:Src/bno055.c  ****  *	@param  bno055 - structure pointer
  74:Src/bno055.c  ****  *
  75:Src/bno055.c  ****  *
  76:Src/bno055.c  ****  *	@return results of bus communication function
  77:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
  78:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
  79:Src/bno055.c  ****  *
  80:Src/bno055.c  ****  *	@note While changing the parameter of the bno055_t
  81:Src/bno055.c  ****  *	consider the following point:
  82:Src/bno055.c  ****  *	Changing the reference value of the parameter
  83:Src/bno055.c  ****  *	will changes the local copy or local reference
  84:Src/bno055.c  ****  *	make sure your changes will not
  85:Src/bno055.c  ****  *	affect the reference value of the parameter
  86:Src/bno055.c  ****  *	(Better case don't change the reference value of the parameter)
  87:Src/bno055.c  ****  */
  88:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_init(struct bno055_t *bno055)
  89:Src/bno055.c  **** {
ARM GAS  /tmp/ccVWLGiI.s 			page 3


  27              		.loc 1 89 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 20
  35              		.cfi_offset 4, -20
  36              		.cfi_offset 5, -16
  37              		.cfi_offset 6, -12
  38              		.cfi_offset 7, -8
  39              		.cfi_offset 14, -4
  40 0002 0446     		mov	r4, r0
  41 0004 83B0     		sub	sp, sp, #12
  42              	.LCFI1:
  43              		.cfi_def_cfa_offset 32
  90:Src/bno055.c  **** 	/* Variable used to return value of
  91:Src/bno055.c  **** 	communication routine*/
  92:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
  93:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
  94:Src/bno055.c  **** 	u8 bno055_page_zero_u8 = BNO055_PAGE_ZERO;
  95:Src/bno055.c  **** 	/* Array holding the Software revision id
  96:Src/bno055.c  **** 	*/
  97:Src/bno055.c  **** 	u8 a_SW_ID_u8[BNO055_REV_ID_SIZE] = {
  98:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
  99:Src/bno055.c  **** 	/* stuct parameters are assign to bno055*/
 100:Src/bno055.c  **** 	p_bno055 = bno055;
  44              		.loc 1 100 0
  45 0006 3A4D     		ldr	r5, .L3
  93:Src/bno055.c  **** 	u8 bno055_page_zero_u8 = BNO055_PAGE_ZERO;
  46              		.loc 1 93 0
  47 0008 0026     		movs	r6, #0
 101:Src/bno055.c  **** 	/* Write the default page as zero*/
 102:Src/bno055.c  **** 	com_rslt = p_bno055->BNO055_BUS_WRITE_FUNC
  48              		.loc 1 102 0
  49 000a C768     		ldr	r7, [r0, #12]
  93:Src/bno055.c  **** 	u8 bno055_page_zero_u8 = BNO055_PAGE_ZERO;
  50              		.loc 1 93 0
  51 000c 8DF80260 		strb	r6, [sp, #2]
  94:Src/bno055.c  **** 	/* Array holding the Software revision id
  52              		.loc 1 94 0
  53 0010 8DF80360 		strb	r6, [sp, #3]
  97:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
  54              		.loc 1 97 0
  55 0014 8DF80460 		strb	r6, [sp, #4]
  56 0018 8DF80560 		strb	r6, [sp, #5]
  57              		.loc 1 102 0
  58 001c 0DF10302 		add	r2, sp, #3
  59 0020 0721     		movs	r1, #7
  60 0022 0123     		movs	r3, #1
  61 0024 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
  62              	.LVL1:
 100:Src/bno055.c  **** 	/* Write the default page as zero*/
  63              		.loc 1 100 0
  64 0026 2C60     		str	r4, [r5]
  65              		.loc 1 102 0
ARM GAS  /tmp/ccVWLGiI.s 			page 4


  66 0028 B847     		blx	r7
  67              	.LVL2:
 103:Src/bno055.c  **** 	(p_bno055->dev_addr,
 104:Src/bno055.c  **** 	BNO055_PAGE_ID_REG, &bno055_page_zero_u8, BNO055_GEN_READ_WRITE_LENGTH);
 105:Src/bno055.c  **** 	/* Read the chip id of the sensor from page
 106:Src/bno055.c  **** 	zero 0x00 register*/
 107:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC
  68              		.loc 1 107 0
  69 002a 2B68     		ldr	r3, [r5]
  70 002c 3146     		mov	r1, r6
  71 002e 0DF10202 		add	r2, sp, #2
  72 0032 1E69     		ldr	r6, [r3, #16]
 102:Src/bno055.c  **** 	(p_bno055->dev_addr,
  73              		.loc 1 102 0
  74 0034 0446     		mov	r4, r0
  75              	.LVL3:
  76              		.loc 1 107 0
  77 0036 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
  78 0038 0123     		movs	r3, #1
  79 003a B047     		blx	r6
  80              	.LVL4:
 108:Src/bno055.c  **** 	(p_bno055->dev_addr,
 109:Src/bno055.c  **** 	BNO055_CHIP_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 110:Src/bno055.c  **** 	p_bno055->chip_id = data_u8;
  81              		.loc 1 110 0
  82 003c 2B68     		ldr	r3, [r5]
  83 003e 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 111:Src/bno055.c  **** 	/* Read the accel revision id from page
 112:Src/bno055.c  **** 	zero 0x01 register*/
 113:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC
  84              		.loc 1 113 0
  85 0042 0121     		movs	r1, #1
 110:Src/bno055.c  **** 	/* Read the accel revision id from page
  86              		.loc 1 110 0
  87 0044 1A70     		strb	r2, [r3]
  88              		.loc 1 113 0
  89 0046 1E69     		ldr	r6, [r3, #16]
  90 0048 0DF10202 		add	r2, sp, #2
 107:Src/bno055.c  **** 	(p_bno055->dev_addr,
  91              		.loc 1 107 0
  92 004c 0444     		add	r4, r4, r0
  93              	.LVL5:
  94              		.loc 1 113 0
  95 004e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
  96 0050 0B46     		mov	r3, r1
  97 0052 B047     		blx	r6
  98              	.LVL6:
 114:Src/bno055.c  **** 	(p_bno055->dev_addr,
 115:Src/bno055.c  **** 	BNO055_ACCEL_REV_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 116:Src/bno055.c  **** 	p_bno055->accel_rev_id = data_u8;
  99              		.loc 1 116 0
 100 0054 2B68     		ldr	r3, [r5]
 101 0056 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 107:Src/bno055.c  **** 	(p_bno055->dev_addr,
 102              		.loc 1 107 0
 103 005a E4B2     		uxtb	r4, r4
 104              	.LVL7:
ARM GAS  /tmp/ccVWLGiI.s 			page 5


 105              		.loc 1 116 0
 106 005c 5A71     		strb	r2, [r3, #5]
 117:Src/bno055.c  **** 	/* Read the mag revision id from page
 118:Src/bno055.c  **** 	zero 0x02 register*/
 119:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC
 107              		.loc 1 119 0
 108 005e 1E69     		ldr	r6, [r3, #16]
 109 0060 0DF10202 		add	r2, sp, #2
 113:Src/bno055.c  **** 	(p_bno055->dev_addr,
 110              		.loc 1 113 0
 111 0064 0444     		add	r4, r4, r0
 112              	.LVL8:
 113              		.loc 1 119 0
 114 0066 0221     		movs	r1, #2
 115 0068 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 116 006a 0123     		movs	r3, #1
 117 006c B047     		blx	r6
 118              	.LVL9:
 120:Src/bno055.c  **** 	(p_bno055->dev_addr,
 121:Src/bno055.c  **** 	BNO055_MAG_REV_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 122:Src/bno055.c  **** 	p_bno055->mag_rev_id = data_u8;
 119              		.loc 1 122 0
 120 006e 2B68     		ldr	r3, [r5]
 121 0070 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 113:Src/bno055.c  **** 	(p_bno055->dev_addr,
 122              		.loc 1 113 0
 123 0074 E4B2     		uxtb	r4, r4
 124              	.LVL10:
 125              		.loc 1 122 0
 126 0076 9A71     		strb	r2, [r3, #6]
 123:Src/bno055.c  **** 	/* Read the gyro revision id from page
 124:Src/bno055.c  **** 	zero 0x02 register*/
 125:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC
 127              		.loc 1 125 0
 128 0078 1E69     		ldr	r6, [r3, #16]
 129 007a 0DF10202 		add	r2, sp, #2
 119:Src/bno055.c  **** 	(p_bno055->dev_addr,
 130              		.loc 1 119 0
 131 007e 0444     		add	r4, r4, r0
 132              	.LVL11:
 133              		.loc 1 125 0
 134 0080 0321     		movs	r1, #3
 135 0082 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 136 0084 0123     		movs	r3, #1
 137 0086 B047     		blx	r6
 138              	.LVL12:
 126:Src/bno055.c  **** 	(p_bno055->dev_addr,
 127:Src/bno055.c  **** 	BNO055_GYRO_REV_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 128:Src/bno055.c  **** 	p_bno055->gyro_rev_id = data_u8;
 139              		.loc 1 128 0
 140 0088 2B68     		ldr	r3, [r5]
 141 008a 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 119:Src/bno055.c  **** 	(p_bno055->dev_addr,
 142              		.loc 1 119 0
 143 008e E4B2     		uxtb	r4, r4
 144              	.LVL13:
 145              		.loc 1 128 0
ARM GAS  /tmp/ccVWLGiI.s 			page 6


 146 0090 DA71     		strb	r2, [r3, #7]
 129:Src/bno055.c  **** 	/* Read the boot loader revision from page
 130:Src/bno055.c  **** 	zero 0x06 register*/
 131:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC
 147              		.loc 1 131 0
 148 0092 1E69     		ldr	r6, [r3, #16]
 149 0094 0DF10202 		add	r2, sp, #2
 125:Src/bno055.c  **** 	(p_bno055->dev_addr,
 150              		.loc 1 125 0
 151 0098 0444     		add	r4, r4, r0
 152              	.LVL14:
 153              		.loc 1 131 0
 154 009a 0621     		movs	r1, #6
 155 009c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 156 009e 0123     		movs	r3, #1
 157 00a0 B047     		blx	r6
 158              	.LVL15:
 132:Src/bno055.c  **** 	(p_bno055->dev_addr,
 133:Src/bno055.c  **** 	BNO055_BL_REV_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 134:Src/bno055.c  **** 	p_bno055->bl_rev_id = data_u8;
 159              		.loc 1 134 0
 160 00a2 2B68     		ldr	r3, [r5]
 161 00a4 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 135:Src/bno055.c  **** 	/* Read the software revision id from page
 136:Src/bno055.c  **** 	zero 0x04 and 0x05 register( 2 bytes of data)*/
 137:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC(p_bno055->dev_addr,
 162              		.loc 1 137 0
 163 00a8 0421     		movs	r1, #4
 125:Src/bno055.c  **** 	(p_bno055->dev_addr,
 164              		.loc 1 125 0
 165 00aa E4B2     		uxtb	r4, r4
 166              	.LVL16:
 134:Src/bno055.c  **** 	/* Read the software revision id from page
 167              		.loc 1 134 0
 168 00ac 1A72     		strb	r2, [r3, #8]
 169              		.loc 1 137 0
 170 00ae 1E69     		ldr	r6, [r3, #16]
 171 00b0 0DEB0102 		add	r2, sp, r1
 131:Src/bno055.c  **** 	(p_bno055->dev_addr,
 172              		.loc 1 131 0
 173 00b4 0444     		add	r4, r4, r0
 174              	.LVL17:
 175              		.loc 1 137 0
 176 00b6 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 177 00b8 0223     		movs	r3, #2
 178 00ba B047     		blx	r6
 179              	.LVL18:
 138:Src/bno055.c  **** 	BNO055_SW_REV_ID_LSB_REG,
 139:Src/bno055.c  **** 	a_SW_ID_u8, BNO055_LSB_MSB_READ_LENGTH);
 140:Src/bno055.c  **** 	a_SW_ID_u8[BNO055_SW_ID_LSB] = BNO055_GET_BITSLICE(
 141:Src/bno055.c  **** 	a_SW_ID_u8[BNO055_SW_ID_LSB],
 142:Src/bno055.c  **** 	BNO055_SW_REV_ID_LSB);
 143:Src/bno055.c  **** 	p_bno055->sw_rev_id = (u16)
 180              		.loc 1 143 0
 181 00bc 9DF80510 		ldrb	r1, [sp, #5]	@ zero_extendqisi2
 182 00c0 9DF80420 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 183 00c4 2B68     		ldr	r3, [r5]
ARM GAS  /tmp/ccVWLGiI.s 			page 7


 184 00c6 42EA0121 		orr	r1, r2, r1, lsl #8
 131:Src/bno055.c  **** 	(p_bno055->dev_addr,
 185              		.loc 1 131 0
 186 00ca E4B2     		uxtb	r4, r4
 187              	.LVL19:
 144:Src/bno055.c  **** 	((((u32)((u8)a_SW_ID_u8[BNO055_SW_ID_MSB])) <<
 145:Src/bno055.c  **** 	BNO055_SHIFT_EIGHT_BITS) | (a_SW_ID_u8[BNO055_SW_ID_LSB]));
 146:Src/bno055.c  **** 	/* Read the page id from the register 0x07*/
 147:Src/bno055.c  **** 	com_rslt += p_bno055->BNO055_BUS_READ_FUNC
 188              		.loc 1 147 0
 189 00cc 0DF10202 		add	r2, sp, #2
 143:Src/bno055.c  **** 	((((u32)((u8)a_SW_ID_u8[BNO055_SW_ID_MSB])) <<
 190              		.loc 1 143 0
 191 00d0 5980     		strh	r1, [r3, #2]	@ movhi
 192              		.loc 1 147 0
 193 00d2 1E69     		ldr	r6, [r3, #16]
 137:Src/bno055.c  **** 	BNO055_SW_REV_ID_LSB_REG,
 194              		.loc 1 137 0
 195 00d4 0444     		add	r4, r4, r0
 196              	.LVL20:
 197              		.loc 1 147 0
 198 00d6 0721     		movs	r1, #7
 199 00d8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 200 00da 0123     		movs	r3, #1
 201 00dc B047     		blx	r6
 202              	.LVL21:
 137:Src/bno055.c  **** 	BNO055_SW_REV_ID_LSB_REG,
 203              		.loc 1 137 0
 204 00de E4B2     		uxtb	r4, r4
 205              	.LVL22:
 148:Src/bno055.c  **** 	(p_bno055->dev_addr,
 149:Src/bno055.c  **** 	BNO055_PAGE_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 150:Src/bno055.c  **** 	p_bno055->page_id = data_u8;
 206              		.loc 1 150 0
 207 00e0 2B68     		ldr	r3, [r5]
 208 00e2 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 147:Src/bno055.c  **** 	(p_bno055->dev_addr,
 209              		.loc 1 147 0
 210 00e6 2044     		add	r0, r0, r4
 211              	.LVL23:
 151:Src/bno055.c  **** 
 152:Src/bno055.c  **** 	return com_rslt;
 153:Src/bno055.c  **** }
 212              		.loc 1 153 0
 213 00e8 40B2     		sxtb	r0, r0
 150:Src/bno055.c  **** 
 214              		.loc 1 150 0
 215 00ea 1A71     		strb	r2, [r3, #4]
 216              		.loc 1 153 0
 217 00ec 03B0     		add	sp, sp, #12
 218              	.LCFI2:
 219              		.cfi_def_cfa_offset 20
 220              		@ sp needed
 221 00ee F0BD     		pop	{r4, r5, r6, r7, pc}
 222              	.L4:
 223              		.align	2
 224              	.L3:
ARM GAS  /tmp/ccVWLGiI.s 			page 8


 225 00f0 00000000 		.word	.LANCHOR0
 226              		.cfi_endproc
 227              	.LFE0:
 229              		.section	.text.bno055_write_register,"ax",%progbits
 230              		.align	2
 231              		.global	bno055_write_register
 232              		.thumb
 233              		.thumb_func
 235              	bno055_write_register:
 236              	.LFB1:
 154:Src/bno055.c  **** /*!
 155:Src/bno055.c  ****  *	@brief
 156:Src/bno055.c  ****  *	This API gives data to the given register and
 157:Src/bno055.c  ****  *	the data is written in the corresponding register address
 158:Src/bno055.c  ****  *
 159:Src/bno055.c  ****  *  @param addr_u8 : Address of the register
 160:Src/bno055.c  ****  *	@param data_u8 : Data to be written to the register
 161:Src/bno055.c  ****  *	@param len_u8  : Length of the Data
 162:Src/bno055.c  ****  *
 163:Src/bno055.c  ****  *	@return results of bus communication function
 164:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 165:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 166:Src/bno055.c  ****  *
 167:Src/bno055.c  ****  *
 168:Src/bno055.c  **** */
 169:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_write_register(u8 addr_u8,
 170:Src/bno055.c  **** u8 *data_u8, u8 len_u8)
 171:Src/bno055.c  **** {
 237              		.loc 1 171 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              		@ link register save eliminated.
 242              	.LVL24:
 172:Src/bno055.c  **** 	/* Variable used to return value of
 173:Src/bno055.c  **** 	communication routine*/
 174:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 175:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 176:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 243              		.loc 1 176 0
 244 0000 084B     		ldr	r3, .L9
 171:Src/bno055.c  **** 	/* Variable used to return value of
 245              		.loc 1 171 0
 246 0002 30B4     		push	{r4, r5}
 247              	.LCFI3:
 248              		.cfi_def_cfa_offset 8
 249              		.cfi_offset 4, -8
 250              		.cfi_offset 5, -4
 251              		.loc 1 176 0
 252 0004 1C68     		ldr	r4, [r3]
 253 0006 44B1     		cbz	r4, .L6
 254 0008 0D46     		mov	r5, r1
 255 000a 1346     		mov	r3, r2
 177:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 178:Src/bno055.c  **** 		} else {
 179:Src/bno055.c  **** 			/* Write the values of respective given register */
 180:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_WRITE_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 9


 256              		.loc 1 180 0
 257 000c 2A46     		mov	r2, r5
 258              	.LVL25:
 259 000e E568     		ldr	r5, [r4, #12]
 260 0010 0146     		mov	r1, r0
 261              	.LVL26:
 262 0012 AC46     		mov	ip, r5
 263 0014 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 264              	.LVL27:
 181:Src/bno055.c  **** 			(p_bno055->dev_addr, addr_u8, data_u8, len_u8);
 182:Src/bno055.c  **** 		}
 183:Src/bno055.c  **** 	return com_rslt;
 184:Src/bno055.c  **** }
 265              		.loc 1 184 0
 266 0016 30BC     		pop	{r4, r5}
 267              	.LCFI4:
 268              		.cfi_remember_state
 269              		.cfi_restore 5
 270              		.cfi_restore 4
 271              		.cfi_def_cfa_offset 0
 180:Src/bno055.c  **** 			(p_bno055->dev_addr, addr_u8, data_u8, len_u8);
 272              		.loc 1 180 0
 273 0018 6047     		bx	ip
 274              	.LVL28:
 275              	.L6:
 276              	.LCFI5:
 277              		.cfi_restore_state
 278              		.loc 1 184 0
 279 001a 6FF07E00 		mvn	r0, #126
 280              	.LVL29:
 281 001e 30BC     		pop	{r4, r5}
 282              	.LCFI6:
 283              		.cfi_restore 5
 284              		.cfi_restore 4
 285              		.cfi_def_cfa_offset 0
 286 0020 7047     		bx	lr
 287              	.L10:
 288 0022 00BF     		.align	2
 289              	.L9:
 290 0024 00000000 		.word	.LANCHOR0
 291              		.cfi_endproc
 292              	.LFE1:
 294              		.section	.text.bno055_read_register,"ax",%progbits
 295              		.align	2
 296              		.global	bno055_read_register
 297              		.thumb
 298              		.thumb_func
 300              	bno055_read_register:
 301              	.LFB2:
 185:Src/bno055.c  **** /*!
 186:Src/bno055.c  ****  *	@brief This API reads the data from
 187:Src/bno055.c  ****  *	the given register address
 188:Src/bno055.c  ****  *
 189:Src/bno055.c  ****  *  @param addr_u8 : Address of the register
 190:Src/bno055.c  ****  *  @param data_u8 : address of the variable,
 191:Src/bno055.c  ****  *	read value will be kept
 192:Src/bno055.c  ****  *  @param len_u8  : Length of the data
ARM GAS  /tmp/ccVWLGiI.s 			page 10


 193:Src/bno055.c  ****  *
 194:Src/bno055.c  ****  *
 195:Src/bno055.c  ****  *	@return results of bus communication function
 196:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 197:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 198:Src/bno055.c  ****  *
 199:Src/bno055.c  ****  */
 200:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_register(u8 addr_u8,
 201:Src/bno055.c  **** u8 *data_u8, u8 len_u8)
 202:Src/bno055.c  **** {
 302              		.loc 1 202 0
 303              		.cfi_startproc
 304              		@ args = 0, pretend = 0, frame = 0
 305              		@ frame_needed = 0, uses_anonymous_args = 0
 306              		@ link register save eliminated.
 307              	.LVL30:
 203:Src/bno055.c  **** 	/* Variable used to return value of
 204:Src/bno055.c  **** 	communication routine*/
 205:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 206:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 207:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 308              		.loc 1 207 0
 309 0000 084B     		ldr	r3, .L14
 202:Src/bno055.c  **** 	/* Variable used to return value of
 310              		.loc 1 202 0
 311 0002 30B4     		push	{r4, r5}
 312              	.LCFI7:
 313              		.cfi_def_cfa_offset 8
 314              		.cfi_offset 4, -8
 315              		.cfi_offset 5, -4
 316              		.loc 1 207 0
 317 0004 1C68     		ldr	r4, [r3]
 318 0006 44B1     		cbz	r4, .L12
 319 0008 0D46     		mov	r5, r1
 320 000a 1346     		mov	r3, r2
 208:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 209:Src/bno055.c  **** 		} else {
 210:Src/bno055.c  **** 		/* Read the value from given register*/
 211:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 321              		.loc 1 211 0
 322 000c 2A46     		mov	r2, r5
 323              	.LVL31:
 324 000e 2569     		ldr	r5, [r4, #16]
 325 0010 0146     		mov	r1, r0
 326              	.LVL32:
 327 0012 AC46     		mov	ip, r5
 328 0014 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 329              	.LVL33:
 212:Src/bno055.c  **** 			(p_bno055->dev_addr, addr_u8, data_u8, len_u8);
 213:Src/bno055.c  **** 		}
 214:Src/bno055.c  **** 	return com_rslt;
 215:Src/bno055.c  **** }
 330              		.loc 1 215 0
 331 0016 30BC     		pop	{r4, r5}
 332              	.LCFI8:
 333              		.cfi_remember_state
 334              		.cfi_restore 5
ARM GAS  /tmp/ccVWLGiI.s 			page 11


 335              		.cfi_restore 4
 336              		.cfi_def_cfa_offset 0
 211:Src/bno055.c  **** 			(p_bno055->dev_addr, addr_u8, data_u8, len_u8);
 337              		.loc 1 211 0
 338 0018 6047     		bx	ip
 339              	.LVL34:
 340              	.L12:
 341              	.LCFI9:
 342              		.cfi_restore_state
 343              		.loc 1 215 0
 344 001a 6FF07E00 		mvn	r0, #126
 345              	.LVL35:
 346 001e 30BC     		pop	{r4, r5}
 347              	.LCFI10:
 348              		.cfi_restore 5
 349              		.cfi_restore 4
 350              		.cfi_def_cfa_offset 0
 351 0020 7047     		bx	lr
 352              	.L15:
 353 0022 00BF     		.align	2
 354              	.L14:
 355 0024 00000000 		.word	.LANCHOR0
 356              		.cfi_endproc
 357              	.LFE2:
 359              		.section	.text.bno055_read_page_id,"ax",%progbits
 360              		.align	2
 361              		.global	bno055_read_page_id
 362              		.thumb
 363              		.thumb_func
 365              	bno055_read_page_id:
 366              	.LFB5:
 216:Src/bno055.c  **** /*!
 217:Src/bno055.c  ****  *	@brief This API reads chip id
 218:Src/bno055.c  ****  *	from register 0x00 it is a byte of data
 219:Src/bno055.c  ****  *
 220:Src/bno055.c  ****  *
 221:Src/bno055.c  ****  *	@param chip_id_u8 : The chip id value 0xA0
 222:Src/bno055.c  ****  *
 223:Src/bno055.c  ****  *	@return results of bus communication function
 224:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 225:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 226:Src/bno055.c  ****  */
 227:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_chip_id(u8 *chip_id_u8)
 228:Src/bno055.c  **** {
 229:Src/bno055.c  **** 	/* Variable used to return value of
 230:Src/bno055.c  **** 	communication routine*/
 231:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 232:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
 233:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 234:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 235:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 236:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 237:Src/bno055.c  **** 		} else {
 238:Src/bno055.c  **** 		/*condition check for page, chip id is
 239:Src/bno055.c  **** 		available in the page zero*/
 240:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 241:Src/bno055.c  **** 			/* Write the page zero*/
ARM GAS  /tmp/ccVWLGiI.s 			page 12


 242:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 243:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 244:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 245:Src/bno055.c  **** 			/* Read the chip id*/
 246:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 247:Src/bno055.c  **** 			(p_bno055->dev_addr,
 248:Src/bno055.c  **** 			BNO055_CHIP_ID_REG, &data_u8,
 249:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
 250:Src/bno055.c  **** 			*chip_id_u8 = data_u8;
 251:Src/bno055.c  **** 		} else {
 252:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 253:Src/bno055.c  **** 		}
 254:Src/bno055.c  **** 	}
 255:Src/bno055.c  **** 	return com_rslt;
 256:Src/bno055.c  **** }
 257:Src/bno055.c  **** /*!
 258:Src/bno055.c  ****  *	@brief This API reads software revision id
 259:Src/bno055.c  ****  *	from register 0x04 and 0x05 it is a two byte of data
 260:Src/bno055.c  ****  *
 261:Src/bno055.c  ****  *	@param sw_id_u8 : The SW revision id
 262:Src/bno055.c  ****  *
 263:Src/bno055.c  ****  *	@return results of bus communication function
 264:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 265:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 266:Src/bno055.c  ****  *
 267:Src/bno055.c  ****  *
 268:Src/bno055.c  ****  */
 269:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_sw_rev_id(u16 *sw_id_u8)
 270:Src/bno055.c  **** {
 271:Src/bno055.c  **** 	/* Variable used to return value of
 272:Src/bno055.c  **** 	communication routine*/
 273:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 274:Src/bno055.c  **** 	/* array having the software revision id
 275:Src/bno055.c  **** 	data_u8[0] - LSB
 276:Src/bno055.c  **** 	data_u8[1] - MSB*/
 277:Src/bno055.c  **** 	u8 data_u8[BNO055_REV_ID_SIZE] = {BNO055_INIT_VALUE,
 278:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 279:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 280:Src/bno055.c  **** 	/* Check the struct  p_bno055 is empty*/
 281:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 282:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 283:Src/bno055.c  **** 		} else {
 284:Src/bno055.c  **** 		/*condition check for page, chip id is
 285:Src/bno055.c  **** 		available in the page zero*/
 286:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 287:Src/bno055.c  **** 			/* Write the page zero*/
 288:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 289:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 290:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 291:Src/bno055.c  **** 			/* Read the two byte value of software
 292:Src/bno055.c  **** 			revision id*/
 293:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 294:Src/bno055.c  **** 			(p_bno055->dev_addr,
 295:Src/bno055.c  **** 			BNO055_SW_REV_ID_LSB_REG,
 296:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
 297:Src/bno055.c  **** 			data_u8[BNO055_SW_ID_LSB] =
 298:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SW_ID_LSB],
ARM GAS  /tmp/ccVWLGiI.s 			page 13


 299:Src/bno055.c  **** 			BNO055_SW_REV_ID_LSB);
 300:Src/bno055.c  **** 			*sw_id_u8 = (u16)
 301:Src/bno055.c  **** 			((((u32)((u8)data_u8[BNO055_SW_ID_MSB])) <<
 302:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
 303:Src/bno055.c  **** 			| (data_u8[BNO055_SW_ID_LSB]));
 304:Src/bno055.c  **** 		} else {
 305:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 306:Src/bno055.c  **** 		}
 307:Src/bno055.c  **** 	}
 308:Src/bno055.c  **** 	return com_rslt;
 309:Src/bno055.c  **** }
 310:Src/bno055.c  **** /*!
 311:Src/bno055.c  ****  *	@brief This API reads page id
 312:Src/bno055.c  ****  *	from register 0x07 it is a byte of data
 313:Src/bno055.c  ****  *
 314:Src/bno055.c  ****  *
 315:Src/bno055.c  ****  *	@param page_id_u8 : The value of page id
 316:Src/bno055.c  ****  *
 317:Src/bno055.c  ****  *	BNO055_PAGE_ZERO -> 0x00
 318:Src/bno055.c  ****  *	BNO055_PAGE_ONE  -> 0x01
 319:Src/bno055.c  ****  *
 320:Src/bno055.c  ****  *	@return results of bus communication function
 321:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 322:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 323:Src/bno055.c  ****  *
 324:Src/bno055.c  ****  *
 325:Src/bno055.c  ****  */
 326:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_page_id(u8 *page_id_u8)
 327:Src/bno055.c  **** {
 367              		.loc 1 327 0
 368              		.cfi_startproc
 369              		@ args = 0, pretend = 0, frame = 8
 370              		@ frame_needed = 0, uses_anonymous_args = 0
 371              	.LVL36:
 372 0000 70B5     		push	{r4, r5, r6, lr}
 373              	.LCFI11:
 374              		.cfi_def_cfa_offset 16
 375              		.cfi_offset 4, -16
 376              		.cfi_offset 5, -12
 377              		.cfi_offset 6, -8
 378              		.cfi_offset 14, -4
 328:Src/bno055.c  **** 	/* Variable used to return value of
 329:Src/bno055.c  **** 	communication routine*/
 330:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 331:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
 332:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 333:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 379              		.loc 1 333 0
 380 0002 0F4D     		ldr	r5, .L22
 327:Src/bno055.c  **** 	/* Variable used to return value of
 381              		.loc 1 327 0
 382 0004 82B0     		sub	sp, sp, #8
 383              	.LCFI12:
 384              		.cfi_def_cfa_offset 24
 385              		.loc 1 333 0
 386 0006 2B68     		ldr	r3, [r5]
 331:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
ARM GAS  /tmp/ccVWLGiI.s 			page 14


 387              		.loc 1 331 0
 388 0008 0022     		movs	r2, #0
 389 000a 8DF80720 		strb	r2, [sp, #7]
 390              		.loc 1 333 0
 391 000e A3B1     		cbz	r3, .L18
 334:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 335:Src/bno055.c  **** 		} else {
 336:Src/bno055.c  **** 		/* Read the page id form 0x07*/
 337:Src/bno055.c  **** 		com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 392              		.loc 1 337 0
 393 0010 0721     		movs	r1, #7
 394 0012 0446     		mov	r4, r0
 395 0014 1E69     		ldr	r6, [r3, #16]
 396 0016 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 397              	.LVL37:
 398 0018 0DEB0102 		add	r2, sp, r1
 399 001c 0123     		movs	r3, #1
 400 001e B047     		blx	r6
 401              	.LVL38:
 338:Src/bno055.c  **** 		(p_bno055->dev_addr,
 339:Src/bno055.c  **** 		BNO055_PAGE_ID_REG, &data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 340:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 402              		.loc 1 340 0
 403 0020 18B1     		cbz	r0, .L21
 341:Src/bno055.c  **** 			data_u8 = BNO055_GET_BITSLICE(data_u8,
 342:Src/bno055.c  **** 			BNO055_PAGE_ID);
 343:Src/bno055.c  **** 			*page_id_u8 = data_u8;
 344:Src/bno055.c  **** 			p_bno055->page_id = data_u8;
 345:Src/bno055.c  **** 		} else {
 346:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 404              		.loc 1 346 0
 405 0022 FF20     		movs	r0, #255
 406              	.LVL39:
 407              	.L17:
 347:Src/bno055.c  **** 		}
 348:Src/bno055.c  **** 	}
 349:Src/bno055.c  **** 	return com_rslt;
 350:Src/bno055.c  **** }
 408              		.loc 1 350 0
 409 0024 40B2     		sxtb	r0, r0
 410 0026 02B0     		add	sp, sp, #8
 411              	.LCFI13:
 412              		.cfi_remember_state
 413              		.cfi_def_cfa_offset 16
 414              		@ sp needed
 415 0028 70BD     		pop	{r4, r5, r6, pc}
 416              	.LVL40:
 417              	.L21:
 418              	.LCFI14:
 419              		.cfi_restore_state
 341:Src/bno055.c  **** 			data_u8 = BNO055_GET_BITSLICE(data_u8,
 420              		.loc 1 341 0
 421 002a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 344:Src/bno055.c  **** 		} else {
 422              		.loc 1 344 0
 423 002e 2A68     		ldr	r2, [r5]
 424              		.loc 1 350 0
ARM GAS  /tmp/ccVWLGiI.s 			page 15


 425 0030 40B2     		sxtb	r0, r0
 343:Src/bno055.c  **** 			p_bno055->page_id = data_u8;
 426              		.loc 1 343 0
 427 0032 2370     		strb	r3, [r4]
 344:Src/bno055.c  **** 		} else {
 428              		.loc 1 344 0
 429 0034 1371     		strb	r3, [r2, #4]
 430              		.loc 1 350 0
 431 0036 02B0     		add	sp, sp, #8
 432              	.LCFI15:
 433              		.cfi_remember_state
 434              		.cfi_def_cfa_offset 16
 435              		@ sp needed
 436 0038 70BD     		pop	{r4, r5, r6, pc}
 437              	.LVL41:
 438              	.L18:
 439              	.LCFI16:
 440              		.cfi_restore_state
 334:Src/bno055.c  **** 		} else {
 441              		.loc 1 334 0
 442 003a 8120     		movs	r0, #129
 443              	.LVL42:
 444 003c F2E7     		b	.L17
 445              	.L23:
 446 003e 00BF     		.align	2
 447              	.L22:
 448 0040 00000000 		.word	.LANCHOR0
 449              		.cfi_endproc
 450              	.LFE5:
 452              		.section	.text.bno055_write_page_id,"ax",%progbits
 453              		.align	2
 454              		.global	bno055_write_page_id
 455              		.thumb
 456              		.thumb_func
 458              	bno055_write_page_id:
 459              	.LFB6:
 351:Src/bno055.c  **** /*!
 352:Src/bno055.c  ****  *	@brief This API used to write
 353:Src/bno055.c  ****  *	the page id register 0x07
 354:Src/bno055.c  ****  *
 355:Src/bno055.c  ****  *	@param page_id_u8 : The value of page id
 356:Src/bno055.c  ****  *
 357:Src/bno055.c  ****  *	BNO055_PAGE_ZERO -> 0x00
 358:Src/bno055.c  ****  *	BNO055_PAGE_ONE  -> 0x01
 359:Src/bno055.c  ****  *
 360:Src/bno055.c  ****  *	@return results of bus communication function
 361:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 362:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 363:Src/bno055.c  ****  *
 364:Src/bno055.c  ****  *
 365:Src/bno055.c  ****  */
 366:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_write_page_id(u8 page_id_u8)
 367:Src/bno055.c  **** {
 460              		.loc 1 367 0
 461              		.cfi_startproc
 462              		@ args = 0, pretend = 0, frame = 8
 463              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccVWLGiI.s 			page 16


 464              	.LVL43:
 465 0000 70B5     		push	{r4, r5, r6, lr}
 466              	.LCFI17:
 467              		.cfi_def_cfa_offset 16
 468              		.cfi_offset 4, -16
 469              		.cfi_offset 5, -12
 470              		.cfi_offset 6, -8
 471              		.cfi_offset 14, -4
 368:Src/bno055.c  **** 	/* Variable used to return value of
 369:Src/bno055.c  **** 	communication routine*/
 370:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 371:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
 372:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 373:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 472              		.loc 1 373 0
 473 0002 134C     		ldr	r4, .L30
 367:Src/bno055.c  **** 	/* Variable used to return value of
 474              		.loc 1 367 0
 475 0004 82B0     		sub	sp, sp, #8
 476              	.LCFI18:
 477              		.cfi_def_cfa_offset 24
 478              		.loc 1 373 0
 479 0006 2368     		ldr	r3, [r4]
 371:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 480              		.loc 1 371 0
 481 0008 0022     		movs	r2, #0
 482 000a 8DF80720 		strb	r2, [sp, #7]
 483              		.loc 1 373 0
 484 000e EBB1     		cbz	r3, .L26
 485 0010 0646     		mov	r6, r0
 374:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 375:Src/bno055.c  **** 		} else {
 376:Src/bno055.c  **** 			/* Read the current page*/
 377:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 486              		.loc 1 377 0
 487 0012 1D69     		ldr	r5, [r3, #16]
 488 0014 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 489              	.LVL44:
 490 0016 0DF10702 		add	r2, sp, #7
 491 001a 0721     		movs	r1, #7
 492 001c 0123     		movs	r3, #1
 493 001e A847     		blx	r5
 494              	.LVL45:
 378:Src/bno055.c  **** 			(p_bno055->dev_addr,
 379:Src/bno055.c  **** 			BNO055_PAGE_ID_REG, &data_u8r,
 380:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
 381:Src/bno055.c  **** 			/* Check condition for communication BNO055_SUCCESS*/
 382:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 495              		.loc 1 382 0
 496 0020 18B1     		cbz	r0, .L29
 383:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE(data_u8r,
 384:Src/bno055.c  **** 				BNO055_PAGE_ID, page_id_u8);
 385:Src/bno055.c  **** 				/* Write the page id*/
 386:Src/bno055.c  **** 				com_rslt += p_bno055->BNO055_BUS_WRITE_FUNC
 387:Src/bno055.c  **** 				(p_bno055->dev_addr,
 388:Src/bno055.c  **** 				BNO055_PAGE_ID_REG,
 389:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 17


 390:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS)
 391:Src/bno055.c  **** 					p_bno055->page_id = page_id_u8;
 392:Src/bno055.c  **** 			} else {
 393:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
 497              		.loc 1 393 0
 498 0022 FF20     		movs	r0, #255
 499              	.LVL46:
 500              	.L25:
 394:Src/bno055.c  **** 			}
 395:Src/bno055.c  **** 		}
 396:Src/bno055.c  **** 	return com_rslt;
 397:Src/bno055.c  **** }
 501              		.loc 1 397 0
 502 0024 40B2     		sxtb	r0, r0
 503 0026 02B0     		add	sp, sp, #8
 504              	.LCFI19:
 505              		.cfi_remember_state
 506              		.cfi_def_cfa_offset 16
 507              		@ sp needed
 508 0028 70BD     		pop	{r4, r5, r6, pc}
 509              	.LVL47:
 510              	.L29:
 511              	.LCFI20:
 512              		.cfi_restore_state
 386:Src/bno055.c  **** 				(p_bno055->dev_addr,
 513              		.loc 1 386 0
 514 002a 2368     		ldr	r3, [r4]
 383:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE(data_u8r,
 515              		.loc 1 383 0
 516 002c 8DF80760 		strb	r6, [sp, #7]
 386:Src/bno055.c  **** 				(p_bno055->dev_addr,
 517              		.loc 1 386 0
 518 0030 DD68     		ldr	r5, [r3, #12]
 519 0032 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 520              	.LVL48:
 521 0034 0DF10702 		add	r2, sp, #7
 522 0038 0721     		movs	r1, #7
 523 003a 0123     		movs	r3, #1
 524 003c A847     		blx	r5
 525              	.LVL49:
 390:Src/bno055.c  **** 					p_bno055->page_id = page_id_u8;
 526              		.loc 1 390 0
 527 003e 0028     		cmp	r0, #0
 528 0040 F0D1     		bne	.L25
 391:Src/bno055.c  **** 			} else {
 529              		.loc 1 391 0
 530 0042 2368     		ldr	r3, [r4]
 531              		.loc 1 397 0
 532 0044 40B2     		sxtb	r0, r0
 391:Src/bno055.c  **** 			} else {
 533              		.loc 1 391 0
 534 0046 1E71     		strb	r6, [r3, #4]
 535              		.loc 1 397 0
 536 0048 02B0     		add	sp, sp, #8
 537              	.LCFI21:
 538              		.cfi_remember_state
 539              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccVWLGiI.s 			page 18


 540              		@ sp needed
 541 004a 70BD     		pop	{r4, r5, r6, pc}
 542              	.LVL50:
 543              	.L26:
 544              	.LCFI22:
 545              		.cfi_restore_state
 374:Src/bno055.c  **** 		} else {
 546              		.loc 1 374 0
 547 004c 8120     		movs	r0, #129
 548              	.LVL51:
 549 004e E9E7     		b	.L25
 550              	.L31:
 551              		.align	2
 552              	.L30:
 553 0050 00000000 		.word	.LANCHOR0
 554              		.cfi_endproc
 555              	.LFE6:
 557              		.section	.text.bno055_read_chip_id,"ax",%progbits
 558              		.align	2
 559              		.global	bno055_read_chip_id
 560              		.thumb
 561              		.thumb_func
 563              	bno055_read_chip_id:
 564              	.LFB3:
 228:Src/bno055.c  **** 	/* Variable used to return value of
 565              		.loc 1 228 0
 566              		.cfi_startproc
 567              		@ args = 0, pretend = 0, frame = 8
 568              		@ frame_needed = 0, uses_anonymous_args = 0
 569              	.LVL52:
 570 0000 30B5     		push	{r4, r5, lr}
 571              	.LCFI23:
 572              		.cfi_def_cfa_offset 12
 573              		.cfi_offset 4, -12
 574              		.cfi_offset 5, -8
 575              		.cfi_offset 14, -4
 235:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 576              		.loc 1 235 0
 577 0002 124C     		ldr	r4, .L43
 228:Src/bno055.c  **** 	/* Variable used to return value of
 578              		.loc 1 228 0
 579 0004 83B0     		sub	sp, sp, #12
 580              	.LCFI24:
 581              		.cfi_def_cfa_offset 24
 235:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 582              		.loc 1 235 0
 583 0006 2368     		ldr	r3, [r4]
 232:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 584              		.loc 1 232 0
 585 0008 0022     		movs	r2, #0
 586 000a 8DF80720 		strb	r2, [sp, #7]
 587              	.LVL53:
 235:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 588              		.loc 1 235 0
 589 000e D3B1     		cbz	r3, .L36
 240:Src/bno055.c  **** 			/* Write the page zero*/
 590              		.loc 1 240 0
ARM GAS  /tmp/ccVWLGiI.s 			page 19


 591 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 592 0012 0546     		mov	r5, r0
 593 0014 61B9     		cbnz	r1, .L42
 594              	.LVL54:
 595              	.L34:
 246:Src/bno055.c  **** 			(p_bno055->dev_addr,
 596              		.loc 1 246 0
 597 0016 1C69     		ldr	r4, [r3, #16]
 598 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 599 001a 0021     		movs	r1, #0
 600 001c 0123     		movs	r3, #1
 601 001e 0DF10702 		add	r2, sp, #7
 602 0022 A047     		blx	r4
 603              	.LVL55:
 250:Src/bno055.c  **** 		} else {
 604              		.loc 1 250 0
 605 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 606 0028 2B70     		strb	r3, [r5]
 607              	.LVL56:
 608              	.L33:
 256:Src/bno055.c  **** /*!
 609              		.loc 1 256 0
 610 002a 40B2     		sxtb	r0, r0
 611 002c 03B0     		add	sp, sp, #12
 612              	.LCFI25:
 613              		.cfi_remember_state
 614              		.cfi_def_cfa_offset 12
 615              		@ sp needed
 616 002e 30BD     		pop	{r4, r5, pc}
 617              	.LVL57:
 618              	.L42:
 619              	.LCFI26:
 620              		.cfi_restore_state
 242:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 621              		.loc 1 242 0
 622 0030 1046     		mov	r0, r2
 623              	.LVL58:
 624 0032 FFF7FEFF 		bl	bno055_write_page_id
 625              	.LVL59:
 626 0036 2368     		ldr	r3, [r4]
 243:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 627              		.loc 1 243 0
 628 0038 0028     		cmp	r0, #0
 629 003a ECD0     		beq	.L34
 630              	.LVL60:
 243:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 631              		.loc 1 243 0 is_stmt 0 discriminator 1
 632 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 252:Src/bno055.c  **** 		}
 633              		.loc 1 252 0 is_stmt 1 discriminator 1
 634 003e FF20     		movs	r0, #255
 243:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 635              		.loc 1 243 0 discriminator 1
 636 0040 002A     		cmp	r2, #0
 637 0042 F2D1     		bne	.L33
 638 0044 E7E7     		b	.L34
 639              	.LVL61:
ARM GAS  /tmp/ccVWLGiI.s 			page 20


 640              	.L36:
 236:Src/bno055.c  **** 		} else {
 641              		.loc 1 236 0
 642 0046 8120     		movs	r0, #129
 643              	.LVL62:
 644 0048 EFE7     		b	.L33
 645              	.L44:
 646 004a 00BF     		.align	2
 647              	.L43:
 648 004c 00000000 		.word	.LANCHOR0
 649              		.cfi_endproc
 650              	.LFE3:
 652              		.section	.text.bno055_read_sw_rev_id,"ax",%progbits
 653              		.align	2
 654              		.global	bno055_read_sw_rev_id
 655              		.thumb
 656              		.thumb_func
 658              	bno055_read_sw_rev_id:
 659              	.LFB4:
 270:Src/bno055.c  **** 	/* Variable used to return value of
 660              		.loc 1 270 0
 661              		.cfi_startproc
 662              		@ args = 0, pretend = 0, frame = 8
 663              		@ frame_needed = 0, uses_anonymous_args = 0
 664              	.LVL63:
 665 0000 30B5     		push	{r4, r5, lr}
 666              	.LCFI27:
 667              		.cfi_def_cfa_offset 12
 668              		.cfi_offset 4, -12
 669              		.cfi_offset 5, -8
 670              		.cfi_offset 14, -4
 281:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 671              		.loc 1 281 0
 672 0002 154C     		ldr	r4, .L56
 270:Src/bno055.c  **** 	/* Variable used to return value of
 673              		.loc 1 270 0
 674 0004 83B0     		sub	sp, sp, #12
 675              	.LCFI28:
 676              		.cfi_def_cfa_offset 24
 281:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 677              		.loc 1 281 0
 678 0006 2368     		ldr	r3, [r4]
 277:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 679              		.loc 1 277 0
 680 0008 0022     		movs	r2, #0
 681 000a 8DF80420 		strb	r2, [sp, #4]
 682 000e 8DF80520 		strb	r2, [sp, #5]
 683              	.LVL64:
 281:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 684              		.loc 1 281 0
 685 0012 F3B1     		cbz	r3, .L49
 286:Src/bno055.c  **** 			/* Write the page zero*/
 686              		.loc 1 286 0
 687 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 688 0016 0546     		mov	r5, r0
 689 0018 81B9     		cbnz	r1, .L55
 690              	.LVL65:
ARM GAS  /tmp/ccVWLGiI.s 			page 21


 691              	.L47:
 293:Src/bno055.c  **** 			(p_bno055->dev_addr,
 692              		.loc 1 293 0
 693 001a 0421     		movs	r1, #4
 694 001c 1C69     		ldr	r4, [r3, #16]
 695 001e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 696 0020 0DEB0102 		add	r2, sp, r1
 697 0024 0223     		movs	r3, #2
 698 0026 A047     		blx	r4
 699              	.LVL66:
 300:Src/bno055.c  **** 			((((u32)((u8)data_u8[BNO055_SW_ID_MSB])) <<
 700              		.loc 1 300 0
 701 0028 9DF80520 		ldrb	r2, [sp, #5]	@ zero_extendqisi2
 702 002c 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 703 0030 43EA0223 		orr	r3, r3, r2, lsl #8
 704 0034 2B80     		strh	r3, [r5]	@ movhi
 705              	.LVL67:
 706              	.L46:
 309:Src/bno055.c  **** /*!
 707              		.loc 1 309 0
 708 0036 40B2     		sxtb	r0, r0
 709 0038 03B0     		add	sp, sp, #12
 710              	.LCFI29:
 711              		.cfi_remember_state
 712              		.cfi_def_cfa_offset 12
 713              		@ sp needed
 714 003a 30BD     		pop	{r4, r5, pc}
 715              	.LVL68:
 716              	.L55:
 717              	.LCFI30:
 718              		.cfi_restore_state
 288:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 719              		.loc 1 288 0
 720 003c 1046     		mov	r0, r2
 721              	.LVL69:
 722 003e FFF7FEFF 		bl	bno055_write_page_id
 723              	.LVL70:
 724 0042 2368     		ldr	r3, [r4]
 289:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 725              		.loc 1 289 0
 726 0044 0028     		cmp	r0, #0
 727 0046 E8D0     		beq	.L47
 728              	.LVL71:
 289:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 729              		.loc 1 289 0 is_stmt 0 discriminator 1
 730 0048 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 305:Src/bno055.c  **** 		}
 731              		.loc 1 305 0 is_stmt 1 discriminator 1
 732 004a FF20     		movs	r0, #255
 289:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 733              		.loc 1 289 0 discriminator 1
 734 004c 002A     		cmp	r2, #0
 735 004e F2D1     		bne	.L46
 736 0050 E3E7     		b	.L47
 737              	.LVL72:
 738              	.L49:
 282:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 22


 739              		.loc 1 282 0
 740 0052 8120     		movs	r0, #129
 741              	.LVL73:
 742 0054 EFE7     		b	.L46
 743              	.L57:
 744 0056 00BF     		.align	2
 745              	.L56:
 746 0058 00000000 		.word	.LANCHOR0
 747              		.cfi_endproc
 748              	.LFE4:
 750              		.section	.text.bno055_read_accel_rev_id,"ax",%progbits
 751              		.align	2
 752              		.global	bno055_read_accel_rev_id
 753              		.thumb
 754              		.thumb_func
 756              	bno055_read_accel_rev_id:
 757              	.LFB7:
 398:Src/bno055.c  **** /*!
 399:Src/bno055.c  ****  *	@brief This API reads accel revision id
 400:Src/bno055.c  ****  *	from register 0x01 it is a byte of value
 401:Src/bno055.c  ****  *
 402:Src/bno055.c  ****  *	@param accel_rev_id_u8 : The accel revision id 0xFB
 403:Src/bno055.c  ****  *
 404:Src/bno055.c  ****  *	@return results of bus communication function
 405:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 406:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 407:Src/bno055.c  ****  *
 408:Src/bno055.c  ****  *
 409:Src/bno055.c  ****  */
 410:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_accel_rev_id(
 411:Src/bno055.c  **** u8 *accel_rev_id_u8)
 412:Src/bno055.c  **** {
 758              		.loc 1 412 0
 759              		.cfi_startproc
 760              		@ args = 0, pretend = 0, frame = 8
 761              		@ frame_needed = 0, uses_anonymous_args = 0
 762              	.LVL74:
 763 0000 30B5     		push	{r4, r5, lr}
 764              	.LCFI31:
 765              		.cfi_def_cfa_offset 12
 766              		.cfi_offset 4, -12
 767              		.cfi_offset 5, -8
 768              		.cfi_offset 14, -4
 413:Src/bno055.c  **** 	/* Variable used to return value of
 414:Src/bno055.c  **** 	communication routine*/
 415:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 416:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
 417:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 418:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 419:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 769              		.loc 1 419 0
 770 0002 124C     		ldr	r4, .L69
 412:Src/bno055.c  **** 	/* Variable used to return value of
 771              		.loc 1 412 0
 772 0004 83B0     		sub	sp, sp, #12
 773              	.LCFI32:
 774              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccVWLGiI.s 			page 23


 775              		.loc 1 419 0
 776 0006 2268     		ldr	r2, [r4]
 416:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 777              		.loc 1 416 0
 778 0008 0023     		movs	r3, #0
 779 000a 8DF80730 		strb	r3, [sp, #7]
 780              	.LVL75:
 781              		.loc 1 419 0
 782 000e D2B1     		cbz	r2, .L62
 420:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 421:Src/bno055.c  **** 		} else {
 422:Src/bno055.c  **** 		/*condition check for page, chip id is
 423:Src/bno055.c  **** 		available in the page zero*/
 424:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 783              		.loc 1 424 0
 784 0010 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 785 0012 0546     		mov	r5, r0
 786 0014 61B9     		cbnz	r1, .L68
 787              	.LVL76:
 788              	.L60:
 425:Src/bno055.c  **** 			/* Write the page zero*/
 426:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 427:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 428:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 429:Src/bno055.c  **** 			/* Read the accel revision id */
 430:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 789              		.loc 1 430 0
 790 0016 0121     		movs	r1, #1
 791 0018 0B46     		mov	r3, r1
 792 001a 1469     		ldr	r4, [r2, #16]
 793 001c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 794 001e 0DF10702 		add	r2, sp, #7
 795 0022 A047     		blx	r4
 796              	.LVL77:
 431:Src/bno055.c  **** 			(p_bno055->dev_addr,
 432:Src/bno055.c  **** 			BNO055_ACCEL_REV_ID_REG,
 433:Src/bno055.c  **** 			&data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 434:Src/bno055.c  **** 			*accel_rev_id_u8 = data_u8;
 797              		.loc 1 434 0
 798 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 799 0028 2B70     		strb	r3, [r5]
 800              	.LVL78:
 801              	.L59:
 435:Src/bno055.c  **** 		} else {
 436:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 437:Src/bno055.c  **** 		}
 438:Src/bno055.c  **** 	}
 439:Src/bno055.c  **** 	return com_rslt;
 440:Src/bno055.c  **** }
 802              		.loc 1 440 0
 803 002a 40B2     		sxtb	r0, r0
 804 002c 03B0     		add	sp, sp, #12
 805              	.LCFI33:
 806              		.cfi_remember_state
 807              		.cfi_def_cfa_offset 12
 808              		@ sp needed
 809 002e 30BD     		pop	{r4, r5, pc}
ARM GAS  /tmp/ccVWLGiI.s 			page 24


 810              	.LVL79:
 811              	.L68:
 812              	.LCFI34:
 813              		.cfi_restore_state
 426:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 814              		.loc 1 426 0
 815 0030 1846     		mov	r0, r3
 816              	.LVL80:
 817 0032 FFF7FEFF 		bl	bno055_write_page_id
 818              	.LVL81:
 819 0036 2268     		ldr	r2, [r4]
 427:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 820              		.loc 1 427 0
 821 0038 0028     		cmp	r0, #0
 822 003a ECD0     		beq	.L60
 823              	.LVL82:
 427:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 824              		.loc 1 427 0 is_stmt 0 discriminator 1
 825 003c 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 436:Src/bno055.c  **** 		}
 826              		.loc 1 436 0 is_stmt 1 discriminator 1
 827 003e FF20     		movs	r0, #255
 427:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 828              		.loc 1 427 0 discriminator 1
 829 0040 002B     		cmp	r3, #0
 830 0042 F2D1     		bne	.L59
 831 0044 E7E7     		b	.L60
 832              	.LVL83:
 833              	.L62:
 420:Src/bno055.c  **** 		} else {
 834              		.loc 1 420 0
 835 0046 8120     		movs	r0, #129
 836              	.LVL84:
 837 0048 EFE7     		b	.L59
 838              	.L70:
 839 004a 00BF     		.align	2
 840              	.L69:
 841 004c 00000000 		.word	.LANCHOR0
 842              		.cfi_endproc
 843              	.LFE7:
 845              		.section	.text.bno055_read_mag_rev_id,"ax",%progbits
 846              		.align	2
 847              		.global	bno055_read_mag_rev_id
 848              		.thumb
 849              		.thumb_func
 851              	bno055_read_mag_rev_id:
 852              	.LFB8:
 441:Src/bno055.c  **** /*!
 442:Src/bno055.c  ****  *	@brief This API reads mag revision id
 443:Src/bno055.c  ****  *	from register 0x02 it is a byte of value
 444:Src/bno055.c  ****  *
 445:Src/bno055.c  ****  *	@param mag_rev_id_u8 : The mag revision id 0x32
 446:Src/bno055.c  ****  *
 447:Src/bno055.c  ****  *	@return results of bus communication function
 448:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 449:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 450:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 25


 451:Src/bno055.c  ****  *
 452:Src/bno055.c  ****  */
 453:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_mag_rev_id(
 454:Src/bno055.c  **** u8 *mag_rev_id_u8)
 455:Src/bno055.c  **** {
 853              		.loc 1 455 0
 854              		.cfi_startproc
 855              		@ args = 0, pretend = 0, frame = 8
 856              		@ frame_needed = 0, uses_anonymous_args = 0
 857              	.LVL85:
 858 0000 30B5     		push	{r4, r5, lr}
 859              	.LCFI35:
 860              		.cfi_def_cfa_offset 12
 861              		.cfi_offset 4, -12
 862              		.cfi_offset 5, -8
 863              		.cfi_offset 14, -4
 456:Src/bno055.c  **** 	/* Variable used to return value of
 457:Src/bno055.c  **** 	communication routine*/
 458:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 459:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
 460:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 461:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 462:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 864              		.loc 1 462 0
 865 0002 124C     		ldr	r4, .L82
 455:Src/bno055.c  **** 	/* Variable used to return value of
 866              		.loc 1 455 0
 867 0004 83B0     		sub	sp, sp, #12
 868              	.LCFI36:
 869              		.cfi_def_cfa_offset 24
 870              		.loc 1 462 0
 871 0006 2368     		ldr	r3, [r4]
 459:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 872              		.loc 1 459 0
 873 0008 0022     		movs	r2, #0
 874 000a 8DF80720 		strb	r2, [sp, #7]
 875              	.LVL86:
 876              		.loc 1 462 0
 877 000e D3B1     		cbz	r3, .L75
 463:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 464:Src/bno055.c  **** 		} else {
 465:Src/bno055.c  **** 		/*condition check for page, chip id is
 466:Src/bno055.c  **** 		available in the page zero*/
 467:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 878              		.loc 1 467 0
 879 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 880 0012 0546     		mov	r5, r0
 881 0014 61B9     		cbnz	r1, .L81
 882              	.LVL87:
 883              	.L73:
 468:Src/bno055.c  **** 			/* Write the page zero*/
 469:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 470:Src/bno055.c  **** 			if ((stat_s8 == BNO055_SUCCESS) ||
 471:Src/bno055.c  **** 			(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 472:Src/bno055.c  **** 				/* Read the mag revision id */
 473:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 884              		.loc 1 473 0
ARM GAS  /tmp/ccVWLGiI.s 			page 26


 885 0016 1C69     		ldr	r4, [r3, #16]
 886 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 887 001a 0221     		movs	r1, #2
 888 001c 0123     		movs	r3, #1
 889 001e 0DF10702 		add	r2, sp, #7
 890 0022 A047     		blx	r4
 891              	.LVL88:
 474:Src/bno055.c  **** 				(p_bno055->dev_addr,
 475:Src/bno055.c  **** 				BNO055_MAG_REV_ID_REG,
 476:Src/bno055.c  **** 				&data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 477:Src/bno055.c  **** 				*mag_rev_id_u8 = data_u8;
 892              		.loc 1 477 0
 893 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 894 0028 2B70     		strb	r3, [r5]
 895              	.LVL89:
 896              	.L72:
 478:Src/bno055.c  **** 			} else {
 479:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
 480:Src/bno055.c  **** 			}
 481:Src/bno055.c  **** 		}
 482:Src/bno055.c  **** 	return com_rslt;
 483:Src/bno055.c  **** }
 897              		.loc 1 483 0
 898 002a 40B2     		sxtb	r0, r0
 899 002c 03B0     		add	sp, sp, #12
 900              	.LCFI37:
 901              		.cfi_remember_state
 902              		.cfi_def_cfa_offset 12
 903              		@ sp needed
 904 002e 30BD     		pop	{r4, r5, pc}
 905              	.LVL90:
 906              	.L81:
 907              	.LCFI38:
 908              		.cfi_restore_state
 469:Src/bno055.c  **** 			if ((stat_s8 == BNO055_SUCCESS) ||
 909              		.loc 1 469 0
 910 0030 1046     		mov	r0, r2
 911              	.LVL91:
 912 0032 FFF7FEFF 		bl	bno055_write_page_id
 913              	.LVL92:
 914 0036 2368     		ldr	r3, [r4]
 470:Src/bno055.c  **** 			(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 915              		.loc 1 470 0
 916 0038 0028     		cmp	r0, #0
 917 003a ECD0     		beq	.L73
 918              	.LVL93:
 470:Src/bno055.c  **** 			(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 919              		.loc 1 470 0 is_stmt 0 discriminator 1
 920 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 479:Src/bno055.c  **** 			}
 921              		.loc 1 479 0 is_stmt 1 discriminator 1
 922 003e FF20     		movs	r0, #255
 470:Src/bno055.c  **** 			(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 923              		.loc 1 470 0 discriminator 1
 924 0040 002A     		cmp	r2, #0
 925 0042 F2D1     		bne	.L72
 926 0044 E7E7     		b	.L73
ARM GAS  /tmp/ccVWLGiI.s 			page 27


 927              	.LVL94:
 928              	.L75:
 463:Src/bno055.c  **** 		} else {
 929              		.loc 1 463 0
 930 0046 8120     		movs	r0, #129
 931              	.LVL95:
 932 0048 EFE7     		b	.L72
 933              	.L83:
 934 004a 00BF     		.align	2
 935              	.L82:
 936 004c 00000000 		.word	.LANCHOR0
 937              		.cfi_endproc
 938              	.LFE8:
 940              		.section	.text.bno055_read_gyro_rev_id,"ax",%progbits
 941              		.align	2
 942              		.global	bno055_read_gyro_rev_id
 943              		.thumb
 944              		.thumb_func
 946              	bno055_read_gyro_rev_id:
 947              	.LFB9:
 484:Src/bno055.c  **** /*!
 485:Src/bno055.c  ****  *	@brief This API reads gyro revision id
 486:Src/bno055.c  ****  *	from register 0x03 it is a byte of value
 487:Src/bno055.c  ****  *
 488:Src/bno055.c  ****  *	@param gyro_rev_id_u8 : The gyro revision id 0xF0
 489:Src/bno055.c  ****  *
 490:Src/bno055.c  ****  *
 491:Src/bno055.c  ****  *
 492:Src/bno055.c  ****  *	@return results of bus communication function
 493:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 494:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 495:Src/bno055.c  ****  *
 496:Src/bno055.c  ****  *
 497:Src/bno055.c  ****  */
 498:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gyro_rev_id(
 499:Src/bno055.c  **** u8 *gyro_rev_id_u8)
 500:Src/bno055.c  **** {
 948              		.loc 1 500 0
 949              		.cfi_startproc
 950              		@ args = 0, pretend = 0, frame = 8
 951              		@ frame_needed = 0, uses_anonymous_args = 0
 952              	.LVL96:
 953 0000 30B5     		push	{r4, r5, lr}
 954              	.LCFI39:
 955              		.cfi_def_cfa_offset 12
 956              		.cfi_offset 4, -12
 957              		.cfi_offset 5, -8
 958              		.cfi_offset 14, -4
 501:Src/bno055.c  **** 	/* Variable used to return value of
 502:Src/bno055.c  **** 	communication routine*/
 503:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 504:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
 505:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 506:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 507:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 959              		.loc 1 507 0
 960 0002 124C     		ldr	r4, .L95
ARM GAS  /tmp/ccVWLGiI.s 			page 28


 500:Src/bno055.c  **** 	/* Variable used to return value of
 961              		.loc 1 500 0
 962 0004 83B0     		sub	sp, sp, #12
 963              	.LCFI40:
 964              		.cfi_def_cfa_offset 24
 965              		.loc 1 507 0
 966 0006 2368     		ldr	r3, [r4]
 504:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 967              		.loc 1 504 0
 968 0008 0022     		movs	r2, #0
 969 000a 8DF80720 		strb	r2, [sp, #7]
 970              	.LVL97:
 971              		.loc 1 507 0
 972 000e D3B1     		cbz	r3, .L88
 508:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 509:Src/bno055.c  **** 		} else {
 510:Src/bno055.c  **** 		/*condition check for page, chip id is
 511:Src/bno055.c  **** 		available in the page zero*/
 512:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 973              		.loc 1 512 0
 974 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 975 0012 0546     		mov	r5, r0
 976 0014 61B9     		cbnz	r1, .L94
 977              	.LVL98:
 978              	.L86:
 513:Src/bno055.c  **** 			/* Write the page zero*/
 514:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 515:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 516:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 517:Src/bno055.c  **** 			/* Read the gyro revision id */
 518:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 979              		.loc 1 518 0
 980 0016 1C69     		ldr	r4, [r3, #16]
 981 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 982 001a 0321     		movs	r1, #3
 983 001c 0123     		movs	r3, #1
 984 001e 0DF10702 		add	r2, sp, #7
 985 0022 A047     		blx	r4
 986              	.LVL99:
 519:Src/bno055.c  **** 			(p_bno055->dev_addr,
 520:Src/bno055.c  **** 			BNO055_GYRO_REV_ID_REG,
 521:Src/bno055.c  **** 			&data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 522:Src/bno055.c  **** 			*gyro_rev_id_u8 = data_u8;
 987              		.loc 1 522 0
 988 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 989 0028 2B70     		strb	r3, [r5]
 990              	.LVL100:
 991              	.L85:
 523:Src/bno055.c  **** 		} else {
 524:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 525:Src/bno055.c  **** 		}
 526:Src/bno055.c  **** 	}
 527:Src/bno055.c  **** 	return com_rslt;
 528:Src/bno055.c  **** }
 992              		.loc 1 528 0
 993 002a 40B2     		sxtb	r0, r0
 994 002c 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 29


 995              	.LCFI41:
 996              		.cfi_remember_state
 997              		.cfi_def_cfa_offset 12
 998              		@ sp needed
 999 002e 30BD     		pop	{r4, r5, pc}
 1000              	.LVL101:
 1001              	.L94:
 1002              	.LCFI42:
 1003              		.cfi_restore_state
 514:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1004              		.loc 1 514 0
 1005 0030 1046     		mov	r0, r2
 1006              	.LVL102:
 1007 0032 FFF7FEFF 		bl	bno055_write_page_id
 1008              	.LVL103:
 1009 0036 2368     		ldr	r3, [r4]
 515:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1010              		.loc 1 515 0
 1011 0038 0028     		cmp	r0, #0
 1012 003a ECD0     		beq	.L86
 1013              	.LVL104:
 515:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1014              		.loc 1 515 0 is_stmt 0 discriminator 1
 1015 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 524:Src/bno055.c  **** 		}
 1016              		.loc 1 524 0 is_stmt 1 discriminator 1
 1017 003e FF20     		movs	r0, #255
 515:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1018              		.loc 1 515 0 discriminator 1
 1019 0040 002A     		cmp	r2, #0
 1020 0042 F2D1     		bne	.L85
 1021 0044 E7E7     		b	.L86
 1022              	.LVL105:
 1023              	.L88:
 508:Src/bno055.c  **** 		} else {
 1024              		.loc 1 508 0
 1025 0046 8120     		movs	r0, #129
 1026              	.LVL106:
 1027 0048 EFE7     		b	.L85
 1028              	.L96:
 1029 004a 00BF     		.align	2
 1030              	.L95:
 1031 004c 00000000 		.word	.LANCHOR0
 1032              		.cfi_endproc
 1033              	.LFE9:
 1035              		.section	.text.bno055_read_bl_rev_id,"ax",%progbits
 1036              		.align	2
 1037              		.global	bno055_read_bl_rev_id
 1038              		.thumb
 1039              		.thumb_func
 1041              	bno055_read_bl_rev_id:
 1042              	.LFB10:
 529:Src/bno055.c  **** /*!
 530:Src/bno055.c  ****  *	@brief This API used to read boot loader revision id
 531:Src/bno055.c  ****  *	from register 0x06 it is a byte of value
 532:Src/bno055.c  ****  *
 533:Src/bno055.c  ****  *	@param bl_rev_id_u8 : The boot loader revision id
ARM GAS  /tmp/ccVWLGiI.s 			page 30


 534:Src/bno055.c  ****  *
 535:Src/bno055.c  ****  *
 536:Src/bno055.c  ****  *	@return results of bus communication function
 537:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 538:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 539:Src/bno055.c  ****  *
 540:Src/bno055.c  ****  *
 541:Src/bno055.c  ****  */
 542:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_bl_rev_id(
 543:Src/bno055.c  **** u8 *bl_rev_id_u8)
 544:Src/bno055.c  **** {
 1043              		.loc 1 544 0
 1044              		.cfi_startproc
 1045              		@ args = 0, pretend = 0, frame = 8
 1046              		@ frame_needed = 0, uses_anonymous_args = 0
 1047              	.LVL107:
 1048 0000 30B5     		push	{r4, r5, lr}
 1049              	.LCFI43:
 1050              		.cfi_def_cfa_offset 12
 1051              		.cfi_offset 4, -12
 1052              		.cfi_offset 5, -8
 1053              		.cfi_offset 14, -4
 545:Src/bno055.c  **** 	/* Variable used to return value of
 546:Src/bno055.c  **** 	communication routine*/
 547:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 548:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
 549:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 550:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 551:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1054              		.loc 1 551 0
 1055 0002 124C     		ldr	r4, .L108
 544:Src/bno055.c  **** 	/* Variable used to return value of
 1056              		.loc 1 544 0
 1057 0004 83B0     		sub	sp, sp, #12
 1058              	.LCFI44:
 1059              		.cfi_def_cfa_offset 24
 1060              		.loc 1 551 0
 1061 0006 2368     		ldr	r3, [r4]
 548:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 1062              		.loc 1 548 0
 1063 0008 0022     		movs	r2, #0
 1064 000a 8DF80720 		strb	r2, [sp, #7]
 1065              	.LVL108:
 1066              		.loc 1 551 0
 1067 000e D3B1     		cbz	r3, .L101
 552:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 553:Src/bno055.c  **** 		} else {
 554:Src/bno055.c  **** 		/*condition check for page, chip id is
 555:Src/bno055.c  **** 		available in the page zero*/
 556:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1068              		.loc 1 556 0
 1069 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1070 0012 0546     		mov	r5, r0
 1071 0014 61B9     		cbnz	r1, .L107
 1072              	.LVL109:
 1073              	.L99:
 557:Src/bno055.c  **** 			/* Write the page zero*/
ARM GAS  /tmp/ccVWLGiI.s 			page 31


 558:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 559:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 560:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 561:Src/bno055.c  **** 			/* Read the boot loader revision id */
 562:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1074              		.loc 1 562 0
 1075 0016 1C69     		ldr	r4, [r3, #16]
 1076 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1077 001a 0621     		movs	r1, #6
 1078 001c 0123     		movs	r3, #1
 1079 001e 0DF10702 		add	r2, sp, #7
 1080 0022 A047     		blx	r4
 1081              	.LVL110:
 563:Src/bno055.c  **** 			(p_bno055->dev_addr,
 564:Src/bno055.c  **** 			BNO055_BL_REV_ID_REG,
 565:Src/bno055.c  **** 			&data_u8, BNO055_GEN_READ_WRITE_LENGTH);
 566:Src/bno055.c  **** 			*bl_rev_id_u8 = data_u8;
 1082              		.loc 1 566 0
 1083 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1084 0028 2B70     		strb	r3, [r5]
 1085              	.LVL111:
 1086              	.L98:
 567:Src/bno055.c  **** 		} else {
 568:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 569:Src/bno055.c  **** 		}
 570:Src/bno055.c  **** 	}
 571:Src/bno055.c  **** 	return com_rslt;
 572:Src/bno055.c  **** }
 1087              		.loc 1 572 0
 1088 002a 40B2     		sxtb	r0, r0
 1089 002c 03B0     		add	sp, sp, #12
 1090              	.LCFI45:
 1091              		.cfi_remember_state
 1092              		.cfi_def_cfa_offset 12
 1093              		@ sp needed
 1094 002e 30BD     		pop	{r4, r5, pc}
 1095              	.LVL112:
 1096              	.L107:
 1097              	.LCFI46:
 1098              		.cfi_restore_state
 558:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1099              		.loc 1 558 0
 1100 0030 1046     		mov	r0, r2
 1101              	.LVL113:
 1102 0032 FFF7FEFF 		bl	bno055_write_page_id
 1103              	.LVL114:
 1104 0036 2368     		ldr	r3, [r4]
 559:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1105              		.loc 1 559 0
 1106 0038 0028     		cmp	r0, #0
 1107 003a ECD0     		beq	.L99
 1108              	.LVL115:
 559:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1109              		.loc 1 559 0 is_stmt 0 discriminator 1
 1110 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 568:Src/bno055.c  **** 		}
 1111              		.loc 1 568 0 is_stmt 1 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 32


 1112 003e FF20     		movs	r0, #255
 559:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1113              		.loc 1 559 0 discriminator 1
 1114 0040 002A     		cmp	r2, #0
 1115 0042 F2D1     		bne	.L98
 1116 0044 E7E7     		b	.L99
 1117              	.LVL116:
 1118              	.L101:
 552:Src/bno055.c  **** 		} else {
 1119              		.loc 1 552 0
 1120 0046 8120     		movs	r0, #129
 1121              	.LVL117:
 1122 0048 EFE7     		b	.L98
 1123              	.L109:
 1124 004a 00BF     		.align	2
 1125              	.L108:
 1126 004c 00000000 		.word	.LANCHOR0
 1127              		.cfi_endproc
 1128              	.LFE10:
 1130              		.section	.text.bno055_read_accel_x,"ax",%progbits
 1131              		.align	2
 1132              		.global	bno055_read_accel_x
 1133              		.thumb
 1134              		.thumb_func
 1136              	bno055_read_accel_x:
 1137              	.LFB11:
 573:Src/bno055.c  **** /*!
 574:Src/bno055.c  ****  *	@brief This API reads acceleration data X values
 575:Src/bno055.c  ****  *	from register 0x08 and 0x09 it is a two byte data
 576:Src/bno055.c  ****  *
 577:Src/bno055.c  ****  *
 578:Src/bno055.c  ****  *
 579:Src/bno055.c  ****  *
 580:Src/bno055.c  ****  *	@param accel_x_s16 : The X raw data
 581:Src/bno055.c  ****  *
 582:Src/bno055.c  ****  *
 583:Src/bno055.c  ****  *
 584:Src/bno055.c  ****  *	@return results of bus communication function
 585:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 586:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 587:Src/bno055.c  ****  *
 588:Src/bno055.c  ****  *
 589:Src/bno055.c  ****  */
 590:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_accel_x(s16 *accel_x_s16)
 591:Src/bno055.c  **** {
 1138              		.loc 1 591 0
 1139              		.cfi_startproc
 1140              		@ args = 0, pretend = 0, frame = 8
 1141              		@ frame_needed = 0, uses_anonymous_args = 0
 1142              	.LVL118:
 1143 0000 30B5     		push	{r4, r5, lr}
 1144              	.LCFI47:
 1145              		.cfi_def_cfa_offset 12
 1146              		.cfi_offset 4, -12
 1147              		.cfi_offset 5, -8
 1148              		.cfi_offset 14, -4
 592:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 33


 593:Src/bno055.c  **** 	communication routine*/
 594:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 595:Src/bno055.c  **** 	/* Array holding the accel x value
 596:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - x-LSB
 597:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - x-MSB
 598:Src/bno055.c  **** 	*/
 599:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_DATA_SIZE] = {BNO055_INIT_VALUE,
 600:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 601:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 602:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 603:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1149              		.loc 1 603 0
 1150 0002 144C     		ldr	r4, .L121
 591:Src/bno055.c  **** 	/* Variable used to return value of
 1151              		.loc 1 591 0
 1152 0004 83B0     		sub	sp, sp, #12
 1153              	.LCFI48:
 1154              		.cfi_def_cfa_offset 24
 1155              		.loc 1 603 0
 1156 0006 2368     		ldr	r3, [r4]
 599:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 1157              		.loc 1 599 0
 1158 0008 0022     		movs	r2, #0
 1159 000a 8DF80420 		strb	r2, [sp, #4]
 1160 000e 8DF80520 		strb	r2, [sp, #5]
 1161              	.LVL119:
 1162              		.loc 1 603 0
 1163 0012 EBB1     		cbz	r3, .L114
 604:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 605:Src/bno055.c  **** 		} else {
 606:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1164              		.loc 1 606 0
 1165 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1166 0016 0546     		mov	r5, r0
 1167 0018 79B9     		cbnz	r1, .L120
 1168              	.LVL120:
 1169              	.L112:
 607:Src/bno055.c  **** 			/* Write the page zero*/
 608:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 609:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 610:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 611:Src/bno055.c  **** 			/* Read the accel x axis two byte value*/
 612:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1170              		.loc 1 612 0
 1171 001a 1C69     		ldr	r4, [r3, #16]
 1172 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1173 001e 01AA     		add	r2, sp, #4
 1174 0020 0223     		movs	r3, #2
 1175 0022 0821     		movs	r1, #8
 1176 0024 A047     		blx	r4
 1177              	.LVL121:
 613:Src/bno055.c  **** 			(p_bno055->dev_addr,
 614:Src/bno055.c  **** 			BNO055_ACCEL_DATA_X_LSB_VALUEX_REG,
 615:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
 616:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
 617:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
 618:Src/bno055.c  **** 			BNO055_ACCEL_DATA_X_LSB_VALUEX);
ARM GAS  /tmp/ccVWLGiI.s 			page 34


 619:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
 620:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
 621:Src/bno055.c  **** 			BNO055_ACCEL_DATA_X_MSB_VALUEX);
 622:Src/bno055.c  **** 			*accel_x_s16 = (s16)((((s32)
 1178              		.loc 1 622 0
 1179 0026 9DF90520 		ldrsb	r2, [sp, #5]
 1180 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1181 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 1182 0032 2B80     		strh	r3, [r5]	@ movhi
 1183              	.LVL122:
 1184              	.L111:
 623:Src/bno055.c  **** 			(s8)(data_u8[BNO055_SENSOR_DATA_MSB])) <<
 624:Src/bno055.c  **** 			(BNO055_SHIFT_EIGHT_BITS))
 625:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
 626:Src/bno055.c  **** 		} else {
 627:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 628:Src/bno055.c  **** 		}
 629:Src/bno055.c  **** 	}
 630:Src/bno055.c  **** 	return com_rslt;
 631:Src/bno055.c  **** }
 1185              		.loc 1 631 0
 1186 0034 40B2     		sxtb	r0, r0
 1187 0036 03B0     		add	sp, sp, #12
 1188              	.LCFI49:
 1189              		.cfi_remember_state
 1190              		.cfi_def_cfa_offset 12
 1191              		@ sp needed
 1192 0038 30BD     		pop	{r4, r5, pc}
 1193              	.LVL123:
 1194              	.L120:
 1195              	.LCFI50:
 1196              		.cfi_restore_state
 608:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1197              		.loc 1 608 0
 1198 003a 1046     		mov	r0, r2
 1199              	.LVL124:
 1200 003c FFF7FEFF 		bl	bno055_write_page_id
 1201              	.LVL125:
 1202 0040 2368     		ldr	r3, [r4]
 609:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1203              		.loc 1 609 0
 1204 0042 0028     		cmp	r0, #0
 1205 0044 E9D0     		beq	.L112
 1206              	.LVL126:
 609:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1207              		.loc 1 609 0 is_stmt 0 discriminator 1
 1208 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 627:Src/bno055.c  **** 		}
 1209              		.loc 1 627 0 is_stmt 1 discriminator 1
 1210 0048 FF20     		movs	r0, #255
 609:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1211              		.loc 1 609 0 discriminator 1
 1212 004a 002A     		cmp	r2, #0
 1213 004c F2D1     		bne	.L111
 1214 004e E4E7     		b	.L112
 1215              	.LVL127:
 1216              	.L114:
ARM GAS  /tmp/ccVWLGiI.s 			page 35


 604:Src/bno055.c  **** 		} else {
 1217              		.loc 1 604 0
 1218 0050 8120     		movs	r0, #129
 1219              	.LVL128:
 1220 0052 EFE7     		b	.L111
 1221              	.L122:
 1222              		.align	2
 1223              	.L121:
 1224 0054 00000000 		.word	.LANCHOR0
 1225              		.cfi_endproc
 1226              	.LFE11:
 1228              		.section	.text.bno055_read_accel_y,"ax",%progbits
 1229              		.align	2
 1230              		.global	bno055_read_accel_y
 1231              		.thumb
 1232              		.thumb_func
 1234              	bno055_read_accel_y:
 1235              	.LFB12:
 632:Src/bno055.c  **** /*!
 633:Src/bno055.c  ****  *	@brief This API reads acceleration data Y values
 634:Src/bno055.c  ****  *	from register 0x0A and 0x0B it is a two byte data
 635:Src/bno055.c  ****  *
 636:Src/bno055.c  ****  *
 637:Src/bno055.c  ****  *
 638:Src/bno055.c  ****  *
 639:Src/bno055.c  ****  *	@param accel_y_s16 : The Y raw data
 640:Src/bno055.c  ****  *
 641:Src/bno055.c  ****  *
 642:Src/bno055.c  ****  *
 643:Src/bno055.c  ****  *	@return results of bus communication function
 644:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 645:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 646:Src/bno055.c  ****  *
 647:Src/bno055.c  ****  *
 648:Src/bno055.c  ****  */
 649:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_accel_y(s16 *accel_y_s16)
 650:Src/bno055.c  **** {
 1236              		.loc 1 650 0
 1237              		.cfi_startproc
 1238              		@ args = 0, pretend = 0, frame = 8
 1239              		@ frame_needed = 0, uses_anonymous_args = 0
 1240              	.LVL129:
 1241 0000 30B5     		push	{r4, r5, lr}
 1242              	.LCFI51:
 1243              		.cfi_def_cfa_offset 12
 1244              		.cfi_offset 4, -12
 1245              		.cfi_offset 5, -8
 1246              		.cfi_offset 14, -4
 651:Src/bno055.c  **** 	/* Variable used to return value of
 652:Src/bno055.c  **** 	communication routine*/
 653:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 654:Src/bno055.c  **** 	/* Array holding the accel y value
 655:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - y-LSB
 656:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - y-MSB
 657:Src/bno055.c  **** 	*/
 658:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_DATA_SIZE] = {BNO055_INIT_VALUE,
 659:Src/bno055.c  **** 	BNO055_INIT_VALUE};
ARM GAS  /tmp/ccVWLGiI.s 			page 36


 660:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 661:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 662:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1247              		.loc 1 662 0
 1248 0002 144C     		ldr	r4, .L134
 650:Src/bno055.c  **** 	/* Variable used to return value of
 1249              		.loc 1 650 0
 1250 0004 83B0     		sub	sp, sp, #12
 1251              	.LCFI52:
 1252              		.cfi_def_cfa_offset 24
 1253              		.loc 1 662 0
 1254 0006 2368     		ldr	r3, [r4]
 658:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 1255              		.loc 1 658 0
 1256 0008 0022     		movs	r2, #0
 1257 000a 8DF80420 		strb	r2, [sp, #4]
 1258 000e 8DF80520 		strb	r2, [sp, #5]
 1259              	.LVL130:
 1260              		.loc 1 662 0
 1261 0012 EBB1     		cbz	r3, .L127
 663:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 664:Src/bno055.c  **** 		} else {
 665:Src/bno055.c  **** 		/*condition check for page, chip id is
 666:Src/bno055.c  **** 		available in the page zero*/
 667:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1262              		.loc 1 667 0
 1263 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1264 0016 0546     		mov	r5, r0
 1265 0018 79B9     		cbnz	r1, .L133
 1266              	.LVL131:
 1267              	.L125:
 668:Src/bno055.c  **** 			/* Write the page zero*/
 669:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 670:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 671:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 672:Src/bno055.c  **** 			/* Read the accel y axis two byte value*/
 673:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1268              		.loc 1 673 0
 1269 001a 1C69     		ldr	r4, [r3, #16]
 1270 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1271 001e 01AA     		add	r2, sp, #4
 1272 0020 0223     		movs	r3, #2
 1273 0022 0A21     		movs	r1, #10
 1274 0024 A047     		blx	r4
 1275              	.LVL132:
 674:Src/bno055.c  **** 			(p_bno055->dev_addr,
 675:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Y_LSB_VALUEY_REG,
 676:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
 677:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
 678:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
 679:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Y_LSB_VALUEY);
 680:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
 681:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
 682:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Y_MSB_VALUEY);
 683:Src/bno055.c  **** 			*accel_y_s16 = (s16)((((s32)
 1276              		.loc 1 683 0
 1277 0026 9DF90520 		ldrsb	r2, [sp, #5]
ARM GAS  /tmp/ccVWLGiI.s 			page 37


 1278 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1279 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 1280 0032 2B80     		strh	r3, [r5]	@ movhi
 1281              	.LVL133:
 1282              	.L124:
 684:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
 685:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
 686:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_LSB]));
 687:Src/bno055.c  **** 		} else {
 688:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 689:Src/bno055.c  **** 		}
 690:Src/bno055.c  **** 	}
 691:Src/bno055.c  **** 	return com_rslt;
 692:Src/bno055.c  **** }
 1283              		.loc 1 692 0
 1284 0034 40B2     		sxtb	r0, r0
 1285 0036 03B0     		add	sp, sp, #12
 1286              	.LCFI53:
 1287              		.cfi_remember_state
 1288              		.cfi_def_cfa_offset 12
 1289              		@ sp needed
 1290 0038 30BD     		pop	{r4, r5, pc}
 1291              	.LVL134:
 1292              	.L133:
 1293              	.LCFI54:
 1294              		.cfi_restore_state
 669:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1295              		.loc 1 669 0
 1296 003a 1046     		mov	r0, r2
 1297              	.LVL135:
 1298 003c FFF7FEFF 		bl	bno055_write_page_id
 1299              	.LVL136:
 1300 0040 2368     		ldr	r3, [r4]
 670:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1301              		.loc 1 670 0
 1302 0042 0028     		cmp	r0, #0
 1303 0044 E9D0     		beq	.L125
 1304              	.LVL137:
 670:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1305              		.loc 1 670 0 is_stmt 0 discriminator 1
 1306 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 688:Src/bno055.c  **** 		}
 1307              		.loc 1 688 0 is_stmt 1 discriminator 1
 1308 0048 FF20     		movs	r0, #255
 670:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1309              		.loc 1 670 0 discriminator 1
 1310 004a 002A     		cmp	r2, #0
 1311 004c F2D1     		bne	.L124
 1312 004e E4E7     		b	.L125
 1313              	.LVL138:
 1314              	.L127:
 663:Src/bno055.c  **** 		} else {
 1315              		.loc 1 663 0
 1316 0050 8120     		movs	r0, #129
 1317              	.LVL139:
 1318 0052 EFE7     		b	.L124
 1319              	.L135:
ARM GAS  /tmp/ccVWLGiI.s 			page 38


 1320              		.align	2
 1321              	.L134:
 1322 0054 00000000 		.word	.LANCHOR0
 1323              		.cfi_endproc
 1324              	.LFE12:
 1326              		.section	.text.bno055_read_accel_z,"ax",%progbits
 1327              		.align	2
 1328              		.global	bno055_read_accel_z
 1329              		.thumb
 1330              		.thumb_func
 1332              	bno055_read_accel_z:
 1333              	.LFB13:
 693:Src/bno055.c  **** /*!
 694:Src/bno055.c  ****  *	@brief This API reads acceleration data z values
 695:Src/bno055.c  ****  *	from register 0x0C and 0x0D it is a two byte data
 696:Src/bno055.c  ****  *
 697:Src/bno055.c  ****  *
 698:Src/bno055.c  ****  *
 699:Src/bno055.c  ****  *
 700:Src/bno055.c  ****  *	@param accel_z_s16 : The z raw data
 701:Src/bno055.c  ****  *
 702:Src/bno055.c  ****  *
 703:Src/bno055.c  ****  *
 704:Src/bno055.c  ****  *	@return results of bus communication function
 705:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 706:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 707:Src/bno055.c  ****  *
 708:Src/bno055.c  ****  *
 709:Src/bno055.c  ****  */
 710:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_accel_z(s16 *accel_z_s16)
 711:Src/bno055.c  **** {
 1334              		.loc 1 711 0
 1335              		.cfi_startproc
 1336              		@ args = 0, pretend = 0, frame = 8
 1337              		@ frame_needed = 0, uses_anonymous_args = 0
 1338              	.LVL140:
 1339 0000 30B5     		push	{r4, r5, lr}
 1340              	.LCFI55:
 1341              		.cfi_def_cfa_offset 12
 1342              		.cfi_offset 4, -12
 1343              		.cfi_offset 5, -8
 1344              		.cfi_offset 14, -4
 712:Src/bno055.c  **** 	/* Variable used to return value of
 713:Src/bno055.c  **** 	communication routine*/
 714:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 715:Src/bno055.c  **** 	/* Array holding the accel z value
 716:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - z-LSB
 717:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - z-MSB
 718:Src/bno055.c  **** 	*/
 719:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_DATA_SIZE] = {BNO055_INIT_VALUE,
 720:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 721:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 722:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 723:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1345              		.loc 1 723 0
 1346 0002 144C     		ldr	r4, .L147
 711:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 39


 1347              		.loc 1 711 0
 1348 0004 83B0     		sub	sp, sp, #12
 1349              	.LCFI56:
 1350              		.cfi_def_cfa_offset 24
 1351              		.loc 1 723 0
 1352 0006 2368     		ldr	r3, [r4]
 719:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 1353              		.loc 1 719 0
 1354 0008 0022     		movs	r2, #0
 1355 000a 8DF80420 		strb	r2, [sp, #4]
 1356 000e 8DF80520 		strb	r2, [sp, #5]
 1357              	.LVL141:
 1358              		.loc 1 723 0
 1359 0012 EBB1     		cbz	r3, .L140
 724:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 725:Src/bno055.c  **** 		} else {
 726:Src/bno055.c  **** 		/*condition check for page, chip id is
 727:Src/bno055.c  **** 		available in the page zero*/
 728:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1360              		.loc 1 728 0
 1361 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1362 0016 0546     		mov	r5, r0
 1363 0018 79B9     		cbnz	r1, .L146
 1364              	.LVL142:
 1365              	.L138:
 729:Src/bno055.c  **** 			/* Write the page zero*/
 730:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 731:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 732:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 733:Src/bno055.c  **** 			/* Read the accel z axis two byte value*/
 734:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1366              		.loc 1 734 0
 1367 001a 1C69     		ldr	r4, [r3, #16]
 1368 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1369 001e 01AA     		add	r2, sp, #4
 1370 0020 0223     		movs	r3, #2
 1371 0022 0C21     		movs	r1, #12
 1372 0024 A047     		blx	r4
 1373              	.LVL143:
 735:Src/bno055.c  **** 			(p_bno055->dev_addr,
 736:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Z_LSB_VALUEZ_REG,
 737:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
 738:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
 739:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
 740:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Z_LSB_VALUEZ);
 741:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
 742:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
 743:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Z_MSB_VALUEZ);
 744:Src/bno055.c  **** 			*accel_z_s16 = (s16)((((s32)
 1374              		.loc 1 744 0
 1375 0026 9DF90520 		ldrsb	r2, [sp, #5]
 1376 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1377 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 1378 0032 2B80     		strh	r3, [r5]	@ movhi
 1379              	.LVL144:
 1380              	.L137:
 745:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
ARM GAS  /tmp/ccVWLGiI.s 			page 40


 746:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
 747:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_LSB]));
 748:Src/bno055.c  **** 		} else {
 749:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 750:Src/bno055.c  **** 		}
 751:Src/bno055.c  **** 	}
 752:Src/bno055.c  **** 	return com_rslt;
 753:Src/bno055.c  **** }
 1381              		.loc 1 753 0
 1382 0034 40B2     		sxtb	r0, r0
 1383 0036 03B0     		add	sp, sp, #12
 1384              	.LCFI57:
 1385              		.cfi_remember_state
 1386              		.cfi_def_cfa_offset 12
 1387              		@ sp needed
 1388 0038 30BD     		pop	{r4, r5, pc}
 1389              	.LVL145:
 1390              	.L146:
 1391              	.LCFI58:
 1392              		.cfi_restore_state
 730:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1393              		.loc 1 730 0
 1394 003a 1046     		mov	r0, r2
 1395              	.LVL146:
 1396 003c FFF7FEFF 		bl	bno055_write_page_id
 1397              	.LVL147:
 1398 0040 2368     		ldr	r3, [r4]
 731:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1399              		.loc 1 731 0
 1400 0042 0028     		cmp	r0, #0
 1401 0044 E9D0     		beq	.L138
 1402              	.LVL148:
 731:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1403              		.loc 1 731 0 is_stmt 0 discriminator 1
 1404 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 749:Src/bno055.c  **** 		}
 1405              		.loc 1 749 0 is_stmt 1 discriminator 1
 1406 0048 FF20     		movs	r0, #255
 731:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1407              		.loc 1 731 0 discriminator 1
 1408 004a 002A     		cmp	r2, #0
 1409 004c F2D1     		bne	.L137
 1410 004e E4E7     		b	.L138
 1411              	.LVL149:
 1412              	.L140:
 724:Src/bno055.c  **** 		} else {
 1413              		.loc 1 724 0
 1414 0050 8120     		movs	r0, #129
 1415              	.LVL150:
 1416 0052 EFE7     		b	.L137
 1417              	.L148:
 1418              		.align	2
 1419              	.L147:
 1420 0054 00000000 		.word	.LANCHOR0
 1421              		.cfi_endproc
 1422              	.LFE13:
 1424              		.section	.text.bno055_read_accel_xyz,"ax",%progbits
ARM GAS  /tmp/ccVWLGiI.s 			page 41


 1425              		.align	2
 1426              		.global	bno055_read_accel_xyz
 1427              		.thumb
 1428              		.thumb_func
 1430              	bno055_read_accel_xyz:
 1431              	.LFB14:
 754:Src/bno055.c  **** /*!
 755:Src/bno055.c  ****  *	@brief This API reads acceleration data xyz values
 756:Src/bno055.c  ****  *	from register 0x08 to 0x0D it is a six byte data
 757:Src/bno055.c  ****  *
 758:Src/bno055.c  ****  *
 759:Src/bno055.c  ****  *	@param accel : The value of accel xyz data
 760:Src/bno055.c  ****  *
 761:Src/bno055.c  ****  *	Parameter |    result
 762:Src/bno055.c  ****  *  --------- | -----------------
 763:Src/bno055.c  ****  *	 x        | The accel x data
 764:Src/bno055.c  ****  *	 y        | The accel y data
 765:Src/bno055.c  ****  *	 z        | The accel z data
 766:Src/bno055.c  ****  *
 767:Src/bno055.c  ****  *
 768:Src/bno055.c  ****  *
 769:Src/bno055.c  ****  *	@return results of bus communication function
 770:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 771:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 772:Src/bno055.c  ****  *
 773:Src/bno055.c  ****  */
 774:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_accel_xyz(
 775:Src/bno055.c  **** struct bno055_accel_t *accel)
 776:Src/bno055.c  **** {
 1432              		.loc 1 776 0
 1433              		.cfi_startproc
 1434              		@ args = 0, pretend = 0, frame = 8
 1435              		@ frame_needed = 0, uses_anonymous_args = 0
 1436              	.LVL151:
 1437 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1438              	.LCFI59:
 1439              		.cfi_def_cfa_offset 20
 1440              		.cfi_offset 4, -20
 1441              		.cfi_offset 5, -16
 1442              		.cfi_offset 6, -12
 1443              		.cfi_offset 7, -8
 1444              		.cfi_offset 14, -4
 777:Src/bno055.c  **** 	/* Variable used to return value of
 778:Src/bno055.c  **** 	communication routine*/
 779:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 780:Src/bno055.c  **** 	/* Array holding the accel xyz value
 781:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] - x->LSB
 782:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] - x->MSB
 783:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] - y->MSB
 784:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] - y->MSB
 785:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] - z->MSB
 786:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] - z->MSB
 787:Src/bno055.c  **** 	*/
 788:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_XYZ_DATA_SIZE] = {
 789:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 790:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 791:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
ARM GAS  /tmp/ccVWLGiI.s 			page 42


 792:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 793:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 794:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1445              		.loc 1 794 0
 1446 0002 1F4D     		ldr	r5, .L160
 776:Src/bno055.c  **** 	/* Variable used to return value of
 1447              		.loc 1 776 0
 1448 0004 83B0     		sub	sp, sp, #12
 1449              	.LCFI60:
 1450              		.cfi_def_cfa_offset 32
 1451              		.loc 1 794 0
 1452 0006 2A68     		ldr	r2, [r5]
 788:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 1453              		.loc 1 788 0
 1454 0008 0023     		movs	r3, #0
 1455 000a 8DF80030 		strb	r3, [sp]
 1456 000e 8DF80130 		strb	r3, [sp, #1]
 1457 0012 8DF80230 		strb	r3, [sp, #2]
 1458 0016 8DF80330 		strb	r3, [sp, #3]
 1459 001a 8DF80430 		strb	r3, [sp, #4]
 1460 001e 8DF80530 		strb	r3, [sp, #5]
 1461              	.LVL152:
 1462              		.loc 1 794 0
 1463 0022 5AB3     		cbz	r2, .L153
 795:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 796:Src/bno055.c  **** 		} else {
 797:Src/bno055.c  **** 		/*condition check for page, chip id is
 798:Src/bno055.c  **** 		available in the page zero*/
 799:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1464              		.loc 1 799 0
 1465 0024 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 1466 0026 0446     		mov	r4, r0
 1467 0028 E9B9     		cbnz	r1, .L159
 1468              	.LVL153:
 1469              	.L151:
 800:Src/bno055.c  **** 			/* Write the page zero*/
 801:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 802:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 803:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 804:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1470              		.loc 1 804 0
 1471 002a 1569     		ldr	r5, [r2, #16]
 1472 002c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 1473 002e 0821     		movs	r1, #8
 1474 0030 6A46     		mov	r2, sp
 1475 0032 0623     		movs	r3, #6
 1476 0034 A847     		blx	r5
 1477              	.LVL154:
 805:Src/bno055.c  **** 			(p_bno055->dev_addr,
 806:Src/bno055.c  **** 			BNO055_ACCEL_DATA_X_LSB_VALUEX_REG,
 807:Src/bno055.c  **** 			data_u8, BNO055_ACCEL_XYZ_DATA_SIZE);
 808:Src/bno055.c  **** 			/* Data X*/
 809:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] =
 810:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
 811:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB],
 812:Src/bno055.c  **** 			BNO055_ACCEL_DATA_X_LSB_VALUEX);
 813:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] =
ARM GAS  /tmp/ccVWLGiI.s 			page 43


 814:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
 815:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB],
 816:Src/bno055.c  **** 			BNO055_ACCEL_DATA_X_MSB_VALUEX);
 817:Src/bno055.c  **** 			accel->x = (s16)((((s32)
 1478              		.loc 1 817 0
 1479 0036 9DF90170 		ldrsb	r7, [sp, #1]
 1480 003a 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
 818:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 819:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
 820:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB]));
 821:Src/bno055.c  **** 			/* Data Y*/
 822:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] =
 823:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
 824:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB],
 825:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Y_LSB_VALUEY);
 826:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] =
 827:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
 828:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB],
 829:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Y_MSB_VALUEY);
 830:Src/bno055.c  **** 			accel->y = (s16)((((s32)
 1481              		.loc 1 830 0
 1482 003e 9DF90360 		ldrsb	r6, [sp, #3]
 1483 0042 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 831:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 832:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
 833:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB]));
 834:Src/bno055.c  **** 			/* Data Z*/
 835:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] =
 836:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
 837:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB],
 838:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Z_LSB_VALUEZ);
 839:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] =
 840:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
 841:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB],
 842:Src/bno055.c  **** 			BNO055_ACCEL_DATA_Z_MSB_VALUEZ);
 843:Src/bno055.c  **** 			accel->z = (s16)((((s32)
 1484              		.loc 1 843 0
 1485 0046 9DF90550 		ldrsb	r5, [sp, #5]
 1486 004a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 817:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 1487              		.loc 1 817 0
 1488 004e 41EA0721 		orr	r1, r1, r7, lsl #8
 830:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 1489              		.loc 1 830 0
 1490 0052 42EA0622 		orr	r2, r2, r6, lsl #8
 1491              		.loc 1 843 0
 1492 0056 43EA0523 		orr	r3, r3, r5, lsl #8
 817:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 1493              		.loc 1 817 0
 1494 005a 2180     		strh	r1, [r4]	@ movhi
 830:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 1495              		.loc 1 830 0
 1496 005c 6280     		strh	r2, [r4, #2]	@ movhi
 1497              		.loc 1 843 0
 1498 005e A380     		strh	r3, [r4, #4]	@ movhi
 1499              	.LVL155:
 1500              	.L150:
ARM GAS  /tmp/ccVWLGiI.s 			page 44


 844:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB])) <<
 845:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
 846:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB]));
 847:Src/bno055.c  **** 		} else {
 848:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 849:Src/bno055.c  **** 		}
 850:Src/bno055.c  **** 	}
 851:Src/bno055.c  **** 	return com_rslt;
 852:Src/bno055.c  **** }
 1501              		.loc 1 852 0
 1502 0060 40B2     		sxtb	r0, r0
 1503 0062 03B0     		add	sp, sp, #12
 1504              	.LCFI61:
 1505              		.cfi_remember_state
 1506              		.cfi_def_cfa_offset 20
 1507              		@ sp needed
 1508 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 1509              	.LVL156:
 1510              	.L159:
 1511              	.LCFI62:
 1512              		.cfi_restore_state
 801:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1513              		.loc 1 801 0
 1514 0066 1846     		mov	r0, r3
 1515              	.LVL157:
 1516 0068 FFF7FEFF 		bl	bno055_write_page_id
 1517              	.LVL158:
 1518 006c 2A68     		ldr	r2, [r5]
 802:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1519              		.loc 1 802 0
 1520 006e 0028     		cmp	r0, #0
 1521 0070 DBD0     		beq	.L151
 1522              	.LVL159:
 802:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1523              		.loc 1 802 0 is_stmt 0 discriminator 1
 1524 0072 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 848:Src/bno055.c  **** 		}
 1525              		.loc 1 848 0 is_stmt 1 discriminator 1
 1526 0074 FF20     		movs	r0, #255
 802:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1527              		.loc 1 802 0 discriminator 1
 1528 0076 002B     		cmp	r3, #0
 1529 0078 F2D1     		bne	.L150
 1530 007a D6E7     		b	.L151
 1531              	.LVL160:
 1532              	.L153:
 795:Src/bno055.c  **** 		} else {
 1533              		.loc 1 795 0
 1534 007c 8120     		movs	r0, #129
 1535              	.LVL161:
 1536 007e EFE7     		b	.L150
 1537              	.L161:
 1538              		.align	2
 1539              	.L160:
 1540 0080 00000000 		.word	.LANCHOR0
 1541              		.cfi_endproc
 1542              	.LFE14:
ARM GAS  /tmp/ccVWLGiI.s 			page 45


 1544              		.section	.text.bno055_read_mag_x,"ax",%progbits
 1545              		.align	2
 1546              		.global	bno055_read_mag_x
 1547              		.thumb
 1548              		.thumb_func
 1550              	bno055_read_mag_x:
 1551              	.LFB15:
 853:Src/bno055.c  **** /*!
 854:Src/bno055.c  ****  *	@brief This API reads mag data x values
 855:Src/bno055.c  ****  *	from register 0x0E and 0x0F it is a two byte data
 856:Src/bno055.c  ****  *
 857:Src/bno055.c  ****  *
 858:Src/bno055.c  ****  *
 859:Src/bno055.c  ****  *
 860:Src/bno055.c  ****  *	@param mag_x_s16 : The x raw data
 861:Src/bno055.c  ****  *
 862:Src/bno055.c  ****  *
 863:Src/bno055.c  ****  *
 864:Src/bno055.c  ****  *	@return results of bus communication function
 865:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 866:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 867:Src/bno055.c  ****  *
 868:Src/bno055.c  ****  *
 869:Src/bno055.c  ****  *
 870:Src/bno055.c  ****  */
 871:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_mag_x(s16 *mag_x_s16)
 872:Src/bno055.c  **** {
 1552              		.loc 1 872 0
 1553              		.cfi_startproc
 1554              		@ args = 0, pretend = 0, frame = 8
 1555              		@ frame_needed = 0, uses_anonymous_args = 0
 1556              	.LVL162:
 1557 0000 30B5     		push	{r4, r5, lr}
 1558              	.LCFI63:
 1559              		.cfi_def_cfa_offset 12
 1560              		.cfi_offset 4, -12
 1561              		.cfi_offset 5, -8
 1562              		.cfi_offset 14, -4
 873:Src/bno055.c  **** 	/* Variable used to return value of
 874:Src/bno055.c  **** 	communication routine*/
 875:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 876:Src/bno055.c  **** 	/* Array holding the mag x value
 877:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - x->LSB
 878:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - x->MSB
 879:Src/bno055.c  **** 	*/
 880:Src/bno055.c  **** 	u8 data_u8[BNO055_MAG_DATA_SIZE] = {BNO055_INIT_VALUE,
 881:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 882:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 883:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 884:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1563              		.loc 1 884 0
 1564 0002 144C     		ldr	r4, .L173
 872:Src/bno055.c  **** 	/* Variable used to return value of
 1565              		.loc 1 872 0
 1566 0004 83B0     		sub	sp, sp, #12
 1567              	.LCFI64:
 1568              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccVWLGiI.s 			page 46


 1569              		.loc 1 884 0
 1570 0006 2368     		ldr	r3, [r4]
 880:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 1571              		.loc 1 880 0
 1572 0008 0022     		movs	r2, #0
 1573 000a 8DF80420 		strb	r2, [sp, #4]
 1574 000e 8DF80520 		strb	r2, [sp, #5]
 1575              	.LVL163:
 1576              		.loc 1 884 0
 1577 0012 EBB1     		cbz	r3, .L166
 885:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 886:Src/bno055.c  **** 		} else {
 887:Src/bno055.c  **** 		/*condition check for page, chip id is
 888:Src/bno055.c  **** 		available in the page zero*/
 889:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1578              		.loc 1 889 0
 1579 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1580 0016 0546     		mov	r5, r0
 1581 0018 79B9     		cbnz	r1, .L172
 1582              	.LVL164:
 1583              	.L164:
 890:Src/bno055.c  **** 			/* Write the page zero*/
 891:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 892:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 893:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 894:Src/bno055.c  **** 			/*Read the mag x two bytes of data */
 895:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1584              		.loc 1 895 0
 1585 001a 1C69     		ldr	r4, [r3, #16]
 1586 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1587 001e 01AA     		add	r2, sp, #4
 1588 0020 0223     		movs	r3, #2
 1589 0022 0E21     		movs	r1, #14
 1590 0024 A047     		blx	r4
 1591              	.LVL165:
 896:Src/bno055.c  **** 			(p_bno055->dev_addr,
 897:Src/bno055.c  **** 			BNO055_MAG_DATA_X_LSB_VALUEX_REG,
 898:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
 899:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
 900:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
 901:Src/bno055.c  **** 			BNO055_MAG_DATA_X_LSB_VALUEX);
 902:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
 903:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
 904:Src/bno055.c  **** 			BNO055_MAG_DATA_X_MSB_VALUEX);
 905:Src/bno055.c  **** 			*mag_x_s16 = (s16)((((s32)
 1592              		.loc 1 905 0
 1593 0026 9DF90520 		ldrsb	r2, [sp, #5]
 1594 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1595 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 1596 0032 2B80     		strh	r3, [r5]	@ movhi
 1597              	.LVL166:
 1598              	.L163:
 906:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
 907:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) | (
 908:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB]));
 909:Src/bno055.c  **** 		} else {
 910:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 47


 911:Src/bno055.c  **** 		}
 912:Src/bno055.c  **** 	}
 913:Src/bno055.c  **** 	return com_rslt;
 914:Src/bno055.c  **** }
 1599              		.loc 1 914 0
 1600 0034 40B2     		sxtb	r0, r0
 1601 0036 03B0     		add	sp, sp, #12
 1602              	.LCFI65:
 1603              		.cfi_remember_state
 1604              		.cfi_def_cfa_offset 12
 1605              		@ sp needed
 1606 0038 30BD     		pop	{r4, r5, pc}
 1607              	.LVL167:
 1608              	.L172:
 1609              	.LCFI66:
 1610              		.cfi_restore_state
 891:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1611              		.loc 1 891 0
 1612 003a 1046     		mov	r0, r2
 1613              	.LVL168:
 1614 003c FFF7FEFF 		bl	bno055_write_page_id
 1615              	.LVL169:
 1616 0040 2368     		ldr	r3, [r4]
 892:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1617              		.loc 1 892 0
 1618 0042 0028     		cmp	r0, #0
 1619 0044 E9D0     		beq	.L164
 1620              	.LVL170:
 892:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1621              		.loc 1 892 0 is_stmt 0 discriminator 1
 1622 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 910:Src/bno055.c  **** 		}
 1623              		.loc 1 910 0 is_stmt 1 discriminator 1
 1624 0048 FF20     		movs	r0, #255
 892:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1625              		.loc 1 892 0 discriminator 1
 1626 004a 002A     		cmp	r2, #0
 1627 004c F2D1     		bne	.L163
 1628 004e E4E7     		b	.L164
 1629              	.LVL171:
 1630              	.L166:
 885:Src/bno055.c  **** 		} else {
 1631              		.loc 1 885 0
 1632 0050 8120     		movs	r0, #129
 1633              	.LVL172:
 1634 0052 EFE7     		b	.L163
 1635              	.L174:
 1636              		.align	2
 1637              	.L173:
 1638 0054 00000000 		.word	.LANCHOR0
 1639              		.cfi_endproc
 1640              	.LFE15:
 1642              		.section	.text.bno055_read_mag_y,"ax",%progbits
 1643              		.align	2
 1644              		.global	bno055_read_mag_y
 1645              		.thumb
 1646              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 48


 1648              	bno055_read_mag_y:
 1649              	.LFB16:
 915:Src/bno055.c  **** /*!
 916:Src/bno055.c  ****  *	@brief This API reads mag data y values
 917:Src/bno055.c  ****  *	from register 0x10 and 0x11 it is a two byte data
 918:Src/bno055.c  ****  *
 919:Src/bno055.c  ****  *
 920:Src/bno055.c  ****  *
 921:Src/bno055.c  ****  *
 922:Src/bno055.c  ****  *	@param mag_y_s16 : The y raw data
 923:Src/bno055.c  ****  *
 924:Src/bno055.c  ****  *
 925:Src/bno055.c  ****  *
 926:Src/bno055.c  ****  *	@return results of bus communication function
 927:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 928:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 929:Src/bno055.c  ****  *
 930:Src/bno055.c  ****  *
 931:Src/bno055.c  ****  */
 932:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_mag_y(s16 *mag_y_s16)
 933:Src/bno055.c  **** {
 1650              		.loc 1 933 0
 1651              		.cfi_startproc
 1652              		@ args = 0, pretend = 0, frame = 8
 1653              		@ frame_needed = 0, uses_anonymous_args = 0
 1654              	.LVL173:
 1655 0000 30B5     		push	{r4, r5, lr}
 1656              	.LCFI67:
 1657              		.cfi_def_cfa_offset 12
 1658              		.cfi_offset 4, -12
 1659              		.cfi_offset 5, -8
 1660              		.cfi_offset 14, -4
 934:Src/bno055.c  **** 	/* Variable used to return value of
 935:Src/bno055.c  **** 	communication routine*/
 936:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 937:Src/bno055.c  **** 	/* Array holding the mag y value
 938:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - y->LSB
 939:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - y->MSB
 940:Src/bno055.c  **** 	*/
 941:Src/bno055.c  **** 	u8 data_u8[BNO055_MAG_DATA_SIZE] = {
 942:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 943:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 944:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
 945:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1661              		.loc 1 945 0
 1662 0002 144C     		ldr	r4, .L186
 933:Src/bno055.c  **** 	/* Variable used to return value of
 1663              		.loc 1 933 0
 1664 0004 83B0     		sub	sp, sp, #12
 1665              	.LCFI68:
 1666              		.cfi_def_cfa_offset 24
 1667              		.loc 1 945 0
 1668 0006 2368     		ldr	r3, [r4]
 941:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 1669              		.loc 1 941 0
 1670 0008 0022     		movs	r2, #0
 1671 000a 8DF80420 		strb	r2, [sp, #4]
ARM GAS  /tmp/ccVWLGiI.s 			page 49


 1672 000e 8DF80520 		strb	r2, [sp, #5]
 1673              	.LVL174:
 1674              		.loc 1 945 0
 1675 0012 EBB1     		cbz	r3, .L179
 946:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 947:Src/bno055.c  **** 		} else {
 948:Src/bno055.c  **** 		/*condition check for page, chip id is
 949:Src/bno055.c  **** 		available in the page zero*/
 950:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1676              		.loc 1 950 0
 1677 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1678 0016 0546     		mov	r5, r0
 1679 0018 79B9     		cbnz	r1, .L185
 1680              	.LVL175:
 1681              	.L177:
 951:Src/bno055.c  **** 			/* Write the page zero*/
 952:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
 953:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 954:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 955:Src/bno055.c  **** 			/*Read the mag y two bytes of data */
 956:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1682              		.loc 1 956 0
 1683 001a 1C69     		ldr	r4, [r3, #16]
 1684 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1685 001e 01AA     		add	r2, sp, #4
 1686 0020 0223     		movs	r3, #2
 1687 0022 1021     		movs	r1, #16
 1688 0024 A047     		blx	r4
 1689              	.LVL176:
 957:Src/bno055.c  **** 			(p_bno055->dev_addr,
 958:Src/bno055.c  **** 			BNO055_MAG_DATA_Y_LSB_VALUEY_REG,
 959:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
 960:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
 961:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
 962:Src/bno055.c  **** 			BNO055_MAG_DATA_Y_LSB_VALUEY);
 963:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
 964:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
 965:Src/bno055.c  **** 			BNO055_MAG_DATA_Y_MSB_VALUEY);
 966:Src/bno055.c  **** 			*mag_y_s16 = (s16)((((s32)
 1690              		.loc 1 966 0
 1691 0026 9DF90520 		ldrsb	r2, [sp, #5]
 1692 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1693 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 1694 0032 2B80     		strh	r3, [r5]	@ movhi
 1695              	.LVL177:
 1696              	.L176:
 967:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
 968:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
 969:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_LSB]));
 970:Src/bno055.c  **** 		} else {
 971:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 972:Src/bno055.c  **** 		}
 973:Src/bno055.c  **** 	}
 974:Src/bno055.c  **** 	return com_rslt;
 975:Src/bno055.c  **** }
 1697              		.loc 1 975 0
 1698 0034 40B2     		sxtb	r0, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 50


 1699 0036 03B0     		add	sp, sp, #12
 1700              	.LCFI69:
 1701              		.cfi_remember_state
 1702              		.cfi_def_cfa_offset 12
 1703              		@ sp needed
 1704 0038 30BD     		pop	{r4, r5, pc}
 1705              	.LVL178:
 1706              	.L185:
 1707              	.LCFI70:
 1708              		.cfi_restore_state
 952:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1709              		.loc 1 952 0
 1710 003a 1046     		mov	r0, r2
 1711              	.LVL179:
 1712 003c FFF7FEFF 		bl	bno055_write_page_id
 1713              	.LVL180:
 1714 0040 2368     		ldr	r3, [r4]
 953:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1715              		.loc 1 953 0
 1716 0042 0028     		cmp	r0, #0
 1717 0044 E9D0     		beq	.L177
 1718              	.LVL181:
 953:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1719              		.loc 1 953 0 is_stmt 0 discriminator 1
 1720 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 971:Src/bno055.c  **** 		}
 1721              		.loc 1 971 0 is_stmt 1 discriminator 1
 1722 0048 FF20     		movs	r0, #255
 953:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1723              		.loc 1 953 0 discriminator 1
 1724 004a 002A     		cmp	r2, #0
 1725 004c F2D1     		bne	.L176
 1726 004e E4E7     		b	.L177
 1727              	.LVL182:
 1728              	.L179:
 946:Src/bno055.c  **** 		} else {
 1729              		.loc 1 946 0
 1730 0050 8120     		movs	r0, #129
 1731              	.LVL183:
 1732 0052 EFE7     		b	.L176
 1733              	.L187:
 1734              		.align	2
 1735              	.L186:
 1736 0054 00000000 		.word	.LANCHOR0
 1737              		.cfi_endproc
 1738              	.LFE16:
 1740              		.section	.text.bno055_read_mag_z,"ax",%progbits
 1741              		.align	2
 1742              		.global	bno055_read_mag_z
 1743              		.thumb
 1744              		.thumb_func
 1746              	bno055_read_mag_z:
 1747              	.LFB17:
 976:Src/bno055.c  **** /*!
 977:Src/bno055.c  ****  *	@brief This API reads mag data z values
 978:Src/bno055.c  ****  *	from register 0x12 and 0x13 it is a two byte data
 979:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 51


 980:Src/bno055.c  ****  *
 981:Src/bno055.c  ****  *
 982:Src/bno055.c  ****  *
 983:Src/bno055.c  ****  *	@param mag_z_s16 : The z raw data
 984:Src/bno055.c  ****  *
 985:Src/bno055.c  ****  *
 986:Src/bno055.c  ****  *
 987:Src/bno055.c  ****  *	@return results of bus communication function
 988:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
 989:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
 990:Src/bno055.c  ****  *
 991:Src/bno055.c  ****  *
 992:Src/bno055.c  ****  *
 993:Src/bno055.c  ****  */
 994:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_mag_z(s16 *mag_z_s16)
 995:Src/bno055.c  **** {
 1748              		.loc 1 995 0
 1749              		.cfi_startproc
 1750              		@ args = 0, pretend = 0, frame = 8
 1751              		@ frame_needed = 0, uses_anonymous_args = 0
 1752              	.LVL184:
 1753 0000 30B5     		push	{r4, r5, lr}
 1754              	.LCFI71:
 1755              		.cfi_def_cfa_offset 12
 1756              		.cfi_offset 4, -12
 1757              		.cfi_offset 5, -8
 1758              		.cfi_offset 14, -4
 996:Src/bno055.c  **** 	/* Variable used to return value of
 997:Src/bno055.c  **** 	communication routine*/
 998:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 999:Src/bno055.c  **** 	/* Array holding the mag z value
1000:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - z->LSB
1001:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - z->MSB
1002:Src/bno055.c  **** 	*/
1003:Src/bno055.c  **** 	u8 data_u8[BNO055_MAG_DATA_SIZE] = {
1004:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1005:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1006:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1007:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1759              		.loc 1 1007 0
 1760 0002 144C     		ldr	r4, .L199
 995:Src/bno055.c  **** 	/* Variable used to return value of
 1761              		.loc 1 995 0
 1762 0004 83B0     		sub	sp, sp, #12
 1763              	.LCFI72:
 1764              		.cfi_def_cfa_offset 24
 1765              		.loc 1 1007 0
 1766 0006 2368     		ldr	r3, [r4]
1003:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 1767              		.loc 1 1003 0
 1768 0008 0022     		movs	r2, #0
 1769 000a 8DF80420 		strb	r2, [sp, #4]
 1770 000e 8DF80520 		strb	r2, [sp, #5]
 1771              	.LVL185:
 1772              		.loc 1 1007 0
 1773 0012 EBB1     		cbz	r3, .L192
1008:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
ARM GAS  /tmp/ccVWLGiI.s 			page 52


1009:Src/bno055.c  **** 		} else {
1010:Src/bno055.c  **** 		/*condition check for page, chip id is
1011:Src/bno055.c  **** 		available in the page zero*/
1012:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1774              		.loc 1 1012 0
 1775 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1776 0016 0546     		mov	r5, r0
 1777 0018 79B9     		cbnz	r1, .L198
 1778              	.LVL186:
 1779              	.L190:
1013:Src/bno055.c  **** 			/* Write the page zero*/
1014:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1015:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1016:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1017:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1780              		.loc 1 1017 0
 1781 001a 1C69     		ldr	r4, [r3, #16]
 1782 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1783 001e 01AA     		add	r2, sp, #4
 1784 0020 0223     		movs	r3, #2
 1785 0022 1221     		movs	r1, #18
 1786 0024 A047     		blx	r4
 1787              	.LVL187:
1018:Src/bno055.c  **** 			(p_bno055->dev_addr,
1019:Src/bno055.c  **** 			BNO055_MAG_DATA_Z_LSB_VALUEZ_REG,
1020:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1021:Src/bno055.c  **** 			/*Read the mag z two bytes of data */
1022:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
1023:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
1024:Src/bno055.c  **** 			BNO055_MAG_DATA_Z_LSB_VALUEZ);
1025:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
1026:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
1027:Src/bno055.c  **** 			BNO055_MAG_DATA_Z_MSB_VALUEZ);
1028:Src/bno055.c  **** 			*mag_z_s16 = (s16)((((s32)
 1788              		.loc 1 1028 0
 1789 0026 9DF90520 		ldrsb	r2, [sp, #5]
 1790 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1791 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 1792 0032 2B80     		strh	r3, [r5]	@ movhi
 1793              	.LVL188:
 1794              	.L189:
1029:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
1030:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1031:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
1032:Src/bno055.c  **** 		} else {
1033:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1034:Src/bno055.c  **** 		}
1035:Src/bno055.c  **** 	}
1036:Src/bno055.c  **** 	return com_rslt;
1037:Src/bno055.c  **** }
 1795              		.loc 1 1037 0
 1796 0034 40B2     		sxtb	r0, r0
 1797 0036 03B0     		add	sp, sp, #12
 1798              	.LCFI73:
 1799              		.cfi_remember_state
 1800              		.cfi_def_cfa_offset 12
 1801              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 53


 1802 0038 30BD     		pop	{r4, r5, pc}
 1803              	.LVL189:
 1804              	.L198:
 1805              	.LCFI74:
 1806              		.cfi_restore_state
1014:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1807              		.loc 1 1014 0
 1808 003a 1046     		mov	r0, r2
 1809              	.LVL190:
 1810 003c FFF7FEFF 		bl	bno055_write_page_id
 1811              	.LVL191:
 1812 0040 2368     		ldr	r3, [r4]
1015:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1813              		.loc 1 1015 0
 1814 0042 0028     		cmp	r0, #0
 1815 0044 E9D0     		beq	.L190
 1816              	.LVL192:
1015:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1817              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1818 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1033:Src/bno055.c  **** 		}
 1819              		.loc 1 1033 0 is_stmt 1 discriminator 1
 1820 0048 FF20     		movs	r0, #255
1015:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1821              		.loc 1 1015 0 discriminator 1
 1822 004a 002A     		cmp	r2, #0
 1823 004c F2D1     		bne	.L189
 1824 004e E4E7     		b	.L190
 1825              	.LVL193:
 1826              	.L192:
1008:Src/bno055.c  **** 		} else {
 1827              		.loc 1 1008 0
 1828 0050 8120     		movs	r0, #129
 1829              	.LVL194:
 1830 0052 EFE7     		b	.L189
 1831              	.L200:
 1832              		.align	2
 1833              	.L199:
 1834 0054 00000000 		.word	.LANCHOR0
 1835              		.cfi_endproc
 1836              	.LFE17:
 1838              		.section	.text.bno055_read_mag_xyz,"ax",%progbits
 1839              		.align	2
 1840              		.global	bno055_read_mag_xyz
 1841              		.thumb
 1842              		.thumb_func
 1844              	bno055_read_mag_xyz:
 1845              	.LFB18:
1038:Src/bno055.c  **** /*!
1039:Src/bno055.c  ****  *	@brief This API reads mag data xyz values
1040:Src/bno055.c  ****  *	from register 0x0E to 0x13 it is a six byte data
1041:Src/bno055.c  ****  *
1042:Src/bno055.c  ****  *
1043:Src/bno055.c  ****  *	@param mag : The mag xyz values
1044:Src/bno055.c  ****  *
1045:Src/bno055.c  ****  *	Parameter |    result
1046:Src/bno055.c  ****  *  --------- | -----------------
ARM GAS  /tmp/ccVWLGiI.s 			page 54


1047:Src/bno055.c  ****  *	 x        | The mag x data
1048:Src/bno055.c  ****  *	 y        | The mag y data
1049:Src/bno055.c  ****  *	 z        | The mag z data
1050:Src/bno055.c  ****  *
1051:Src/bno055.c  ****  *
1052:Src/bno055.c  ****  *
1053:Src/bno055.c  ****  *	@return results of bus communication function
1054:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1055:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1056:Src/bno055.c  ****  *
1057:Src/bno055.c  ****  */
1058:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_mag_xyz(struct bno055_mag_t *mag)
1059:Src/bno055.c  **** {
 1846              		.loc 1 1059 0
 1847              		.cfi_startproc
 1848              		@ args = 0, pretend = 0, frame = 8
 1849              		@ frame_needed = 0, uses_anonymous_args = 0
 1850              	.LVL195:
 1851 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1852              	.LCFI75:
 1853              		.cfi_def_cfa_offset 20
 1854              		.cfi_offset 4, -20
 1855              		.cfi_offset 5, -16
 1856              		.cfi_offset 6, -12
 1857              		.cfi_offset 7, -8
 1858              		.cfi_offset 14, -4
1060:Src/bno055.c  **** 	/* Variable used to return value of
1061:Src/bno055.c  **** 	communication routine*/
1062:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1063:Src/bno055.c  **** 	/* Array holding the mag xyz value
1064:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] - x->LSB
1065:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] - x->MSB
1066:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] - y->MSB
1067:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] - y->MSB
1068:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] - z->MSB
1069:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] - z->MSB
1070:Src/bno055.c  **** 	*/
1071:Src/bno055.c  **** 	u8 data_u8[BNO055_MAG_XYZ_DATA_SIZE] = {
1072:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1073:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1074:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1075:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1076:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1077:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1859              		.loc 1 1077 0
 1860 0002 1F4D     		ldr	r5, .L212
1059:Src/bno055.c  **** 	/* Variable used to return value of
 1861              		.loc 1 1059 0
 1862 0004 83B0     		sub	sp, sp, #12
 1863              	.LCFI76:
 1864              		.cfi_def_cfa_offset 32
 1865              		.loc 1 1077 0
 1866 0006 2A68     		ldr	r2, [r5]
1071:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 1867              		.loc 1 1071 0
 1868 0008 0023     		movs	r3, #0
 1869 000a 8DF80030 		strb	r3, [sp]
ARM GAS  /tmp/ccVWLGiI.s 			page 55


 1870 000e 8DF80130 		strb	r3, [sp, #1]
 1871 0012 8DF80230 		strb	r3, [sp, #2]
 1872 0016 8DF80330 		strb	r3, [sp, #3]
 1873 001a 8DF80430 		strb	r3, [sp, #4]
 1874 001e 8DF80530 		strb	r3, [sp, #5]
 1875              	.LVL196:
 1876              		.loc 1 1077 0
 1877 0022 5AB3     		cbz	r2, .L205
1078:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1079:Src/bno055.c  **** 		} else {
1080:Src/bno055.c  **** 		/*condition check for page, chip id is
1081:Src/bno055.c  **** 		available in the page zero*/
1082:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1878              		.loc 1 1082 0
 1879 0024 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 1880 0026 0446     		mov	r4, r0
 1881 0028 E9B9     		cbnz	r1, .L211
 1882              	.LVL197:
 1883              	.L203:
1083:Src/bno055.c  **** 			/* Write the page zero*/
1084:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1085:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1086:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1087:Src/bno055.c  **** 			/*Read the six byte value of mag xyz*/
1088:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1884              		.loc 1 1088 0
 1885 002a 1569     		ldr	r5, [r2, #16]
 1886 002c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 1887 002e 0E21     		movs	r1, #14
 1888 0030 6A46     		mov	r2, sp
 1889 0032 0623     		movs	r3, #6
 1890 0034 A847     		blx	r5
 1891              	.LVL198:
1089:Src/bno055.c  **** 			(p_bno055->dev_addr,
1090:Src/bno055.c  **** 			BNO055_MAG_DATA_X_LSB_VALUEX_REG,
1091:Src/bno055.c  **** 			data_u8, BNO055_MAG_XYZ_DATA_SIZE);
1092:Src/bno055.c  **** 			/* Data X*/
1093:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] =
1094:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1095:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB],
1096:Src/bno055.c  **** 			BNO055_MAG_DATA_X_LSB_VALUEX);
1097:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] =
1098:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1099:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB],
1100:Src/bno055.c  **** 			BNO055_MAG_DATA_X_MSB_VALUEX);
1101:Src/bno055.c  **** 			mag->x = (s16)((((s32)
 1892              		.loc 1 1101 0
 1893 0036 9DF90170 		ldrsb	r7, [sp, #1]
 1894 003a 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
1102:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
1103:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1104:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB]));
1105:Src/bno055.c  **** 			/* Data Y*/
1106:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] =
1107:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1108:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB],
1109:Src/bno055.c  **** 			BNO055_MAG_DATA_Y_LSB_VALUEY);
ARM GAS  /tmp/ccVWLGiI.s 			page 56


1110:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] =
1111:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1112:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB],
1113:Src/bno055.c  **** 			BNO055_MAG_DATA_Y_MSB_VALUEY);
1114:Src/bno055.c  **** 			mag->y = (s16)((((s32)
 1895              		.loc 1 1114 0
 1896 003e 9DF90360 		ldrsb	r6, [sp, #3]
 1897 0042 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
1115:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
1116:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1117:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB]));
1118:Src/bno055.c  **** 			/* Data Z*/
1119:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] =
1120:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1121:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB],
1122:Src/bno055.c  **** 			BNO055_MAG_DATA_Z_LSB_VALUEZ);
1123:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] =
1124:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1125:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB],
1126:Src/bno055.c  **** 			BNO055_MAG_DATA_Z_MSB_VALUEZ);
1127:Src/bno055.c  **** 			mag->z = (s16)((((s32)
 1898              		.loc 1 1127 0
 1899 0046 9DF90550 		ldrsb	r5, [sp, #5]
 1900 004a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
1101:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 1901              		.loc 1 1101 0
 1902 004e 41EA0721 		orr	r1, r1, r7, lsl #8
1114:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 1903              		.loc 1 1114 0
 1904 0052 42EA0622 		orr	r2, r2, r6, lsl #8
 1905              		.loc 1 1127 0
 1906 0056 43EA0523 		orr	r3, r3, r5, lsl #8
1101:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 1907              		.loc 1 1101 0
 1908 005a 2180     		strh	r1, [r4]	@ movhi
1114:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 1909              		.loc 1 1114 0
 1910 005c 6280     		strh	r2, [r4, #2]	@ movhi
 1911              		.loc 1 1127 0
 1912 005e A380     		strh	r3, [r4, #4]	@ movhi
 1913              	.LVL199:
 1914              	.L202:
1128:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB])) <<
1129:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1130:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB]));
1131:Src/bno055.c  **** 		} else {
1132:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1133:Src/bno055.c  **** 		}
1134:Src/bno055.c  **** 	}
1135:Src/bno055.c  **** 	return com_rslt;
1136:Src/bno055.c  **** }
 1915              		.loc 1 1136 0
 1916 0060 40B2     		sxtb	r0, r0
 1917 0062 03B0     		add	sp, sp, #12
 1918              	.LCFI77:
 1919              		.cfi_remember_state
 1920              		.cfi_def_cfa_offset 20
ARM GAS  /tmp/ccVWLGiI.s 			page 57


 1921              		@ sp needed
 1922 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 1923              	.LVL200:
 1924              	.L211:
 1925              	.LCFI78:
 1926              		.cfi_restore_state
1084:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 1927              		.loc 1 1084 0
 1928 0066 1846     		mov	r0, r3
 1929              	.LVL201:
 1930 0068 FFF7FEFF 		bl	bno055_write_page_id
 1931              	.LVL202:
 1932 006c 2A68     		ldr	r2, [r5]
1085:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1933              		.loc 1 1085 0
 1934 006e 0028     		cmp	r0, #0
 1935 0070 DBD0     		beq	.L203
 1936              	.LVL203:
1085:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1937              		.loc 1 1085 0 is_stmt 0 discriminator 1
 1938 0072 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
1132:Src/bno055.c  **** 		}
 1939              		.loc 1 1132 0 is_stmt 1 discriminator 1
 1940 0074 FF20     		movs	r0, #255
1085:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 1941              		.loc 1 1085 0 discriminator 1
 1942 0076 002B     		cmp	r3, #0
 1943 0078 F2D1     		bne	.L202
 1944 007a D6E7     		b	.L203
 1945              	.LVL204:
 1946              	.L205:
1078:Src/bno055.c  **** 		} else {
 1947              		.loc 1 1078 0
 1948 007c 8120     		movs	r0, #129
 1949              	.LVL205:
 1950 007e EFE7     		b	.L202
 1951              	.L213:
 1952              		.align	2
 1953              	.L212:
 1954 0080 00000000 		.word	.LANCHOR0
 1955              		.cfi_endproc
 1956              	.LFE18:
 1958              		.section	.text.bno055_read_gyro_x,"ax",%progbits
 1959              		.align	2
 1960              		.global	bno055_read_gyro_x
 1961              		.thumb
 1962              		.thumb_func
 1964              	bno055_read_gyro_x:
 1965              	.LFB19:
1137:Src/bno055.c  **** /*!
1138:Src/bno055.c  ****  *	@brief This API reads gyro data x values
1139:Src/bno055.c  ****  *	from register 0x14 and 0x15 it is a two byte data
1140:Src/bno055.c  ****  *
1141:Src/bno055.c  ****  *
1142:Src/bno055.c  ****  *
1143:Src/bno055.c  ****  *
1144:Src/bno055.c  ****  *	@param gyro_x_s16 : The x raw data
ARM GAS  /tmp/ccVWLGiI.s 			page 58


1145:Src/bno055.c  ****  *
1146:Src/bno055.c  ****  *
1147:Src/bno055.c  ****  *
1148:Src/bno055.c  ****  *	@return results of bus communication function
1149:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1150:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1151:Src/bno055.c  ****  *
1152:Src/bno055.c  ****  *
1153:Src/bno055.c  ****  */
1154:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gyro_x(s16 *gyro_x_s16)
1155:Src/bno055.c  **** {
 1966              		.loc 1 1155 0
 1967              		.cfi_startproc
 1968              		@ args = 0, pretend = 0, frame = 8
 1969              		@ frame_needed = 0, uses_anonymous_args = 0
 1970              	.LVL206:
 1971 0000 30B5     		push	{r4, r5, lr}
 1972              	.LCFI79:
 1973              		.cfi_def_cfa_offset 12
 1974              		.cfi_offset 4, -12
 1975              		.cfi_offset 5, -8
 1976              		.cfi_offset 14, -4
1156:Src/bno055.c  **** 	/* Variable used to return value of
1157:Src/bno055.c  **** 	communication routine*/
1158:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1159:Src/bno055.c  **** 	u8 data_u8[BNO055_GYRO_DATA_SIZE] = {
1160:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1161:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1162:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1163:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 1977              		.loc 1 1163 0
 1978 0002 144C     		ldr	r4, .L225
1155:Src/bno055.c  **** 	/* Variable used to return value of
 1979              		.loc 1 1155 0
 1980 0004 83B0     		sub	sp, sp, #12
 1981              	.LCFI80:
 1982              		.cfi_def_cfa_offset 24
 1983              		.loc 1 1163 0
 1984 0006 2368     		ldr	r3, [r4]
1159:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 1985              		.loc 1 1159 0
 1986 0008 0022     		movs	r2, #0
 1987 000a 8DF80420 		strb	r2, [sp, #4]
 1988 000e 8DF80520 		strb	r2, [sp, #5]
 1989              	.LVL207:
 1990              		.loc 1 1163 0
 1991 0012 EBB1     		cbz	r3, .L218
1164:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1165:Src/bno055.c  **** 		} else {
1166:Src/bno055.c  **** 		/*condition check for page, chip id is
1167:Src/bno055.c  **** 		available in the page zero*/
1168:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 1992              		.loc 1 1168 0
 1993 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1994 0016 0546     		mov	r5, r0
 1995 0018 79B9     		cbnz	r1, .L224
 1996              	.LVL208:
ARM GAS  /tmp/ccVWLGiI.s 			page 59


 1997              	.L216:
1169:Src/bno055.c  **** 			/* Write the page zero*/
1170:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1171:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1172:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1173:Src/bno055.c  **** 			/* Read the gyro 16 bit x value*/
1174:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 1998              		.loc 1 1174 0
 1999 001a 1C69     		ldr	r4, [r3, #16]
 2000 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2001 001e 01AA     		add	r2, sp, #4
 2002 0020 0223     		movs	r3, #2
 2003 0022 1421     		movs	r1, #20
 2004 0024 A047     		blx	r4
 2005              	.LVL209:
1175:Src/bno055.c  **** 			(p_bno055->dev_addr,
1176:Src/bno055.c  **** 			BNO055_GYRO_DATA_X_LSB_VALUEX_REG,
1177:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1178:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
1179:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
1180:Src/bno055.c  **** 			BNO055_GYRO_DATA_X_LSB_VALUEX);
1181:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
1182:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
1183:Src/bno055.c  **** 			BNO055_GYRO_DATA_X_MSB_VALUEX);
1184:Src/bno055.c  **** 			*gyro_x_s16 = (s16)((((s32)
 2006              		.loc 1 1184 0
 2007 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2008 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2009 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2010 0032 2B80     		strh	r3, [r5]	@ movhi
 2011              	.LVL210:
 2012              	.L215:
1185:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
1186:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1187:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_LSB]));
1188:Src/bno055.c  **** 		} else {
1189:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1190:Src/bno055.c  **** 		}
1191:Src/bno055.c  **** 	}
1192:Src/bno055.c  **** 	return com_rslt;
1193:Src/bno055.c  **** }
 2013              		.loc 1 1193 0
 2014 0034 40B2     		sxtb	r0, r0
 2015 0036 03B0     		add	sp, sp, #12
 2016              	.LCFI81:
 2017              		.cfi_remember_state
 2018              		.cfi_def_cfa_offset 12
 2019              		@ sp needed
 2020 0038 30BD     		pop	{r4, r5, pc}
 2021              	.LVL211:
 2022              	.L224:
 2023              	.LCFI82:
 2024              		.cfi_restore_state
1170:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2025              		.loc 1 1170 0
 2026 003a 1046     		mov	r0, r2
 2027              	.LVL212:
ARM GAS  /tmp/ccVWLGiI.s 			page 60


 2028 003c FFF7FEFF 		bl	bno055_write_page_id
 2029              	.LVL213:
 2030 0040 2368     		ldr	r3, [r4]
1171:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2031              		.loc 1 1171 0
 2032 0042 0028     		cmp	r0, #0
 2033 0044 E9D0     		beq	.L216
 2034              	.LVL214:
1171:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2035              		.loc 1 1171 0 is_stmt 0 discriminator 1
 2036 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1189:Src/bno055.c  **** 		}
 2037              		.loc 1 1189 0 is_stmt 1 discriminator 1
 2038 0048 FF20     		movs	r0, #255
1171:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2039              		.loc 1 1171 0 discriminator 1
 2040 004a 002A     		cmp	r2, #0
 2041 004c F2D1     		bne	.L215
 2042 004e E4E7     		b	.L216
 2043              	.LVL215:
 2044              	.L218:
1164:Src/bno055.c  **** 		} else {
 2045              		.loc 1 1164 0
 2046 0050 8120     		movs	r0, #129
 2047              	.LVL216:
 2048 0052 EFE7     		b	.L215
 2049              	.L226:
 2050              		.align	2
 2051              	.L225:
 2052 0054 00000000 		.word	.LANCHOR0
 2053              		.cfi_endproc
 2054              	.LFE19:
 2056              		.section	.text.bno055_read_gyro_y,"ax",%progbits
 2057              		.align	2
 2058              		.global	bno055_read_gyro_y
 2059              		.thumb
 2060              		.thumb_func
 2062              	bno055_read_gyro_y:
 2063              	.LFB20:
1194:Src/bno055.c  **** /*!
1195:Src/bno055.c  ****  *	@brief This API reads gyro data y values
1196:Src/bno055.c  ****  *	from register 0x16 and 0x17 it is a two byte data
1197:Src/bno055.c  ****  *
1198:Src/bno055.c  ****  *
1199:Src/bno055.c  ****  *
1200:Src/bno055.c  ****  *
1201:Src/bno055.c  ****  *	@param gyro_y_s16 : The y raw data
1202:Src/bno055.c  ****  *
1203:Src/bno055.c  ****  *
1204:Src/bno055.c  ****  *
1205:Src/bno055.c  ****  *	@return results of bus communication function
1206:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1207:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1208:Src/bno055.c  ****  *
1209:Src/bno055.c  ****  *
1210:Src/bno055.c  ****  */
1211:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gyro_y(s16 *gyro_y_s16)
ARM GAS  /tmp/ccVWLGiI.s 			page 61


1212:Src/bno055.c  **** {
 2064              		.loc 1 1212 0
 2065              		.cfi_startproc
 2066              		@ args = 0, pretend = 0, frame = 8
 2067              		@ frame_needed = 0, uses_anonymous_args = 0
 2068              	.LVL217:
 2069 0000 30B5     		push	{r4, r5, lr}
 2070              	.LCFI83:
 2071              		.cfi_def_cfa_offset 12
 2072              		.cfi_offset 4, -12
 2073              		.cfi_offset 5, -8
 2074              		.cfi_offset 14, -4
1213:Src/bno055.c  **** 	/* Variable used to return value of
1214:Src/bno055.c  **** 	communication routine*/
1215:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1216:Src/bno055.c  **** 	u8 data_u8[BNO055_GYRO_DATA_SIZE] = {
1217:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1218:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1219:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1220:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2075              		.loc 1 1220 0
 2076 0002 144C     		ldr	r4, .L238
1212:Src/bno055.c  **** 	/* Variable used to return value of
 2077              		.loc 1 1212 0
 2078 0004 83B0     		sub	sp, sp, #12
 2079              	.LCFI84:
 2080              		.cfi_def_cfa_offset 24
 2081              		.loc 1 1220 0
 2082 0006 2368     		ldr	r3, [r4]
1216:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 2083              		.loc 1 1216 0
 2084 0008 0022     		movs	r2, #0
 2085 000a 8DF80420 		strb	r2, [sp, #4]
 2086 000e 8DF80520 		strb	r2, [sp, #5]
 2087              	.LVL218:
 2088              		.loc 1 1220 0
 2089 0012 EBB1     		cbz	r3, .L231
1221:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1222:Src/bno055.c  **** 		} else {
1223:Src/bno055.c  **** 		/*condition check for page, chip id is
1224:Src/bno055.c  **** 		available in the page zero*/
1225:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2090              		.loc 1 1225 0
 2091 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2092 0016 0546     		mov	r5, r0
 2093 0018 79B9     		cbnz	r1, .L237
 2094              	.LVL219:
 2095              	.L229:
1226:Src/bno055.c  **** 			/* Write the page zero*/
1227:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1228:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1229:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1230:Src/bno055.c  **** 			/* Read the value of gyro y */
1231:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2096              		.loc 1 1231 0
 2097 001a 1C69     		ldr	r4, [r3, #16]
 2098 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 62


 2099 001e 01AA     		add	r2, sp, #4
 2100 0020 0223     		movs	r3, #2
 2101 0022 1621     		movs	r1, #22
 2102 0024 A047     		blx	r4
 2103              	.LVL220:
1232:Src/bno055.c  **** 			(p_bno055->dev_addr,
1233:Src/bno055.c  **** 			BNO055_GYRO_DATA_Y_LSB_VALUEY_REG,
1234:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1235:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
1236:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
1237:Src/bno055.c  **** 			BNO055_GYRO_DATA_Y_LSB_VALUEY);
1238:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
1239:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
1240:Src/bno055.c  **** 			BNO055_GYRO_DATA_Y_MSB_VALUEY);
1241:Src/bno055.c  **** 			*gyro_y_s16 = (s16)((((s32)
 2104              		.loc 1 1241 0
 2105 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2106 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2107 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2108 0032 2B80     		strh	r3, [r5]	@ movhi
 2109              	.LVL221:
 2110              	.L228:
1242:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
1243:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1244:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
1245:Src/bno055.c  **** 		} else {
1246:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1247:Src/bno055.c  **** 		}
1248:Src/bno055.c  **** 	}
1249:Src/bno055.c  **** 	return com_rslt;
1250:Src/bno055.c  **** }
 2111              		.loc 1 1250 0
 2112 0034 40B2     		sxtb	r0, r0
 2113 0036 03B0     		add	sp, sp, #12
 2114              	.LCFI85:
 2115              		.cfi_remember_state
 2116              		.cfi_def_cfa_offset 12
 2117              		@ sp needed
 2118 0038 30BD     		pop	{r4, r5, pc}
 2119              	.LVL222:
 2120              	.L237:
 2121              	.LCFI86:
 2122              		.cfi_restore_state
1227:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2123              		.loc 1 1227 0
 2124 003a 1046     		mov	r0, r2
 2125              	.LVL223:
 2126 003c FFF7FEFF 		bl	bno055_write_page_id
 2127              	.LVL224:
 2128 0040 2368     		ldr	r3, [r4]
1228:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2129              		.loc 1 1228 0
 2130 0042 0028     		cmp	r0, #0
 2131 0044 E9D0     		beq	.L229
 2132              	.LVL225:
1228:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2133              		.loc 1 1228 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 63


 2134 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1246:Src/bno055.c  **** 		}
 2135              		.loc 1 1246 0 is_stmt 1 discriminator 1
 2136 0048 FF20     		movs	r0, #255
1228:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2137              		.loc 1 1228 0 discriminator 1
 2138 004a 002A     		cmp	r2, #0
 2139 004c F2D1     		bne	.L228
 2140 004e E4E7     		b	.L229
 2141              	.LVL226:
 2142              	.L231:
1221:Src/bno055.c  **** 		} else {
 2143              		.loc 1 1221 0
 2144 0050 8120     		movs	r0, #129
 2145              	.LVL227:
 2146 0052 EFE7     		b	.L228
 2147              	.L239:
 2148              		.align	2
 2149              	.L238:
 2150 0054 00000000 		.word	.LANCHOR0
 2151              		.cfi_endproc
 2152              	.LFE20:
 2154              		.section	.text.bno055_read_gyro_z,"ax",%progbits
 2155              		.align	2
 2156              		.global	bno055_read_gyro_z
 2157              		.thumb
 2158              		.thumb_func
 2160              	bno055_read_gyro_z:
 2161              	.LFB21:
1251:Src/bno055.c  **** /*!
1252:Src/bno055.c  ****  *	@brief This API reads gyro data z values
1253:Src/bno055.c  ****  *	from register 0x18 and 0x19 it is a two byte data
1254:Src/bno055.c  ****  *
1255:Src/bno055.c  ****  *	@param gyro_z_s16 : The z raw data
1256:Src/bno055.c  ****  *
1257:Src/bno055.c  ****  *	@return results of bus communication function
1258:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1259:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1260:Src/bno055.c  ****  *
1261:Src/bno055.c  ****  *
1262:Src/bno055.c  ****  */
1263:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gyro_z(s16 *gyro_z_s16)
1264:Src/bno055.c  **** {
 2162              		.loc 1 1264 0
 2163              		.cfi_startproc
 2164              		@ args = 0, pretend = 0, frame = 8
 2165              		@ frame_needed = 0, uses_anonymous_args = 0
 2166              	.LVL228:
 2167 0000 30B5     		push	{r4, r5, lr}
 2168              	.LCFI87:
 2169              		.cfi_def_cfa_offset 12
 2170              		.cfi_offset 4, -12
 2171              		.cfi_offset 5, -8
 2172              		.cfi_offset 14, -4
1265:Src/bno055.c  **** 	/* Variable used to return value of
1266:Src/bno055.c  **** 	communication routine*/
1267:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 64


1268:Src/bno055.c  **** 	u8 data_u8[BNO055_GYRO_DATA_SIZE] = {
1269:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1270:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1271:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1272:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2173              		.loc 1 1272 0
 2174 0002 144C     		ldr	r4, .L251
1264:Src/bno055.c  **** 	/* Variable used to return value of
 2175              		.loc 1 1264 0
 2176 0004 83B0     		sub	sp, sp, #12
 2177              	.LCFI88:
 2178              		.cfi_def_cfa_offset 24
 2179              		.loc 1 1272 0
 2180 0006 2368     		ldr	r3, [r4]
1268:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 2181              		.loc 1 1268 0
 2182 0008 0022     		movs	r2, #0
 2183 000a 8DF80420 		strb	r2, [sp, #4]
 2184 000e 8DF80520 		strb	r2, [sp, #5]
 2185              	.LVL229:
 2186              		.loc 1 1272 0
 2187 0012 EBB1     		cbz	r3, .L244
1273:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1274:Src/bno055.c  **** 		} else {
1275:Src/bno055.c  **** 		/*condition check for page, chip id is
1276:Src/bno055.c  **** 		available in the page zero*/
1277:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2188              		.loc 1 1277 0
 2189 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2190 0016 0546     		mov	r5, r0
 2191 0018 79B9     		cbnz	r1, .L250
 2192              	.LVL230:
 2193              	.L242:
1278:Src/bno055.c  **** 			/* Write the page zero*/
1279:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1280:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1281:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1282:Src/bno055.c  **** 			/* Read the gyro z 16 bit value*/
1283:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2194              		.loc 1 1283 0
 2195 001a 1C69     		ldr	r4, [r3, #16]
 2196 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2197 001e 01AA     		add	r2, sp, #4
 2198 0020 0223     		movs	r3, #2
 2199 0022 1821     		movs	r1, #24
 2200 0024 A047     		blx	r4
 2201              	.LVL231:
1284:Src/bno055.c  **** 			(p_bno055->dev_addr,
1285:Src/bno055.c  **** 			BNO055_GYRO_DATA_Z_LSB_VALUEZ_REG,
1286:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1287:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
1288:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
1289:Src/bno055.c  **** 			BNO055_GYRO_DATA_Z_LSB_VALUEZ);
1290:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
1291:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
1292:Src/bno055.c  **** 			BNO055_GYRO_DATA_Z_MSB_VALUEZ);
1293:Src/bno055.c  **** 			*gyro_z_s16 = (s16)((((s32)
ARM GAS  /tmp/ccVWLGiI.s 			page 65


 2202              		.loc 1 1293 0
 2203 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2204 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2205 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2206 0032 2B80     		strh	r3, [r5]	@ movhi
 2207              	.LVL232:
 2208              	.L241:
1294:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
1295:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1296:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
1297:Src/bno055.c  **** 		} else {
1298:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1299:Src/bno055.c  **** 		}
1300:Src/bno055.c  **** 	}
1301:Src/bno055.c  **** 	return com_rslt;
1302:Src/bno055.c  **** }
 2209              		.loc 1 1302 0
 2210 0034 40B2     		sxtb	r0, r0
 2211 0036 03B0     		add	sp, sp, #12
 2212              	.LCFI89:
 2213              		.cfi_remember_state
 2214              		.cfi_def_cfa_offset 12
 2215              		@ sp needed
 2216 0038 30BD     		pop	{r4, r5, pc}
 2217              	.LVL233:
 2218              	.L250:
 2219              	.LCFI90:
 2220              		.cfi_restore_state
1279:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2221              		.loc 1 1279 0
 2222 003a 1046     		mov	r0, r2
 2223              	.LVL234:
 2224 003c FFF7FEFF 		bl	bno055_write_page_id
 2225              	.LVL235:
 2226 0040 2368     		ldr	r3, [r4]
1280:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2227              		.loc 1 1280 0
 2228 0042 0028     		cmp	r0, #0
 2229 0044 E9D0     		beq	.L242
 2230              	.LVL236:
1280:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2231              		.loc 1 1280 0 is_stmt 0 discriminator 1
 2232 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1298:Src/bno055.c  **** 		}
 2233              		.loc 1 1298 0 is_stmt 1 discriminator 1
 2234 0048 FF20     		movs	r0, #255
1280:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2235              		.loc 1 1280 0 discriminator 1
 2236 004a 002A     		cmp	r2, #0
 2237 004c F2D1     		bne	.L241
 2238 004e E4E7     		b	.L242
 2239              	.LVL237:
 2240              	.L244:
1273:Src/bno055.c  **** 		} else {
 2241              		.loc 1 1273 0
 2242 0050 8120     		movs	r0, #129
 2243              	.LVL238:
ARM GAS  /tmp/ccVWLGiI.s 			page 66


 2244 0052 EFE7     		b	.L241
 2245              	.L252:
 2246              		.align	2
 2247              	.L251:
 2248 0054 00000000 		.word	.LANCHOR0
 2249              		.cfi_endproc
 2250              	.LFE21:
 2252              		.section	.text.bno055_read_gyro_xyz,"ax",%progbits
 2253              		.align	2
 2254              		.global	bno055_read_gyro_xyz
 2255              		.thumb
 2256              		.thumb_func
 2258              	bno055_read_gyro_xyz:
 2259              	.LFB22:
1303:Src/bno055.c  **** /*!
1304:Src/bno055.c  ****  *	@brief This API reads gyro data xyz values
1305:Src/bno055.c  ****  *	from register 0x14 to 0x19 it is a six byte data
1306:Src/bno055.c  ****  *
1307:Src/bno055.c  ****  *
1308:Src/bno055.c  ****  *	@param gyro : The value of gyro xyz data's
1309:Src/bno055.c  ****  *
1310:Src/bno055.c  ****  *	Parameter |    result
1311:Src/bno055.c  ****  *  --------- | -----------------
1312:Src/bno055.c  ****  *	 x        | The gyro x data
1313:Src/bno055.c  ****  *	 y        | The gyro y data
1314:Src/bno055.c  ****  *	 z        | The gyro z data
1315:Src/bno055.c  ****  *
1316:Src/bno055.c  ****  *
1317:Src/bno055.c  ****  *
1318:Src/bno055.c  ****  *	@return results of bus communication function
1319:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1320:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1321:Src/bno055.c  ****  *
1322:Src/bno055.c  ****  */
1323:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gyro_xyz(struct bno055_gyro_t *gyro)
1324:Src/bno055.c  **** {
 2260              		.loc 1 1324 0
 2261              		.cfi_startproc
 2262              		@ args = 0, pretend = 0, frame = 8
 2263              		@ frame_needed = 0, uses_anonymous_args = 0
 2264              	.LVL239:
 2265 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2266              	.LCFI91:
 2267              		.cfi_def_cfa_offset 20
 2268              		.cfi_offset 4, -20
 2269              		.cfi_offset 5, -16
 2270              		.cfi_offset 6, -12
 2271              		.cfi_offset 7, -8
 2272              		.cfi_offset 14, -4
1325:Src/bno055.c  **** 	/* Variable used to return value of
1326:Src/bno055.c  **** 	communication routine*/
1327:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1328:Src/bno055.c  **** 	/* Array holding the gyro xyz value
1329:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] - x->LSB
1330:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] - x->MSB
1331:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] - y->MSB
1332:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] - y->MSB
ARM GAS  /tmp/ccVWLGiI.s 			page 67


1333:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] - z->MSB
1334:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] - z->MSB
1335:Src/bno055.c  **** 	*/
1336:Src/bno055.c  **** 	u8 data_u8[BNO055_GYRO_XYZ_DATA_SIZE] = {
1337:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1338:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1339:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1340:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1341:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1342:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2273              		.loc 1 1342 0
 2274 0002 1F4D     		ldr	r5, .L264
1324:Src/bno055.c  **** 	/* Variable used to return value of
 2275              		.loc 1 1324 0
 2276 0004 83B0     		sub	sp, sp, #12
 2277              	.LCFI92:
 2278              		.cfi_def_cfa_offset 32
 2279              		.loc 1 1342 0
 2280 0006 2A68     		ldr	r2, [r5]
1336:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 2281              		.loc 1 1336 0
 2282 0008 0023     		movs	r3, #0
 2283 000a 8DF80030 		strb	r3, [sp]
 2284 000e 8DF80130 		strb	r3, [sp, #1]
 2285 0012 8DF80230 		strb	r3, [sp, #2]
 2286 0016 8DF80330 		strb	r3, [sp, #3]
 2287 001a 8DF80430 		strb	r3, [sp, #4]
 2288 001e 8DF80530 		strb	r3, [sp, #5]
 2289              	.LVL240:
 2290              		.loc 1 1342 0
 2291 0022 5AB3     		cbz	r2, .L257
1343:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1344:Src/bno055.c  **** 		} else {
1345:Src/bno055.c  **** 		/*condition check for page, chip id is
1346:Src/bno055.c  **** 		available in the page zero*/
1347:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2292              		.loc 1 1347 0
 2293 0024 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 2294 0026 0446     		mov	r4, r0
 2295 0028 E9B9     		cbnz	r1, .L263
 2296              	.LVL241:
 2297              	.L255:
1348:Src/bno055.c  **** 			/* Write the page zero*/
1349:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1350:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1351:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1352:Src/bno055.c  **** 			/* Read the six bytes data of gyro xyz*/
1353:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2298              		.loc 1 1353 0
 2299 002a 1569     		ldr	r5, [r2, #16]
 2300 002c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 2301 002e 1421     		movs	r1, #20
 2302 0030 6A46     		mov	r2, sp
 2303 0032 0623     		movs	r3, #6
 2304 0034 A847     		blx	r5
 2305              	.LVL242:
1354:Src/bno055.c  **** 			(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 68


1355:Src/bno055.c  **** 			BNO055_GYRO_DATA_X_LSB_VALUEX_REG,
1356:Src/bno055.c  **** 			data_u8, BNO055_GYRO_XYZ_DATA_SIZE);
1357:Src/bno055.c  **** 			/* Data x*/
1358:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] =
1359:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1360:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB],
1361:Src/bno055.c  **** 			BNO055_GYRO_DATA_X_LSB_VALUEX);
1362:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] =
1363:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1364:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB],
1365:Src/bno055.c  **** 			BNO055_GYRO_DATA_X_MSB_VALUEX);
1366:Src/bno055.c  **** 			gyro->x = (s16)((((s32)
 2306              		.loc 1 1366 0
 2307 0036 9DF90170 		ldrsb	r7, [sp, #1]
 2308 003a 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
1367:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
1368:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1369:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB]));
1370:Src/bno055.c  **** 			/* Data y*/
1371:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] =
1372:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1373:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB],
1374:Src/bno055.c  **** 			BNO055_GYRO_DATA_Y_LSB_VALUEY);
1375:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] =
1376:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1377:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB],
1378:Src/bno055.c  **** 			BNO055_GYRO_DATA_Y_MSB_VALUEY);
1379:Src/bno055.c  **** 			gyro->y = (s16)((((s32)
 2309              		.loc 1 1379 0
 2310 003e 9DF90360 		ldrsb	r6, [sp, #3]
 2311 0042 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
1380:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
1381:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1382:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB]));
1383:Src/bno055.c  **** 			/* Data z*/
1384:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] =
1385:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1386:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB],
1387:Src/bno055.c  **** 			BNO055_GYRO_DATA_Z_LSB_VALUEZ);
1388:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] =
1389:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1390:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB],
1391:Src/bno055.c  **** 			BNO055_GYRO_DATA_Z_MSB_VALUEZ);
1392:Src/bno055.c  **** 			gyro->z = (s16)((((s32)
 2312              		.loc 1 1392 0
 2313 0046 9DF90550 		ldrsb	r5, [sp, #5]
 2314 004a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
1366:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 2315              		.loc 1 1366 0
 2316 004e 41EA0721 		orr	r1, r1, r7, lsl #8
1379:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 2317              		.loc 1 1379 0
 2318 0052 42EA0622 		orr	r2, r2, r6, lsl #8
 2319              		.loc 1 1392 0
 2320 0056 43EA0523 		orr	r3, r3, r5, lsl #8
1366:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 2321              		.loc 1 1366 0
ARM GAS  /tmp/ccVWLGiI.s 			page 69


 2322 005a 2180     		strh	r1, [r4]	@ movhi
1379:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 2323              		.loc 1 1379 0
 2324 005c 6280     		strh	r2, [r4, #2]	@ movhi
 2325              		.loc 1 1392 0
 2326 005e A380     		strh	r3, [r4, #4]	@ movhi
 2327              	.LVL243:
 2328              	.L254:
1393:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB])) <<
1394:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1395:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB]));
1396:Src/bno055.c  **** 		} else {
1397:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1398:Src/bno055.c  **** 		}
1399:Src/bno055.c  **** 	}
1400:Src/bno055.c  **** 	return com_rslt;
1401:Src/bno055.c  **** }
 2329              		.loc 1 1401 0
 2330 0060 40B2     		sxtb	r0, r0
 2331 0062 03B0     		add	sp, sp, #12
 2332              	.LCFI93:
 2333              		.cfi_remember_state
 2334              		.cfi_def_cfa_offset 20
 2335              		@ sp needed
 2336 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 2337              	.LVL244:
 2338              	.L263:
 2339              	.LCFI94:
 2340              		.cfi_restore_state
1349:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2341              		.loc 1 1349 0
 2342 0066 1846     		mov	r0, r3
 2343              	.LVL245:
 2344 0068 FFF7FEFF 		bl	bno055_write_page_id
 2345              	.LVL246:
 2346 006c 2A68     		ldr	r2, [r5]
1350:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2347              		.loc 1 1350 0
 2348 006e 0028     		cmp	r0, #0
 2349 0070 DBD0     		beq	.L255
 2350              	.LVL247:
1350:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2351              		.loc 1 1350 0 is_stmt 0 discriminator 1
 2352 0072 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
1397:Src/bno055.c  **** 		}
 2353              		.loc 1 1397 0 is_stmt 1 discriminator 1
 2354 0074 FF20     		movs	r0, #255
1350:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2355              		.loc 1 1350 0 discriminator 1
 2356 0076 002B     		cmp	r3, #0
 2357 0078 F2D1     		bne	.L254
 2358 007a D6E7     		b	.L255
 2359              	.LVL248:
 2360              	.L257:
1343:Src/bno055.c  **** 		} else {
 2361              		.loc 1 1343 0
 2362 007c 8120     		movs	r0, #129
ARM GAS  /tmp/ccVWLGiI.s 			page 70


 2363              	.LVL249:
 2364 007e EFE7     		b	.L254
 2365              	.L265:
 2366              		.align	2
 2367              	.L264:
 2368 0080 00000000 		.word	.LANCHOR0
 2369              		.cfi_endproc
 2370              	.LFE22:
 2372              		.section	.text.bno055_read_euler_h,"ax",%progbits
 2373              		.align	2
 2374              		.global	bno055_read_euler_h
 2375              		.thumb
 2376              		.thumb_func
 2378              	bno055_read_euler_h:
 2379              	.LFB23:
1402:Src/bno055.c  **** /*!
1403:Src/bno055.c  ****  *	@brief This API reads gyro data z values
1404:Src/bno055.c  ****  *	from register 0x1A and 0x1B it is a two byte data
1405:Src/bno055.c  ****  *
1406:Src/bno055.c  ****  *	@param euler_h_s16 : The raw h data
1407:Src/bno055.c  ****  *
1408:Src/bno055.c  ****  *	@return results of bus communication function
1409:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1410:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1411:Src/bno055.c  ****  *
1412:Src/bno055.c  ****  */
1413:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_euler_h(s16 *euler_h_s16)
1414:Src/bno055.c  **** {
 2380              		.loc 1 1414 0
 2381              		.cfi_startproc
 2382              		@ args = 0, pretend = 0, frame = 8
 2383              		@ frame_needed = 0, uses_anonymous_args = 0
 2384              	.LVL250:
 2385 0000 30B5     		push	{r4, r5, lr}
 2386              	.LCFI95:
 2387              		.cfi_def_cfa_offset 12
 2388              		.cfi_offset 4, -12
 2389              		.cfi_offset 5, -8
 2390              		.cfi_offset 14, -4
1415:Src/bno055.c  **** 	/* Variable used to return value of
1416:Src/bno055.c  **** 	communication routine*/
1417:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1418:Src/bno055.c  **** 	/* Array holding the Euler h value
1419:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_LSB] - h->LSB
1420:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_MSB] - h->MSB
1421:Src/bno055.c  **** 	*/
1422:Src/bno055.c  **** 	u8 data_u8[BNO055_EULER_DATA_SIZE] = {
1423:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1424:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1425:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1426:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2391              		.loc 1 1426 0
 2392 0002 144C     		ldr	r4, .L277
1414:Src/bno055.c  **** 	/* Variable used to return value of
 2393              		.loc 1 1414 0
 2394 0004 83B0     		sub	sp, sp, #12
 2395              	.LCFI96:
ARM GAS  /tmp/ccVWLGiI.s 			page 71


 2396              		.cfi_def_cfa_offset 24
 2397              		.loc 1 1426 0
 2398 0006 2368     		ldr	r3, [r4]
1422:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 2399              		.loc 1 1422 0
 2400 0008 0022     		movs	r2, #0
 2401 000a 8DF80420 		strb	r2, [sp, #4]
 2402 000e 8DF80520 		strb	r2, [sp, #5]
 2403              	.LVL251:
 2404              		.loc 1 1426 0
 2405 0012 EBB1     		cbz	r3, .L270
1427:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1428:Src/bno055.c  **** 		} else {
1429:Src/bno055.c  **** 		/*condition check for page, chip id is
1430:Src/bno055.c  **** 		available in the page zero*/
1431:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2406              		.loc 1 1431 0
 2407 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2408 0016 0546     		mov	r5, r0
 2409 0018 79B9     		cbnz	r1, .L276
 2410              	.LVL252:
 2411              	.L268:
1432:Src/bno055.c  **** 			/* Write the page zero*/
1433:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1434:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1435:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1436:Src/bno055.c  **** 			/* Read the eulre heading data*/
1437:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2412              		.loc 1 1437 0
 2413 001a 1C69     		ldr	r4, [r3, #16]
 2414 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2415 001e 01AA     		add	r2, sp, #4
 2416 0020 0223     		movs	r3, #2
 2417 0022 1A21     		movs	r1, #26
 2418 0024 A047     		blx	r4
 2419              	.LVL253:
1438:Src/bno055.c  **** 			(p_bno055->dev_addr,
1439:Src/bno055.c  **** 			BNO055_EULER_H_LSB_VALUEH_REG,
1440:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1441:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_LSB] =
1442:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1443:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_LSB],
1444:Src/bno055.c  **** 			BNO055_EULER_H_LSB_VALUEH);
1445:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_MSB] =
1446:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1447:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_MSB],
1448:Src/bno055.c  **** 			BNO055_EULER_H_MSB_VALUEH);
1449:Src/bno055.c  **** 			*euler_h_s16 = (s16)((((s32)
 2420              		.loc 1 1449 0
 2421 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2422 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2423 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2424 0032 2B80     		strh	r3, [r5]	@ movhi
 2425              	.LVL254:
 2426              	.L267:
1450:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_MSB])) <<
1451:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
ARM GAS  /tmp/ccVWLGiI.s 			page 72


1452:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_EULER_LSB]));
1453:Src/bno055.c  **** 		} else {
1454:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1455:Src/bno055.c  **** 		}
1456:Src/bno055.c  **** 	}
1457:Src/bno055.c  **** 	return com_rslt;
1458:Src/bno055.c  **** }
 2427              		.loc 1 1458 0
 2428 0034 40B2     		sxtb	r0, r0
 2429 0036 03B0     		add	sp, sp, #12
 2430              	.LCFI97:
 2431              		.cfi_remember_state
 2432              		.cfi_def_cfa_offset 12
 2433              		@ sp needed
 2434 0038 30BD     		pop	{r4, r5, pc}
 2435              	.LVL255:
 2436              	.L276:
 2437              	.LCFI98:
 2438              		.cfi_restore_state
1433:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2439              		.loc 1 1433 0
 2440 003a 1046     		mov	r0, r2
 2441              	.LVL256:
 2442 003c FFF7FEFF 		bl	bno055_write_page_id
 2443              	.LVL257:
 2444 0040 2368     		ldr	r3, [r4]
1434:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2445              		.loc 1 1434 0
 2446 0042 0028     		cmp	r0, #0
 2447 0044 E9D0     		beq	.L268
 2448              	.LVL258:
1434:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2449              		.loc 1 1434 0 is_stmt 0 discriminator 1
 2450 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1454:Src/bno055.c  **** 		}
 2451              		.loc 1 1454 0 is_stmt 1 discriminator 1
 2452 0048 FF20     		movs	r0, #255
1434:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2453              		.loc 1 1434 0 discriminator 1
 2454 004a 002A     		cmp	r2, #0
 2455 004c F2D1     		bne	.L267
 2456 004e E4E7     		b	.L268
 2457              	.LVL259:
 2458              	.L270:
1427:Src/bno055.c  **** 		} else {
 2459              		.loc 1 1427 0
 2460 0050 8120     		movs	r0, #129
 2461              	.LVL260:
 2462 0052 EFE7     		b	.L267
 2463              	.L278:
 2464              		.align	2
 2465              	.L277:
 2466 0054 00000000 		.word	.LANCHOR0
 2467              		.cfi_endproc
 2468              	.LFE23:
 2470              		.section	.text.bno055_read_euler_r,"ax",%progbits
 2471              		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 73


 2472              		.global	bno055_read_euler_r
 2473              		.thumb
 2474              		.thumb_func
 2476              	bno055_read_euler_r:
 2477              	.LFB24:
1459:Src/bno055.c  **** /*!
1460:Src/bno055.c  ****  *	@brief This API reads Euler data r values
1461:Src/bno055.c  ****  *	from register 0x1C and 0x1D it is a two byte data
1462:Src/bno055.c  ****  *
1463:Src/bno055.c  ****  *	@param euler_r_s16 : The raw r data
1464:Src/bno055.c  ****  *
1465:Src/bno055.c  ****  *	@return results of bus communication function
1466:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1467:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1468:Src/bno055.c  ****  *
1469:Src/bno055.c  ****  */
1470:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_euler_r(s16 *euler_r_s16)
1471:Src/bno055.c  **** {
 2478              		.loc 1 1471 0
 2479              		.cfi_startproc
 2480              		@ args = 0, pretend = 0, frame = 8
 2481              		@ frame_needed = 0, uses_anonymous_args = 0
 2482              	.LVL261:
 2483 0000 30B5     		push	{r4, r5, lr}
 2484              	.LCFI99:
 2485              		.cfi_def_cfa_offset 12
 2486              		.cfi_offset 4, -12
 2487              		.cfi_offset 5, -8
 2488              		.cfi_offset 14, -4
1472:Src/bno055.c  **** 	/* Variable used to return value of
1473:Src/bno055.c  **** 	communication routine*/
1474:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1475:Src/bno055.c  **** 	/* Array holding the Euler r value
1476:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_LSB] - r->LSB
1477:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_MSB] - r->MSB
1478:Src/bno055.c  **** 	*/
1479:Src/bno055.c  **** 	u8 data_u8[BNO055_EULER_DATA_SIZE] = {
1480:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1481:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1482:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1483:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2489              		.loc 1 1483 0
 2490 0002 144C     		ldr	r4, .L290
1471:Src/bno055.c  **** 	/* Variable used to return value of
 2491              		.loc 1 1471 0
 2492 0004 83B0     		sub	sp, sp, #12
 2493              	.LCFI100:
 2494              		.cfi_def_cfa_offset 24
 2495              		.loc 1 1483 0
 2496 0006 2368     		ldr	r3, [r4]
1479:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 2497              		.loc 1 1479 0
 2498 0008 0022     		movs	r2, #0
 2499 000a 8DF80420 		strb	r2, [sp, #4]
 2500 000e 8DF80520 		strb	r2, [sp, #5]
 2501              	.LVL262:
 2502              		.loc 1 1483 0
ARM GAS  /tmp/ccVWLGiI.s 			page 74


 2503 0012 EBB1     		cbz	r3, .L283
1484:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1485:Src/bno055.c  **** 		} else {
1486:Src/bno055.c  **** 		/*condition check for page, chip id is
1487:Src/bno055.c  **** 		available in the page zero*/
1488:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2504              		.loc 1 1488 0
 2505 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2506 0016 0546     		mov	r5, r0
 2507 0018 79B9     		cbnz	r1, .L289
 2508              	.LVL263:
 2509              	.L281:
1489:Src/bno055.c  **** 			/* Write the page zero*/
1490:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1491:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1492:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1493:Src/bno055.c  **** 			/* Read the Euler roll data*/
1494:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2510              		.loc 1 1494 0
 2511 001a 1C69     		ldr	r4, [r3, #16]
 2512 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2513 001e 01AA     		add	r2, sp, #4
 2514 0020 0223     		movs	r3, #2
 2515 0022 1C21     		movs	r1, #28
 2516 0024 A047     		blx	r4
 2517              	.LVL264:
1495:Src/bno055.c  **** 			(p_bno055->dev_addr,
1496:Src/bno055.c  **** 			BNO055_EULER_R_LSB_VALUER_REG,
1497:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1498:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_LSB] =
1499:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1500:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_LSB],
1501:Src/bno055.c  **** 			BNO055_EULER_R_LSB_VALUER);
1502:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_MSB] =
1503:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1504:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_MSB],
1505:Src/bno055.c  **** 			BNO055_EULER_R_MSB_VALUER);
1506:Src/bno055.c  **** 			*euler_r_s16 = (s16)((((s32)
 2518              		.loc 1 1506 0
 2519 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2520 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2521 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2522 0032 2B80     		strh	r3, [r5]	@ movhi
 2523              	.LVL265:
 2524              	.L280:
1507:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_MSB])) <<
1508:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1509:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_EULER_LSB]));
1510:Src/bno055.c  **** 		} else {
1511:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1512:Src/bno055.c  **** 		}
1513:Src/bno055.c  **** 	}
1514:Src/bno055.c  **** 	return com_rslt;
1515:Src/bno055.c  **** }
 2525              		.loc 1 1515 0
 2526 0034 40B2     		sxtb	r0, r0
 2527 0036 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 75


 2528              	.LCFI101:
 2529              		.cfi_remember_state
 2530              		.cfi_def_cfa_offset 12
 2531              		@ sp needed
 2532 0038 30BD     		pop	{r4, r5, pc}
 2533              	.LVL266:
 2534              	.L289:
 2535              	.LCFI102:
 2536              		.cfi_restore_state
1490:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2537              		.loc 1 1490 0
 2538 003a 1046     		mov	r0, r2
 2539              	.LVL267:
 2540 003c FFF7FEFF 		bl	bno055_write_page_id
 2541              	.LVL268:
 2542 0040 2368     		ldr	r3, [r4]
1491:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2543              		.loc 1 1491 0
 2544 0042 0028     		cmp	r0, #0
 2545 0044 E9D0     		beq	.L281
 2546              	.LVL269:
1491:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2547              		.loc 1 1491 0 is_stmt 0 discriminator 1
 2548 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1511:Src/bno055.c  **** 		}
 2549              		.loc 1 1511 0 is_stmt 1 discriminator 1
 2550 0048 FF20     		movs	r0, #255
1491:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2551              		.loc 1 1491 0 discriminator 1
 2552 004a 002A     		cmp	r2, #0
 2553 004c F2D1     		bne	.L280
 2554 004e E4E7     		b	.L281
 2555              	.LVL270:
 2556              	.L283:
1484:Src/bno055.c  **** 		} else {
 2557              		.loc 1 1484 0
 2558 0050 8120     		movs	r0, #129
 2559              	.LVL271:
 2560 0052 EFE7     		b	.L280
 2561              	.L291:
 2562              		.align	2
 2563              	.L290:
 2564 0054 00000000 		.word	.LANCHOR0
 2565              		.cfi_endproc
 2566              	.LFE24:
 2568              		.section	.text.bno055_read_euler_p,"ax",%progbits
 2569              		.align	2
 2570              		.global	bno055_read_euler_p
 2571              		.thumb
 2572              		.thumb_func
 2574              	bno055_read_euler_p:
 2575              	.LFB25:
1516:Src/bno055.c  **** /*!
1517:Src/bno055.c  ****  *	@brief This API reads Euler data p values
1518:Src/bno055.c  ****  *	from register 0x1E and 0x1F it is a two byte data
1519:Src/bno055.c  ****  *
1520:Src/bno055.c  ****  *	@param euler_p_s16 : The raw p data
ARM GAS  /tmp/ccVWLGiI.s 			page 76


1521:Src/bno055.c  ****  *
1522:Src/bno055.c  ****  *	@return results of bus communication function
1523:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1524:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1525:Src/bno055.c  ****  *
1526:Src/bno055.c  ****  *
1527:Src/bno055.c  ****  */
1528:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_euler_p(s16 *euler_p_s16)
1529:Src/bno055.c  **** {
 2576              		.loc 1 1529 0
 2577              		.cfi_startproc
 2578              		@ args = 0, pretend = 0, frame = 8
 2579              		@ frame_needed = 0, uses_anonymous_args = 0
 2580              	.LVL272:
 2581 0000 30B5     		push	{r4, r5, lr}
 2582              	.LCFI103:
 2583              		.cfi_def_cfa_offset 12
 2584              		.cfi_offset 4, -12
 2585              		.cfi_offset 5, -8
 2586              		.cfi_offset 14, -4
1530:Src/bno055.c  **** 	/* Variable used to return value of
1531:Src/bno055.c  **** 	communication routine*/
1532:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1533:Src/bno055.c  **** 	/* Array holding the Euler p value
1534:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_LSB] - p->LSB
1535:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_MSB] - p->MSB
1536:Src/bno055.c  **** 	*/
1537:Src/bno055.c  **** 	u8 data_u8[BNO055_EULER_DATA_SIZE] = {
1538:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1539:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1540:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1541:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2587              		.loc 1 1541 0
 2588 0002 144C     		ldr	r4, .L303
1529:Src/bno055.c  **** 	/* Variable used to return value of
 2589              		.loc 1 1529 0
 2590 0004 83B0     		sub	sp, sp, #12
 2591              	.LCFI104:
 2592              		.cfi_def_cfa_offset 24
 2593              		.loc 1 1541 0
 2594 0006 2368     		ldr	r3, [r4]
1537:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 2595              		.loc 1 1537 0
 2596 0008 0022     		movs	r2, #0
 2597 000a 8DF80420 		strb	r2, [sp, #4]
 2598 000e 8DF80520 		strb	r2, [sp, #5]
 2599              	.LVL273:
 2600              		.loc 1 1541 0
 2601 0012 EBB1     		cbz	r3, .L296
1542:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1543:Src/bno055.c  **** 		} else {
1544:Src/bno055.c  **** 		/*condition check for page, chip id is
1545:Src/bno055.c  **** 		available in the page zero*/
1546:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2602              		.loc 1 1546 0
 2603 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2604 0016 0546     		mov	r5, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 77


 2605 0018 79B9     		cbnz	r1, .L302
 2606              	.LVL274:
 2607              	.L294:
1547:Src/bno055.c  **** 			/* Write the page zero*/
1548:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1549:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1550:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1551:Src/bno055.c  **** 			/* Read the Euler p data*/
1552:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2608              		.loc 1 1552 0
 2609 001a 1C69     		ldr	r4, [r3, #16]
 2610 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2611 001e 01AA     		add	r2, sp, #4
 2612 0020 0223     		movs	r3, #2
 2613 0022 1E21     		movs	r1, #30
 2614 0024 A047     		blx	r4
 2615              	.LVL275:
1553:Src/bno055.c  **** 			(p_bno055->dev_addr,
1554:Src/bno055.c  **** 			BNO055_EULER_P_LSB_VALUEP_REG,
1555:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1556:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_LSB] =
1557:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1558:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_LSB],
1559:Src/bno055.c  **** 			BNO055_EULER_P_LSB_VALUEP);
1560:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_MSB] =
1561:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1562:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_MSB],
1563:Src/bno055.c  **** 			BNO055_EULER_P_MSB_VALUEP);
1564:Src/bno055.c  **** 			*euler_p_s16 = (s16)((((s32)
 2616              		.loc 1 1564 0
 2617 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2618 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2619 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2620 0032 2B80     		strh	r3, [r5]	@ movhi
 2621              	.LVL276:
 2622              	.L293:
1565:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_MSB])) <<
1566:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1567:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_EULER_LSB]));
1568:Src/bno055.c  **** 		} else {
1569:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1570:Src/bno055.c  **** 		}
1571:Src/bno055.c  **** 	}
1572:Src/bno055.c  **** 	return com_rslt;
1573:Src/bno055.c  **** }
 2623              		.loc 1 1573 0
 2624 0034 40B2     		sxtb	r0, r0
 2625 0036 03B0     		add	sp, sp, #12
 2626              	.LCFI105:
 2627              		.cfi_remember_state
 2628              		.cfi_def_cfa_offset 12
 2629              		@ sp needed
 2630 0038 30BD     		pop	{r4, r5, pc}
 2631              	.LVL277:
 2632              	.L302:
 2633              	.LCFI106:
 2634              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 78


1548:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2635              		.loc 1 1548 0
 2636 003a 1046     		mov	r0, r2
 2637              	.LVL278:
 2638 003c FFF7FEFF 		bl	bno055_write_page_id
 2639              	.LVL279:
 2640 0040 2368     		ldr	r3, [r4]
1549:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2641              		.loc 1 1549 0
 2642 0042 0028     		cmp	r0, #0
 2643 0044 E9D0     		beq	.L294
 2644              	.LVL280:
1549:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2645              		.loc 1 1549 0 is_stmt 0 discriminator 1
 2646 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1569:Src/bno055.c  **** 		}
 2647              		.loc 1 1569 0 is_stmt 1 discriminator 1
 2648 0048 FF20     		movs	r0, #255
1549:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2649              		.loc 1 1549 0 discriminator 1
 2650 004a 002A     		cmp	r2, #0
 2651 004c F2D1     		bne	.L293
 2652 004e E4E7     		b	.L294
 2653              	.LVL281:
 2654              	.L296:
1542:Src/bno055.c  **** 		} else {
 2655              		.loc 1 1542 0
 2656 0050 8120     		movs	r0, #129
 2657              	.LVL282:
 2658 0052 EFE7     		b	.L293
 2659              	.L304:
 2660              		.align	2
 2661              	.L303:
 2662 0054 00000000 		.word	.LANCHOR0
 2663              		.cfi_endproc
 2664              	.LFE25:
 2666              		.section	.text.bno055_read_euler_hrp,"ax",%progbits
 2667              		.align	2
 2668              		.global	bno055_read_euler_hrp
 2669              		.thumb
 2670              		.thumb_func
 2672              	bno055_read_euler_hrp:
 2673              	.LFB26:
1574:Src/bno055.c  **** /*!
1575:Src/bno055.c  ****  *	@brief This API reads Euler data hrp values
1576:Src/bno055.c  ****  *	from register 0x1A to 0x1F it is a six byte data
1577:Src/bno055.c  ****  *
1578:Src/bno055.c  ****  *
1579:Src/bno055.c  ****  *	@param euler : The Euler hrp data's
1580:Src/bno055.c  ****  *
1581:Src/bno055.c  ****  *	Parameter |    result
1582:Src/bno055.c  ****  *  --------- | -----------------
1583:Src/bno055.c  ****  *	 h        | The Euler h data
1584:Src/bno055.c  ****  *	 r        | The Euler r data
1585:Src/bno055.c  ****  *	 p        | The Euler p data
1586:Src/bno055.c  ****  *
1587:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 79


1588:Src/bno055.c  ****  *	@return results of bus communication function
1589:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1590:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1591:Src/bno055.c  ****  *
1592:Src/bno055.c  ****  */
1593:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_euler_hrp(
1594:Src/bno055.c  **** struct bno055_euler_t *euler)
1595:Src/bno055.c  **** {
 2674              		.loc 1 1595 0
 2675              		.cfi_startproc
 2676              		@ args = 0, pretend = 0, frame = 8
 2677              		@ frame_needed = 0, uses_anonymous_args = 0
 2678              	.LVL283:
 2679 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2680              	.LCFI107:
 2681              		.cfi_def_cfa_offset 20
 2682              		.cfi_offset 4, -20
 2683              		.cfi_offset 5, -16
 2684              		.cfi_offset 6, -12
 2685              		.cfi_offset 7, -8
 2686              		.cfi_offset 14, -4
1596:Src/bno055.c  **** 	/* Variable used to return value of
1597:Src/bno055.c  **** 	communication routine*/
1598:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1599:Src/bno055.c  **** 	/* Array holding the Euler hrp value
1600:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_LSB] - h->LSB
1601:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_MSB] - h->MSB
1602:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_LSB] - r->MSB
1603:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_MSB] - r->MSB
1604:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_LSB] - p->MSB
1605:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_MSB] - p->MSB
1606:Src/bno055.c  **** 	*/
1607:Src/bno055.c  **** 	u8 data_u8[BNO055_EULER_HRP_DATA_SIZE] = {
1608:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1609:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1610:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1611:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1612:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1613:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2687              		.loc 1 1613 0
 2688 0002 1F4D     		ldr	r5, .L316
1595:Src/bno055.c  **** 	/* Variable used to return value of
 2689              		.loc 1 1595 0
 2690 0004 83B0     		sub	sp, sp, #12
 2691              	.LCFI108:
 2692              		.cfi_def_cfa_offset 32
 2693              		.loc 1 1613 0
 2694 0006 2A68     		ldr	r2, [r5]
1607:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 2695              		.loc 1 1607 0
 2696 0008 0023     		movs	r3, #0
 2697 000a 8DF80030 		strb	r3, [sp]
 2698 000e 8DF80130 		strb	r3, [sp, #1]
 2699 0012 8DF80230 		strb	r3, [sp, #2]
 2700 0016 8DF80330 		strb	r3, [sp, #3]
 2701 001a 8DF80430 		strb	r3, [sp, #4]
 2702 001e 8DF80530 		strb	r3, [sp, #5]
ARM GAS  /tmp/ccVWLGiI.s 			page 80


 2703              	.LVL284:
 2704              		.loc 1 1613 0
 2705 0022 5AB3     		cbz	r2, .L309
1614:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1615:Src/bno055.c  **** 		} else {
1616:Src/bno055.c  **** 		/*condition check for page, chip id is
1617:Src/bno055.c  **** 		available in the page zero*/
1618:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2706              		.loc 1 1618 0
 2707 0024 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 2708 0026 0446     		mov	r4, r0
 2709 0028 E9B9     		cbnz	r1, .L315
 2710              	.LVL285:
 2711              	.L307:
1619:Src/bno055.c  **** 			/* Write the page zero*/
1620:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1621:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1622:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1623:Src/bno055.c  **** 			/* Read the six byte of Euler hrp data*/
1624:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2712              		.loc 1 1624 0
 2713 002a 1569     		ldr	r5, [r2, #16]
 2714 002c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 2715 002e 1A21     		movs	r1, #26
 2716 0030 6A46     		mov	r2, sp
 2717 0032 0623     		movs	r3, #6
 2718 0034 A847     		blx	r5
 2719              	.LVL286:
1625:Src/bno055.c  **** 			(p_bno055->dev_addr,
1626:Src/bno055.c  **** 			BNO055_EULER_H_LSB_VALUEH_REG,
1627:Src/bno055.c  **** 			data_u8, BNO055_EULER_HRP_DATA_SIZE);
1628:Src/bno055.c  **** 			/* Data h*/
1629:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_LSB] =
1630:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1631:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_LSB],
1632:Src/bno055.c  **** 			BNO055_EULER_H_LSB_VALUEH);
1633:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_MSB] =
1634:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1635:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_MSB],
1636:Src/bno055.c  **** 			BNO055_EULER_H_MSB_VALUEH);
1637:Src/bno055.c  **** 			euler->h = (s16)((((s32)
 2720              		.loc 1 1637 0
 2721 0036 9DF90170 		ldrsb	r7, [sp, #1]
 2722 003a 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
1638:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_MSB])) <<
1639:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1640:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_LSB]));
1641:Src/bno055.c  **** 			/* Data r*/
1642:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_LSB] =
1643:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1644:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_LSB],
1645:Src/bno055.c  **** 			BNO055_EULER_R_LSB_VALUER);
1646:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_MSB] =
1647:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1648:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_MSB],
1649:Src/bno055.c  **** 			BNO055_EULER_R_MSB_VALUER);
1650:Src/bno055.c  **** 			euler->r = (s16)((((s32)
ARM GAS  /tmp/ccVWLGiI.s 			page 81


 2723              		.loc 1 1650 0
 2724 003e 9DF90360 		ldrsb	r6, [sp, #3]
 2725 0042 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
1651:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_MSB])) <<
1652:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1653:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_LSB]));
1654:Src/bno055.c  **** 			/* Data p*/
1655:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_LSB] =
1656:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1657:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_LSB],
1658:Src/bno055.c  **** 			BNO055_EULER_P_LSB_VALUEP);
1659:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_MSB] =
1660:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1661:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_MSB],
1662:Src/bno055.c  **** 			BNO055_EULER_P_MSB_VALUEP);
1663:Src/bno055.c  **** 			euler->p = (s16)((((s32)
 2726              		.loc 1 1663 0
 2727 0046 9DF90550 		ldrsb	r5, [sp, #5]
 2728 004a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
1637:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_MSB])) <<
 2729              		.loc 1 1637 0
 2730 004e 41EA0721 		orr	r1, r1, r7, lsl #8
1650:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_MSB])) <<
 2731              		.loc 1 1650 0
 2732 0052 42EA0622 		orr	r2, r2, r6, lsl #8
 2733              		.loc 1 1663 0
 2734 0056 43EA0523 		orr	r3, r3, r5, lsl #8
1637:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_H_MSB])) <<
 2735              		.loc 1 1637 0
 2736 005a 2180     		strh	r1, [r4]	@ movhi
1650:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_R_MSB])) <<
 2737              		.loc 1 1650 0
 2738 005c 6280     		strh	r2, [r4, #2]	@ movhi
 2739              		.loc 1 1663 0
 2740 005e A380     		strh	r3, [r4, #4]	@ movhi
 2741              	.LVL287:
 2742              	.L306:
1664:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_MSB])) <<
1665:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1666:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_EULER_HRP_P_LSB]));
1667:Src/bno055.c  **** 		} else {
1668:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1669:Src/bno055.c  **** 		}
1670:Src/bno055.c  **** 	}
1671:Src/bno055.c  **** 	return com_rslt;
1672:Src/bno055.c  **** }
 2743              		.loc 1 1672 0
 2744 0060 40B2     		sxtb	r0, r0
 2745 0062 03B0     		add	sp, sp, #12
 2746              	.LCFI109:
 2747              		.cfi_remember_state
 2748              		.cfi_def_cfa_offset 20
 2749              		@ sp needed
 2750 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 2751              	.LVL288:
 2752              	.L315:
 2753              	.LCFI110:
ARM GAS  /tmp/ccVWLGiI.s 			page 82


 2754              		.cfi_restore_state
1620:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2755              		.loc 1 1620 0
 2756 0066 1846     		mov	r0, r3
 2757              	.LVL289:
 2758 0068 FFF7FEFF 		bl	bno055_write_page_id
 2759              	.LVL290:
 2760 006c 2A68     		ldr	r2, [r5]
1621:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2761              		.loc 1 1621 0
 2762 006e 0028     		cmp	r0, #0
 2763 0070 DBD0     		beq	.L307
 2764              	.LVL291:
1621:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2765              		.loc 1 1621 0 is_stmt 0 discriminator 1
 2766 0072 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
1668:Src/bno055.c  **** 		}
 2767              		.loc 1 1668 0 is_stmt 1 discriminator 1
 2768 0074 FF20     		movs	r0, #255
1621:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2769              		.loc 1 1621 0 discriminator 1
 2770 0076 002B     		cmp	r3, #0
 2771 0078 F2D1     		bne	.L306
 2772 007a D6E7     		b	.L307
 2773              	.LVL292:
 2774              	.L309:
1614:Src/bno055.c  **** 		} else {
 2775              		.loc 1 1614 0
 2776 007c 8120     		movs	r0, #129
 2777              	.LVL293:
 2778 007e EFE7     		b	.L306
 2779              	.L317:
 2780              		.align	2
 2781              	.L316:
 2782 0080 00000000 		.word	.LANCHOR0
 2783              		.cfi_endproc
 2784              	.LFE26:
 2786              		.section	.text.bno055_read_quaternion_w,"ax",%progbits
 2787              		.align	2
 2788              		.global	bno055_read_quaternion_w
 2789              		.thumb
 2790              		.thumb_func
 2792              	bno055_read_quaternion_w:
 2793              	.LFB27:
1673:Src/bno055.c  **** /*!
1674:Src/bno055.c  ****  *	@brief This API reads quaternion data w values
1675:Src/bno055.c  ****  *	from register 0x20 and 0x21 it is a two byte data
1676:Src/bno055.c  ****  *
1677:Src/bno055.c  ****  *	@param quaternion_w_s16 : The raw w data
1678:Src/bno055.c  ****  *
1679:Src/bno055.c  ****  *	@return results of bus communication function
1680:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1681:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1682:Src/bno055.c  ****  *
1683:Src/bno055.c  ****  *
1684:Src/bno055.c  ****  */
1685:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_quaternion_w(
ARM GAS  /tmp/ccVWLGiI.s 			page 83


1686:Src/bno055.c  **** s16 *quaternion_w_s16)
1687:Src/bno055.c  **** {
 2794              		.loc 1 1687 0
 2795              		.cfi_startproc
 2796              		@ args = 0, pretend = 0, frame = 8
 2797              		@ frame_needed = 0, uses_anonymous_args = 0
 2798              	.LVL294:
 2799 0000 30B5     		push	{r4, r5, lr}
 2800              	.LCFI111:
 2801              		.cfi_def_cfa_offset 12
 2802              		.cfi_offset 4, -12
 2803              		.cfi_offset 5, -8
 2804              		.cfi_offset 14, -4
1688:Src/bno055.c  **** 	/* Variable used to return value of
1689:Src/bno055.c  **** 	communication routine*/
1690:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1691:Src/bno055.c  **** 	/* Array holding the Quaternion w value
1692:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] - w->LSB
1693:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] - w->MSB
1694:Src/bno055.c  **** 	*/
1695:Src/bno055.c  **** 	u8 data_u8[BNO055_QUATERNION_DATA_SIZE] = {
1696:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1697:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1698:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1699:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2805              		.loc 1 1699 0
 2806 0002 144C     		ldr	r4, .L329
1687:Src/bno055.c  **** 	/* Variable used to return value of
 2807              		.loc 1 1687 0
 2808 0004 83B0     		sub	sp, sp, #12
 2809              	.LCFI112:
 2810              		.cfi_def_cfa_offset 24
 2811              		.loc 1 1699 0
 2812 0006 2368     		ldr	r3, [r4]
1695:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 2813              		.loc 1 1695 0
 2814 0008 0022     		movs	r2, #0
 2815 000a 8DF80420 		strb	r2, [sp, #4]
 2816 000e 8DF80520 		strb	r2, [sp, #5]
 2817              	.LVL295:
 2818              		.loc 1 1699 0
 2819 0012 EBB1     		cbz	r3, .L322
1700:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1701:Src/bno055.c  **** 		} else {
1702:Src/bno055.c  **** 		/*condition check for page, chip id is
1703:Src/bno055.c  **** 		available in the page zero*/
1704:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2820              		.loc 1 1704 0
 2821 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2822 0016 0546     		mov	r5, r0
 2823 0018 79B9     		cbnz	r1, .L328
 2824              	.LVL296:
 2825              	.L320:
1705:Src/bno055.c  **** 			/* Write the page zero*/
1706:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1707:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1708:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 84


1709:Src/bno055.c  **** 			/* Read the two byte value
1710:Src/bno055.c  **** 			of quaternion w data*/
1711:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2826              		.loc 1 1711 0
 2827 001a 1C69     		ldr	r4, [r3, #16]
 2828 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2829 001e 01AA     		add	r2, sp, #4
 2830 0020 0223     		movs	r3, #2
 2831 0022 2021     		movs	r1, #32
 2832 0024 A047     		blx	r4
 2833              	.LVL297:
1712:Src/bno055.c  **** 			(p_bno055->dev_addr,
1713:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_W_LSB_VALUEW_REG,
1714:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1715:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] =
1716:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1717:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB],
1718:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_W_LSB_VALUEW);
1719:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] =
1720:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1721:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB],
1722:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_W_MSB_VALUEW);
1723:Src/bno055.c  **** 			*quaternion_w_s16 = (s16)((((s32)
 2834              		.loc 1 1723 0
 2835 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2836 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2837 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2838 0032 2B80     		strh	r3, [r5]	@ movhi
 2839              	.LVL298:
 2840              	.L319:
1724:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB])) <<
1725:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1726:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB]));
1727:Src/bno055.c  **** 		} else {
1728:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1729:Src/bno055.c  **** 		}
1730:Src/bno055.c  **** 	}
1731:Src/bno055.c  **** 	return com_rslt;
1732:Src/bno055.c  **** }
 2841              		.loc 1 1732 0
 2842 0034 40B2     		sxtb	r0, r0
 2843 0036 03B0     		add	sp, sp, #12
 2844              	.LCFI113:
 2845              		.cfi_remember_state
 2846              		.cfi_def_cfa_offset 12
 2847              		@ sp needed
 2848 0038 30BD     		pop	{r4, r5, pc}
 2849              	.LVL299:
 2850              	.L328:
 2851              	.LCFI114:
 2852              		.cfi_restore_state
1706:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2853              		.loc 1 1706 0
 2854 003a 1046     		mov	r0, r2
 2855              	.LVL300:
 2856 003c FFF7FEFF 		bl	bno055_write_page_id
 2857              	.LVL301:
ARM GAS  /tmp/ccVWLGiI.s 			page 85


 2858 0040 2368     		ldr	r3, [r4]
1707:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2859              		.loc 1 1707 0
 2860 0042 0028     		cmp	r0, #0
 2861 0044 E9D0     		beq	.L320
 2862              	.LVL302:
1707:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2863              		.loc 1 1707 0 is_stmt 0 discriminator 1
 2864 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1728:Src/bno055.c  **** 		}
 2865              		.loc 1 1728 0 is_stmt 1 discriminator 1
 2866 0048 FF20     		movs	r0, #255
1707:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2867              		.loc 1 1707 0 discriminator 1
 2868 004a 002A     		cmp	r2, #0
 2869 004c F2D1     		bne	.L319
 2870 004e E4E7     		b	.L320
 2871              	.LVL303:
 2872              	.L322:
1700:Src/bno055.c  **** 		} else {
 2873              		.loc 1 1700 0
 2874 0050 8120     		movs	r0, #129
 2875              	.LVL304:
 2876 0052 EFE7     		b	.L319
 2877              	.L330:
 2878              		.align	2
 2879              	.L329:
 2880 0054 00000000 		.word	.LANCHOR0
 2881              		.cfi_endproc
 2882              	.LFE27:
 2884              		.section	.text.bno055_read_quaternion_x,"ax",%progbits
 2885              		.align	2
 2886              		.global	bno055_read_quaternion_x
 2887              		.thumb
 2888              		.thumb_func
 2890              	bno055_read_quaternion_x:
 2891              	.LFB28:
1733:Src/bno055.c  **** /*!
1734:Src/bno055.c  ****  *	@brief This API reads quaternion data x values
1735:Src/bno055.c  ****  *	from register 0x22 and 0x23 it is a two byte data
1736:Src/bno055.c  ****  *
1737:Src/bno055.c  ****  *	@param quaternion_x_s16 : The raw x data
1738:Src/bno055.c  ****  *
1739:Src/bno055.c  ****  *	@return results of bus communication function
1740:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1741:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1742:Src/bno055.c  ****  *
1743:Src/bno055.c  ****  *
1744:Src/bno055.c  ****  */
1745:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_quaternion_x(
1746:Src/bno055.c  **** s16 *quaternion_x_s16)
1747:Src/bno055.c  **** {
 2892              		.loc 1 1747 0
 2893              		.cfi_startproc
 2894              		@ args = 0, pretend = 0, frame = 8
 2895              		@ frame_needed = 0, uses_anonymous_args = 0
 2896              	.LVL305:
ARM GAS  /tmp/ccVWLGiI.s 			page 86


 2897 0000 30B5     		push	{r4, r5, lr}
 2898              	.LCFI115:
 2899              		.cfi_def_cfa_offset 12
 2900              		.cfi_offset 4, -12
 2901              		.cfi_offset 5, -8
 2902              		.cfi_offset 14, -4
1748:Src/bno055.c  **** 	/* Variable used to return value of
1749:Src/bno055.c  **** 	communication routine*/
1750:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1751:Src/bno055.c  **** 	/* Array holding the quaternion x value
1752:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] - x->LSB
1753:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] - x->MSB
1754:Src/bno055.c  **** 	*/
1755:Src/bno055.c  **** 	u8 data_u8[BNO055_QUATERNION_DATA_SIZE] = {BNO055_INIT_VALUE,
1756:Src/bno055.c  **** 	BNO055_INIT_VALUE};
1757:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1758:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1759:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 2903              		.loc 1 1759 0
 2904 0002 144C     		ldr	r4, .L342
1747:Src/bno055.c  **** 	/* Variable used to return value of
 2905              		.loc 1 1747 0
 2906 0004 83B0     		sub	sp, sp, #12
 2907              	.LCFI116:
 2908              		.cfi_def_cfa_offset 24
 2909              		.loc 1 1759 0
 2910 0006 2368     		ldr	r3, [r4]
1755:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 2911              		.loc 1 1755 0
 2912 0008 0022     		movs	r2, #0
 2913 000a 8DF80420 		strb	r2, [sp, #4]
 2914 000e 8DF80520 		strb	r2, [sp, #5]
 2915              	.LVL306:
 2916              		.loc 1 1759 0
 2917 0012 EBB1     		cbz	r3, .L335
1760:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1761:Src/bno055.c  **** 		} else {
1762:Src/bno055.c  **** 		/*condition check for page, chip id is
1763:Src/bno055.c  **** 		available in the page zero*/
1764:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 2918              		.loc 1 1764 0
 2919 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 2920 0016 0546     		mov	r5, r0
 2921 0018 79B9     		cbnz	r1, .L341
 2922              	.LVL307:
 2923              	.L333:
1765:Src/bno055.c  **** 			/* Write the page zero*/
1766:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1767:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1768:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1769:Src/bno055.c  **** 			/* Read the two byte value
1770:Src/bno055.c  **** 			of quaternion x data*/
1771:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 2924              		.loc 1 1771 0
 2925 001a 1C69     		ldr	r4, [r3, #16]
 2926 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 2927 001e 01AA     		add	r2, sp, #4
ARM GAS  /tmp/ccVWLGiI.s 			page 87


 2928 0020 0223     		movs	r3, #2
 2929 0022 2221     		movs	r1, #34
 2930 0024 A047     		blx	r4
 2931              	.LVL308:
1772:Src/bno055.c  **** 			(p_bno055->dev_addr,
1773:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_X_LSB_VALUEX_REG,
1774:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1775:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] =
1776:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1777:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB],
1778:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_X_LSB_VALUEX);
1779:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] =
1780:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1781:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB],
1782:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_X_MSB_VALUEX);
1783:Src/bno055.c  **** 			*quaternion_x_s16 = (s16)((((s32)
 2932              		.loc 1 1783 0
 2933 0026 9DF90520 		ldrsb	r2, [sp, #5]
 2934 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2935 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 2936 0032 2B80     		strh	r3, [r5]	@ movhi
 2937              	.LVL309:
 2938              	.L332:
1784:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB])) <<
1785:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1786:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB]));
1787:Src/bno055.c  **** 		} else {
1788:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1789:Src/bno055.c  **** 		}
1790:Src/bno055.c  **** 	}
1791:Src/bno055.c  **** 	return com_rslt;
1792:Src/bno055.c  **** }
 2939              		.loc 1 1792 0
 2940 0034 40B2     		sxtb	r0, r0
 2941 0036 03B0     		add	sp, sp, #12
 2942              	.LCFI117:
 2943              		.cfi_remember_state
 2944              		.cfi_def_cfa_offset 12
 2945              		@ sp needed
 2946 0038 30BD     		pop	{r4, r5, pc}
 2947              	.LVL310:
 2948              	.L341:
 2949              	.LCFI118:
 2950              		.cfi_restore_state
1766:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 2951              		.loc 1 1766 0
 2952 003a 1046     		mov	r0, r2
 2953              	.LVL311:
 2954 003c FFF7FEFF 		bl	bno055_write_page_id
 2955              	.LVL312:
 2956 0040 2368     		ldr	r3, [r4]
1767:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2957              		.loc 1 1767 0
 2958 0042 0028     		cmp	r0, #0
 2959 0044 E9D0     		beq	.L333
 2960              	.LVL313:
1767:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 88


 2961              		.loc 1 1767 0 is_stmt 0 discriminator 1
 2962 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1788:Src/bno055.c  **** 		}
 2963              		.loc 1 1788 0 is_stmt 1 discriminator 1
 2964 0048 FF20     		movs	r0, #255
1767:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 2965              		.loc 1 1767 0 discriminator 1
 2966 004a 002A     		cmp	r2, #0
 2967 004c F2D1     		bne	.L332
 2968 004e E4E7     		b	.L333
 2969              	.LVL314:
 2970              	.L335:
1760:Src/bno055.c  **** 		} else {
 2971              		.loc 1 1760 0
 2972 0050 8120     		movs	r0, #129
 2973              	.LVL315:
 2974 0052 EFE7     		b	.L332
 2975              	.L343:
 2976              		.align	2
 2977              	.L342:
 2978 0054 00000000 		.word	.LANCHOR0
 2979              		.cfi_endproc
 2980              	.LFE28:
 2982              		.section	.text.bno055_read_quaternion_y,"ax",%progbits
 2983              		.align	2
 2984              		.global	bno055_read_quaternion_y
 2985              		.thumb
 2986              		.thumb_func
 2988              	bno055_read_quaternion_y:
 2989              	.LFB29:
1793:Src/bno055.c  **** /*!
1794:Src/bno055.c  ****  *	@brief This API reads quaternion data y values
1795:Src/bno055.c  ****  *	from register 0x24 and 0x25 it is a two byte data
1796:Src/bno055.c  ****  *
1797:Src/bno055.c  ****  *	@param quaternion_y_s16 : The raw y data
1798:Src/bno055.c  ****  *
1799:Src/bno055.c  ****  *	@return results of bus communication function
1800:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1801:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1802:Src/bno055.c  ****  *
1803:Src/bno055.c  ****  *
1804:Src/bno055.c  ****  */
1805:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_quaternion_y(
1806:Src/bno055.c  **** s16 *quaternion_y_s16)
1807:Src/bno055.c  **** {
 2990              		.loc 1 1807 0
 2991              		.cfi_startproc
 2992              		@ args = 0, pretend = 0, frame = 8
 2993              		@ frame_needed = 0, uses_anonymous_args = 0
 2994              	.LVL316:
 2995 0000 30B5     		push	{r4, r5, lr}
 2996              	.LCFI119:
 2997              		.cfi_def_cfa_offset 12
 2998              		.cfi_offset 4, -12
 2999              		.cfi_offset 5, -8
 3000              		.cfi_offset 14, -4
1808:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 89


1809:Src/bno055.c  **** 	communication routine*/
1810:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1811:Src/bno055.c  **** 	/* Array holding the quaternion y value
1812:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] - y->LSB
1813:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] - y->MSB
1814:Src/bno055.c  **** 	*/
1815:Src/bno055.c  **** 	u8 data_u8[BNO055_QUATERNION_DATA_SIZE] = {BNO055_INIT_VALUE,
1816:Src/bno055.c  **** 	BNO055_INIT_VALUE};
1817:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1818:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1819:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3001              		.loc 1 1819 0
 3002 0002 144C     		ldr	r4, .L355
1807:Src/bno055.c  **** 	/* Variable used to return value of
 3003              		.loc 1 1807 0
 3004 0004 83B0     		sub	sp, sp, #12
 3005              	.LCFI120:
 3006              		.cfi_def_cfa_offset 24
 3007              		.loc 1 1819 0
 3008 0006 2368     		ldr	r3, [r4]
1815:Src/bno055.c  **** 	BNO055_INIT_VALUE};
 3009              		.loc 1 1815 0
 3010 0008 0022     		movs	r2, #0
 3011 000a 8DF80420 		strb	r2, [sp, #4]
 3012 000e 8DF80520 		strb	r2, [sp, #5]
 3013              	.LVL317:
 3014              		.loc 1 1819 0
 3015 0012 EBB1     		cbz	r3, .L348
1820:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1821:Src/bno055.c  **** 		} else {
1822:Src/bno055.c  **** 		/*condition check for page, chip id is
1823:Src/bno055.c  **** 		available in the page zero*/
1824:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3016              		.loc 1 1824 0
 3017 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3018 0016 0546     		mov	r5, r0
 3019 0018 79B9     		cbnz	r1, .L354
 3020              	.LVL318:
 3021              	.L346:
1825:Src/bno055.c  **** 			/* Write the page zero*/
1826:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1827:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1828:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1829:Src/bno055.c  **** 			/* Read the two byte value
1830:Src/bno055.c  **** 			of quaternion y data*/
1831:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3022              		.loc 1 1831 0
 3023 001a 1C69     		ldr	r4, [r3, #16]
 3024 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3025 001e 01AA     		add	r2, sp, #4
 3026 0020 0223     		movs	r3, #2
 3027 0022 2421     		movs	r1, #36
 3028 0024 A047     		blx	r4
 3029              	.LVL319:
1832:Src/bno055.c  **** 			(p_bno055->dev_addr,
1833:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Y_LSB_VALUEY_REG,
1834:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 90


1835:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] =
1836:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1837:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB],
1838:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Y_LSB_VALUEY);
1839:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] =
1840:Src/bno055.c  **** 			BNO055_GET_BITSLICE
1841:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB],
1842:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Y_MSB_VALUEY);
1843:Src/bno055.c  **** 			*quaternion_y_s16 = (s16)((((s32)
 3030              		.loc 1 1843 0
 3031 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3032 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3033 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3034 0032 2B80     		strh	r3, [r5]	@ movhi
 3035              	.LVL320:
 3036              	.L345:
1844:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB])) <<
1845:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1846:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB]));
1847:Src/bno055.c  **** 		} else {
1848:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1849:Src/bno055.c  **** 		}
1850:Src/bno055.c  **** 	}
1851:Src/bno055.c  **** 	return com_rslt;
1852:Src/bno055.c  **** }
 3037              		.loc 1 1852 0
 3038 0034 40B2     		sxtb	r0, r0
 3039 0036 03B0     		add	sp, sp, #12
 3040              	.LCFI121:
 3041              		.cfi_remember_state
 3042              		.cfi_def_cfa_offset 12
 3043              		@ sp needed
 3044 0038 30BD     		pop	{r4, r5, pc}
 3045              	.LVL321:
 3046              	.L354:
 3047              	.LCFI122:
 3048              		.cfi_restore_state
1826:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3049              		.loc 1 1826 0
 3050 003a 1046     		mov	r0, r2
 3051              	.LVL322:
 3052 003c FFF7FEFF 		bl	bno055_write_page_id
 3053              	.LVL323:
 3054 0040 2368     		ldr	r3, [r4]
1827:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3055              		.loc 1 1827 0
 3056 0042 0028     		cmp	r0, #0
 3057 0044 E9D0     		beq	.L346
 3058              	.LVL324:
1827:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3059              		.loc 1 1827 0 is_stmt 0 discriminator 1
 3060 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1848:Src/bno055.c  **** 		}
 3061              		.loc 1 1848 0 is_stmt 1 discriminator 1
 3062 0048 FF20     		movs	r0, #255
1827:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3063              		.loc 1 1827 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 91


 3064 004a 002A     		cmp	r2, #0
 3065 004c F2D1     		bne	.L345
 3066 004e E4E7     		b	.L346
 3067              	.LVL325:
 3068              	.L348:
1820:Src/bno055.c  **** 		} else {
 3069              		.loc 1 1820 0
 3070 0050 8120     		movs	r0, #129
 3071              	.LVL326:
 3072 0052 EFE7     		b	.L345
 3073              	.L356:
 3074              		.align	2
 3075              	.L355:
 3076 0054 00000000 		.word	.LANCHOR0
 3077              		.cfi_endproc
 3078              	.LFE29:
 3080              		.section	.text.bno055_read_quaternion_z,"ax",%progbits
 3081              		.align	2
 3082              		.global	bno055_read_quaternion_z
 3083              		.thumb
 3084              		.thumb_func
 3086              	bno055_read_quaternion_z:
 3087              	.LFB30:
1853:Src/bno055.c  **** /*!
1854:Src/bno055.c  ****  *	@brief This API reads quaternion data z values
1855:Src/bno055.c  ****  *	from register 0x26 and 0x27 it is a two byte data
1856:Src/bno055.c  ****  *
1857:Src/bno055.c  ****  *	@param quaternion_z_s16 : The raw z data
1858:Src/bno055.c  ****  *
1859:Src/bno055.c  ****  *	@return results of bus communication function
1860:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1861:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1862:Src/bno055.c  ****  *
1863:Src/bno055.c  ****  *
1864:Src/bno055.c  ****  */
1865:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_quaternion_z(
1866:Src/bno055.c  **** s16 *quaternion_z_s16)
1867:Src/bno055.c  **** {
 3088              		.loc 1 1867 0
 3089              		.cfi_startproc
 3090              		@ args = 0, pretend = 0, frame = 8
 3091              		@ frame_needed = 0, uses_anonymous_args = 0
 3092              	.LVL327:
 3093 0000 30B5     		push	{r4, r5, lr}
 3094              	.LCFI123:
 3095              		.cfi_def_cfa_offset 12
 3096              		.cfi_offset 4, -12
 3097              		.cfi_offset 5, -8
 3098              		.cfi_offset 14, -4
1868:Src/bno055.c  **** 	/* Variable used to return value of
1869:Src/bno055.c  **** 	communication routine*/
1870:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1871:Src/bno055.c  **** 	/* Array holding the quaternion z value
1872:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] - z->LSB
1873:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] - z->MSB
1874:Src/bno055.c  **** 	*/
1875:Src/bno055.c  **** 	u8 data_u8[BNO055_QUATERNION_DATA_SIZE] = {
ARM GAS  /tmp/ccVWLGiI.s 			page 92


1876:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1877:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1878:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1879:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3099              		.loc 1 1879 0
 3100 0002 144C     		ldr	r4, .L368
1867:Src/bno055.c  **** 	/* Variable used to return value of
 3101              		.loc 1 1867 0
 3102 0004 83B0     		sub	sp, sp, #12
 3103              	.LCFI124:
 3104              		.cfi_def_cfa_offset 24
 3105              		.loc 1 1879 0
 3106 0006 2368     		ldr	r3, [r4]
1875:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3107              		.loc 1 1875 0
 3108 0008 0022     		movs	r2, #0
 3109 000a 8DF80420 		strb	r2, [sp, #4]
 3110 000e 8DF80520 		strb	r2, [sp, #5]
 3111              	.LVL328:
 3112              		.loc 1 1879 0
 3113 0012 EBB1     		cbz	r3, .L361
1880:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1881:Src/bno055.c  **** 		} else {
1882:Src/bno055.c  **** 		/*condition check for page, chip id is
1883:Src/bno055.c  **** 		available in the page zero*/
1884:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3114              		.loc 1 1884 0
 3115 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3116 0016 0546     		mov	r5, r0
 3117 0018 79B9     		cbnz	r1, .L367
 3118              	.LVL329:
 3119              	.L359:
1885:Src/bno055.c  **** 			/* Write the page zero*/
1886:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1887:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1888:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1889:Src/bno055.c  **** 			/* Read the two byte value
1890:Src/bno055.c  **** 			of quaternion z data*/
1891:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3120              		.loc 1 1891 0
 3121 001a 1C69     		ldr	r4, [r3, #16]
 3122 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3123 001e 01AA     		add	r2, sp, #4
 3124 0020 0223     		movs	r3, #2
 3125 0022 2621     		movs	r1, #38
 3126 0024 A047     		blx	r4
 3127              	.LVL330:
1892:Src/bno055.c  **** 			(p_bno055->dev_addr,
1893:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Z_LSB_VALUEZ_REG,
1894:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
1895:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB] =
1896:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1897:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB],
1898:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Z_LSB_VALUEZ);
1899:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB] =
1900:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1901:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB],
ARM GAS  /tmp/ccVWLGiI.s 			page 93


1902:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Z_MSB_VALUEZ);
1903:Src/bno055.c  **** 			*quaternion_z_s16 = (s16)((((s32)
 3128              		.loc 1 1903 0
 3129 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3130 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3131 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3132 0032 2B80     		strh	r3, [r5]	@ movhi
 3133              	.LVL331:
 3134              	.L358:
1904:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_QUATERNION_MSB])) <<
1905:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
1906:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_QUATERNION_LSB]));
1907:Src/bno055.c  **** 		} else {
1908:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
1909:Src/bno055.c  **** 		}
1910:Src/bno055.c  **** 	}
1911:Src/bno055.c  **** 	return com_rslt;
1912:Src/bno055.c  **** }
 3135              		.loc 1 1912 0
 3136 0034 40B2     		sxtb	r0, r0
 3137 0036 03B0     		add	sp, sp, #12
 3138              	.LCFI125:
 3139              		.cfi_remember_state
 3140              		.cfi_def_cfa_offset 12
 3141              		@ sp needed
 3142 0038 30BD     		pop	{r4, r5, pc}
 3143              	.LVL332:
 3144              	.L367:
 3145              	.LCFI126:
 3146              		.cfi_restore_state
1886:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3147              		.loc 1 1886 0
 3148 003a 1046     		mov	r0, r2
 3149              	.LVL333:
 3150 003c FFF7FEFF 		bl	bno055_write_page_id
 3151              	.LVL334:
 3152 0040 2368     		ldr	r3, [r4]
1887:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3153              		.loc 1 1887 0
 3154 0042 0028     		cmp	r0, #0
 3155 0044 E9D0     		beq	.L359
 3156              	.LVL335:
1887:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3157              		.loc 1 1887 0 is_stmt 0 discriminator 1
 3158 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
1908:Src/bno055.c  **** 		}
 3159              		.loc 1 1908 0 is_stmt 1 discriminator 1
 3160 0048 FF20     		movs	r0, #255
1887:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3161              		.loc 1 1887 0 discriminator 1
 3162 004a 002A     		cmp	r2, #0
 3163 004c F2D1     		bne	.L358
 3164 004e E4E7     		b	.L359
 3165              	.LVL336:
 3166              	.L361:
1880:Src/bno055.c  **** 		} else {
 3167              		.loc 1 1880 0
ARM GAS  /tmp/ccVWLGiI.s 			page 94


 3168 0050 8120     		movs	r0, #129
 3169              	.LVL337:
 3170 0052 EFE7     		b	.L358
 3171              	.L369:
 3172              		.align	2
 3173              	.L368:
 3174 0054 00000000 		.word	.LANCHOR0
 3175              		.cfi_endproc
 3176              	.LFE30:
 3178              		.section	.text.bno055_read_quaternion_wxyz,"ax",%progbits
 3179              		.align	2
 3180              		.global	bno055_read_quaternion_wxyz
 3181              		.thumb
 3182              		.thumb_func
 3184              	bno055_read_quaternion_wxyz:
 3185              	.LFB31:
1913:Src/bno055.c  **** /*!
1914:Src/bno055.c  ****  *	@brief This API reads Quaternion data wxyz values
1915:Src/bno055.c  ****  *	from register 0x20 to 0x27 it is a six byte data
1916:Src/bno055.c  ****  *
1917:Src/bno055.c  ****  *
1918:Src/bno055.c  ****  *	@param quaternion : The value of quaternion wxyz data's
1919:Src/bno055.c  ****  *
1920:Src/bno055.c  ****  *	Parameter |    result
1921:Src/bno055.c  ****  *  --------- | -----------------
1922:Src/bno055.c  ****  *	 w        | The quaternion w data
1923:Src/bno055.c  ****  *	 x        | The quaternion x data
1924:Src/bno055.c  ****  *	 y        | The quaternion y data
1925:Src/bno055.c  ****  *	 z        | The quaternion z data
1926:Src/bno055.c  ****  *
1927:Src/bno055.c  ****  *
1928:Src/bno055.c  ****  *
1929:Src/bno055.c  ****  *	@return results of bus communication function
1930:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
1931:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
1932:Src/bno055.c  ****  *
1933:Src/bno055.c  ****  */
1934:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_quaternion_wxyz(
1935:Src/bno055.c  **** struct bno055_quaternion_t *quaternion)
1936:Src/bno055.c  **** {
 3186              		.loc 1 1936 0
 3187              		.cfi_startproc
 3188              		@ args = 0, pretend = 0, frame = 8
 3189              		@ frame_needed = 0, uses_anonymous_args = 0
 3190              	.LVL338:
 3191 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3192              	.LCFI127:
 3193              		.cfi_def_cfa_offset 20
 3194              		.cfi_offset 4, -20
 3195              		.cfi_offset 5, -16
 3196              		.cfi_offset 6, -12
 3197              		.cfi_offset 7, -8
 3198              		.cfi_offset 14, -4
1937:Src/bno055.c  **** 	/* Variable used to return value of
1938:Src/bno055.c  **** 	communication routine*/
1939:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
1940:Src/bno055.c  **** 	/* Array holding the quaternion wxyz value
ARM GAS  /tmp/ccVWLGiI.s 			page 95


1941:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_LSB] - w->LSB
1942:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_MSB] - w->MSB
1943:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_LSB] - x->LSB
1944:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_MSB] - x->MSB
1945:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_LSB] - y->MSB
1946:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_MSB] - y->MSB
1947:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_LSB] - z->MSB
1948:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_MSB] - z->MSB
1949:Src/bno055.c  **** 	*/
1950:Src/bno055.c  **** 	u8 data_u8[BNO055_QUATERNION_WXYZ_DATA_SIZE] = {
1951:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1952:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1953:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
1954:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
1955:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
1956:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
1957:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3199              		.loc 1 1957 0
 3200 0002 254D     		ldr	r5, .L381
1936:Src/bno055.c  **** 	/* Variable used to return value of
 3201              		.loc 1 1936 0
 3202 0004 83B0     		sub	sp, sp, #12
 3203              	.LCFI128:
 3204              		.cfi_def_cfa_offset 32
 3205              		.loc 1 1957 0
 3206 0006 2A68     		ldr	r2, [r5]
1950:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 3207              		.loc 1 1950 0
 3208 0008 0023     		movs	r3, #0
 3209 000a 8DF80030 		strb	r3, [sp]
 3210 000e 8DF80130 		strb	r3, [sp, #1]
 3211 0012 8DF80230 		strb	r3, [sp, #2]
 3212 0016 8DF80330 		strb	r3, [sp, #3]
 3213 001a 8DF80430 		strb	r3, [sp, #4]
 3214 001e 8DF80530 		strb	r3, [sp, #5]
 3215 0022 8DF80630 		strb	r3, [sp, #6]
 3216 0026 8DF80730 		strb	r3, [sp, #7]
 3217              	.LVL339:
 3218              		.loc 1 1957 0
 3219 002a 002A     		cmp	r2, #0
 3220 002c 32D0     		beq	.L374
1958:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
1959:Src/bno055.c  **** 		} else {
1960:Src/bno055.c  **** 		/*condition check for page, chip id is
1961:Src/bno055.c  **** 		available in the page zero*/
1962:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3221              		.loc 1 1962 0
 3222 002e 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 3223 0030 0446     		mov	r4, r0
 3224 0032 21BB     		cbnz	r1, .L380
 3225              	.LVL340:
 3226              	.L372:
1963:Src/bno055.c  **** 			/* Write the page zero*/
1964:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
1965:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
1966:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
1967:Src/bno055.c  **** 			/* Read the eight byte value
ARM GAS  /tmp/ccVWLGiI.s 			page 96


1968:Src/bno055.c  **** 			of quaternion wxyz data*/
1969:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3227              		.loc 1 1969 0
 3228 0034 1569     		ldr	r5, [r2, #16]
 3229 0036 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 3230 0038 2021     		movs	r1, #32
 3231 003a 6A46     		mov	r2, sp
 3232 003c 0823     		movs	r3, #8
 3233 003e A847     		blx	r5
 3234              	.LVL341:
1970:Src/bno055.c  **** 			(p_bno055->dev_addr,
1971:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_W_LSB_VALUEW_REG,
1972:Src/bno055.c  **** 			data_u8, BNO055_QUATERNION_WXYZ_DATA_SIZE);
1973:Src/bno055.c  **** 			/* Data W*/
1974:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_LSB] =
1975:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1976:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_LSB],
1977:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_W_LSB_VALUEW);
1978:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_MSB] =
1979:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1980:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_MSB],
1981:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_W_MSB_VALUEW);
1982:Src/bno055.c  **** 			quaternion->w = (s16)((((s32)((s8)
 3235              		.loc 1 1982 0
 3236 0040 9DF901C0 		ldrsb	ip, [sp, #1]
 3237 0044 9DF80050 		ldrb	r5, [sp]	@ zero_extendqisi2
1983:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_MSB])) <<
1984:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1985:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_LSB]));
1986:Src/bno055.c  **** 			/* Data X*/
1987:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_LSB] =
1988:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1989:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_LSB],
1990:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_X_LSB_VALUEX);
1991:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_MSB] =
1992:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
1993:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_MSB],
1994:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_X_MSB_VALUEX);
1995:Src/bno055.c  **** 			quaternion->x = (s16)((((s32)((s8)
 3238              		.loc 1 1995 0
 3239 0048 9DF903E0 		ldrsb	lr, [sp, #3]
 3240 004c 9DF80210 		ldrb	r1, [sp, #2]	@ zero_extendqisi2
1996:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_MSB])) <<
1997:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
1998:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_LSB]));
1999:Src/bno055.c  **** 			/* Data Y*/
2000:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_LSB] =
2001:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2002:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_LSB],
2003:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Y_LSB_VALUEY);
2004:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_MSB] =
2005:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2006:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_MSB],
2007:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Y_MSB_VALUEY);
2008:Src/bno055.c  **** 			quaternion->y = (s16)((((s32)((s8)
 3241              		.loc 1 2008 0
 3242 0050 9DF90570 		ldrsb	r7, [sp, #5]
ARM GAS  /tmp/ccVWLGiI.s 			page 97


 3243 0054 9DF80420 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
2009:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_MSB])) <<
2010:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
2011:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_LSB]));
2012:Src/bno055.c  **** 			/* Data Z*/
2013:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_LSB] =
2014:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2015:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_LSB],
2016:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Z_LSB_VALUEZ);
2017:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_MSB] =
2018:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2019:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_MSB],
2020:Src/bno055.c  **** 			BNO055_QUATERNION_DATA_Z_MSB_VALUEZ);
2021:Src/bno055.c  **** 			quaternion->z = (s16)((((s32)((s8)
 3244              		.loc 1 2021 0
 3245 0058 9DF90760 		ldrsb	r6, [sp, #7]
 3246 005c 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
1982:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_MSB])) <<
 3247              		.loc 1 1982 0
 3248 0060 45EA0C25 		orr	r5, r5, ip, lsl #8
1995:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_MSB])) <<
 3249              		.loc 1 1995 0
 3250 0064 41EA0E21 		orr	r1, r1, lr, lsl #8
2008:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_MSB])) <<
 3251              		.loc 1 2008 0
 3252 0068 42EA0722 		orr	r2, r2, r7, lsl #8
 3253              		.loc 1 2021 0
 3254 006c 43EA0623 		orr	r3, r3, r6, lsl #8
1982:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_W_MSB])) <<
 3255              		.loc 1 1982 0
 3256 0070 2580     		strh	r5, [r4]	@ movhi
1995:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_X_MSB])) <<
 3257              		.loc 1 1995 0
 3258 0072 6180     		strh	r1, [r4, #2]	@ movhi
2008:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Y_MSB])) <<
 3259              		.loc 1 2008 0
 3260 0074 A280     		strh	r2, [r4, #4]	@ movhi
 3261              		.loc 1 2021 0
 3262 0076 E380     		strh	r3, [r4, #6]	@ movhi
 3263              	.LVL342:
 3264              	.L371:
2022:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_MSB])) <<
2023:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
2024:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_QUATERNION_WXYZ_Z_LSB]));
2025:Src/bno055.c  **** 		} else {
2026:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2027:Src/bno055.c  **** 		}
2028:Src/bno055.c  **** 	}
2029:Src/bno055.c  **** 	return com_rslt;
2030:Src/bno055.c  **** }
 3265              		.loc 1 2030 0
 3266 0078 40B2     		sxtb	r0, r0
 3267 007a 03B0     		add	sp, sp, #12
 3268              	.LCFI129:
 3269              		.cfi_remember_state
 3270              		.cfi_def_cfa_offset 20
 3271              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 98


 3272 007c F0BD     		pop	{r4, r5, r6, r7, pc}
 3273              	.LVL343:
 3274              	.L380:
 3275              	.LCFI130:
 3276              		.cfi_restore_state
1964:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3277              		.loc 1 1964 0
 3278 007e 1846     		mov	r0, r3
 3279              	.LVL344:
 3280 0080 FFF7FEFF 		bl	bno055_write_page_id
 3281              	.LVL345:
 3282 0084 2A68     		ldr	r2, [r5]
1965:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3283              		.loc 1 1965 0
 3284 0086 0028     		cmp	r0, #0
 3285 0088 D4D0     		beq	.L372
 3286              	.LVL346:
1965:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3287              		.loc 1 1965 0 is_stmt 0 discriminator 1
 3288 008a 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
2026:Src/bno055.c  **** 		}
 3289              		.loc 1 2026 0 is_stmt 1 discriminator 1
 3290 008c FF20     		movs	r0, #255
1965:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3291              		.loc 1 1965 0 discriminator 1
 3292 008e 002B     		cmp	r3, #0
 3293 0090 F2D1     		bne	.L371
 3294 0092 CFE7     		b	.L372
 3295              	.LVL347:
 3296              	.L374:
1958:Src/bno055.c  **** 		} else {
 3297              		.loc 1 1958 0
 3298 0094 8120     		movs	r0, #129
 3299              	.LVL348:
 3300 0096 EFE7     		b	.L371
 3301              	.L382:
 3302              		.align	2
 3303              	.L381:
 3304 0098 00000000 		.word	.LANCHOR0
 3305              		.cfi_endproc
 3306              	.LFE31:
 3308              		.section	.text.bno055_read_linear_accel_x,"ax",%progbits
 3309              		.align	2
 3310              		.global	bno055_read_linear_accel_x
 3311              		.thumb
 3312              		.thumb_func
 3314              	bno055_read_linear_accel_x:
 3315              	.LFB32:
2031:Src/bno055.c  **** /*!
2032:Src/bno055.c  ****  *	@brief This API reads Linear accel data x values
2033:Src/bno055.c  ****  *	from register 0x29 and 0x2A it is a two byte data
2034:Src/bno055.c  ****  *
2035:Src/bno055.c  ****  *	@param linear_accel_x_s16 : The raw x data
2036:Src/bno055.c  ****  *
2037:Src/bno055.c  ****  *	@return results of bus communication function
2038:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2039:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
ARM GAS  /tmp/ccVWLGiI.s 			page 99


2040:Src/bno055.c  ****  *
2041:Src/bno055.c  ****  *
2042:Src/bno055.c  ****  */
2043:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_linear_accel_x(
2044:Src/bno055.c  **** s16 *linear_accel_x_s16)
2045:Src/bno055.c  **** {
 3316              		.loc 1 2045 0
 3317              		.cfi_startproc
 3318              		@ args = 0, pretend = 0, frame = 8
 3319              		@ frame_needed = 0, uses_anonymous_args = 0
 3320              	.LVL349:
 3321 0000 30B5     		push	{r4, r5, lr}
 3322              	.LCFI131:
 3323              		.cfi_def_cfa_offset 12
 3324              		.cfi_offset 4, -12
 3325              		.cfi_offset 5, -8
 3326              		.cfi_offset 14, -4
2046:Src/bno055.c  **** 	/* Variable used to return value of
2047:Src/bno055.c  **** 	communication routine*/
2048:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2049:Src/bno055.c  **** 	/* Array holding the linear accel x value
2050:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - x->LSB
2051:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - x->MSB
2052:Src/bno055.c  **** 	*/
2053:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_DATA_SIZE] = {
2054:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2055:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2056:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2057:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3327              		.loc 1 2057 0
 3328 0002 144C     		ldr	r4, .L394
2045:Src/bno055.c  **** 	/* Variable used to return value of
 3329              		.loc 1 2045 0
 3330 0004 83B0     		sub	sp, sp, #12
 3331              	.LCFI132:
 3332              		.cfi_def_cfa_offset 24
 3333              		.loc 1 2057 0
 3334 0006 2368     		ldr	r3, [r4]
2053:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3335              		.loc 1 2053 0
 3336 0008 0022     		movs	r2, #0
 3337 000a 8DF80420 		strb	r2, [sp, #4]
 3338 000e 8DF80520 		strb	r2, [sp, #5]
 3339              	.LVL350:
 3340              		.loc 1 2057 0
 3341 0012 EBB1     		cbz	r3, .L387
2058:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2059:Src/bno055.c  **** 		} else {
2060:Src/bno055.c  **** 		/*condition check for page, chip id is
2061:Src/bno055.c  **** 		available in the page zero*/
2062:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3342              		.loc 1 2062 0
 3343 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3344 0016 0546     		mov	r5, r0
 3345 0018 79B9     		cbnz	r1, .L393
 3346              	.LVL351:
 3347              	.L385:
ARM GAS  /tmp/ccVWLGiI.s 			page 100


2063:Src/bno055.c  **** 			/* Write the page zero*/
2064:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2065:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2066:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2067:Src/bno055.c  **** 			/* Read the two byte value
2068:Src/bno055.c  **** 			of linear accel x data*/
2069:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3348              		.loc 1 2069 0
 3349 001a 1C69     		ldr	r4, [r3, #16]
 3350 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3351 001e 01AA     		add	r2, sp, #4
 3352 0020 0223     		movs	r3, #2
 3353 0022 2821     		movs	r1, #40
 3354 0024 A047     		blx	r4
 3355              	.LVL352:
2070:Src/bno055.c  **** 			(p_bno055->dev_addr,
2071:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_X_LSB_VALUEX_REG,
2072:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
2073:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
2074:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
2075:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_X_LSB_VALUEX);
2076:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
2077:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
2078:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_X_MSB_VALUEX);
2079:Src/bno055.c  **** 			*linear_accel_x_s16 = (s16)((((s32)
 3356              		.loc 1 2079 0
 3357 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3358 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3359 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3360 0032 2B80     		strh	r3, [r5]	@ movhi
 3361              	.LVL353:
 3362              	.L384:
2080:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
2081:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2082:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
2083:Src/bno055.c  **** 		} else {
2084:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2085:Src/bno055.c  **** 		}
2086:Src/bno055.c  **** 	}
2087:Src/bno055.c  **** 	return com_rslt;
2088:Src/bno055.c  **** }
 3363              		.loc 1 2088 0
 3364 0034 40B2     		sxtb	r0, r0
 3365 0036 03B0     		add	sp, sp, #12
 3366              	.LCFI133:
 3367              		.cfi_remember_state
 3368              		.cfi_def_cfa_offset 12
 3369              		@ sp needed
 3370 0038 30BD     		pop	{r4, r5, pc}
 3371              	.LVL354:
 3372              	.L393:
 3373              	.LCFI134:
 3374              		.cfi_restore_state
2064:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3375              		.loc 1 2064 0
 3376 003a 1046     		mov	r0, r2
 3377              	.LVL355:
ARM GAS  /tmp/ccVWLGiI.s 			page 101


 3378 003c FFF7FEFF 		bl	bno055_write_page_id
 3379              	.LVL356:
 3380 0040 2368     		ldr	r3, [r4]
2065:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3381              		.loc 1 2065 0
 3382 0042 0028     		cmp	r0, #0
 3383 0044 E9D0     		beq	.L385
 3384              	.LVL357:
2065:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3385              		.loc 1 2065 0 is_stmt 0 discriminator 1
 3386 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2084:Src/bno055.c  **** 		}
 3387              		.loc 1 2084 0 is_stmt 1 discriminator 1
 3388 0048 FF20     		movs	r0, #255
2065:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3389              		.loc 1 2065 0 discriminator 1
 3390 004a 002A     		cmp	r2, #0
 3391 004c F2D1     		bne	.L384
 3392 004e E4E7     		b	.L385
 3393              	.LVL358:
 3394              	.L387:
2058:Src/bno055.c  **** 		} else {
 3395              		.loc 1 2058 0
 3396 0050 8120     		movs	r0, #129
 3397              	.LVL359:
 3398 0052 EFE7     		b	.L384
 3399              	.L395:
 3400              		.align	2
 3401              	.L394:
 3402 0054 00000000 		.word	.LANCHOR0
 3403              		.cfi_endproc
 3404              	.LFE32:
 3406              		.section	.text.bno055_read_linear_accel_y,"ax",%progbits
 3407              		.align	2
 3408              		.global	bno055_read_linear_accel_y
 3409              		.thumb
 3410              		.thumb_func
 3412              	bno055_read_linear_accel_y:
 3413              	.LFB33:
2089:Src/bno055.c  **** /*!
2090:Src/bno055.c  ****  *	@brief This API reads Linear accel data x values
2091:Src/bno055.c  ****  *	from register 0x2B and 0x2C it is a two byte data
2092:Src/bno055.c  ****  *
2093:Src/bno055.c  ****  *	@param linear_accel_y_s16 : The raw y data
2094:Src/bno055.c  ****  *
2095:Src/bno055.c  ****  *	@return results of bus communication function
2096:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2097:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2098:Src/bno055.c  ****  *
2099:Src/bno055.c  ****  *
2100:Src/bno055.c  ****  */
2101:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_linear_accel_y(
2102:Src/bno055.c  **** s16 *linear_accel_y_s16)
2103:Src/bno055.c  **** {
 3414              		.loc 1 2103 0
 3415              		.cfi_startproc
 3416              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccVWLGiI.s 			page 102


 3417              		@ frame_needed = 0, uses_anonymous_args = 0
 3418              	.LVL360:
 3419 0000 30B5     		push	{r4, r5, lr}
 3420              	.LCFI135:
 3421              		.cfi_def_cfa_offset 12
 3422              		.cfi_offset 4, -12
 3423              		.cfi_offset 5, -8
 3424              		.cfi_offset 14, -4
2104:Src/bno055.c  **** 	/* Variable used to return value of
2105:Src/bno055.c  **** 	communication routine*/
2106:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2107:Src/bno055.c  **** 	/* Array holding the linear accel y value
2108:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - y->LSB
2109:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - y->MSB
2110:Src/bno055.c  **** 	*/
2111:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_DATA_SIZE] = {
2112:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2113:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2114:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2115:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3425              		.loc 1 2115 0
 3426 0002 144C     		ldr	r4, .L407
2103:Src/bno055.c  **** 	/* Variable used to return value of
 3427              		.loc 1 2103 0
 3428 0004 83B0     		sub	sp, sp, #12
 3429              	.LCFI136:
 3430              		.cfi_def_cfa_offset 24
 3431              		.loc 1 2115 0
 3432 0006 2368     		ldr	r3, [r4]
2111:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3433              		.loc 1 2111 0
 3434 0008 0022     		movs	r2, #0
 3435 000a 8DF80420 		strb	r2, [sp, #4]
 3436 000e 8DF80520 		strb	r2, [sp, #5]
 3437              	.LVL361:
 3438              		.loc 1 2115 0
 3439 0012 EBB1     		cbz	r3, .L400
2116:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2117:Src/bno055.c  **** 		} else {
2118:Src/bno055.c  **** 		/*condition check for page, chip id is
2119:Src/bno055.c  **** 		available in the page zero*/
2120:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3440              		.loc 1 2120 0
 3441 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3442 0016 0546     		mov	r5, r0
 3443 0018 79B9     		cbnz	r1, .L406
 3444              	.LVL362:
 3445              	.L398:
2121:Src/bno055.c  **** 			/* Write the page zero*/
2122:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2123:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2124:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2125:Src/bno055.c  **** 			/* Read the two byte value
2126:Src/bno055.c  **** 			of linear accel y data*/
2127:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3446              		.loc 1 2127 0
 3447 001a 1C69     		ldr	r4, [r3, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 103


 3448 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3449 001e 01AA     		add	r2, sp, #4
 3450 0020 0223     		movs	r3, #2
 3451 0022 2A21     		movs	r1, #42
 3452 0024 A047     		blx	r4
 3453              	.LVL363:
2128:Src/bno055.c  **** 			(p_bno055->dev_addr,
2129:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Y_LSB_VALUEY_REG,
2130:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
2131:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
2132:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
2133:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Y_LSB_VALUEY);
2134:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
2135:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
2136:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Y_MSB_VALUEY);
2137:Src/bno055.c  **** 			*linear_accel_y_s16 = (s16)((((s32)
 3454              		.loc 1 2137 0
 3455 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3456 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3457 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3458 0032 2B80     		strh	r3, [r5]	@ movhi
 3459              	.LVL364:
 3460              	.L397:
2138:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
2139:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) | (
2140:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB]));
2141:Src/bno055.c  **** 		} else {
2142:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2143:Src/bno055.c  **** 		}
2144:Src/bno055.c  **** 	}
2145:Src/bno055.c  **** 	return com_rslt;
2146:Src/bno055.c  **** }
 3461              		.loc 1 2146 0
 3462 0034 40B2     		sxtb	r0, r0
 3463 0036 03B0     		add	sp, sp, #12
 3464              	.LCFI137:
 3465              		.cfi_remember_state
 3466              		.cfi_def_cfa_offset 12
 3467              		@ sp needed
 3468 0038 30BD     		pop	{r4, r5, pc}
 3469              	.LVL365:
 3470              	.L406:
 3471              	.LCFI138:
 3472              		.cfi_restore_state
2122:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3473              		.loc 1 2122 0
 3474 003a 1046     		mov	r0, r2
 3475              	.LVL366:
 3476 003c FFF7FEFF 		bl	bno055_write_page_id
 3477              	.LVL367:
 3478 0040 2368     		ldr	r3, [r4]
2123:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3479              		.loc 1 2123 0
 3480 0042 0028     		cmp	r0, #0
 3481 0044 E9D0     		beq	.L398
 3482              	.LVL368:
2123:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 104


 3483              		.loc 1 2123 0 is_stmt 0 discriminator 1
 3484 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2142:Src/bno055.c  **** 		}
 3485              		.loc 1 2142 0 is_stmt 1 discriminator 1
 3486 0048 FF20     		movs	r0, #255
2123:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3487              		.loc 1 2123 0 discriminator 1
 3488 004a 002A     		cmp	r2, #0
 3489 004c F2D1     		bne	.L397
 3490 004e E4E7     		b	.L398
 3491              	.LVL369:
 3492              	.L400:
2116:Src/bno055.c  **** 		} else {
 3493              		.loc 1 2116 0
 3494 0050 8120     		movs	r0, #129
 3495              	.LVL370:
 3496 0052 EFE7     		b	.L397
 3497              	.L408:
 3498              		.align	2
 3499              	.L407:
 3500 0054 00000000 		.word	.LANCHOR0
 3501              		.cfi_endproc
 3502              	.LFE33:
 3504              		.section	.text.bno055_read_linear_accel_z,"ax",%progbits
 3505              		.align	2
 3506              		.global	bno055_read_linear_accel_z
 3507              		.thumb
 3508              		.thumb_func
 3510              	bno055_read_linear_accel_z:
 3511              	.LFB34:
2147:Src/bno055.c  **** /*!
2148:Src/bno055.c  ****  *	@brief This API reads Linear accel data x values
2149:Src/bno055.c  ****  *	from register 0x2C and 0x2D it is a two byte data
2150:Src/bno055.c  ****  *
2151:Src/bno055.c  ****  *	@param linear_accel_z_s16 : The raw z data
2152:Src/bno055.c  ****  *
2153:Src/bno055.c  ****  *	@return results of bus communication function
2154:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2155:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2156:Src/bno055.c  ****  *
2157:Src/bno055.c  ****  *
2158:Src/bno055.c  ****  */
2159:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_linear_accel_z(
2160:Src/bno055.c  **** s16 *linear_accel_z_s16)
2161:Src/bno055.c  **** {
 3512              		.loc 1 2161 0
 3513              		.cfi_startproc
 3514              		@ args = 0, pretend = 0, frame = 8
 3515              		@ frame_needed = 0, uses_anonymous_args = 0
 3516              	.LVL371:
 3517 0000 30B5     		push	{r4, r5, lr}
 3518              	.LCFI139:
 3519              		.cfi_def_cfa_offset 12
 3520              		.cfi_offset 4, -12
 3521              		.cfi_offset 5, -8
 3522              		.cfi_offset 14, -4
2162:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 105


2163:Src/bno055.c  **** 	communication routine*/
2164:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2165:Src/bno055.c  **** 	/* Array holding the linear accel z value
2166:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - z->LSB
2167:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - z->MSB
2168:Src/bno055.c  **** 	*/
2169:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_DATA_SIZE] = {
2170:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2171:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2172:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2173:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3523              		.loc 1 2173 0
 3524 0002 144C     		ldr	r4, .L420
2161:Src/bno055.c  **** 	/* Variable used to return value of
 3525              		.loc 1 2161 0
 3526 0004 83B0     		sub	sp, sp, #12
 3527              	.LCFI140:
 3528              		.cfi_def_cfa_offset 24
 3529              		.loc 1 2173 0
 3530 0006 2368     		ldr	r3, [r4]
2169:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3531              		.loc 1 2169 0
 3532 0008 0022     		movs	r2, #0
 3533 000a 8DF80420 		strb	r2, [sp, #4]
 3534 000e 8DF80520 		strb	r2, [sp, #5]
 3535              	.LVL372:
 3536              		.loc 1 2173 0
 3537 0012 EBB1     		cbz	r3, .L413
2174:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2175:Src/bno055.c  **** 		} else {
2176:Src/bno055.c  **** 		/*condition check for page, chip id is
2177:Src/bno055.c  **** 		available in the page zero*/
2178:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3538              		.loc 1 2178 0
 3539 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3540 0016 0546     		mov	r5, r0
 3541 0018 79B9     		cbnz	r1, .L419
 3542              	.LVL373:
 3543              	.L411:
2179:Src/bno055.c  **** 			/* Write the page zero*/
2180:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2181:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2182:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2183:Src/bno055.c  **** 			/* Read the two byte value
2184:Src/bno055.c  **** 			of linear accel z data*/
2185:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3544              		.loc 1 2185 0
 3545 001a 1C69     		ldr	r4, [r3, #16]
 3546 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3547 001e 01AA     		add	r2, sp, #4
 3548 0020 0223     		movs	r3, #2
 3549 0022 2C21     		movs	r1, #44
 3550 0024 A047     		blx	r4
 3551              	.LVL374:
2186:Src/bno055.c  **** 			(p_bno055->dev_addr,
2187:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Z_LSB_VALUEZ_REG,
2188:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 106


2189:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
2190:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
2191:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Z_LSB_VALUEZ);
2192:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
2193:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
2194:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Z_MSB_VALUEZ);
2195:Src/bno055.c  **** 			*linear_accel_z_s16 = (s16)((((s32)
 3552              		.loc 1 2195 0
 3553 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3554 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3555 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3556 0032 2B80     		strh	r3, [r5]	@ movhi
 3557              	.LVL375:
 3558              	.L410:
2196:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
2197:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) | (
2198:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB]));
2199:Src/bno055.c  **** 		} else {
2200:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2201:Src/bno055.c  **** 		}
2202:Src/bno055.c  **** 	}
2203:Src/bno055.c  **** 	return com_rslt;
2204:Src/bno055.c  **** }
 3559              		.loc 1 2204 0
 3560 0034 40B2     		sxtb	r0, r0
 3561 0036 03B0     		add	sp, sp, #12
 3562              	.LCFI141:
 3563              		.cfi_remember_state
 3564              		.cfi_def_cfa_offset 12
 3565              		@ sp needed
 3566 0038 30BD     		pop	{r4, r5, pc}
 3567              	.LVL376:
 3568              	.L419:
 3569              	.LCFI142:
 3570              		.cfi_restore_state
2180:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3571              		.loc 1 2180 0
 3572 003a 1046     		mov	r0, r2
 3573              	.LVL377:
 3574 003c FFF7FEFF 		bl	bno055_write_page_id
 3575              	.LVL378:
 3576 0040 2368     		ldr	r3, [r4]
2181:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3577              		.loc 1 2181 0
 3578 0042 0028     		cmp	r0, #0
 3579 0044 E9D0     		beq	.L411
 3580              	.LVL379:
2181:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3581              		.loc 1 2181 0 is_stmt 0 discriminator 1
 3582 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2200:Src/bno055.c  **** 		}
 3583              		.loc 1 2200 0 is_stmt 1 discriminator 1
 3584 0048 FF20     		movs	r0, #255
2181:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3585              		.loc 1 2181 0 discriminator 1
 3586 004a 002A     		cmp	r2, #0
 3587 004c F2D1     		bne	.L410
ARM GAS  /tmp/ccVWLGiI.s 			page 107


 3588 004e E4E7     		b	.L411
 3589              	.LVL380:
 3590              	.L413:
2174:Src/bno055.c  **** 		} else {
 3591              		.loc 1 2174 0
 3592 0050 8120     		movs	r0, #129
 3593              	.LVL381:
 3594 0052 EFE7     		b	.L410
 3595              	.L421:
 3596              		.align	2
 3597              	.L420:
 3598 0054 00000000 		.word	.LANCHOR0
 3599              		.cfi_endproc
 3600              	.LFE34:
 3602              		.section	.text.bno055_read_linear_accel_xyz,"ax",%progbits
 3603              		.align	2
 3604              		.global	bno055_read_linear_accel_xyz
 3605              		.thumb
 3606              		.thumb_func
 3608              	bno055_read_linear_accel_xyz:
 3609              	.LFB35:
2205:Src/bno055.c  **** /*!
2206:Src/bno055.c  ****  *	@brief This API reads Linear accel data xyz values
2207:Src/bno055.c  ****  *	from register 0x28 to 0x2D it is a six byte data
2208:Src/bno055.c  ****  *
2209:Src/bno055.c  ****  *
2210:Src/bno055.c  ****  *	@param linear_accel : The value of linear accel xyz data's
2211:Src/bno055.c  ****  *
2212:Src/bno055.c  ****  *	Parameter |    result
2213:Src/bno055.c  ****  *  --------- | -----------------
2214:Src/bno055.c  ****  *	 x        | The linear accel x data
2215:Src/bno055.c  ****  *	 y        | The linear accel y data
2216:Src/bno055.c  ****  *	 z        | The linear accel z data
2217:Src/bno055.c  ****  *
2218:Src/bno055.c  ****  *
2219:Src/bno055.c  ****  *	@return results of bus communication function
2220:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2221:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2222:Src/bno055.c  ****  */
2223:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_linear_accel_xyz(
2224:Src/bno055.c  **** struct bno055_linear_accel_t *linear_accel)
2225:Src/bno055.c  **** {
 3610              		.loc 1 2225 0
 3611              		.cfi_startproc
 3612              		@ args = 0, pretend = 0, frame = 8
 3613              		@ frame_needed = 0, uses_anonymous_args = 0
 3614              	.LVL382:
 3615 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3616              	.LCFI143:
 3617              		.cfi_def_cfa_offset 20
 3618              		.cfi_offset 4, -20
 3619              		.cfi_offset 5, -16
 3620              		.cfi_offset 6, -12
 3621              		.cfi_offset 7, -8
 3622              		.cfi_offset 14, -4
2226:Src/bno055.c  **** 	/* Variable used to return value of
2227:Src/bno055.c  **** 	communication routine*/
ARM GAS  /tmp/ccVWLGiI.s 			page 108


2228:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2229:Src/bno055.c  **** 	/* Array holding the linear accel xyz value
2230:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] - x->LSB
2231:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] - x->MSB
2232:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] - y->MSB
2233:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] - y->MSB
2234:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] - z->MSB
2235:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] - z->MSB
2236:Src/bno055.c  **** 	*/
2237:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_XYZ_DATA_SIZE] = {
2238:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
2239:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
2240:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2241:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2242:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2243:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3623              		.loc 1 2243 0
 3624 0002 1F4D     		ldr	r5, .L433
2225:Src/bno055.c  **** 	/* Variable used to return value of
 3625              		.loc 1 2225 0
 3626 0004 83B0     		sub	sp, sp, #12
 3627              	.LCFI144:
 3628              		.cfi_def_cfa_offset 32
 3629              		.loc 1 2243 0
 3630 0006 2A68     		ldr	r2, [r5]
2237:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 3631              		.loc 1 2237 0
 3632 0008 0023     		movs	r3, #0
 3633 000a 8DF80030 		strb	r3, [sp]
 3634 000e 8DF80130 		strb	r3, [sp, #1]
 3635 0012 8DF80230 		strb	r3, [sp, #2]
 3636 0016 8DF80330 		strb	r3, [sp, #3]
 3637 001a 8DF80430 		strb	r3, [sp, #4]
 3638 001e 8DF80530 		strb	r3, [sp, #5]
 3639              	.LVL383:
 3640              		.loc 1 2243 0
 3641 0022 5AB3     		cbz	r2, .L426
2244:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2245:Src/bno055.c  **** 		} else {
2246:Src/bno055.c  **** 		/*condition check for page, chip id is
2247:Src/bno055.c  **** 		available in the page zero*/
2248:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3642              		.loc 1 2248 0
 3643 0024 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 3644 0026 0446     		mov	r4, r0
 3645 0028 E9B9     		cbnz	r1, .L432
 3646              	.LVL384:
 3647              	.L424:
2249:Src/bno055.c  **** 			/* Write the page zero*/
2250:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2251:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2252:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2253:Src/bno055.c  **** 			/* Read the six byte value
2254:Src/bno055.c  **** 			of linear accel xyz data*/
2255:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3648              		.loc 1 2255 0
 3649 002a 1569     		ldr	r5, [r2, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 109


 3650 002c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 3651 002e 2821     		movs	r1, #40
 3652 0030 6A46     		mov	r2, sp
 3653 0032 0623     		movs	r3, #6
 3654 0034 A847     		blx	r5
 3655              	.LVL385:
2256:Src/bno055.c  **** 			(p_bno055->dev_addr,
2257:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_X_LSB_VALUEX_REG,
2258:Src/bno055.c  **** 			data_u8, BNO055_ACCEL_XYZ_DATA_SIZE);
2259:Src/bno055.c  **** 			/* Data x*/
2260:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] =
2261:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2262:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB],
2263:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_X_LSB_VALUEX);
2264:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] =
2265:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2266:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB],
2267:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_X_MSB_VALUEX);
2268:Src/bno055.c  **** 			linear_accel->x = (s16)((((s32)
 3656              		.loc 1 2268 0
 3657 0036 9DF90170 		ldrsb	r7, [sp, #1]
 3658 003a 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
2269:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
2270:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2271:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB]));
2272:Src/bno055.c  **** 			/* Data y*/
2273:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] =
2274:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2275:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB],
2276:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Y_LSB_VALUEY);
2277:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] =
2278:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2279:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB],
2280:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Y_MSB_VALUEY);
2281:Src/bno055.c  **** 			linear_accel->y = (s16)((((s32)
 3659              		.loc 1 2281 0
 3660 003e 9DF90360 		ldrsb	r6, [sp, #3]
 3661 0042 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
2282:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
2283:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2284:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB]));
2285:Src/bno055.c  **** 			/* Data z*/
2286:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] =
2287:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2288:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB],
2289:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Z_LSB_VALUEZ);
2290:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] =
2291:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2292:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB],
2293:Src/bno055.c  **** 			BNO055_LINEAR_ACCEL_DATA_Z_MSB_VALUEZ);
2294:Src/bno055.c  **** 			linear_accel->z = (s16)((((s32)
 3662              		.loc 1 2294 0
 3663 0046 9DF90550 		ldrsb	r5, [sp, #5]
 3664 004a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
2268:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 3665              		.loc 1 2268 0
 3666 004e 41EA0721 		orr	r1, r1, r7, lsl #8
ARM GAS  /tmp/ccVWLGiI.s 			page 110


2281:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 3667              		.loc 1 2281 0
 3668 0052 42EA0622 		orr	r2, r2, r6, lsl #8
 3669              		.loc 1 2294 0
 3670 0056 43EA0523 		orr	r3, r3, r5, lsl #8
2268:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB])) <<
 3671              		.loc 1 2268 0
 3672 005a 2180     		strh	r1, [r4]	@ movhi
2281:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 3673              		.loc 1 2281 0
 3674 005c 6280     		strh	r2, [r4, #2]	@ movhi
 3675              		.loc 1 2294 0
 3676 005e A380     		strh	r3, [r4, #4]	@ movhi
 3677              	.LVL386:
 3678              	.L423:
2295:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB])) <<
2296:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2297:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB]));
2298:Src/bno055.c  **** 		} else {
2299:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2300:Src/bno055.c  **** 		}
2301:Src/bno055.c  **** 	}
2302:Src/bno055.c  **** 	return com_rslt;
2303:Src/bno055.c  **** }
 3679              		.loc 1 2303 0
 3680 0060 40B2     		sxtb	r0, r0
 3681 0062 03B0     		add	sp, sp, #12
 3682              	.LCFI145:
 3683              		.cfi_remember_state
 3684              		.cfi_def_cfa_offset 20
 3685              		@ sp needed
 3686 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 3687              	.LVL387:
 3688              	.L432:
 3689              	.LCFI146:
 3690              		.cfi_restore_state
2250:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3691              		.loc 1 2250 0
 3692 0066 1846     		mov	r0, r3
 3693              	.LVL388:
 3694 0068 FFF7FEFF 		bl	bno055_write_page_id
 3695              	.LVL389:
 3696 006c 2A68     		ldr	r2, [r5]
2251:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3697              		.loc 1 2251 0
 3698 006e 0028     		cmp	r0, #0
 3699 0070 DBD0     		beq	.L424
 3700              	.LVL390:
2251:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3701              		.loc 1 2251 0 is_stmt 0 discriminator 1
 3702 0072 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
2299:Src/bno055.c  **** 		}
 3703              		.loc 1 2299 0 is_stmt 1 discriminator 1
 3704 0074 FF20     		movs	r0, #255
2251:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3705              		.loc 1 2251 0 discriminator 1
 3706 0076 002B     		cmp	r3, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 111


 3707 0078 F2D1     		bne	.L423
 3708 007a D6E7     		b	.L424
 3709              	.LVL391:
 3710              	.L426:
2244:Src/bno055.c  **** 		} else {
 3711              		.loc 1 2244 0
 3712 007c 8120     		movs	r0, #129
 3713              	.LVL392:
 3714 007e EFE7     		b	.L423
 3715              	.L434:
 3716              		.align	2
 3717              	.L433:
 3718 0080 00000000 		.word	.LANCHOR0
 3719              		.cfi_endproc
 3720              	.LFE35:
 3722              		.section	.text.bno055_read_gravity_x,"ax",%progbits
 3723              		.align	2
 3724              		.global	bno055_read_gravity_x
 3725              		.thumb
 3726              		.thumb_func
 3728              	bno055_read_gravity_x:
 3729              	.LFB36:
2304:Src/bno055.c  **** /*!
2305:Src/bno055.c  ****  *	@brief This API reads gravity data x values
2306:Src/bno055.c  ****  *	from register 0x2E and 0x2F it is a two byte data
2307:Src/bno055.c  ****  *
2308:Src/bno055.c  ****  *	@param gravity_x_s16 : The raw x data
2309:Src/bno055.c  ****  *
2310:Src/bno055.c  ****  *	@return results of bus communication function
2311:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2312:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2313:Src/bno055.c  ****  *
2314:Src/bno055.c  ****  *
2315:Src/bno055.c  ****  */
2316:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gravity_x(
2317:Src/bno055.c  **** s16 *gravity_x_s16)
2318:Src/bno055.c  **** {
 3730              		.loc 1 2318 0
 3731              		.cfi_startproc
 3732              		@ args = 0, pretend = 0, frame = 8
 3733              		@ frame_needed = 0, uses_anonymous_args = 0
 3734              	.LVL393:
 3735 0000 30B5     		push	{r4, r5, lr}
 3736              	.LCFI147:
 3737              		.cfi_def_cfa_offset 12
 3738              		.cfi_offset 4, -12
 3739              		.cfi_offset 5, -8
 3740              		.cfi_offset 14, -4
2319:Src/bno055.c  **** 	/* Variable used to return value of
2320:Src/bno055.c  **** 	communication routine*/
2321:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2322:Src/bno055.c  **** 	/* Array holding the gravity x value
2323:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - x->LSB
2324:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - x->MSB
2325:Src/bno055.c  **** 	*/
2326:Src/bno055.c  **** 	u8 data_u8[BNO055_GRAVITY_DATA_SIZE] = {
2327:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
ARM GAS  /tmp/ccVWLGiI.s 			page 112


2328:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2329:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2330:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3741              		.loc 1 2330 0
 3742 0002 144C     		ldr	r4, .L446
2318:Src/bno055.c  **** 	/* Variable used to return value of
 3743              		.loc 1 2318 0
 3744 0004 83B0     		sub	sp, sp, #12
 3745              	.LCFI148:
 3746              		.cfi_def_cfa_offset 24
 3747              		.loc 1 2330 0
 3748 0006 2368     		ldr	r3, [r4]
2326:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3749              		.loc 1 2326 0
 3750 0008 0022     		movs	r2, #0
 3751 000a 8DF80420 		strb	r2, [sp, #4]
 3752 000e 8DF80520 		strb	r2, [sp, #5]
 3753              	.LVL394:
 3754              		.loc 1 2330 0
 3755 0012 EBB1     		cbz	r3, .L439
2331:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2332:Src/bno055.c  **** 		} else {
2333:Src/bno055.c  **** 		/*condition check for page, chip id is
2334:Src/bno055.c  **** 		available in the page zero*/
2335:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3756              		.loc 1 2335 0
 3757 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3758 0016 0546     		mov	r5, r0
 3759 0018 79B9     		cbnz	r1, .L445
 3760              	.LVL395:
 3761              	.L437:
2336:Src/bno055.c  **** 			/* Write the page zero*/
2337:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2338:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2339:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2340:Src/bno055.c  **** 			/* Read the two byte value
2341:Src/bno055.c  **** 			of gravity x data*/
2342:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3762              		.loc 1 2342 0
 3763 001a 1C69     		ldr	r4, [r3, #16]
 3764 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3765 001e 01AA     		add	r2, sp, #4
 3766 0020 0223     		movs	r3, #2
 3767 0022 2E21     		movs	r1, #46
 3768 0024 A047     		blx	r4
 3769              	.LVL396:
2343:Src/bno055.c  **** 			(p_bno055->dev_addr,
2344:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_X_LSB_VALUEX_REG,
2345:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
2346:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
2347:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
2348:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_X_LSB_VALUEX);
2349:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
2350:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
2351:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_X_MSB_VALUEX);
2352:Src/bno055.c  **** 			*gravity_x_s16 = (s16)((((s32)
 3770              		.loc 1 2352 0
ARM GAS  /tmp/ccVWLGiI.s 			page 113


 3771 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3772 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3773 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3774 0032 2B80     		strh	r3, [r5]	@ movhi
 3775              	.LVL397:
 3776              	.L436:
2353:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
2354:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2355:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
2356:Src/bno055.c  **** 		} else {
2357:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2358:Src/bno055.c  **** 		}
2359:Src/bno055.c  **** 	}
2360:Src/bno055.c  **** 	return com_rslt;
2361:Src/bno055.c  **** }
 3777              		.loc 1 2361 0
 3778 0034 40B2     		sxtb	r0, r0
 3779 0036 03B0     		add	sp, sp, #12
 3780              	.LCFI149:
 3781              		.cfi_remember_state
 3782              		.cfi_def_cfa_offset 12
 3783              		@ sp needed
 3784 0038 30BD     		pop	{r4, r5, pc}
 3785              	.LVL398:
 3786              	.L445:
 3787              	.LCFI150:
 3788              		.cfi_restore_state
2337:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3789              		.loc 1 2337 0
 3790 003a 1046     		mov	r0, r2
 3791              	.LVL399:
 3792 003c FFF7FEFF 		bl	bno055_write_page_id
 3793              	.LVL400:
 3794 0040 2368     		ldr	r3, [r4]
2338:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3795              		.loc 1 2338 0
 3796 0042 0028     		cmp	r0, #0
 3797 0044 E9D0     		beq	.L437
 3798              	.LVL401:
2338:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3799              		.loc 1 2338 0 is_stmt 0 discriminator 1
 3800 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2357:Src/bno055.c  **** 		}
 3801              		.loc 1 2357 0 is_stmt 1 discriminator 1
 3802 0048 FF20     		movs	r0, #255
2338:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3803              		.loc 1 2338 0 discriminator 1
 3804 004a 002A     		cmp	r2, #0
 3805 004c F2D1     		bne	.L436
 3806 004e E4E7     		b	.L437
 3807              	.LVL402:
 3808              	.L439:
2331:Src/bno055.c  **** 		} else {
 3809              		.loc 1 2331 0
 3810 0050 8120     		movs	r0, #129
 3811              	.LVL403:
 3812 0052 EFE7     		b	.L436
ARM GAS  /tmp/ccVWLGiI.s 			page 114


 3813              	.L447:
 3814              		.align	2
 3815              	.L446:
 3816 0054 00000000 		.word	.LANCHOR0
 3817              		.cfi_endproc
 3818              	.LFE36:
 3820              		.section	.text.bno055_read_gravity_y,"ax",%progbits
 3821              		.align	2
 3822              		.global	bno055_read_gravity_y
 3823              		.thumb
 3824              		.thumb_func
 3826              	bno055_read_gravity_y:
 3827              	.LFB37:
2362:Src/bno055.c  **** /*!
2363:Src/bno055.c  ****  *	@brief This API reads gravity data y values
2364:Src/bno055.c  ****  *	from register 0x30 and 0x31 it is a two byte data
2365:Src/bno055.c  ****  *
2366:Src/bno055.c  ****  *	@param gravity_y_s16 : The raw y data
2367:Src/bno055.c  ****  *
2368:Src/bno055.c  ****  *	@return results of bus communication function
2369:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2370:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2371:Src/bno055.c  ****  *
2372:Src/bno055.c  ****  *
2373:Src/bno055.c  ****  */
2374:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gravity_y(
2375:Src/bno055.c  **** s16 *gravity_y_s16)
2376:Src/bno055.c  **** {
 3828              		.loc 1 2376 0
 3829              		.cfi_startproc
 3830              		@ args = 0, pretend = 0, frame = 8
 3831              		@ frame_needed = 0, uses_anonymous_args = 0
 3832              	.LVL404:
 3833 0000 30B5     		push	{r4, r5, lr}
 3834              	.LCFI151:
 3835              		.cfi_def_cfa_offset 12
 3836              		.cfi_offset 4, -12
 3837              		.cfi_offset 5, -8
 3838              		.cfi_offset 14, -4
2377:Src/bno055.c  **** 	/* Variable used to return value of
2378:Src/bno055.c  **** 	communication routine*/
2379:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2380:Src/bno055.c  **** 	/* Array holding the gravity y value
2381:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - y->LSB
2382:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - y->MSB
2383:Src/bno055.c  **** 	*/
2384:Src/bno055.c  **** 	u8 data_u8[BNO055_GRAVITY_DATA_SIZE] = {
2385:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2386:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2387:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2388:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3839              		.loc 1 2388 0
 3840 0002 144C     		ldr	r4, .L459
2376:Src/bno055.c  **** 	/* Variable used to return value of
 3841              		.loc 1 2376 0
 3842 0004 83B0     		sub	sp, sp, #12
 3843              	.LCFI152:
ARM GAS  /tmp/ccVWLGiI.s 			page 115


 3844              		.cfi_def_cfa_offset 24
 3845              		.loc 1 2388 0
 3846 0006 2368     		ldr	r3, [r4]
2384:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3847              		.loc 1 2384 0
 3848 0008 0022     		movs	r2, #0
 3849 000a 8DF80420 		strb	r2, [sp, #4]
 3850 000e 8DF80520 		strb	r2, [sp, #5]
 3851              	.LVL405:
 3852              		.loc 1 2388 0
 3853 0012 EBB1     		cbz	r3, .L452
2389:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2390:Src/bno055.c  **** 		} else {
2391:Src/bno055.c  **** 		/*condition check for page, chip id is
2392:Src/bno055.c  **** 		available in the page zero*/
2393:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3854              		.loc 1 2393 0
 3855 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3856 0016 0546     		mov	r5, r0
 3857 0018 79B9     		cbnz	r1, .L458
 3858              	.LVL406:
 3859              	.L450:
2394:Src/bno055.c  **** 			/* Write the page zero*/
2395:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2396:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2397:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2398:Src/bno055.c  **** 			/* Read the two byte value
2399:Src/bno055.c  **** 			of gravity y data*/
2400:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3860              		.loc 1 2400 0
 3861 001a 1C69     		ldr	r4, [r3, #16]
 3862 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3863 001e 01AA     		add	r2, sp, #4
 3864 0020 0223     		movs	r3, #2
 3865 0022 3021     		movs	r1, #48
 3866 0024 A047     		blx	r4
 3867              	.LVL407:
2401:Src/bno055.c  **** 			(p_bno055->dev_addr,
2402:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Y_LSB_VALUEY_REG,
2403:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
2404:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
2405:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
2406:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Y_LSB_VALUEY);
2407:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
2408:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
2409:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Y_MSB_VALUEY);
2410:Src/bno055.c  **** 			*gravity_y_s16 = (s16)((((s32)
 3868              		.loc 1 2410 0
 3869 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3870 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3871 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3872 0032 2B80     		strh	r3, [r5]	@ movhi
 3873              	.LVL408:
 3874              	.L449:
2411:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
2412:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2413:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
ARM GAS  /tmp/ccVWLGiI.s 			page 116


2414:Src/bno055.c  **** 		} else {
2415:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2416:Src/bno055.c  **** 		}
2417:Src/bno055.c  **** 	}
2418:Src/bno055.c  **** 	return com_rslt;
2419:Src/bno055.c  **** }
 3875              		.loc 1 2419 0
 3876 0034 40B2     		sxtb	r0, r0
 3877 0036 03B0     		add	sp, sp, #12
 3878              	.LCFI153:
 3879              		.cfi_remember_state
 3880              		.cfi_def_cfa_offset 12
 3881              		@ sp needed
 3882 0038 30BD     		pop	{r4, r5, pc}
 3883              	.LVL409:
 3884              	.L458:
 3885              	.LCFI154:
 3886              		.cfi_restore_state
2395:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3887              		.loc 1 2395 0
 3888 003a 1046     		mov	r0, r2
 3889              	.LVL410:
 3890 003c FFF7FEFF 		bl	bno055_write_page_id
 3891              	.LVL411:
 3892 0040 2368     		ldr	r3, [r4]
2396:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3893              		.loc 1 2396 0
 3894 0042 0028     		cmp	r0, #0
 3895 0044 E9D0     		beq	.L450
 3896              	.LVL412:
2396:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3897              		.loc 1 2396 0 is_stmt 0 discriminator 1
 3898 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2415:Src/bno055.c  **** 		}
 3899              		.loc 1 2415 0 is_stmt 1 discriminator 1
 3900 0048 FF20     		movs	r0, #255
2396:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3901              		.loc 1 2396 0 discriminator 1
 3902 004a 002A     		cmp	r2, #0
 3903 004c F2D1     		bne	.L449
 3904 004e E4E7     		b	.L450
 3905              	.LVL413:
 3906              	.L452:
2389:Src/bno055.c  **** 		} else {
 3907              		.loc 1 2389 0
 3908 0050 8120     		movs	r0, #129
 3909              	.LVL414:
 3910 0052 EFE7     		b	.L449
 3911              	.L460:
 3912              		.align	2
 3913              	.L459:
 3914 0054 00000000 		.word	.LANCHOR0
 3915              		.cfi_endproc
 3916              	.LFE37:
 3918              		.section	.text.bno055_read_gravity_z,"ax",%progbits
 3919              		.align	2
 3920              		.global	bno055_read_gravity_z
ARM GAS  /tmp/ccVWLGiI.s 			page 117


 3921              		.thumb
 3922              		.thumb_func
 3924              	bno055_read_gravity_z:
 3925              	.LFB38:
2420:Src/bno055.c  **** /*!
2421:Src/bno055.c  ****  *	@brief This API reads gravity data z values
2422:Src/bno055.c  ****  *	from register 0x32 and 0x33 it is a two byte data
2423:Src/bno055.c  ****  *
2424:Src/bno055.c  ****  *	@param gravity_z_s16 : The raw z data
2425:Src/bno055.c  ****  *
2426:Src/bno055.c  ****  *	@return results of bus communication function
2427:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2428:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2429:Src/bno055.c  ****  *
2430:Src/bno055.c  ****  *
2431:Src/bno055.c  ****  */
2432:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gravity_z(
2433:Src/bno055.c  **** s16 *gravity_z_s16)
2434:Src/bno055.c  **** {
 3926              		.loc 1 2434 0
 3927              		.cfi_startproc
 3928              		@ args = 0, pretend = 0, frame = 8
 3929              		@ frame_needed = 0, uses_anonymous_args = 0
 3930              	.LVL415:
 3931 0000 30B5     		push	{r4, r5, lr}
 3932              	.LCFI155:
 3933              		.cfi_def_cfa_offset 12
 3934              		.cfi_offset 4, -12
 3935              		.cfi_offset 5, -8
 3936              		.cfi_offset 14, -4
2435:Src/bno055.c  **** 	/* Variable used to return value of
2436:Src/bno055.c  **** 	communication routine*/
2437:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2438:Src/bno055.c  **** 	/* Array holding the gravity z value
2439:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_LSB] - z->LSB
2440:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_MSB] - z->MSB
2441:Src/bno055.c  **** 	*/
2442:Src/bno055.c  **** 	u8 data_u8[BNO055_GRAVITY_DATA_SIZE] = {
2443:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2444:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2445:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2446:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 3937              		.loc 1 2446 0
 3938 0002 144C     		ldr	r4, .L472
2434:Src/bno055.c  **** 	/* Variable used to return value of
 3939              		.loc 1 2434 0
 3940 0004 83B0     		sub	sp, sp, #12
 3941              	.LCFI156:
 3942              		.cfi_def_cfa_offset 24
 3943              		.loc 1 2446 0
 3944 0006 2368     		ldr	r3, [r4]
2442:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 3945              		.loc 1 2442 0
 3946 0008 0022     		movs	r2, #0
 3947 000a 8DF80420 		strb	r2, [sp, #4]
 3948 000e 8DF80520 		strb	r2, [sp, #5]
 3949              	.LVL416:
ARM GAS  /tmp/ccVWLGiI.s 			page 118


 3950              		.loc 1 2446 0
 3951 0012 EBB1     		cbz	r3, .L465
2447:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2448:Src/bno055.c  **** 		} else {
2449:Src/bno055.c  **** 		/*condition check for page, chip id is
2450:Src/bno055.c  **** 		available in the page zero*/
2451:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 3952              		.loc 1 2451 0
 3953 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 3954 0016 0546     		mov	r5, r0
 3955 0018 79B9     		cbnz	r1, .L471
 3956              	.LVL417:
 3957              	.L463:
2452:Src/bno055.c  **** 			/* Write the page zero*/
2453:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2454:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2455:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2456:Src/bno055.c  **** 			/* Read the two byte value
2457:Src/bno055.c  **** 			of gravity z data*/
2458:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 3958              		.loc 1 2458 0
 3959 001a 1C69     		ldr	r4, [r3, #16]
 3960 001c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 3961 001e 01AA     		add	r2, sp, #4
 3962 0020 0223     		movs	r3, #2
 3963 0022 3221     		movs	r1, #50
 3964 0024 A047     		blx	r4
 3965              	.LVL418:
2459:Src/bno055.c  **** 			(p_bno055->dev_addr,
2460:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Z_LSB_VALUEZ_REG,
2461:Src/bno055.c  **** 			data_u8, BNO055_LSB_MSB_READ_LENGTH);
2462:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_LSB] =
2463:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_LSB],
2464:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Z_LSB_VALUEZ);
2465:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_MSB] =
2466:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8[BNO055_SENSOR_DATA_MSB],
2467:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Z_MSB_VALUEZ);
2468:Src/bno055.c  **** 			*gravity_z_s16 = (s16)((((s32)
 3966              		.loc 1 2468 0
 3967 0026 9DF90520 		ldrsb	r2, [sp, #5]
 3968 002a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3969 002e 43EA0223 		orr	r3, r3, r2, lsl #8
 3970 0032 2B80     		strh	r3, [r5]	@ movhi
 3971              	.LVL419:
 3972              	.L462:
2469:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_MSB])) <<
2470:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2471:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_LSB]));
2472:Src/bno055.c  **** 		} else {
2473:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2474:Src/bno055.c  **** 		}
2475:Src/bno055.c  **** 	}
2476:Src/bno055.c  **** 	return com_rslt;
2477:Src/bno055.c  **** }
 3973              		.loc 1 2477 0
 3974 0034 40B2     		sxtb	r0, r0
 3975 0036 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 119


 3976              	.LCFI157:
 3977              		.cfi_remember_state
 3978              		.cfi_def_cfa_offset 12
 3979              		@ sp needed
 3980 0038 30BD     		pop	{r4, r5, pc}
 3981              	.LVL420:
 3982              	.L471:
 3983              	.LCFI158:
 3984              		.cfi_restore_state
2453:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 3985              		.loc 1 2453 0
 3986 003a 1046     		mov	r0, r2
 3987              	.LVL421:
 3988 003c FFF7FEFF 		bl	bno055_write_page_id
 3989              	.LVL422:
 3990 0040 2368     		ldr	r3, [r4]
2454:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3991              		.loc 1 2454 0
 3992 0042 0028     		cmp	r0, #0
 3993 0044 E9D0     		beq	.L463
 3994              	.LVL423:
2454:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3995              		.loc 1 2454 0 is_stmt 0 discriminator 1
 3996 0046 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2473:Src/bno055.c  **** 		}
 3997              		.loc 1 2473 0 is_stmt 1 discriminator 1
 3998 0048 FF20     		movs	r0, #255
2454:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 3999              		.loc 1 2454 0 discriminator 1
 4000 004a 002A     		cmp	r2, #0
 4001 004c F2D1     		bne	.L462
 4002 004e E4E7     		b	.L463
 4003              	.LVL424:
 4004              	.L465:
2447:Src/bno055.c  **** 		} else {
 4005              		.loc 1 2447 0
 4006 0050 8120     		movs	r0, #129
 4007              	.LVL425:
 4008 0052 EFE7     		b	.L462
 4009              	.L473:
 4010              		.align	2
 4011              	.L472:
 4012 0054 00000000 		.word	.LANCHOR0
 4013              		.cfi_endproc
 4014              	.LFE38:
 4016              		.section	.text.bno055_read_gravity_xyz,"ax",%progbits
 4017              		.align	2
 4018              		.global	bno055_read_gravity_xyz
 4019              		.thumb
 4020              		.thumb_func
 4022              	bno055_read_gravity_xyz:
 4023              	.LFB39:
2478:Src/bno055.c  **** /*!
2479:Src/bno055.c  ****   *	@brief This API reads gravity data xyz values
2480:Src/bno055.c  ****  *	from register 0x2E to 0x33 it is a six byte data
2481:Src/bno055.c  ****  *
2482:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 120


2483:Src/bno055.c  ****  *	@param gravity : The value of gravity xyz data's
2484:Src/bno055.c  ****  *
2485:Src/bno055.c  ****  *	Parameter |    result
2486:Src/bno055.c  ****  *  --------- | -----------------
2487:Src/bno055.c  ****  *	 x        | The gravity x data
2488:Src/bno055.c  ****  *	 y        | The gravity y data
2489:Src/bno055.c  ****  *	 z        | The gravity z data
2490:Src/bno055.c  ****  *
2491:Src/bno055.c  ****  *
2492:Src/bno055.c  ****  *	@return results of bus communication function
2493:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2494:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2495:Src/bno055.c  ****  *
2496:Src/bno055.c  ****  */
2497:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gravity_xyz(
2498:Src/bno055.c  **** struct bno055_gravity_t *gravity)
2499:Src/bno055.c  **** {
 4024              		.loc 1 2499 0
 4025              		.cfi_startproc
 4026              		@ args = 0, pretend = 0, frame = 8
 4027              		@ frame_needed = 0, uses_anonymous_args = 0
 4028              	.LVL426:
 4029 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4030              	.LCFI159:
 4031              		.cfi_def_cfa_offset 20
 4032              		.cfi_offset 4, -20
 4033              		.cfi_offset 5, -16
 4034              		.cfi_offset 6, -12
 4035              		.cfi_offset 7, -8
 4036              		.cfi_offset 14, -4
2500:Src/bno055.c  **** 	/* Variable used to return value of
2501:Src/bno055.c  **** 	communication routine*/
2502:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2503:Src/bno055.c  **** 	/* Array holding the gravity xyz value
2504:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] - x->LSB
2505:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] - x->MSB
2506:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] - y->MSB
2507:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] - y->MSB
2508:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] - z->MSB
2509:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] - z->MSB
2510:Src/bno055.c  **** 	*/
2511:Src/bno055.c  **** 	u8 data_u8[BNO055_GRAVITY_XYZ_DATA_SIZE] = {
2512:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
2513:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
2514:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2515:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2516:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2517:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 4037              		.loc 1 2517 0
 4038 0002 1F4D     		ldr	r5, .L485
2499:Src/bno055.c  **** 	/* Variable used to return value of
 4039              		.loc 1 2499 0
 4040 0004 83B0     		sub	sp, sp, #12
 4041              	.LCFI160:
 4042              		.cfi_def_cfa_offset 32
 4043              		.loc 1 2517 0
 4044 0006 2A68     		ldr	r2, [r5]
ARM GAS  /tmp/ccVWLGiI.s 			page 121


2511:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 4045              		.loc 1 2511 0
 4046 0008 0023     		movs	r3, #0
 4047 000a 8DF80030 		strb	r3, [sp]
 4048 000e 8DF80130 		strb	r3, [sp, #1]
 4049 0012 8DF80230 		strb	r3, [sp, #2]
 4050 0016 8DF80330 		strb	r3, [sp, #3]
 4051 001a 8DF80430 		strb	r3, [sp, #4]
 4052 001e 8DF80530 		strb	r3, [sp, #5]
 4053              	.LVL427:
 4054              		.loc 1 2517 0
 4055 0022 5AB3     		cbz	r2, .L478
2518:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2519:Src/bno055.c  **** 		} else {
2520:Src/bno055.c  **** 		/*condition check for page, chip id is
2521:Src/bno055.c  **** 		available in the page zero*/
2522:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 4056              		.loc 1 2522 0
 4057 0024 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 4058 0026 0446     		mov	r4, r0
 4059 0028 E9B9     		cbnz	r1, .L484
 4060              	.LVL428:
 4061              	.L476:
2523:Src/bno055.c  **** 			/* Write the page zero*/
2524:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2525:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2526:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2527:Src/bno055.c  **** 			/* Read the six byte value
2528:Src/bno055.c  **** 			of gravity xyz data*/
2529:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 4062              		.loc 1 2529 0
 4063 002a 1569     		ldr	r5, [r2, #16]
 4064 002c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 4065 002e 2E21     		movs	r1, #46
 4066 0030 6A46     		mov	r2, sp
 4067 0032 0623     		movs	r3, #6
 4068 0034 A847     		blx	r5
 4069              	.LVL429:
2530:Src/bno055.c  **** 			(p_bno055->dev_addr,
2531:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_X_LSB_VALUEX_REG,
2532:Src/bno055.c  **** 			data_u8, BNO055_GRAVITY_XYZ_DATA_SIZE);
2533:Src/bno055.c  **** 			/* Data x*/
2534:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB] =
2535:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2536:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB],
2537:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_X_LSB_VALUEX);
2538:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB] =
2539:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2540:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB],
2541:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_X_MSB_VALUEX);
2542:Src/bno055.c  **** 			gravity->x = (s16)(((s32)
 4070              		.loc 1 2542 0
 4071 0036 9DF90170 		ldrsb	r7, [sp, #1]
 4072 003a 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
2543:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB]) <<
2544:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) |
2545:Src/bno055.c  **** 			(data_u8[BNO055_SENSOR_DATA_XYZ_X_LSB]));
ARM GAS  /tmp/ccVWLGiI.s 			page 122


2546:Src/bno055.c  **** 			/* Data y*/
2547:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB] =
2548:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2549:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB],
2550:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Y_LSB_VALUEY);
2551:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB] =
2552:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2553:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB],
2554:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Y_MSB_VALUEY);
2555:Src/bno055.c  **** 			gravity->y = (s16)((((s32)
 4073              		.loc 1 2555 0
 4074 003e 9DF90360 		ldrsb	r6, [sp, #3]
 4075 0042 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
2556:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
2557:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS) | (
2558:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Y_LSB]));
2559:Src/bno055.c  **** 			/* Data z*/
2560:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB] =
2561:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2562:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB],
2563:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Z_LSB_VALUEZ);
2564:Src/bno055.c  **** 			data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB] =
2565:Src/bno055.c  **** 			BNO055_GET_BITSLICE(
2566:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB],
2567:Src/bno055.c  **** 			BNO055_GRAVITY_DATA_Z_MSB_VALUEZ);
2568:Src/bno055.c  **** 			gravity->z = (s16)((((s32)
 4076              		.loc 1 2568 0
 4077 0046 9DF90550 		ldrsb	r5, [sp, #5]
 4078 004a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
2542:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB]) <<
 4079              		.loc 1 2542 0
 4080 004e 41EA0721 		orr	r1, r1, r7, lsl #8
2555:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 4081              		.loc 1 2555 0
 4082 0052 42EA0622 		orr	r2, r2, r6, lsl #8
 4083              		.loc 1 2568 0
 4084 0056 43EA0523 		orr	r3, r3, r5, lsl #8
2542:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_X_MSB]) <<
 4085              		.loc 1 2542 0
 4086 005a 2180     		strh	r1, [r4]	@ movhi
2555:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Y_MSB])) <<
 4087              		.loc 1 2555 0
 4088 005c 6280     		strh	r2, [r4, #2]	@ movhi
 4089              		.loc 1 2568 0
 4090 005e A380     		strh	r3, [r4, #4]	@ movhi
 4091              	.LVL430:
 4092              	.L475:
2569:Src/bno055.c  **** 			((s8)data_u8[BNO055_SENSOR_DATA_XYZ_Z_MSB])) <<
2570:Src/bno055.c  **** 			BNO055_SHIFT_EIGHT_BITS)
2571:Src/bno055.c  **** 			| (data_u8[BNO055_SENSOR_DATA_XYZ_Z_LSB]));
2572:Src/bno055.c  **** 		} else {
2573:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2574:Src/bno055.c  **** 		}
2575:Src/bno055.c  **** 	}
2576:Src/bno055.c  **** 	return com_rslt;
2577:Src/bno055.c  **** }
 4093              		.loc 1 2577 0
ARM GAS  /tmp/ccVWLGiI.s 			page 123


 4094 0060 40B2     		sxtb	r0, r0
 4095 0062 03B0     		add	sp, sp, #12
 4096              	.LCFI161:
 4097              		.cfi_remember_state
 4098              		.cfi_def_cfa_offset 20
 4099              		@ sp needed
 4100 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 4101              	.LVL431:
 4102              	.L484:
 4103              	.LCFI162:
 4104              		.cfi_restore_state
2524:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 4105              		.loc 1 2524 0
 4106 0066 1846     		mov	r0, r3
 4107              	.LVL432:
 4108 0068 FFF7FEFF 		bl	bno055_write_page_id
 4109              	.LVL433:
 4110 006c 2A68     		ldr	r2, [r5]
2525:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 4111              		.loc 1 2525 0
 4112 006e 0028     		cmp	r0, #0
 4113 0070 DBD0     		beq	.L476
 4114              	.LVL434:
2525:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 4115              		.loc 1 2525 0 is_stmt 0 discriminator 1
 4116 0072 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
2573:Src/bno055.c  **** 		}
 4117              		.loc 1 2573 0 is_stmt 1 discriminator 1
 4118 0074 FF20     		movs	r0, #255
2525:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 4119              		.loc 1 2525 0 discriminator 1
 4120 0076 002B     		cmp	r3, #0
 4121 0078 F2D1     		bne	.L475
 4122 007a D6E7     		b	.L476
 4123              	.LVL435:
 4124              	.L478:
2518:Src/bno055.c  **** 		} else {
 4125              		.loc 1 2518 0
 4126 007c 8120     		movs	r0, #129
 4127              	.LVL436:
 4128 007e EFE7     		b	.L475
 4129              	.L486:
 4130              		.align	2
 4131              	.L485:
 4132 0080 00000000 		.word	.LANCHOR0
 4133              		.cfi_endproc
 4134              	.LFE39:
 4136              		.section	.text.bno055_read_temp_data,"ax",%progbits
 4137              		.align	2
 4138              		.global	bno055_read_temp_data
 4139              		.thumb
 4140              		.thumb_func
 4142              	bno055_read_temp_data:
 4143              	.LFB40:
2578:Src/bno055.c  **** /*!
2579:Src/bno055.c  ****  *	@brief This API reads temperature values
2580:Src/bno055.c  ****  *	from register 0x33 it is a byte data
ARM GAS  /tmp/ccVWLGiI.s 			page 124


2581:Src/bno055.c  ****  *
2582:Src/bno055.c  ****  *	@param temp_s8 : The raw temperature data
2583:Src/bno055.c  ****  *
2584:Src/bno055.c  ****  *	@return results of bus communication function
2585:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2586:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2587:Src/bno055.c  ****  *
2588:Src/bno055.c  ****  *
2589:Src/bno055.c  ****  */
2590:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_temp_data(s8 *temp_s8)
2591:Src/bno055.c  **** {
 4144              		.loc 1 2591 0
 4145              		.cfi_startproc
 4146              		@ args = 0, pretend = 0, frame = 8
 4147              		@ frame_needed = 0, uses_anonymous_args = 0
 4148              	.LVL437:
 4149 0000 30B5     		push	{r4, r5, lr}
 4150              	.LCFI163:
 4151              		.cfi_def_cfa_offset 12
 4152              		.cfi_offset 4, -12
 4153              		.cfi_offset 5, -8
 4154              		.cfi_offset 14, -4
2592:Src/bno055.c  **** 	/* Variable used to return value of
2593:Src/bno055.c  **** 	communication routine*/
2594:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2595:Src/bno055.c  **** 	u8 data_u8 = BNO055_INIT_VALUE;
2596:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
2597:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
2598:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 4155              		.loc 1 2598 0
 4156 0002 124C     		ldr	r4, .L498
2591:Src/bno055.c  **** 	/* Variable used to return value of
 4157              		.loc 1 2591 0
 4158 0004 83B0     		sub	sp, sp, #12
 4159              	.LCFI164:
 4160              		.cfi_def_cfa_offset 24
 4161              		.loc 1 2598 0
 4162 0006 2368     		ldr	r3, [r4]
2595:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 4163              		.loc 1 2595 0
 4164 0008 0022     		movs	r2, #0
 4165 000a 8DF80720 		strb	r2, [sp, #7]
 4166              	.LVL438:
 4167              		.loc 1 2598 0
 4168 000e D3B1     		cbz	r3, .L491
2599:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
2600:Src/bno055.c  **** 		} else {
2601:Src/bno055.c  **** 		/*condition check for page, chip id is
2602:Src/bno055.c  **** 		available in the page zero*/
2603:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 4169              		.loc 1 2603 0
 4170 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 4171 0012 0546     		mov	r5, r0
 4172 0014 61B9     		cbnz	r1, .L497
 4173              	.LVL439:
 4174              	.L489:
2604:Src/bno055.c  **** 			/* Write the page zero*/
ARM GAS  /tmp/ccVWLGiI.s 			page 125


2605:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
2606:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
2607:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
2608:Src/bno055.c  **** 			/* Read the raw temperature data */
2609:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 4175              		.loc 1 2609 0
 4176 0016 1C69     		ldr	r4, [r3, #16]
 4177 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 4178 001a 3421     		movs	r1, #52
 4179 001c 0123     		movs	r3, #1
 4180 001e 0DF10702 		add	r2, sp, #7
 4181 0022 A047     		blx	r4
 4182              	.LVL440:
2610:Src/bno055.c  **** 			(p_bno055->dev_addr,
2611:Src/bno055.c  **** 			BNO055_TEMP_REG, &data_u8,
2612:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
2613:Src/bno055.c  **** 			*temp_s8 = data_u8;
 4183              		.loc 1 2613 0
 4184 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4185 0028 2B70     		strb	r3, [r5]
 4186              	.LVL441:
 4187              	.L488:
2614:Src/bno055.c  **** 		} else {
2615:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2616:Src/bno055.c  **** 		}
2617:Src/bno055.c  **** 	}
2618:Src/bno055.c  **** 	return com_rslt;
2619:Src/bno055.c  **** }
 4188              		.loc 1 2619 0
 4189 002a 40B2     		sxtb	r0, r0
 4190 002c 03B0     		add	sp, sp, #12
 4191              	.LCFI165:
 4192              		.cfi_remember_state
 4193              		.cfi_def_cfa_offset 12
 4194              		@ sp needed
 4195 002e 30BD     		pop	{r4, r5, pc}
 4196              	.LVL442:
 4197              	.L497:
 4198              	.LCFI166:
 4199              		.cfi_restore_state
2605:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 4200              		.loc 1 2605 0
 4201 0030 1046     		mov	r0, r2
 4202              	.LVL443:
 4203 0032 FFF7FEFF 		bl	bno055_write_page_id
 4204              	.LVL444:
 4205 0036 2368     		ldr	r3, [r4]
2606:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 4206              		.loc 1 2606 0
 4207 0038 0028     		cmp	r0, #0
 4208 003a ECD0     		beq	.L489
 4209              	.LVL445:
2606:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 4210              		.loc 1 2606 0 is_stmt 0 discriminator 1
 4211 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
2615:Src/bno055.c  **** 		}
 4212              		.loc 1 2615 0 is_stmt 1 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 126


 4213 003e FF20     		movs	r0, #255
2606:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 4214              		.loc 1 2606 0 discriminator 1
 4215 0040 002A     		cmp	r2, #0
 4216 0042 F2D1     		bne	.L488
 4217 0044 E7E7     		b	.L489
 4218              	.LVL446:
 4219              	.L491:
2599:Src/bno055.c  **** 		} else {
 4220              		.loc 1 2599 0
 4221 0046 8120     		movs	r0, #129
 4222              	.LVL447:
 4223 0048 EFE7     		b	.L488
 4224              	.L499:
 4225 004a 00BF     		.align	2
 4226              	.L498:
 4227 004c 00000000 		.word	.LANCHOR0
 4228              		.cfi_endproc
 4229              	.LFE40:
 4231              		.global	__aeabi_i2d
 4232              		.global	__aeabi_dmul
 4233              		.global	__aeabi_d2f
 4234              		.section	.text.bno055_convert_float_mag_x_uT,"ax",%progbits
 4235              		.align	2
 4236              		.global	bno055_convert_float_mag_x_uT
 4237              		.thumb
 4238              		.thumb_func
 4240              	bno055_convert_float_mag_x_uT:
 4241              	.LFB49:
2620:Src/bno055.c  **** #ifdef	BNO055_FLOAT_ENABLE
2621:Src/bno055.c  **** /*!
2622:Src/bno055.c  ****  *	@brief This API is used to convert the accel x raw data
2623:Src/bno055.c  ****  *	to meterpersecseq output as float
2624:Src/bno055.c  ****  *
2625:Src/bno055.c  ****  *	@param accel_x_f : The accel x meterpersecseq data
2626:Src/bno055.c  ****  *
2627:Src/bno055.c  ****  *
2628:Src/bno055.c  ****  *
2629:Src/bno055.c  ****  *	@return results of bus communication function
2630:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2631:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2632:Src/bno055.c  ****  *
2633:Src/bno055.c  ****  *
2634:Src/bno055.c  ****  */
2635:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_x_msq(
2636:Src/bno055.c  **** float *accel_x_f)
2637:Src/bno055.c  **** {
2638:Src/bno055.c  **** 	/* Variable used to return value of
2639:Src/bno055.c  **** 	communication routine*/
2640:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2641:Src/bno055.c  **** 	s16 reg_accel_x_s16 = BNO055_INIT_VALUE;
2642:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
2643:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2644:Src/bno055.c  **** 	/* Read the current accel unit and set the
2645:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
2646:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2647:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
ARM GAS  /tmp/ccVWLGiI.s 			page 127


2648:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
2649:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2650:Src/bno055.c  **** 			/* Read the accel raw x data*/
2651:Src/bno055.c  **** 			com_rslt += bno055_read_accel_x(&reg_accel_x_s16);
2652:Src/bno055.c  **** 			p_bno055->delay_msec(BNO055_GEN_READ_WRITE_LENGTH);
2653:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2654:Src/bno055.c  **** 				/* Convert the raw accel x to m/s2*/
2655:Src/bno055.c  **** 				data_f =
2656:Src/bno055.c  **** 				(float)(reg_accel_x_s16/BNO055_ACCEL_DIV_MSQ);
2657:Src/bno055.c  **** 				*accel_x_f = data_f;
2658:Src/bno055.c  **** 			} else {
2659:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2660:Src/bno055.c  **** 			}
2661:Src/bno055.c  **** 		} else {
2662:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2663:Src/bno055.c  **** 		}
2664:Src/bno055.c  **** 	return com_rslt;
2665:Src/bno055.c  **** }
2666:Src/bno055.c  **** /*!
2667:Src/bno055.c  ****  *	@brief This API is used to convert the accel x raw data
2668:Src/bno055.c  ****  *	to millig output as float
2669:Src/bno055.c  ****  *
2670:Src/bno055.c  ****  *	@param accel_x_f : The accel x millig data
2671:Src/bno055.c  ****  *
2672:Src/bno055.c  ****  *
2673:Src/bno055.c  ****  *
2674:Src/bno055.c  ****  *	@return results of bus communication function
2675:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2676:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2677:Src/bno055.c  ****  *
2678:Src/bno055.c  ****  *
2679:Src/bno055.c  ****  *
2680:Src/bno055.c  ****  */
2681:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_x_mg(
2682:Src/bno055.c  **** float *accel_x_f)
2683:Src/bno055.c  **** {
2684:Src/bno055.c  **** 	/* Variable used to return value of
2685:Src/bno055.c  **** 	communication routine*/
2686:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2687:Src/bno055.c  **** 	s16 reg_accel_x_s16 = BNO055_INIT_VALUE;
2688:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
2689:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2690:Src/bno055.c  **** 	/* Read the current accel unit and set the
2691:Src/bno055.c  **** 	unit as mg if the unit is in m/s2*/
2692:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2693:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
2694:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
2695:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2696:Src/bno055.c  **** 			/* Read the accel raw x data*/
2697:Src/bno055.c  **** 			com_rslt += bno055_read_accel_x(&reg_accel_x_s16);
2698:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2699:Src/bno055.c  **** 				/* Convert the raw accel x to m/s2*/
2700:Src/bno055.c  **** 				data_f =
2701:Src/bno055.c  **** 				(float)(reg_accel_x_s16/BNO055_ACCEL_DIV_MG);
2702:Src/bno055.c  **** 				*accel_x_f = data_f;
2703:Src/bno055.c  **** 			} else {
2704:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 128


2705:Src/bno055.c  **** 			}
2706:Src/bno055.c  **** 		} else {
2707:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2708:Src/bno055.c  **** 		}
2709:Src/bno055.c  **** 	return com_rslt;
2710:Src/bno055.c  **** }
2711:Src/bno055.c  **** /*!
2712:Src/bno055.c  ****  *	@brief This API is used to convert the accel x raw data
2713:Src/bno055.c  ****  *	to meterpersecseq output as float
2714:Src/bno055.c  ****  *
2715:Src/bno055.c  ****  *	@param accel_y_f : The accel y meterpersecseq data
2716:Src/bno055.c  ****  *
2717:Src/bno055.c  ****  *
2718:Src/bno055.c  ****  *
2719:Src/bno055.c  ****  *	@return results of bus communication function
2720:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2721:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2722:Src/bno055.c  ****  *
2723:Src/bno055.c  ****  *
2724:Src/bno055.c  ****  */
2725:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_y_msq(
2726:Src/bno055.c  **** float *accel_y_f)
2727:Src/bno055.c  **** {
2728:Src/bno055.c  **** 	/* Variable used to return value of
2729:Src/bno055.c  **** 	communication routine*/
2730:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2731:Src/bno055.c  **** 	s16 reg_accel_y_s16 = BNO055_INIT_VALUE;
2732:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
2733:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2734:Src/bno055.c  **** 	/* Read the current accel unit and set the
2735:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
2736:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2737:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
2738:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
2739:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2740:Src/bno055.c  **** 			com_rslt += bno055_read_accel_y(&reg_accel_y_s16);
2741:Src/bno055.c  **** 			p_bno055->delay_msec(BNO055_GEN_READ_WRITE_LENGTH);
2742:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2743:Src/bno055.c  **** 				/* Convert the raw accel y to m/s2*/
2744:Src/bno055.c  **** 				data_f =
2745:Src/bno055.c  **** 				(float)(reg_accel_y_s16/BNO055_ACCEL_DIV_MSQ);
2746:Src/bno055.c  **** 				*accel_y_f = data_f;
2747:Src/bno055.c  **** 			} else {
2748:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2749:Src/bno055.c  **** 			}
2750:Src/bno055.c  **** 		} else {
2751:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2752:Src/bno055.c  **** 		}
2753:Src/bno055.c  **** 	return com_rslt;
2754:Src/bno055.c  **** }
2755:Src/bno055.c  **** /*!
2756:Src/bno055.c  ****  *	@brief This API is used to convert the accel y raw data
2757:Src/bno055.c  ****  *	to millig output as float
2758:Src/bno055.c  ****  *
2759:Src/bno055.c  ****  *	@param accel_y_f : The accel y millig data
2760:Src/bno055.c  ****  *
2761:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 129


2762:Src/bno055.c  ****  *
2763:Src/bno055.c  ****  *	@return results of bus communication function
2764:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2765:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2766:Src/bno055.c  ****  *
2767:Src/bno055.c  ****  */
2768:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_y_mg(
2769:Src/bno055.c  **** float *accel_y_f)
2770:Src/bno055.c  **** {
2771:Src/bno055.c  **** 	/* Variable used to return value of
2772:Src/bno055.c  **** 	communication routine*/
2773:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2774:Src/bno055.c  **** 	s16 reg_accel_y_s16 = BNO055_INIT_VALUE;
2775:Src/bno055.c  **** 	float data = BNO055_INIT_VALUE;
2776:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2777:Src/bno055.c  **** 	/* Read the current accel unit and set the
2778:Src/bno055.c  **** 	unit as mg if the unit is in m/s2*/
2779:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2780:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
2781:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
2782:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2783:Src/bno055.c  **** 			/* Read the accel raw z data*/
2784:Src/bno055.c  **** 			com_rslt += bno055_read_accel_y(&reg_accel_y_s16);
2785:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2786:Src/bno055.c  **** 				/* Convert the raw accel z to mg*/
2787:Src/bno055.c  **** 				data = (float)(
2788:Src/bno055.c  **** 				reg_accel_y_s16/BNO055_ACCEL_DIV_MG);
2789:Src/bno055.c  **** 				*accel_y_f = data;
2790:Src/bno055.c  **** 			} else {
2791:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2792:Src/bno055.c  **** 			}
2793:Src/bno055.c  **** 		} else {
2794:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2795:Src/bno055.c  **** 		}
2796:Src/bno055.c  **** 	return com_rslt;
2797:Src/bno055.c  **** }
2798:Src/bno055.c  **** /*!
2799:Src/bno055.c  ****  *	@brief This API is used to convert the accel z raw data
2800:Src/bno055.c  ****  *	to meterpersecseq output as float
2801:Src/bno055.c  ****  *
2802:Src/bno055.c  ****  *	@param accel_z_f : The accel z meterpersecseq data
2803:Src/bno055.c  ****  *
2804:Src/bno055.c  ****  *
2805:Src/bno055.c  ****  *
2806:Src/bno055.c  ****  *	@return results of bus communication function
2807:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2808:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2809:Src/bno055.c  ****  *
2810:Src/bno055.c  ****  *
2811:Src/bno055.c  ****  */
2812:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_z_msq(
2813:Src/bno055.c  **** float *accel_z_f)
2814:Src/bno055.c  **** {
2815:Src/bno055.c  **** 	/* Variable used to return value of
2816:Src/bno055.c  **** 	communication routine*/
2817:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2818:Src/bno055.c  **** 	s16 reg_accel_z_s16 = BNO055_INIT_VALUE;
ARM GAS  /tmp/ccVWLGiI.s 			page 130


2819:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
2820:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2821:Src/bno055.c  **** 	/* Read the current accel unit and set the
2822:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
2823:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2824:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
2825:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
2826:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2827:Src/bno055.c  **** 			/* Read the accel raw z data*/
2828:Src/bno055.c  **** 			com_rslt += bno055_read_accel_z(&reg_accel_z_s16);
2829:Src/bno055.c  **** 			p_bno055->delay_msec(BNO055_GEN_READ_WRITE_LENGTH);
2830:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2831:Src/bno055.c  **** 				/* Convert the raw accel z to m/s2*/
2832:Src/bno055.c  **** 				data_f =
2833:Src/bno055.c  **** 				(float)(reg_accel_z_s16/BNO055_ACCEL_DIV_MSQ);
2834:Src/bno055.c  **** 				*accel_z_f = data_f;
2835:Src/bno055.c  **** 			} else {
2836:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2837:Src/bno055.c  **** 			}
2838:Src/bno055.c  **** 		} else {
2839:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2840:Src/bno055.c  **** 		}
2841:Src/bno055.c  **** 	return com_rslt;
2842:Src/bno055.c  **** }
2843:Src/bno055.c  **** /*!
2844:Src/bno055.c  ****  *	@brief This API is used to convert the accel z raw data
2845:Src/bno055.c  ****  *	to millig output as float
2846:Src/bno055.c  ****  *
2847:Src/bno055.c  ****  *	@param accel_z_f : The accel z millig data
2848:Src/bno055.c  ****  *
2849:Src/bno055.c  ****  *
2850:Src/bno055.c  ****  *
2851:Src/bno055.c  ****  *	@return results of bus communication function
2852:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2853:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2854:Src/bno055.c  ****  *
2855:Src/bno055.c  ****  *
2856:Src/bno055.c  ****  */
2857:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_z_mg(
2858:Src/bno055.c  **** float *accel_z_f)
2859:Src/bno055.c  **** {
2860:Src/bno055.c  **** 	/* Variable used to return value of
2861:Src/bno055.c  **** 	communication routine*/
2862:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2863:Src/bno055.c  **** 	s16 reg_accel_z_s16 = BNO055_INIT_VALUE;
2864:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
2865:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2866:Src/bno055.c  **** 	/* Read the current accel unit and set the
2867:Src/bno055.c  **** 	unit as mg if the unit is in m/s2 */
2868:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2869:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
2870:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
2871:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2872:Src/bno055.c  **** 			/* Read the accel raw z data*/
2873:Src/bno055.c  **** 			com_rslt += bno055_read_accel_z(&reg_accel_z_s16);
2874:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2875:Src/bno055.c  **** 				/* Convert the raw accel x to mg*/
ARM GAS  /tmp/ccVWLGiI.s 			page 131


2876:Src/bno055.c  **** 				data_f =
2877:Src/bno055.c  **** 				(float)(reg_accel_z_s16/BNO055_ACCEL_DIV_MG);
2878:Src/bno055.c  **** 				*accel_z_f = data_f;
2879:Src/bno055.c  **** 			} else {
2880:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2881:Src/bno055.c  **** 			}
2882:Src/bno055.c  **** 		} else {
2883:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2884:Src/bno055.c  **** 		}
2885:Src/bno055.c  **** 	return com_rslt;
2886:Src/bno055.c  **** }
2887:Src/bno055.c  **** /*!
2888:Src/bno055.c  ****  *	@brief This API is used to convert the accel xyz raw data
2889:Src/bno055.c  ****  *	to meterpersecseq output as float
2890:Src/bno055.c  ****  *
2891:Src/bno055.c  ****  *	@param accel_xyz : The meterpersecseq data of accel xyz
2892:Src/bno055.c  ****  *
2893:Src/bno055.c  ****  *	Parameter |    result
2894:Src/bno055.c  ****  *  --------- | -----------------
2895:Src/bno055.c  ****  *	 x        | meterpersecseq data of accel
2896:Src/bno055.c  ****  *	 y        | meterpersecseq data of accel
2897:Src/bno055.c  ****  *	 z        | meterpersecseq data of accel
2898:Src/bno055.c  ****  *
2899:Src/bno055.c  ****  *	@return results of bus communication function
2900:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2901:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2902:Src/bno055.c  ****  *
2903:Src/bno055.c  ****  *
2904:Src/bno055.c  ****  */
2905:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_xyz_msq(
2906:Src/bno055.c  **** struct bno055_accel_float_t *accel_xyz)
2907:Src/bno055.c  **** {
2908:Src/bno055.c  **** 	/* Variable used to return value of
2909:Src/bno055.c  **** 	communication routine*/
2910:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2911:Src/bno055.c  **** 	struct bno055_accel_t reg_accel_xyz = {
2912:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2913:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2914:Src/bno055.c  **** 	/* Read the current accel unit and set the
2915:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
2916:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2917:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
2918:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
2919:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2920:Src/bno055.c  **** 			/* Read the accel raw xyz data*/
2921:Src/bno055.c  **** 			com_rslt += bno055_read_accel_xyz(&reg_accel_xyz);
2922:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2923:Src/bno055.c  **** 				/* Convert the accel raw xyz to meterpersecseq*/
2924:Src/bno055.c  **** 				accel_xyz->x =
2925:Src/bno055.c  **** 				(float)(reg_accel_xyz.x/BNO055_ACCEL_DIV_MSQ);
2926:Src/bno055.c  **** 				accel_xyz->y =
2927:Src/bno055.c  **** 				(float)(reg_accel_xyz.y/BNO055_ACCEL_DIV_MSQ);
2928:Src/bno055.c  **** 				accel_xyz->z =
2929:Src/bno055.c  **** 				(float)(reg_accel_xyz.z/BNO055_ACCEL_DIV_MSQ);
2930:Src/bno055.c  **** 			} else {
2931:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2932:Src/bno055.c  **** 			}
ARM GAS  /tmp/ccVWLGiI.s 			page 132


2933:Src/bno055.c  **** 		} else {
2934:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2935:Src/bno055.c  **** 		}
2936:Src/bno055.c  **** 	return com_rslt;
2937:Src/bno055.c  **** }
2938:Src/bno055.c  **** /*!
2939:Src/bno055.c  ****  *	@brief This API is used to convert the accel xyz raw data
2940:Src/bno055.c  ****  *	to millig output as float
2941:Src/bno055.c  ****  *
2942:Src/bno055.c  ****  *	@param accel_xyz : The millig data of accel xyz
2943:Src/bno055.c  ****  *
2944:Src/bno055.c  ****  *	Parameter |    result
2945:Src/bno055.c  ****  *  --------- | -----------------
2946:Src/bno055.c  ****  *	 x        | millig data of accel
2947:Src/bno055.c  ****  *	 y        | millig data of accel
2948:Src/bno055.c  ****  *	 z        | millig data of accel
2949:Src/bno055.c  ****  *
2950:Src/bno055.c  ****  *
2951:Src/bno055.c  ****  *	@return results of bus communication function
2952:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
2953:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
2954:Src/bno055.c  ****  *
2955:Src/bno055.c  ****  *
2956:Src/bno055.c  ****  */
2957:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_accel_xyz_mg(
2958:Src/bno055.c  **** struct bno055_accel_float_t *accel_xyz)
2959:Src/bno055.c  **** {
2960:Src/bno055.c  **** 	/* Variable used to return value of
2961:Src/bno055.c  **** 	communication routine*/
2962:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
2963:Src/bno055.c  **** 	struct bno055_accel_t reg_accel_xyz = {
2964:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
2965:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
2966:Src/bno055.c  **** 	/* Read the current accel unit and set the
2967:Src/bno055.c  **** 	unit as mg if the unit is in m/s2*/
2968:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
2969:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
2970:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
2971:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
2972:Src/bno055.c  **** 			/* Read the accel raw y data*/
2973:Src/bno055.c  **** 			com_rslt += bno055_read_accel_xyz(&reg_accel_xyz);
2974:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
2975:Src/bno055.c  **** 				/*Convert the accel raw xyz to millig */
2976:Src/bno055.c  **** 				accel_xyz->x =
2977:Src/bno055.c  **** 				(float)(reg_accel_xyz.x/BNO055_ACCEL_DIV_MG);
2978:Src/bno055.c  **** 				accel_xyz->y =
2979:Src/bno055.c  **** 				(float)(reg_accel_xyz.y/BNO055_ACCEL_DIV_MG);
2980:Src/bno055.c  **** 				accel_xyz->z =
2981:Src/bno055.c  **** 				(float)(reg_accel_xyz.z/BNO055_ACCEL_DIV_MG);
2982:Src/bno055.c  **** 			} else {
2983:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
2984:Src/bno055.c  **** 			}
2985:Src/bno055.c  **** 		} else {
2986:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
2987:Src/bno055.c  **** 		}
2988:Src/bno055.c  **** 	return com_rslt;
2989:Src/bno055.c  **** }
ARM GAS  /tmp/ccVWLGiI.s 			page 133


2990:Src/bno055.c  **** /*!
2991:Src/bno055.c  ****  *	@brief This API is used to convert the mag x raw data
2992:Src/bno055.c  ****  *	to microTesla output as float
2993:Src/bno055.c  ****  *
2994:Src/bno055.c  ****  *	@param mag_x_f : The mag x microTesla data
2995:Src/bno055.c  ****  *
2996:Src/bno055.c  ****  *
2997:Src/bno055.c  ****  *
2998:Src/bno055.c  ****  *	@return results of bus communication function
2999:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3000:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3001:Src/bno055.c  ****  *
3002:Src/bno055.c  ****  *
3003:Src/bno055.c  ****  */
3004:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_mag_x_uT(
3005:Src/bno055.c  **** float *mag_x_f)
3006:Src/bno055.c  **** {
 4242              		.loc 1 3006 0
 4243              		.cfi_startproc
 4244              		@ args = 0, pretend = 0, frame = 8
 4245              		@ frame_needed = 0, uses_anonymous_args = 0
 4246              	.LVL448:
 4247 0000 30B5     		push	{r4, r5, lr}
 4248              	.LCFI167:
 4249              		.cfi_def_cfa_offset 12
 4250              		.cfi_offset 4, -12
 4251              		.cfi_offset 5, -8
 4252              		.cfi_offset 14, -4
 4253 0002 83B0     		sub	sp, sp, #12
 4254              	.LCFI168:
 4255              		.cfi_def_cfa_offset 24
3007:Src/bno055.c  **** 	/* Variable used to return value of
3008:Src/bno055.c  **** 	communication routine*/
3009:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3010:Src/bno055.c  **** 	s16 reg_mag_x_s16 = BNO055_INIT_VALUE;
 4256              		.loc 1 3010 0
 4257 0004 02AB     		add	r3, sp, #8
 4258 0006 0022     		movs	r2, #0
 4259 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4260              	.LVL449:
3006:Src/bno055.c  **** 	/* Variable used to return value of
 4261              		.loc 1 3006 0
 4262 000c 0546     		mov	r5, r0
3011:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3012:Src/bno055.c  **** 	/* Read raw mag x data */
3013:Src/bno055.c  **** 	com_rslt = bno055_read_mag_x(&reg_mag_x_s16);
 4263              		.loc 1 3013 0
 4264 000e 1846     		mov	r0, r3
 4265              	.LVL450:
 4266 0010 FFF7FEFF 		bl	bno055_read_mag_x
 4267              	.LVL451:
3014:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4268              		.loc 1 3014 0
 4269 0014 0446     		mov	r4, r0
 4270 0016 68B9     		cbnz	r0, .L502
 4271              	.LVL452:
3015:Src/bno055.c  **** 		/* Convert the raw mag x to microTesla*/
ARM GAS  /tmp/ccVWLGiI.s 			page 134


3016:Src/bno055.c  **** 		data_f = (float)(reg_mag_x_s16/BNO055_MAG_DIV_UT);
 4272              		.loc 1 3016 0
 4273 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4274              	.LVL453:
 4275 001c FFF7FEFF 		bl	__aeabi_i2d
 4276              	.LVL454:
 4277 0020 0022     		movs	r2, #0
 4278 0022 054B     		ldr	r3, .L504
 4279 0024 FFF7FEFF 		bl	__aeabi_dmul
 4280              	.LVL455:
 4281 0028 FFF7FEFF 		bl	__aeabi_d2f
 4282              	.LVL456:
 4283 002c 2860     		str	r0, [r5]	@ float
 4284              	.L501:
 4285              	.LVL457:
3017:Src/bno055.c  **** 		*mag_x_f = data_f;
3018:Src/bno055.c  **** 	} else {
3019:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
3020:Src/bno055.c  **** 	}
3021:Src/bno055.c  **** 	return com_rslt;
3022:Src/bno055.c  **** }
 4286              		.loc 1 3022 0
 4287 002e 60B2     		sxtb	r0, r4
 4288 0030 03B0     		add	sp, sp, #12
 4289              	.LCFI169:
 4290              		.cfi_remember_state
 4291              		.cfi_def_cfa_offset 12
 4292              		@ sp needed
 4293 0032 30BD     		pop	{r4, r5, pc}
 4294              	.LVL458:
 4295              	.L502:
 4296              	.LCFI170:
 4297              		.cfi_restore_state
3019:Src/bno055.c  **** 	}
 4298              		.loc 1 3019 0
 4299 0034 FF24     		movs	r4, #255
 4300 0036 FAE7     		b	.L501
 4301              	.L505:
 4302              		.align	2
 4303              	.L504:
 4304 0038 0000B03F 		.word	1068498944
 4305              		.cfi_endproc
 4306              	.LFE49:
 4308              		.section	.text.bno055_convert_float_mag_y_uT,"ax",%progbits
 4309              		.align	2
 4310              		.global	bno055_convert_float_mag_y_uT
 4311              		.thumb
 4312              		.thumb_func
 4314              	bno055_convert_float_mag_y_uT:
 4315              	.LFB50:
3023:Src/bno055.c  **** /*!
3024:Src/bno055.c  ****  *	@brief This API is used to convert the mag y raw data
3025:Src/bno055.c  ****  *	to microTesla output as float
3026:Src/bno055.c  ****  *
3027:Src/bno055.c  ****  *	@param mag_y_f : The mag y microTesla data
3028:Src/bno055.c  ****  *
3029:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 135


3030:Src/bno055.c  ****  *
3031:Src/bno055.c  ****  *	@return results of bus communication function
3032:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3033:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3034:Src/bno055.c  ****  *
3035:Src/bno055.c  ****  */
3036:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_mag_y_uT(
3037:Src/bno055.c  **** float *mag_y_f)
3038:Src/bno055.c  **** {
 4316              		.loc 1 3038 0
 4317              		.cfi_startproc
 4318              		@ args = 0, pretend = 0, frame = 8
 4319              		@ frame_needed = 0, uses_anonymous_args = 0
 4320              	.LVL459:
 4321 0000 30B5     		push	{r4, r5, lr}
 4322              	.LCFI171:
 4323              		.cfi_def_cfa_offset 12
 4324              		.cfi_offset 4, -12
 4325              		.cfi_offset 5, -8
 4326              		.cfi_offset 14, -4
 4327 0002 83B0     		sub	sp, sp, #12
 4328              	.LCFI172:
 4329              		.cfi_def_cfa_offset 24
3039:Src/bno055.c  **** 	/* Variable used to return value of
3040:Src/bno055.c  **** 	communication routine*/
3041:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3042:Src/bno055.c  **** 	s16 reg_mag_y_s16 = BNO055_INIT_VALUE;
 4330              		.loc 1 3042 0
 4331 0004 02AB     		add	r3, sp, #8
 4332 0006 0022     		movs	r2, #0
 4333 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4334              	.LVL460:
3038:Src/bno055.c  **** 	/* Variable used to return value of
 4335              		.loc 1 3038 0
 4336 000c 0546     		mov	r5, r0
3043:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3044:Src/bno055.c  **** 	/* Read raw mag y data */
3045:Src/bno055.c  **** 	com_rslt = bno055_read_mag_y(&reg_mag_y_s16);
 4337              		.loc 1 3045 0
 4338 000e 1846     		mov	r0, r3
 4339              	.LVL461:
 4340 0010 FFF7FEFF 		bl	bno055_read_mag_y
 4341              	.LVL462:
3046:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4342              		.loc 1 3046 0
 4343 0014 0446     		mov	r4, r0
 4344 0016 68B9     		cbnz	r0, .L508
 4345              	.LVL463:
3047:Src/bno055.c  **** 		/* Convert the raw mag y to microTesla*/
3048:Src/bno055.c  **** 		data_f = (float)(reg_mag_y_s16/BNO055_MAG_DIV_UT);
 4346              		.loc 1 3048 0
 4347 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4348              	.LVL464:
 4349 001c FFF7FEFF 		bl	__aeabi_i2d
 4350              	.LVL465:
 4351 0020 0022     		movs	r2, #0
 4352 0022 054B     		ldr	r3, .L510
ARM GAS  /tmp/ccVWLGiI.s 			page 136


 4353 0024 FFF7FEFF 		bl	__aeabi_dmul
 4354              	.LVL466:
 4355 0028 FFF7FEFF 		bl	__aeabi_d2f
 4356              	.LVL467:
 4357 002c 2860     		str	r0, [r5]	@ float
 4358              	.L507:
 4359              	.LVL468:
3049:Src/bno055.c  **** 		*mag_y_f = data_f;
3050:Src/bno055.c  **** 	} else {
3051:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
3052:Src/bno055.c  **** 	}
3053:Src/bno055.c  **** 	return com_rslt;
3054:Src/bno055.c  **** }
 4360              		.loc 1 3054 0
 4361 002e 60B2     		sxtb	r0, r4
 4362 0030 03B0     		add	sp, sp, #12
 4363              	.LCFI173:
 4364              		.cfi_remember_state
 4365              		.cfi_def_cfa_offset 12
 4366              		@ sp needed
 4367 0032 30BD     		pop	{r4, r5, pc}
 4368              	.LVL469:
 4369              	.L508:
 4370              	.LCFI174:
 4371              		.cfi_restore_state
3051:Src/bno055.c  **** 	}
 4372              		.loc 1 3051 0
 4373 0034 FF24     		movs	r4, #255
 4374 0036 FAE7     		b	.L507
 4375              	.L511:
 4376              		.align	2
 4377              	.L510:
 4378 0038 0000B03F 		.word	1068498944
 4379              		.cfi_endproc
 4380              	.LFE50:
 4382              		.section	.text.bno055_convert_float_mag_z_uT,"ax",%progbits
 4383              		.align	2
 4384              		.global	bno055_convert_float_mag_z_uT
 4385              		.thumb
 4386              		.thumb_func
 4388              	bno055_convert_float_mag_z_uT:
 4389              	.LFB51:
3055:Src/bno055.c  **** /*!
3056:Src/bno055.c  ****  *	@brief This API is used to convert the mag z raw data
3057:Src/bno055.c  ****  *	to microTesla output as float
3058:Src/bno055.c  ****  *
3059:Src/bno055.c  ****  *	@param mag_z_f : The mag z microTesla data
3060:Src/bno055.c  ****  *
3061:Src/bno055.c  ****  *
3062:Src/bno055.c  ****  *
3063:Src/bno055.c  ****  *	@return results of bus communication function
3064:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3065:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3066:Src/bno055.c  ****  *
3067:Src/bno055.c  ****  */
3068:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_mag_z_uT(
3069:Src/bno055.c  **** float *mag_z_f)
ARM GAS  /tmp/ccVWLGiI.s 			page 137


3070:Src/bno055.c  **** {
 4390              		.loc 1 3070 0
 4391              		.cfi_startproc
 4392              		@ args = 0, pretend = 0, frame = 8
 4393              		@ frame_needed = 0, uses_anonymous_args = 0
 4394              	.LVL470:
 4395 0000 30B5     		push	{r4, r5, lr}
 4396              	.LCFI175:
 4397              		.cfi_def_cfa_offset 12
 4398              		.cfi_offset 4, -12
 4399              		.cfi_offset 5, -8
 4400              		.cfi_offset 14, -4
 4401 0002 83B0     		sub	sp, sp, #12
 4402              	.LCFI176:
 4403              		.cfi_def_cfa_offset 24
3071:Src/bno055.c  **** 	/* Variable used to return value of
3072:Src/bno055.c  **** 	communication routine*/
3073:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3074:Src/bno055.c  **** 	s16 reg_mag_z_s16 = BNO055_INIT_VALUE;
 4404              		.loc 1 3074 0
 4405 0004 02AB     		add	r3, sp, #8
 4406 0006 0022     		movs	r2, #0
 4407 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4408              	.LVL471:
3070:Src/bno055.c  **** 	/* Variable used to return value of
 4409              		.loc 1 3070 0
 4410 000c 0546     		mov	r5, r0
3075:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3076:Src/bno055.c  **** 	/* Read raw mag z data */
3077:Src/bno055.c  **** 	com_rslt = bno055_read_mag_z(&reg_mag_z_s16);
 4411              		.loc 1 3077 0
 4412 000e 1846     		mov	r0, r3
 4413              	.LVL472:
 4414 0010 FFF7FEFF 		bl	bno055_read_mag_z
 4415              	.LVL473:
3078:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4416              		.loc 1 3078 0
 4417 0014 0446     		mov	r4, r0
 4418 0016 68B9     		cbnz	r0, .L514
 4419              	.LVL474:
3079:Src/bno055.c  **** 		/* Convert the raw mag z to microTesla*/
3080:Src/bno055.c  **** 		data_f = (float)(reg_mag_z_s16/BNO055_MAG_DIV_UT);
 4420              		.loc 1 3080 0
 4421 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4422              	.LVL475:
 4423 001c FFF7FEFF 		bl	__aeabi_i2d
 4424              	.LVL476:
 4425 0020 0022     		movs	r2, #0
 4426 0022 054B     		ldr	r3, .L516
 4427 0024 FFF7FEFF 		bl	__aeabi_dmul
 4428              	.LVL477:
 4429 0028 FFF7FEFF 		bl	__aeabi_d2f
 4430              	.LVL478:
 4431 002c 2860     		str	r0, [r5]	@ float
 4432              	.L513:
 4433              	.LVL479:
3081:Src/bno055.c  **** 		*mag_z_f = data_f;
ARM GAS  /tmp/ccVWLGiI.s 			page 138


3082:Src/bno055.c  **** 	} else {
3083:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
3084:Src/bno055.c  **** 	}
3085:Src/bno055.c  **** 	return com_rslt;
3086:Src/bno055.c  **** }
 4434              		.loc 1 3086 0
 4435 002e 60B2     		sxtb	r0, r4
 4436 0030 03B0     		add	sp, sp, #12
 4437              	.LCFI177:
 4438              		.cfi_remember_state
 4439              		.cfi_def_cfa_offset 12
 4440              		@ sp needed
 4441 0032 30BD     		pop	{r4, r5, pc}
 4442              	.LVL480:
 4443              	.L514:
 4444              	.LCFI178:
 4445              		.cfi_restore_state
3083:Src/bno055.c  **** 	}
 4446              		.loc 1 3083 0
 4447 0034 FF24     		movs	r4, #255
 4448 0036 FAE7     		b	.L513
 4449              	.L517:
 4450              		.align	2
 4451              	.L516:
 4452 0038 0000B03F 		.word	1068498944
 4453              		.cfi_endproc
 4454              	.LFE51:
 4456              		.section	.text.bno055_convert_float_mag_xyz_uT,"ax",%progbits
 4457              		.align	2
 4458              		.global	bno055_convert_float_mag_xyz_uT
 4459              		.thumb
 4460              		.thumb_func
 4462              	bno055_convert_float_mag_xyz_uT:
 4463              	.LFB52:
3087:Src/bno055.c  **** /*!
3088:Src/bno055.c  ****  *	@brief This API is used to convert the mag yz raw data
3089:Src/bno055.c  ****  *	to microTesla output as float
3090:Src/bno055.c  ****  *
3091:Src/bno055.c  ****  *	@param mag_xyz_data : The microTesla data of mag xyz
3092:Src/bno055.c  ****  *
3093:Src/bno055.c  ****  *	Parameter |    result
3094:Src/bno055.c  ****  *  --------- | -----------------
3095:Src/bno055.c  ****  *	  x       | microTesla data of mag
3096:Src/bno055.c  ****  *	  y       | microTesla data of mag
3097:Src/bno055.c  ****  *	  z       | microTesla data of mag
3098:Src/bno055.c  ****  *
3099:Src/bno055.c  ****  *
3100:Src/bno055.c  ****  *	@return results of bus communication function
3101:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3102:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3103:Src/bno055.c  ****  *
3104:Src/bno055.c  ****  */
3105:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_mag_xyz_uT(
3106:Src/bno055.c  **** struct bno055_mag_float_t *mag_xyz_data)
3107:Src/bno055.c  **** {
 4464              		.loc 1 3107 0
 4465              		.cfi_startproc
ARM GAS  /tmp/ccVWLGiI.s 			page 139


 4466              		@ args = 0, pretend = 0, frame = 8
 4467              		@ frame_needed = 0, uses_anonymous_args = 0
 4468              	.LVL481:
 4469 0000 30B5     		push	{r4, r5, lr}
 4470              	.LCFI179:
 4471              		.cfi_def_cfa_offset 12
 4472              		.cfi_offset 4, -12
 4473              		.cfi_offset 5, -8
 4474              		.cfi_offset 14, -4
 4475 0002 83B0     		sub	sp, sp, #12
 4476              	.LCFI180:
 4477              		.cfi_def_cfa_offset 24
3108:Src/bno055.c  **** 	/* Variable used to return value of
3109:Src/bno055.c  **** 	communication routine*/
3110:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3111:Src/bno055.c  **** 	struct bno055_mag_t mag_xyz = {
 4478              		.loc 1 3111 0
 4479 0004 0023     		movs	r3, #0
3107:Src/bno055.c  **** 	/* Variable used to return value of
 4480              		.loc 1 3107 0
 4481 0006 0446     		mov	r4, r0
3112:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
3113:Src/bno055.c  **** 	/* Read raw mag x data */
3114:Src/bno055.c  **** 	com_rslt = bno055_read_mag_xyz(&mag_xyz);
 4482              		.loc 1 3114 0
 4483 0008 6846     		mov	r0, sp
 4484              	.LVL482:
3111:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 4485              		.loc 1 3111 0
 4486 000a ADF80030 		strh	r3, [sp]	@ movhi
 4487 000e ADF80230 		strh	r3, [sp, #2]	@ movhi
 4488 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 4489              		.loc 1 3114 0
 4490 0016 FFF7FEFF 		bl	bno055_read_mag_xyz
 4491              	.LVL483:
3115:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4492              		.loc 1 3115 0
 4493 001a 0546     		mov	r5, r0
 4494 001c 18BB     		cbnz	r0, .L520
3116:Src/bno055.c  **** 		/* Convert mag raw xyz to microTesla*/
3117:Src/bno055.c  **** 		mag_xyz_data->x = (float)(mag_xyz.x/BNO055_MAG_DIV_UT);
 4495              		.loc 1 3117 0
 4496 001e BDF90000 		ldrsh	r0, [sp]
 4497              	.LVL484:
 4498 0022 FFF7FEFF 		bl	__aeabi_i2d
 4499              	.LVL485:
 4500 0026 0022     		movs	r2, #0
 4501 0028 104B     		ldr	r3, .L522
 4502 002a FFF7FEFF 		bl	__aeabi_dmul
 4503              	.LVL486:
 4504 002e FFF7FEFF 		bl	__aeabi_d2f
 4505              	.LVL487:
 4506 0032 2060     		str	r0, [r4]	@ float
3118:Src/bno055.c  **** 		mag_xyz_data->y = (float)(mag_xyz.y/BNO055_MAG_DIV_UT);
 4507              		.loc 1 3118 0
 4508 0034 BDF90200 		ldrsh	r0, [sp, #2]
 4509 0038 FFF7FEFF 		bl	__aeabi_i2d
ARM GAS  /tmp/ccVWLGiI.s 			page 140


 4510              	.LVL488:
 4511 003c 0022     		movs	r2, #0
 4512 003e 0B4B     		ldr	r3, .L522
 4513 0040 FFF7FEFF 		bl	__aeabi_dmul
 4514              	.LVL489:
 4515 0044 FFF7FEFF 		bl	__aeabi_d2f
 4516              	.LVL490:
 4517 0048 6060     		str	r0, [r4, #4]	@ float
3119:Src/bno055.c  **** 		mag_xyz_data->z = (float)(mag_xyz.z/BNO055_MAG_DIV_UT);
 4518              		.loc 1 3119 0
 4519 004a BDF90400 		ldrsh	r0, [sp, #4]
 4520 004e FFF7FEFF 		bl	__aeabi_i2d
 4521              	.LVL491:
 4522 0052 0022     		movs	r2, #0
 4523 0054 054B     		ldr	r3, .L522
 4524 0056 FFF7FEFF 		bl	__aeabi_dmul
 4525              	.LVL492:
 4526 005a FFF7FEFF 		bl	__aeabi_d2f
 4527              	.LVL493:
 4528 005e A060     		str	r0, [r4, #8]	@ float
 4529              	.L519:
 4530              	.LVL494:
3120:Src/bno055.c  **** 	} else {
3121:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
3122:Src/bno055.c  **** 	}
3123:Src/bno055.c  **** 
3124:Src/bno055.c  **** 	return com_rslt;
3125:Src/bno055.c  **** }
 4531              		.loc 1 3125 0
 4532 0060 68B2     		sxtb	r0, r5
 4533 0062 03B0     		add	sp, sp, #12
 4534              	.LCFI181:
 4535              		.cfi_remember_state
 4536              		.cfi_def_cfa_offset 12
 4537              		@ sp needed
 4538 0064 30BD     		pop	{r4, r5, pc}
 4539              	.LVL495:
 4540              	.L520:
 4541              	.LCFI182:
 4542              		.cfi_restore_state
3121:Src/bno055.c  **** 	}
 4543              		.loc 1 3121 0
 4544 0066 FF25     		movs	r5, #255
 4545 0068 FAE7     		b	.L519
 4546              	.L523:
 4547 006a 00BF     		.align	2
 4548              	.L522:
 4549 006c 0000B03F 		.word	1068498944
 4550              		.cfi_endproc
 4551              	.LFE52:
 4553              		.global	__aeabi_ddiv
 4554              		.section	.text.bno055_convert_float_linear_accel_x_msq,"ax",%progbits
 4555              		.align	2
 4556              		.global	bno055_convert_float_linear_accel_x_msq
 4557              		.thumb
 4558              		.thumb_func
 4560              	bno055_convert_float_linear_accel_x_msq:
ARM GAS  /tmp/ccVWLGiI.s 			page 141


 4561              	.LFB69:
3126:Src/bno055.c  **** /*!
3127:Src/bno055.c  ****  *	@brief This API is used to convert the gyro x raw data
3128:Src/bno055.c  ****  *	to dps output as float
3129:Src/bno055.c  ****  *
3130:Src/bno055.c  ****  *	@param gyro_x_f : The gyro x dps float data
3131:Src/bno055.c  ****  *
3132:Src/bno055.c  ****  *
3133:Src/bno055.c  ****  *
3134:Src/bno055.c  ****  *	@return results of bus communication function
3135:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3136:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3137:Src/bno055.c  ****  */
3138:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_x_dps(
3139:Src/bno055.c  **** float *gyro_x_f)
3140:Src/bno055.c  **** {
3141:Src/bno055.c  **** 	/* Variable used to return value of
3142:Src/bno055.c  **** 	communication routine*/
3143:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3144:Src/bno055.c  **** 	s16 reg_gyro_x_s16 = BNO055_INIT_VALUE;
3145:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3146:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3147:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3148:Src/bno055.c  **** 	unit as dps if the unit is in rps */
3149:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3150:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
3151:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
3152:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3153:Src/bno055.c  **** 			/* Read gyro raw x data */
3154:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_x(&reg_gyro_x_s16);
3155:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3156:Src/bno055.c  **** 				/* Convert the raw gyro x to dps*/
3157:Src/bno055.c  **** 				data_f =
3158:Src/bno055.c  **** 				(float)(reg_gyro_x_s16/BNO055_GYRO_DIV_DPS);
3159:Src/bno055.c  **** 				*gyro_x_f = data_f;
3160:Src/bno055.c  **** 			} else {
3161:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3162:Src/bno055.c  **** 			}
3163:Src/bno055.c  **** 		} else {
3164:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3165:Src/bno055.c  **** 		}
3166:Src/bno055.c  **** 	return com_rslt;
3167:Src/bno055.c  **** }
3168:Src/bno055.c  **** /*!
3169:Src/bno055.c  ****  *	@brief This API is used to convert the gyro x raw data
3170:Src/bno055.c  ****  *	to rps output as float
3171:Src/bno055.c  ****  *
3172:Src/bno055.c  ****  *	@param gyro_x_f : The gyro x dps float data
3173:Src/bno055.c  ****  *
3174:Src/bno055.c  ****  *
3175:Src/bno055.c  ****  *
3176:Src/bno055.c  ****  *	@return results of bus communication function
3177:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3178:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3179:Src/bno055.c  ****  *
3180:Src/bno055.c  ****  */
3181:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_x_rps(
ARM GAS  /tmp/ccVWLGiI.s 			page 142


3182:Src/bno055.c  **** float *gyro_x_f)
3183:Src/bno055.c  **** {
3184:Src/bno055.c  **** 	/* Variable used to return value of
3185:Src/bno055.c  **** 	communication routine*/
3186:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3187:Src/bno055.c  **** 	s16 reg_gyro_x_s16 = BNO055_INIT_VALUE;
3188:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3189:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3190:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3191:Src/bno055.c  **** 	unit as rps if the unit is in dps */
3192:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3193:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
3194:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
3195:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3196:Src/bno055.c  **** 			/* Read gyro raw x data */
3197:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_x(&reg_gyro_x_s16);
3198:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3199:Src/bno055.c  **** 				/* Convert the raw gyro x to rps*/
3200:Src/bno055.c  **** 				data_f =
3201:Src/bno055.c  **** 				(float)(reg_gyro_x_s16/BNO055_GYRO_DIV_RPS);
3202:Src/bno055.c  **** 				*gyro_x_f = data_f;
3203:Src/bno055.c  **** 			} else {
3204:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3205:Src/bno055.c  **** 			}
3206:Src/bno055.c  **** 		} else {
3207:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3208:Src/bno055.c  **** 		}
3209:Src/bno055.c  **** 	return com_rslt;
3210:Src/bno055.c  **** }
3211:Src/bno055.c  **** /*!
3212:Src/bno055.c  ****  *	@brief This API is used to convert the gyro y raw data
3213:Src/bno055.c  ****  *	to dps output as float
3214:Src/bno055.c  ****  *
3215:Src/bno055.c  ****  *	@param gyro_y_f : The gyro y dps float data
3216:Src/bno055.c  ****  *
3217:Src/bno055.c  ****  *
3218:Src/bno055.c  ****  *
3219:Src/bno055.c  ****  *	@return results of bus communication function
3220:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3221:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3222:Src/bno055.c  ****  *
3223:Src/bno055.c  ****  */
3224:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_y_dps(
3225:Src/bno055.c  **** float *gyro_y_f)
3226:Src/bno055.c  **** {
3227:Src/bno055.c  **** 	/* Variable used to return value of
3228:Src/bno055.c  **** 	communication routine*/
3229:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3230:Src/bno055.c  **** 	s16 reg_gyro_y_s16 = BNO055_INIT_VALUE;
3231:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3232:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3233:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3234:Src/bno055.c  **** 	unit as dps if the unit is in rps */
3235:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3236:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
3237:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
3238:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 143


3239:Src/bno055.c  **** 			/* Read gyro raw y data */
3240:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_y(&reg_gyro_y_s16);
3241:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3242:Src/bno055.c  **** 				/* Convert the raw gyro x to dps*/
3243:Src/bno055.c  **** 				data_f =
3244:Src/bno055.c  **** 				(float)(reg_gyro_y_s16/BNO055_GYRO_DIV_DPS);
3245:Src/bno055.c  **** 				*gyro_y_f = data_f;
3246:Src/bno055.c  **** 			} else {
3247:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3248:Src/bno055.c  **** 			}
3249:Src/bno055.c  **** 		} else {
3250:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3251:Src/bno055.c  **** 		}
3252:Src/bno055.c  **** 	return com_rslt;
3253:Src/bno055.c  **** }
3254:Src/bno055.c  **** /*!
3255:Src/bno055.c  ****  *	@brief This API is used to convert the gyro y raw data
3256:Src/bno055.c  ****  *	to rps output as float
3257:Src/bno055.c  ****  *
3258:Src/bno055.c  ****  *	@param gyro_y_f : The gyro y dps float data
3259:Src/bno055.c  ****  *
3260:Src/bno055.c  ****  *
3261:Src/bno055.c  ****  *
3262:Src/bno055.c  ****  *	@return results of bus communication function
3263:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3264:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3265:Src/bno055.c  ****  *
3266:Src/bno055.c  ****  *
3267:Src/bno055.c  ****  */
3268:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_y_rps(
3269:Src/bno055.c  **** float *gyro_y_f)
3270:Src/bno055.c  **** {
3271:Src/bno055.c  **** 	/* Variable used to return value of
3272:Src/bno055.c  **** 	communication routine*/
3273:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3274:Src/bno055.c  **** 	s16 reg_gyro_y_s16 = BNO055_INIT_VALUE;
3275:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3276:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3277:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3278:Src/bno055.c  **** 	unit as rps if the unit is in dps */
3279:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3280:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
3281:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
3282:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3283:Src/bno055.c  **** 			/* Read gyro raw y data */
3284:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_y(&reg_gyro_y_s16);
3285:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3286:Src/bno055.c  **** 				/* Convert the raw gyro x to rps*/
3287:Src/bno055.c  **** 				data_f =
3288:Src/bno055.c  **** 				(float)(reg_gyro_y_s16/BNO055_GYRO_DIV_RPS);
3289:Src/bno055.c  **** 				*gyro_y_f = data_f;
3290:Src/bno055.c  **** 			} else {
3291:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3292:Src/bno055.c  **** 			}
3293:Src/bno055.c  **** 		} else {
3294:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3295:Src/bno055.c  **** 		}
ARM GAS  /tmp/ccVWLGiI.s 			page 144


3296:Src/bno055.c  **** 	return com_rslt;
3297:Src/bno055.c  **** }
3298:Src/bno055.c  **** /*!
3299:Src/bno055.c  ****  *	@brief This API is used to convert the gyro z raw data
3300:Src/bno055.c  ****  *	to dps output as float
3301:Src/bno055.c  ****  *
3302:Src/bno055.c  ****  *	@param gyro_z_f : The gyro z dps float data
3303:Src/bno055.c  ****  *
3304:Src/bno055.c  ****  *
3305:Src/bno055.c  ****  *
3306:Src/bno055.c  ****  *	@return results of bus communication function
3307:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3308:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3309:Src/bno055.c  ****  *
3310:Src/bno055.c  ****  */
3311:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_z_dps(
3312:Src/bno055.c  **** float *gyro_z_f)
3313:Src/bno055.c  **** {
3314:Src/bno055.c  **** 	/* Variable used to return value of
3315:Src/bno055.c  **** 	communication routine*/
3316:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3317:Src/bno055.c  **** 	s16 reg_gyro_z_s16 = BNO055_INIT_VALUE;
3318:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3319:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3320:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3321:Src/bno055.c  **** 	unit as dps if the unit is in rps */
3322:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3323:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
3324:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
3325:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3326:Src/bno055.c  **** 			/* Read gyro raw z data */
3327:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_z(&reg_gyro_z_s16);
3328:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3329:Src/bno055.c  **** 				/* Convert the raw gyro x to dps*/
3330:Src/bno055.c  **** 				data_f =
3331:Src/bno055.c  **** 				(float)(reg_gyro_z_s16/BNO055_GYRO_DIV_DPS);
3332:Src/bno055.c  **** 				*gyro_z_f = data_f;
3333:Src/bno055.c  **** 			} else {
3334:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3335:Src/bno055.c  **** 			}
3336:Src/bno055.c  **** 		} else {
3337:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3338:Src/bno055.c  **** 		}
3339:Src/bno055.c  **** 	return com_rslt;
3340:Src/bno055.c  **** }
3341:Src/bno055.c  **** /*!
3342:Src/bno055.c  ****  *	@brief This API is used to convert the gyro z raw data
3343:Src/bno055.c  ****  *	to rps output as float
3344:Src/bno055.c  ****  *
3345:Src/bno055.c  ****  *	@param gyro_z_f : The gyro z rps float data
3346:Src/bno055.c  ****  *
3347:Src/bno055.c  ****  *
3348:Src/bno055.c  ****  *
3349:Src/bno055.c  ****  *	@return results of bus communication function
3350:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3351:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3352:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 145


3353:Src/bno055.c  ****  */
3354:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_z_rps(
3355:Src/bno055.c  **** float *gyro_z_f)
3356:Src/bno055.c  **** {
3357:Src/bno055.c  **** 	/* Variable used to return value of
3358:Src/bno055.c  **** 	communication routine*/
3359:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3360:Src/bno055.c  **** 	s16 reg_gyro_z_s16 = BNO055_INIT_VALUE;
3361:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3362:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3363:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3364:Src/bno055.c  **** 	unit as rps if the unit is in dps */
3365:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3366:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
3367:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
3368:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3369:Src/bno055.c  **** 			/* Read gyro raw x data */
3370:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_z(&reg_gyro_z_s16);
3371:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3372:Src/bno055.c  **** 				/* Convert the raw gyro x to rps*/
3373:Src/bno055.c  **** 				data_f =
3374:Src/bno055.c  **** 				(float)(reg_gyro_z_s16/BNO055_GYRO_DIV_RPS);
3375:Src/bno055.c  **** 				*gyro_z_f = data_f;
3376:Src/bno055.c  **** 			} else {
3377:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3378:Src/bno055.c  **** 			}
3379:Src/bno055.c  **** 		} else {
3380:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3381:Src/bno055.c  **** 		}
3382:Src/bno055.c  **** 	return com_rslt;
3383:Src/bno055.c  **** }
3384:Src/bno055.c  **** /*!
3385:Src/bno055.c  ****  *	@brief This API is used to convert the gyro xyz raw data
3386:Src/bno055.c  ****  *	to dps output as float
3387:Src/bno055.c  ****  *
3388:Src/bno055.c  ****  *	@param gyro_xyz_data : The dps data of gyro xyz
3389:Src/bno055.c  ****  *
3390:Src/bno055.c  ****  *	Parameter |    result
3391:Src/bno055.c  ****  *  --------- | -----------------
3392:Src/bno055.c  ****  *	  x       | dps data of gyro
3393:Src/bno055.c  ****  *	  y       | dps data of gyro
3394:Src/bno055.c  ****  *	  z       | dps data of gyro
3395:Src/bno055.c  ****  *
3396:Src/bno055.c  ****  *
3397:Src/bno055.c  ****  *	@return results of bus communication function
3398:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3399:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3400:Src/bno055.c  ****  *
3401:Src/bno055.c  ****  *
3402:Src/bno055.c  ****  */
3403:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_xyz_dps(
3404:Src/bno055.c  **** struct bno055_gyro_float_t *gyro_xyz_data)
3405:Src/bno055.c  **** {
3406:Src/bno055.c  **** 	/* Variable used to return value of
3407:Src/bno055.c  **** 	communication routine*/
3408:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3409:Src/bno055.c  **** 	struct bno055_gyro_t gyro_xyz = {
ARM GAS  /tmp/ccVWLGiI.s 			page 146


3410:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
3411:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3412:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3413:Src/bno055.c  **** 	unit as dps if the unit is in rps */
3414:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
3415:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
3416:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
3417:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3418:Src/bno055.c  **** 			/* Read gyro raw xyz data */
3419:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_xyz(&gyro_xyz);
3420:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3421:Src/bno055.c  **** 				/* Convert gyro raw xyz to dps*/
3422:Src/bno055.c  **** 				gyro_xyz_data->x =
3423:Src/bno055.c  **** 				(float)(gyro_xyz.x/BNO055_GYRO_DIV_DPS);
3424:Src/bno055.c  **** 				gyro_xyz_data->y =
3425:Src/bno055.c  **** 				(float)(gyro_xyz.y/BNO055_GYRO_DIV_DPS);
3426:Src/bno055.c  **** 				gyro_xyz_data->z =
3427:Src/bno055.c  **** 				(float)(gyro_xyz.z/BNO055_GYRO_DIV_DPS);
3428:Src/bno055.c  **** 			} else {
3429:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3430:Src/bno055.c  **** 			}
3431:Src/bno055.c  **** 		} else {
3432:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3433:Src/bno055.c  **** 		}
3434:Src/bno055.c  **** 	return com_rslt;
3435:Src/bno055.c  **** }
3436:Src/bno055.c  **** /*!
3437:Src/bno055.c  ****  *	@brief This API is used to convert the gyro xyz raw data
3438:Src/bno055.c  ****  *	to rps output as float
3439:Src/bno055.c  ****  *
3440:Src/bno055.c  ****  *	@param gyro_xyz_data : The rps data of gyro xyz
3441:Src/bno055.c  ****  *
3442:Src/bno055.c  ****  *	Parameter |    result
3443:Src/bno055.c  ****  *  --------- | -----------------
3444:Src/bno055.c  ****  *	  x       | rps data of gyro
3445:Src/bno055.c  ****  *	  y       | rps data of gyro
3446:Src/bno055.c  ****  *	  z       | rps data of gyro
3447:Src/bno055.c  ****  *
3448:Src/bno055.c  ****  *
3449:Src/bno055.c  ****  *	@return results of bus communication function
3450:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3451:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3452:Src/bno055.c  ****  *
3453:Src/bno055.c  ****  *
3454:Src/bno055.c  ****  */
3455:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gyro_xyz_rps(
3456:Src/bno055.c  **** struct bno055_gyro_float_t *gyro_xyz_data)
3457:Src/bno055.c  **** {
3458:Src/bno055.c  **** 	/* Variable used to return value of
3459:Src/bno055.c  **** 	communication routine*/
3460:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3461:Src/bno055.c  **** 	struct bno055_gyro_t gyro_xyz = {BNO055_INIT_VALUE,
3462:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
3463:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
3464:Src/bno055.c  **** 	/* Read the current gyro unit and set the
3465:Src/bno055.c  **** 	unit as rps if the unit is in dps */
3466:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 147


3467:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
3468:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
3469:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3470:Src/bno055.c  **** 			/* Read gyro raw xyz data */
3471:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_xyz(&gyro_xyz);
3472:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3473:Src/bno055.c  **** 				/* Convert gyro raw xyz to rps*/
3474:Src/bno055.c  **** 				gyro_xyz_data->x =
3475:Src/bno055.c  **** 				(float)(gyro_xyz.x/BNO055_GYRO_DIV_RPS);
3476:Src/bno055.c  **** 				gyro_xyz_data->y =
3477:Src/bno055.c  **** 				(float)(gyro_xyz.y/BNO055_GYRO_DIV_RPS);
3478:Src/bno055.c  **** 				gyro_xyz_data->z =
3479:Src/bno055.c  **** 				(float)(gyro_xyz.z/BNO055_GYRO_DIV_RPS);
3480:Src/bno055.c  **** 			} else {
3481:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3482:Src/bno055.c  **** 			}
3483:Src/bno055.c  **** 		} else {
3484:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3485:Src/bno055.c  **** 		}
3486:Src/bno055.c  **** 	return com_rslt;
3487:Src/bno055.c  **** }
3488:Src/bno055.c  **** /*!
3489:Src/bno055.c  ****  *	@brief This API is used to convert the Euler h raw data
3490:Src/bno055.c  ****  *	to degree output as float
3491:Src/bno055.c  ****  *
3492:Src/bno055.c  ****  *	@param euler_h_f : The float value of Euler h degree
3493:Src/bno055.c  ****  *
3494:Src/bno055.c  ****  *	@return results of bus communication function
3495:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3496:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3497:Src/bno055.c  ****  *
3498:Src/bno055.c  ****  *
3499:Src/bno055.c  ****  */
3500:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_h_deg(
3501:Src/bno055.c  **** float *euler_h_f)
3502:Src/bno055.c  **** {
3503:Src/bno055.c  **** 	/* Variable used to return value of
3504:Src/bno055.c  **** 	communication routine*/
3505:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3506:Src/bno055.c  **** 	s16 reg_euler_h_s16 = BNO055_INIT_VALUE;
3507:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3508:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3509:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3510:Src/bno055.c  **** 	unit as degree if the unit is in radians */
3511:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3512:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
3513:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
3514:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
3515:Src/bno055.c  **** 			/* Read Euler raw h data*/
3516:Src/bno055.c  **** 			com_rslt += bno055_read_euler_h(&reg_euler_h_s16);
3517:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3518:Src/bno055.c  **** 				/* Convert raw Euler h data to degree*/
3519:Src/bno055.c  **** 				data_f =
3520:Src/bno055.c  **** 				(float)(reg_euler_h_s16/BNO055_EULER_DIV_DEG);
3521:Src/bno055.c  **** 				*euler_h_f = data_f;
3522:Src/bno055.c  **** 			} else {
3523:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 148


3524:Src/bno055.c  **** 			}
3525:Src/bno055.c  **** 		} else {
3526:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3527:Src/bno055.c  **** 		}
3528:Src/bno055.c  **** 	return com_rslt;
3529:Src/bno055.c  **** }
3530:Src/bno055.c  **** /*!
3531:Src/bno055.c  ****  *	@brief This API is used to convert the Euler h raw data
3532:Src/bno055.c  ****  *	to radians output as float
3533:Src/bno055.c  ****  *
3534:Src/bno055.c  ****  *	@param euler_h_f : The float value of Euler h radians
3535:Src/bno055.c  ****  *
3536:Src/bno055.c  ****  *	@return results of bus communication function
3537:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3538:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3539:Src/bno055.c  ****  *
3540:Src/bno055.c  ****  *
3541:Src/bno055.c  ****  */
3542:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_h_rad(
3543:Src/bno055.c  **** float *euler_h_f)
3544:Src/bno055.c  **** {
3545:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3546:Src/bno055.c  **** 	s16 reg_euler_h_s16 = BNO055_INIT_VALUE;
3547:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3548:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3549:Src/bno055.c  **** 
3550:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3551:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
3552:Src/bno055.c  **** 		/* Read the current Euler unit and set the
3553:Src/bno055.c  **** 		unit as radians if the unit is in degree */
3554:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
3555:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3556:Src/bno055.c  **** 			/* Read Euler raw h data*/
3557:Src/bno055.c  **** 			com_rslt += bno055_read_euler_h(&reg_euler_h_s16);
3558:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3559:Src/bno055.c  **** 				/* Convert raw Euler h data to degree*/
3560:Src/bno055.c  **** 				data_f =
3561:Src/bno055.c  **** 				(float)(reg_euler_h_s16/BNO055_EULER_DIV_RAD);
3562:Src/bno055.c  **** 				*euler_h_f = data_f;
3563:Src/bno055.c  **** 			} else {
3564:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3565:Src/bno055.c  **** 			}
3566:Src/bno055.c  **** 		} else {
3567:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3568:Src/bno055.c  **** 		}
3569:Src/bno055.c  **** 	return com_rslt;
3570:Src/bno055.c  **** }
3571:Src/bno055.c  **** /*!
3572:Src/bno055.c  ****  *	@brief This API is used to convert the Euler r raw data
3573:Src/bno055.c  ****  *	to degree output as float
3574:Src/bno055.c  ****  *
3575:Src/bno055.c  ****  *	@param euler_r_f : The float value of Euler r degree
3576:Src/bno055.c  ****  *
3577:Src/bno055.c  ****  *	@return results of bus communication function
3578:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3579:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3580:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 149


3581:Src/bno055.c  ****  */
3582:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_r_deg(
3583:Src/bno055.c  **** float *euler_r_f)
3584:Src/bno055.c  **** {
3585:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3586:Src/bno055.c  **** 	s16 reg_euler_r = BNO055_INIT_VALUE;
3587:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3588:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3589:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3590:Src/bno055.c  **** 	unit as degree if the unit is in radians */
3591:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3592:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
3593:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
3594:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
3595:Src/bno055.c  **** 			/* Read Euler raw r data*/
3596:Src/bno055.c  **** 			com_rslt += bno055_read_euler_r(&reg_euler_r);
3597:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3598:Src/bno055.c  **** 				/* Convert raw Euler r data to degree*/
3599:Src/bno055.c  **** 				data_f = (float)(
3600:Src/bno055.c  **** 				reg_euler_r/BNO055_EULER_DIV_DEG);
3601:Src/bno055.c  **** 				*euler_r_f = data_f;
3602:Src/bno055.c  **** 			} else {
3603:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3604:Src/bno055.c  **** 			}
3605:Src/bno055.c  **** 		} else {
3606:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3607:Src/bno055.c  **** 		}
3608:Src/bno055.c  **** 	return com_rslt;
3609:Src/bno055.c  **** }
3610:Src/bno055.c  **** /*!
3611:Src/bno055.c  ****  *	@brief This API is used to convert the Euler r raw data
3612:Src/bno055.c  ****  *	to radians output as float
3613:Src/bno055.c  ****  *
3614:Src/bno055.c  ****  *	@param euler_r_f : The float value of Euler r radians
3615:Src/bno055.c  ****  *
3616:Src/bno055.c  ****  *	@return results of bus communication function
3617:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3618:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3619:Src/bno055.c  ****  *
3620:Src/bno055.c  ****  */
3621:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_r_rad(
3622:Src/bno055.c  **** float *euler_r_f)
3623:Src/bno055.c  **** {
3624:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3625:Src/bno055.c  **** 	s16 reg_euler_r_f = BNO055_INIT_VALUE;
3626:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3627:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3628:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3629:Src/bno055.c  **** 	unit as radians if the unit is in degree */
3630:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3631:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
3632:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
3633:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3634:Src/bno055.c  **** 			/* Read Euler raw r data*/
3635:Src/bno055.c  **** 			com_rslt += bno055_read_euler_r(&reg_euler_r_f);
3636:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3637:Src/bno055.c  **** 				/* Convert raw Euler r data to radians*/
ARM GAS  /tmp/ccVWLGiI.s 			page 150


3638:Src/bno055.c  **** 				data_f =
3639:Src/bno055.c  **** 				(float)(reg_euler_r_f/BNO055_EULER_DIV_RAD);
3640:Src/bno055.c  **** 				*euler_r_f = data_f;
3641:Src/bno055.c  **** 			} else {
3642:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3643:Src/bno055.c  **** 			}
3644:Src/bno055.c  **** 		} else {
3645:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3646:Src/bno055.c  **** 		}
3647:Src/bno055.c  **** 	return com_rslt;
3648:Src/bno055.c  **** }
3649:Src/bno055.c  **** /*!
3650:Src/bno055.c  ****  *	@brief This API is used to convert the Euler p raw data
3651:Src/bno055.c  ****  *	to degree output as float
3652:Src/bno055.c  ****  *
3653:Src/bno055.c  ****  *	@param euler_p_f : The float value of Euler p degree
3654:Src/bno055.c  ****  *
3655:Src/bno055.c  ****  *	@return results of bus communication function
3656:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3657:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3658:Src/bno055.c  ****  *
3659:Src/bno055.c  ****  */
3660:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_p_deg(
3661:Src/bno055.c  **** float *euler_p_f)
3662:Src/bno055.c  **** {
3663:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3664:Src/bno055.c  **** 	s16 reg_euler_p_f = BNO055_INIT_VALUE;
3665:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3666:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3667:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3668:Src/bno055.c  **** 	unit as degree if the unit is in radians */
3669:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3670:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
3671:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
3672:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
3673:Src/bno055.c  **** 			/* Read Euler raw p data*/
3674:Src/bno055.c  **** 			com_rslt += bno055_read_euler_p(&reg_euler_p_f);
3675:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3676:Src/bno055.c  **** 				/* Convert raw Euler p data to degree*/
3677:Src/bno055.c  **** 				data_f =
3678:Src/bno055.c  **** 				(float)(reg_euler_p_f/BNO055_EULER_DIV_DEG);
3679:Src/bno055.c  **** 				*euler_p_f = data_f;
3680:Src/bno055.c  **** 			} else {
3681:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3682:Src/bno055.c  **** 			}
3683:Src/bno055.c  **** 		} else {
3684:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3685:Src/bno055.c  **** 		}
3686:Src/bno055.c  **** 	return com_rslt;
3687:Src/bno055.c  **** }
3688:Src/bno055.c  **** /*!
3689:Src/bno055.c  ****  *	@brief This API is used to convert the Euler p raw data
3690:Src/bno055.c  ****  *	to radians output as float
3691:Src/bno055.c  ****  *
3692:Src/bno055.c  ****  *	@param euler_p_f : The float value of Euler p radians
3693:Src/bno055.c  ****  *
3694:Src/bno055.c  ****  *	@return results of bus communication function
ARM GAS  /tmp/ccVWLGiI.s 			page 151


3695:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3696:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3697:Src/bno055.c  ****  *
3698:Src/bno055.c  ****  *
3699:Src/bno055.c  ****  */
3700:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_p_rad(
3701:Src/bno055.c  **** float *euler_p_f)
3702:Src/bno055.c  **** {
3703:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3704:Src/bno055.c  **** 	s16 reg_euler_p_f = BNO055_INIT_VALUE;
3705:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3706:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3707:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3708:Src/bno055.c  **** 	unit as radians if the unit is in degree */
3709:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3710:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
3711:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
3712:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3713:Src/bno055.c  **** 			/* Read Euler raw r data*/
3714:Src/bno055.c  **** 			com_rslt += bno055_read_euler_p(&reg_euler_p_f);
3715:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3716:Src/bno055.c  **** 				/* Convert raw Euler r data to radians*/
3717:Src/bno055.c  **** 				data_f =
3718:Src/bno055.c  **** 				(float)(reg_euler_p_f/BNO055_EULER_DIV_RAD);
3719:Src/bno055.c  **** 				*euler_p_f = data_f;
3720:Src/bno055.c  **** 			} else {
3721:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3722:Src/bno055.c  **** 			}
3723:Src/bno055.c  **** 		} else {
3724:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3725:Src/bno055.c  **** 		}
3726:Src/bno055.c  **** 	return com_rslt;
3727:Src/bno055.c  **** }
3728:Src/bno055.c  **** /*!
3729:Src/bno055.c  ****  *	@brief This API is used to convert the Euler hrp raw data
3730:Src/bno055.c  ****  *	to degree output as float
3731:Src/bno055.c  ****  *
3732:Src/bno055.c  ****  *	@param euler_hpr : The degree data of Euler hrp
3733:Src/bno055.c  ****  *
3734:Src/bno055.c  ****  *	Parameter |    result
3735:Src/bno055.c  ****  *  --------- | -----------------
3736:Src/bno055.c  ****  *	  h       | degree data of Euler
3737:Src/bno055.c  ****  *	  r       | degree data of Euler
3738:Src/bno055.c  ****  *	  p       | degree data of Euler
3739:Src/bno055.c  ****  *
3740:Src/bno055.c  ****  *
3741:Src/bno055.c  ****  *	@return results of bus communication function
3742:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3743:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3744:Src/bno055.c  ****  *
3745:Src/bno055.c  ****  */
3746:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_hpr_deg(
3747:Src/bno055.c  **** struct bno055_euler_float_t *euler_hpr)
3748:Src/bno055.c  **** {
3749:Src/bno055.c  **** 	/* Variable used to return value of
3750:Src/bno055.c  **** 	communication routine*/
3751:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 152


3752:Src/bno055.c  **** 	struct bno055_euler_t reg_euler = {BNO055_INIT_VALUE,
3753:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
3754:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3755:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3756:Src/bno055.c  **** 	unit as degree if the unit is in radians */
3757:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
3758:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
3759:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
3760:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3761:Src/bno055.c  **** 			/* Read Euler raw hrp data*/
3762:Src/bno055.c  **** 			com_rslt += bno055_read_euler_hrp(&reg_euler);
3763:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3764:Src/bno055.c  **** 				/* Convert raw Euler hrp to degree*/
3765:Src/bno055.c  **** 				euler_hpr->h =
3766:Src/bno055.c  **** 				(float)(reg_euler.h/BNO055_EULER_DIV_DEG);
3767:Src/bno055.c  **** 				euler_hpr->p =
3768:Src/bno055.c  **** 				(float)(reg_euler.p/BNO055_EULER_DIV_DEG);
3769:Src/bno055.c  **** 				euler_hpr->r =
3770:Src/bno055.c  **** 				(float)(reg_euler.r/BNO055_EULER_DIV_DEG);
3771:Src/bno055.c  **** 			} else {
3772:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3773:Src/bno055.c  **** 			}
3774:Src/bno055.c  **** 		} else {
3775:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3776:Src/bno055.c  **** 		}
3777:Src/bno055.c  **** 	return com_rslt;
3778:Src/bno055.c  **** }
3779:Src/bno055.c  **** /*!
3780:Src/bno055.c  ****  *	@brief This API is used to convert the Euler xyz raw data
3781:Src/bno055.c  ****  *	to radians output as float
3782:Src/bno055.c  ****  *
3783:Src/bno055.c  ****  *	@param euler_hpr : The radians data of Euler hrp
3784:Src/bno055.c  ****  *
3785:Src/bno055.c  ****  *	Parameter |    result
3786:Src/bno055.c  ****  *  --------- | -----------------
3787:Src/bno055.c  ****  *	  h       | radians data of Euler
3788:Src/bno055.c  ****  *	  r       | radians data of Euler
3789:Src/bno055.c  ****  *	  p       | radians data of Euler
3790:Src/bno055.c  ****  *
3791:Src/bno055.c  ****  *
3792:Src/bno055.c  ****  *	@return results of bus communication function
3793:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3794:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3795:Src/bno055.c  ****  *
3796:Src/bno055.c  ****  */
3797:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_euler_hpr_rad(
3798:Src/bno055.c  **** struct bno055_euler_float_t *euler_hpr)
3799:Src/bno055.c  **** {
3800:Src/bno055.c  **** 	/* Variable used to return value of
3801:Src/bno055.c  **** 	communication routine*/
3802:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3803:Src/bno055.c  **** 	struct bno055_euler_t reg_euler = {BNO055_INIT_VALUE,
3804:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
3805:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
3806:Src/bno055.c  **** 	/* Read the current Euler unit and set the
3807:Src/bno055.c  **** 	unit as radians if the unit is in degree */
3808:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 153


3809:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
3810:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
3811:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
3812:Src/bno055.c  **** 			/* Read Euler raw hrp data*/
3813:Src/bno055.c  **** 			com_rslt += bno055_read_euler_hrp(&reg_euler);
3814:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
3815:Src/bno055.c  **** 				/* Convert raw hrp to radians */
3816:Src/bno055.c  **** 				euler_hpr->h =
3817:Src/bno055.c  **** 				(float)(reg_euler.h/BNO055_EULER_DIV_RAD);
3818:Src/bno055.c  **** 				euler_hpr->p =
3819:Src/bno055.c  **** 				(float)(reg_euler.p/BNO055_EULER_DIV_RAD);
3820:Src/bno055.c  **** 				euler_hpr->r =
3821:Src/bno055.c  **** 				(float)(reg_euler.r/BNO055_EULER_DIV_RAD);
3822:Src/bno055.c  **** 			} else {
3823:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
3824:Src/bno055.c  **** 			}
3825:Src/bno055.c  **** 		} else {
3826:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3827:Src/bno055.c  **** 		}
3828:Src/bno055.c  **** 	return com_rslt;
3829:Src/bno055.c  **** }
3830:Src/bno055.c  **** /*!
3831:Src/bno055.c  ****  *	@brief This API is used to convert the linear
3832:Src/bno055.c  ****  *	accel x raw data to meterpersecseq output as float
3833:Src/bno055.c  ****  *
3834:Src/bno055.c  ****  *	@param linear_accel_x_f : The float value of linear accel x meterpersecseq
3835:Src/bno055.c  ****  *
3836:Src/bno055.c  ****  *	@return results of bus communication function
3837:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3838:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3839:Src/bno055.c  ****  */
3840:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_linear_accel_x_msq(
3841:Src/bno055.c  **** float *linear_accel_x_f)
3842:Src/bno055.c  **** {
 4562              		.loc 1 3842 0
 4563              		.cfi_startproc
 4564              		@ args = 0, pretend = 0, frame = 8
 4565              		@ frame_needed = 0, uses_anonymous_args = 0
 4566              	.LVL496:
 4567 0000 30B5     		push	{r4, r5, lr}
 4568              	.LCFI183:
 4569              		.cfi_def_cfa_offset 12
 4570              		.cfi_offset 4, -12
 4571              		.cfi_offset 5, -8
 4572              		.cfi_offset 14, -4
 4573 0002 83B0     		sub	sp, sp, #12
 4574              	.LCFI184:
 4575              		.cfi_def_cfa_offset 24
3843:Src/bno055.c  **** 	/* Variable used to return value of
3844:Src/bno055.c  **** 	communication routine*/
3845:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3846:Src/bno055.c  **** 	s16 reg_linear_accel_x_s16 = BNO055_INIT_VALUE;
 4576              		.loc 1 3846 0
 4577 0004 02AB     		add	r3, sp, #8
 4578 0006 0022     		movs	r2, #0
 4579 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4580              	.LVL497:
ARM GAS  /tmp/ccVWLGiI.s 			page 154


3842:Src/bno055.c  **** 	/* Variable used to return value of
 4581              		.loc 1 3842 0
 4582 000c 0546     		mov	r5, r0
3847:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3848:Src/bno055.c  **** 	/* Read the raw x of linear accel */
3849:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_x(&reg_linear_accel_x_s16);
 4583              		.loc 1 3849 0
 4584 000e 1846     		mov	r0, r3
 4585              	.LVL498:
 4586 0010 FFF7FEFF 		bl	bno055_read_linear_accel_x
 4587              	.LVL499:
3850:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4588              		.loc 1 3850 0
 4589 0014 0446     		mov	r4, r0
 4590 0016 68B9     		cbnz	r0, .L526
 4591              	.LVL500:
3851:Src/bno055.c  **** 		/* Convert the raw linear accel x to m/s2*/
3852:Src/bno055.c  **** 		data_f =
3853:Src/bno055.c  **** 		(float)(reg_linear_accel_x_s16/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4592              		.loc 1 3853 0
 4593 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4594              	.LVL501:
 4595 001c FFF7FEFF 		bl	__aeabi_i2d
 4596              	.LVL502:
 4597 0020 0022     		movs	r2, #0
 4598 0022 054B     		ldr	r3, .L528
 4599 0024 FFF7FEFF 		bl	__aeabi_ddiv
 4600              	.LVL503:
3852:Src/bno055.c  **** 		(float)(reg_linear_accel_x_s16/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4601              		.loc 1 3852 0
 4602 0028 FFF7FEFF 		bl	__aeabi_d2f
 4603              	.LVL504:
 4604 002c 2860     		str	r0, [r5]	@ float
 4605              	.L525:
 4606              	.LVL505:
3854:Src/bno055.c  **** 		*linear_accel_x_f = data_f;
3855:Src/bno055.c  **** 	} else {
3856:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3857:Src/bno055.c  **** 	}
3858:Src/bno055.c  **** 	return com_rslt;
3859:Src/bno055.c  **** }
 4607              		.loc 1 3859 0
 4608 002e 60B2     		sxtb	r0, r4
 4609 0030 03B0     		add	sp, sp, #12
 4610              	.LCFI185:
 4611              		.cfi_remember_state
 4612              		.cfi_def_cfa_offset 12
 4613              		@ sp needed
 4614 0032 30BD     		pop	{r4, r5, pc}
 4615              	.LVL506:
 4616              	.L526:
 4617              	.LCFI186:
 4618              		.cfi_restore_state
3856:Src/bno055.c  **** 	}
 4619              		.loc 1 3856 0
 4620 0034 FF24     		movs	r4, #255
 4621 0036 FAE7     		b	.L525
ARM GAS  /tmp/ccVWLGiI.s 			page 155


 4622              	.L529:
 4623              		.align	2
 4624              	.L528:
 4625 0038 00005940 		.word	1079574528
 4626              		.cfi_endproc
 4627              	.LFE69:
 4629              		.section	.text.bno055_convert_float_linear_accel_y_msq,"ax",%progbits
 4630              		.align	2
 4631              		.global	bno055_convert_float_linear_accel_y_msq
 4632              		.thumb
 4633              		.thumb_func
 4635              	bno055_convert_float_linear_accel_y_msq:
 4636              	.LFB70:
3860:Src/bno055.c  **** /*!
3861:Src/bno055.c  ****  *	@brief This API is used to convert the linear
3862:Src/bno055.c  ****  *	accel y raw data to meterpersecseq output as float
3863:Src/bno055.c  ****  *
3864:Src/bno055.c  ****  *	@param linear_accel_y_f : The float value of linear accel y meterpersecseq
3865:Src/bno055.c  ****  *
3866:Src/bno055.c  ****  *	@return results of bus communication function
3867:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3868:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3869:Src/bno055.c  ****  */
3870:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_linear_accel_y_msq(
3871:Src/bno055.c  **** float *linear_accel_y_f)
3872:Src/bno055.c  **** {
 4637              		.loc 1 3872 0
 4638              		.cfi_startproc
 4639              		@ args = 0, pretend = 0, frame = 8
 4640              		@ frame_needed = 0, uses_anonymous_args = 0
 4641              	.LVL507:
 4642 0000 30B5     		push	{r4, r5, lr}
 4643              	.LCFI187:
 4644              		.cfi_def_cfa_offset 12
 4645              		.cfi_offset 4, -12
 4646              		.cfi_offset 5, -8
 4647              		.cfi_offset 14, -4
 4648 0002 83B0     		sub	sp, sp, #12
 4649              	.LCFI188:
 4650              		.cfi_def_cfa_offset 24
3873:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3874:Src/bno055.c  **** 	s16 reg_linear_accel_y = BNO055_INIT_VALUE;
 4651              		.loc 1 3874 0
 4652 0004 02AB     		add	r3, sp, #8
 4653 0006 0022     		movs	r2, #0
 4654 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4655              	.LVL508:
3872:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 4656              		.loc 1 3872 0
 4657 000c 0546     		mov	r5, r0
3875:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3876:Src/bno055.c  **** 	/* Read the raw y of linear accel */
3877:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_y(&reg_linear_accel_y);
 4658              		.loc 1 3877 0
 4659 000e 1846     		mov	r0, r3
 4660              	.LVL509:
 4661 0010 FFF7FEFF 		bl	bno055_read_linear_accel_y
ARM GAS  /tmp/ccVWLGiI.s 			page 156


 4662              	.LVL510:
3878:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4663              		.loc 1 3878 0
 4664 0014 0446     		mov	r4, r0
 4665 0016 68B9     		cbnz	r0, .L532
 4666              	.LVL511:
3879:Src/bno055.c  **** 		/* Convert the raw linear accel x to m/s2*/
3880:Src/bno055.c  **** 		data_f = (float)
3881:Src/bno055.c  **** 		(reg_linear_accel_y/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4667              		.loc 1 3881 0
 4668 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4669              	.LVL512:
 4670 001c FFF7FEFF 		bl	__aeabi_i2d
 4671              	.LVL513:
 4672 0020 0022     		movs	r2, #0
 4673 0022 054B     		ldr	r3, .L534
 4674 0024 FFF7FEFF 		bl	__aeabi_ddiv
 4675              	.LVL514:
3880:Src/bno055.c  **** 		(reg_linear_accel_y/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4676              		.loc 1 3880 0
 4677 0028 FFF7FEFF 		bl	__aeabi_d2f
 4678              	.LVL515:
 4679 002c 2860     		str	r0, [r5]	@ float
 4680              	.L531:
 4681              	.LVL516:
3882:Src/bno055.c  **** 		*linear_accel_y_f = data_f;
3883:Src/bno055.c  **** 	} else {
3884:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3885:Src/bno055.c  **** 	}
3886:Src/bno055.c  **** 	return com_rslt;
3887:Src/bno055.c  **** }
 4682              		.loc 1 3887 0
 4683 002e 60B2     		sxtb	r0, r4
 4684 0030 03B0     		add	sp, sp, #12
 4685              	.LCFI189:
 4686              		.cfi_remember_state
 4687              		.cfi_def_cfa_offset 12
 4688              		@ sp needed
 4689 0032 30BD     		pop	{r4, r5, pc}
 4690              	.LVL517:
 4691              	.L532:
 4692              	.LCFI190:
 4693              		.cfi_restore_state
3884:Src/bno055.c  **** 	}
 4694              		.loc 1 3884 0
 4695 0034 FF24     		movs	r4, #255
 4696 0036 FAE7     		b	.L531
 4697              	.L535:
 4698              		.align	2
 4699              	.L534:
 4700 0038 00005940 		.word	1079574528
 4701              		.cfi_endproc
 4702              	.LFE70:
 4704              		.section	.text.bno055_convert_float_linear_accel_z_msq,"ax",%progbits
 4705              		.align	2
 4706              		.global	bno055_convert_float_linear_accel_z_msq
 4707              		.thumb
ARM GAS  /tmp/ccVWLGiI.s 			page 157


 4708              		.thumb_func
 4710              	bno055_convert_float_linear_accel_z_msq:
 4711              	.LFB71:
3888:Src/bno055.c  **** /*!
3889:Src/bno055.c  ****  *	@brief This API is used to convert the linear
3890:Src/bno055.c  ****  *	accel z raw data to meterpersecseq output as float
3891:Src/bno055.c  ****  *
3892:Src/bno055.c  ****  *	@param linear_accel_z_f : The float value of linear accel z meterpersecseq
3893:Src/bno055.c  ****  *
3894:Src/bno055.c  ****  *	@return results of bus communication function
3895:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3896:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3897:Src/bno055.c  ****  *
3898:Src/bno055.c  ****  */
3899:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_linear_accel_z_msq(
3900:Src/bno055.c  **** float *linear_accel_z_f)
3901:Src/bno055.c  **** {
 4712              		.loc 1 3901 0
 4713              		.cfi_startproc
 4714              		@ args = 0, pretend = 0, frame = 8
 4715              		@ frame_needed = 0, uses_anonymous_args = 0
 4716              	.LVL518:
 4717 0000 30B5     		push	{r4, r5, lr}
 4718              	.LCFI191:
 4719              		.cfi_def_cfa_offset 12
 4720              		.cfi_offset 4, -12
 4721              		.cfi_offset 5, -8
 4722              		.cfi_offset 14, -4
 4723 0002 83B0     		sub	sp, sp, #12
 4724              	.LCFI192:
 4725              		.cfi_def_cfa_offset 24
3902:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3903:Src/bno055.c  **** 	s16 reg_linear_accel_z = BNO055_INIT_VALUE;
 4726              		.loc 1 3903 0
 4727 0004 02AB     		add	r3, sp, #8
 4728 0006 0022     		movs	r2, #0
 4729 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4730              	.LVL519:
3901:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 4731              		.loc 1 3901 0
 4732 000c 0546     		mov	r5, r0
3904:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3905:Src/bno055.c  **** 	/* Read the raw x of linear accel */
3906:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_z(&reg_linear_accel_z);
 4733              		.loc 1 3906 0
 4734 000e 1846     		mov	r0, r3
 4735              	.LVL520:
 4736 0010 FFF7FEFF 		bl	bno055_read_linear_accel_z
 4737              	.LVL521:
3907:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4738              		.loc 1 3907 0
 4739 0014 0446     		mov	r4, r0
 4740 0016 68B9     		cbnz	r0, .L538
 4741              	.LVL522:
3908:Src/bno055.c  **** 		/* Convert the raw linear accel z to m/s2*/
3909:Src/bno055.c  **** 		data_f = (float)
3910:Src/bno055.c  **** 		(reg_linear_accel_z/BNO055_LINEAR_ACCEL_DIV_MSQ);
ARM GAS  /tmp/ccVWLGiI.s 			page 158


 4742              		.loc 1 3910 0
 4743 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4744              	.LVL523:
 4745 001c FFF7FEFF 		bl	__aeabi_i2d
 4746              	.LVL524:
 4747 0020 0022     		movs	r2, #0
 4748 0022 054B     		ldr	r3, .L540
 4749 0024 FFF7FEFF 		bl	__aeabi_ddiv
 4750              	.LVL525:
3909:Src/bno055.c  **** 		(reg_linear_accel_z/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4751              		.loc 1 3909 0
 4752 0028 FFF7FEFF 		bl	__aeabi_d2f
 4753              	.LVL526:
 4754 002c 2860     		str	r0, [r5]	@ float
 4755              	.L537:
 4756              	.LVL527:
3911:Src/bno055.c  **** 		*linear_accel_z_f = data_f;
3912:Src/bno055.c  **** 	} else {
3913:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3914:Src/bno055.c  **** 	}
3915:Src/bno055.c  **** 	return com_rslt;
3916:Src/bno055.c  **** }
 4757              		.loc 1 3916 0
 4758 002e 60B2     		sxtb	r0, r4
 4759 0030 03B0     		add	sp, sp, #12
 4760              	.LCFI193:
 4761              		.cfi_remember_state
 4762              		.cfi_def_cfa_offset 12
 4763              		@ sp needed
 4764 0032 30BD     		pop	{r4, r5, pc}
 4765              	.LVL528:
 4766              	.L538:
 4767              	.LCFI194:
 4768              		.cfi_restore_state
3913:Src/bno055.c  **** 	}
 4769              		.loc 1 3913 0
 4770 0034 FF24     		movs	r4, #255
 4771 0036 FAE7     		b	.L537
 4772              	.L541:
 4773              		.align	2
 4774              	.L540:
 4775 0038 00005940 		.word	1079574528
 4776              		.cfi_endproc
 4777              	.LFE71:
 4779              		.section	.text.bno055_convert_float_linear_accel_xyz_msq,"ax",%progbits
 4780              		.align	2
 4781              		.global	bno055_convert_float_linear_accel_xyz_msq
 4782              		.thumb
 4783              		.thumb_func
 4785              	bno055_convert_float_linear_accel_xyz_msq:
 4786              	.LFB72:
3917:Src/bno055.c  **** /*!
3918:Src/bno055.c  ****  *	@brief This API is used to convert the linear accel xyz raw data
3919:Src/bno055.c  ****  *	to meterpersecseq output as float
3920:Src/bno055.c  ****  *
3921:Src/bno055.c  ****  *	@param linear_accel_xyz : The meterpersecseq data of linear accel xyz
3922:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 159


3923:Src/bno055.c  ****  *	Parameter |    result
3924:Src/bno055.c  ****  *  --------- | -----------------
3925:Src/bno055.c  ****  *	  x       | meterpersecseq data of linear accel
3926:Src/bno055.c  ****  *	  y       | meterpersecseq data of linear accel
3927:Src/bno055.c  ****  *	  z       | meterpersecseq data of linear accel
3928:Src/bno055.c  ****  *
3929:Src/bno055.c  ****  *
3930:Src/bno055.c  ****  *	@return results of bus communication function
3931:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3932:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3933:Src/bno055.c  ****  *
3934:Src/bno055.c  ****  *
3935:Src/bno055.c  ****  */
3936:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_linear_accel_xyz_msq(
3937:Src/bno055.c  **** struct bno055_linear_accel_float_t *linear_accel_xyz)
3938:Src/bno055.c  **** {
 4787              		.loc 1 3938 0
 4788              		.cfi_startproc
 4789              		@ args = 0, pretend = 0, frame = 8
 4790              		@ frame_needed = 0, uses_anonymous_args = 0
 4791              	.LVL529:
 4792 0000 30B5     		push	{r4, r5, lr}
 4793              	.LCFI195:
 4794              		.cfi_def_cfa_offset 12
 4795              		.cfi_offset 4, -12
 4796              		.cfi_offset 5, -8
 4797              		.cfi_offset 14, -4
 4798 0002 83B0     		sub	sp, sp, #12
 4799              	.LCFI196:
 4800              		.cfi_def_cfa_offset 24
3939:Src/bno055.c  **** 	/* Variable used to return value of
3940:Src/bno055.c  **** 	communication routine*/
3941:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3942:Src/bno055.c  **** 	struct bno055_linear_accel_t reg_linear_accel = {
 4801              		.loc 1 3942 0
 4802 0004 0023     		movs	r3, #0
3938:Src/bno055.c  **** 	/* Variable used to return value of
 4803              		.loc 1 3938 0
 4804 0006 0446     		mov	r4, r0
3943:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
3944:Src/bno055.c  **** 	/* Read the raw x of linear accel */
3945:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_xyz(&reg_linear_accel);
 4805              		.loc 1 3945 0
 4806 0008 6846     		mov	r0, sp
 4807              	.LVL530:
3942:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 4808              		.loc 1 3942 0
 4809 000a ADF80030 		strh	r3, [sp]	@ movhi
 4810 000e ADF80230 		strh	r3, [sp, #2]	@ movhi
 4811 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 4812              		.loc 1 3945 0
 4813 0016 FFF7FEFF 		bl	bno055_read_linear_accel_xyz
 4814              	.LVL531:
3946:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4815              		.loc 1 3946 0
 4816 001a 0546     		mov	r5, r0
 4817 001c 18BB     		cbnz	r0, .L544
ARM GAS  /tmp/ccVWLGiI.s 			page 160


3947:Src/bno055.c  **** 		linear_accel_xyz->x =
3948:Src/bno055.c  **** 		(float)(reg_linear_accel.x/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4818              		.loc 1 3948 0
 4819 001e BDF90000 		ldrsh	r0, [sp]
 4820              	.LVL532:
 4821 0022 FFF7FEFF 		bl	__aeabi_i2d
 4822              	.LVL533:
 4823 0026 0022     		movs	r2, #0
 4824 0028 104B     		ldr	r3, .L546
 4825 002a FFF7FEFF 		bl	__aeabi_ddiv
 4826              	.LVL534:
 4827 002e FFF7FEFF 		bl	__aeabi_d2f
 4828              	.LVL535:
 4829 0032 2060     		str	r0, [r4]	@ float
3949:Src/bno055.c  **** 		linear_accel_xyz->y =
3950:Src/bno055.c  **** 		(float)(reg_linear_accel.y/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4830              		.loc 1 3950 0
 4831 0034 BDF90200 		ldrsh	r0, [sp, #2]
 4832 0038 FFF7FEFF 		bl	__aeabi_i2d
 4833              	.LVL536:
 4834 003c 0022     		movs	r2, #0
 4835 003e 0B4B     		ldr	r3, .L546
 4836 0040 FFF7FEFF 		bl	__aeabi_ddiv
 4837              	.LVL537:
 4838 0044 FFF7FEFF 		bl	__aeabi_d2f
 4839              	.LVL538:
 4840 0048 6060     		str	r0, [r4, #4]	@ float
3951:Src/bno055.c  **** 		linear_accel_xyz->z =
3952:Src/bno055.c  **** 		(float)(reg_linear_accel.z/BNO055_LINEAR_ACCEL_DIV_MSQ);
 4841              		.loc 1 3952 0
 4842 004a BDF90400 		ldrsh	r0, [sp, #4]
 4843 004e FFF7FEFF 		bl	__aeabi_i2d
 4844              	.LVL539:
 4845 0052 0022     		movs	r2, #0
 4846 0054 054B     		ldr	r3, .L546
 4847 0056 FFF7FEFF 		bl	__aeabi_ddiv
 4848              	.LVL540:
 4849 005a FFF7FEFF 		bl	__aeabi_d2f
 4850              	.LVL541:
 4851 005e A060     		str	r0, [r4, #8]	@ float
 4852              	.L543:
 4853              	.LVL542:
3953:Src/bno055.c  **** 	} else {
3954:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3955:Src/bno055.c  **** 	}
3956:Src/bno055.c  **** 	return com_rslt;
3957:Src/bno055.c  **** }
 4854              		.loc 1 3957 0
 4855 0060 68B2     		sxtb	r0, r5
 4856 0062 03B0     		add	sp, sp, #12
 4857              	.LCFI197:
 4858              		.cfi_remember_state
 4859              		.cfi_def_cfa_offset 12
 4860              		@ sp needed
 4861 0064 30BD     		pop	{r4, r5, pc}
 4862              	.LVL543:
 4863              	.L544:
ARM GAS  /tmp/ccVWLGiI.s 			page 161


 4864              	.LCFI198:
 4865              		.cfi_restore_state
3954:Src/bno055.c  **** 	}
 4866              		.loc 1 3954 0
 4867 0066 FF25     		movs	r5, #255
 4868 0068 FAE7     		b	.L543
 4869              	.L547:
 4870 006a 00BF     		.align	2
 4871              	.L546:
 4872 006c 00005940 		.word	1079574528
 4873              		.cfi_endproc
 4874              	.LFE72:
 4876              		.section	.text.bno055_convert_gravity_float_x_msq,"ax",%progbits
 4877              		.align	2
 4878              		.global	bno055_convert_gravity_float_x_msq
 4879              		.thumb
 4880              		.thumb_func
 4882              	bno055_convert_gravity_float_x_msq:
 4883              	.LFB73:
3958:Src/bno055.c  **** /*!
3959:Src/bno055.c  ****  *	@brief This API is used to convert the gravity
3960:Src/bno055.c  ****  *	x raw data to meterpersecseq output as float
3961:Src/bno055.c  ****  *
3962:Src/bno055.c  ****  *	@param gravity_x_f : The float value of gravity x meterpersecseq
3963:Src/bno055.c  ****  *
3964:Src/bno055.c  ****  *	@return results of bus communication function
3965:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3966:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3967:Src/bno055.c  ****  *
3968:Src/bno055.c  ****  *
3969:Src/bno055.c  ****  */
3970:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_gravity_float_x_msq(
3971:Src/bno055.c  **** float *gravity_x_f)
3972:Src/bno055.c  **** {
 4884              		.loc 1 3972 0
 4885              		.cfi_startproc
 4886              		@ args = 0, pretend = 0, frame = 8
 4887              		@ frame_needed = 0, uses_anonymous_args = 0
 4888              	.LVL544:
 4889 0000 30B5     		push	{r4, r5, lr}
 4890              	.LCFI199:
 4891              		.cfi_def_cfa_offset 12
 4892              		.cfi_offset 4, -12
 4893              		.cfi_offset 5, -8
 4894              		.cfi_offset 14, -4
 4895 0002 83B0     		sub	sp, sp, #12
 4896              	.LCFI200:
 4897              		.cfi_def_cfa_offset 24
3973:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
3974:Src/bno055.c  **** 	s16 reg_gravity_x_s16 = BNO055_INIT_VALUE;
 4898              		.loc 1 3974 0
 4899 0004 02AB     		add	r3, sp, #8
 4900 0006 0022     		movs	r2, #0
 4901 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4902              	.LVL545:
3972:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 4903              		.loc 1 3972 0
ARM GAS  /tmp/ccVWLGiI.s 			page 162


 4904 000c 0546     		mov	r5, r0
3975:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
3976:Src/bno055.c  **** 	/* Read raw gravity of x*/
3977:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_x(&reg_gravity_x_s16);
 4905              		.loc 1 3977 0
 4906 000e 1846     		mov	r0, r3
 4907              	.LVL546:
 4908 0010 FFF7FEFF 		bl	bno055_read_gravity_x
 4909              	.LVL547:
3978:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4910              		.loc 1 3978 0
 4911 0014 0446     		mov	r4, r0
 4912 0016 68B9     		cbnz	r0, .L550
 4913              	.LVL548:
3979:Src/bno055.c  **** 		/* Convert the raw gravity x to m/s2*/
3980:Src/bno055.c  **** 		data_f = (float)(reg_gravity_x_s16/BNO055_GRAVITY_DIV_MSQ);
 4914              		.loc 1 3980 0
 4915 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4916              	.LVL549:
 4917 001c FFF7FEFF 		bl	__aeabi_i2d
 4918              	.LVL550:
 4919 0020 0022     		movs	r2, #0
 4920 0022 054B     		ldr	r3, .L552
 4921 0024 FFF7FEFF 		bl	__aeabi_ddiv
 4922              	.LVL551:
 4923 0028 FFF7FEFF 		bl	__aeabi_d2f
 4924              	.LVL552:
 4925 002c 2860     		str	r0, [r5]	@ float
 4926              	.L549:
 4927              	.LVL553:
3981:Src/bno055.c  **** 		*gravity_x_f = data_f;
3982:Src/bno055.c  **** 	} else {
3983:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
3984:Src/bno055.c  **** 	}
3985:Src/bno055.c  **** 	return com_rslt;
3986:Src/bno055.c  **** }
 4928              		.loc 1 3986 0
 4929 002e 60B2     		sxtb	r0, r4
 4930 0030 03B0     		add	sp, sp, #12
 4931              	.LCFI201:
 4932              		.cfi_remember_state
 4933              		.cfi_def_cfa_offset 12
 4934              		@ sp needed
 4935 0032 30BD     		pop	{r4, r5, pc}
 4936              	.LVL554:
 4937              	.L550:
 4938              	.LCFI202:
 4939              		.cfi_restore_state
3983:Src/bno055.c  **** 	}
 4940              		.loc 1 3983 0
 4941 0034 FF24     		movs	r4, #255
 4942 0036 FAE7     		b	.L549
 4943              	.L553:
 4944              		.align	2
 4945              	.L552:
 4946 0038 00005940 		.word	1079574528
 4947              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 163


 4948              	.LFE73:
 4950              		.section	.text.bno055_convert_gravity_float_y_msq,"ax",%progbits
 4951              		.align	2
 4952              		.global	bno055_convert_gravity_float_y_msq
 4953              		.thumb
 4954              		.thumb_func
 4956              	bno055_convert_gravity_float_y_msq:
 4957              	.LFB74:
3987:Src/bno055.c  **** /*!
3988:Src/bno055.c  ****  *	@brief This API is used to convert the gravity
3989:Src/bno055.c  ****  *	y raw data to meterpersecseq output as float
3990:Src/bno055.c  ****  *
3991:Src/bno055.c  ****  *	@param gravity_y_f : The float value of gravity y meterpersecseq
3992:Src/bno055.c  ****  *
3993:Src/bno055.c  ****  *	@return results of bus communication function
3994:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
3995:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
3996:Src/bno055.c  ****  *
3997:Src/bno055.c  ****  *
3998:Src/bno055.c  ****  */
3999:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_gravity_float_y_msq(
4000:Src/bno055.c  **** float *gravity_y_f)
4001:Src/bno055.c  **** {
 4958              		.loc 1 4001 0
 4959              		.cfi_startproc
 4960              		@ args = 0, pretend = 0, frame = 8
 4961              		@ frame_needed = 0, uses_anonymous_args = 0
 4962              	.LVL555:
 4963 0000 30B5     		push	{r4, r5, lr}
 4964              	.LCFI203:
 4965              		.cfi_def_cfa_offset 12
 4966              		.cfi_offset 4, -12
 4967              		.cfi_offset 5, -8
 4968              		.cfi_offset 14, -4
 4969 0002 83B0     		sub	sp, sp, #12
 4970              	.LCFI204:
 4971              		.cfi_def_cfa_offset 24
4002:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4003:Src/bno055.c  **** 	s16 reg_gravity_y_s16 = BNO055_INIT_VALUE;
 4972              		.loc 1 4003 0
 4973 0004 02AB     		add	r3, sp, #8
 4974 0006 0022     		movs	r2, #0
 4975 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 4976              	.LVL556:
4001:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 4977              		.loc 1 4001 0
 4978 000c 0546     		mov	r5, r0
4004:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
4005:Src/bno055.c  **** 	/* Read raw gravity of y*/
4006:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_y(&reg_gravity_y_s16);
 4979              		.loc 1 4006 0
 4980 000e 1846     		mov	r0, r3
 4981              	.LVL557:
 4982 0010 FFF7FEFF 		bl	bno055_read_gravity_y
 4983              	.LVL558:
4007:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 4984              		.loc 1 4007 0
ARM GAS  /tmp/ccVWLGiI.s 			page 164


 4985 0014 0446     		mov	r4, r0
 4986 0016 68B9     		cbnz	r0, .L556
 4987              	.LVL559:
4008:Src/bno055.c  **** 		/* Convert the raw gravity y to m/s2*/
4009:Src/bno055.c  **** 		data_f = (float)(reg_gravity_y_s16/BNO055_GRAVITY_DIV_MSQ);
 4988              		.loc 1 4009 0
 4989 0018 BDF90600 		ldrsh	r0, [sp, #6]
 4990              	.LVL560:
 4991 001c FFF7FEFF 		bl	__aeabi_i2d
 4992              	.LVL561:
 4993 0020 0022     		movs	r2, #0
 4994 0022 054B     		ldr	r3, .L558
 4995 0024 FFF7FEFF 		bl	__aeabi_ddiv
 4996              	.LVL562:
 4997 0028 FFF7FEFF 		bl	__aeabi_d2f
 4998              	.LVL563:
 4999 002c 2860     		str	r0, [r5]	@ float
 5000              	.L555:
 5001              	.LVL564:
4010:Src/bno055.c  **** 		*gravity_y_f = data_f;
4011:Src/bno055.c  **** 	} else {
4012:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4013:Src/bno055.c  **** 	}
4014:Src/bno055.c  **** 	return com_rslt;
4015:Src/bno055.c  **** }
 5002              		.loc 1 4015 0
 5003 002e 60B2     		sxtb	r0, r4
 5004 0030 03B0     		add	sp, sp, #12
 5005              	.LCFI205:
 5006              		.cfi_remember_state
 5007              		.cfi_def_cfa_offset 12
 5008              		@ sp needed
 5009 0032 30BD     		pop	{r4, r5, pc}
 5010              	.LVL565:
 5011              	.L556:
 5012              	.LCFI206:
 5013              		.cfi_restore_state
4012:Src/bno055.c  **** 	}
 5014              		.loc 1 4012 0
 5015 0034 FF24     		movs	r4, #255
 5016 0036 FAE7     		b	.L555
 5017              	.L559:
 5018              		.align	2
 5019              	.L558:
 5020 0038 00005940 		.word	1079574528
 5021              		.cfi_endproc
 5022              	.LFE74:
 5024              		.section	.text.bno055_convert_gravity_float_z_msq,"ax",%progbits
 5025              		.align	2
 5026              		.global	bno055_convert_gravity_float_z_msq
 5027              		.thumb
 5028              		.thumb_func
 5030              	bno055_convert_gravity_float_z_msq:
 5031              	.LFB75:
4016:Src/bno055.c  **** /*!
4017:Src/bno055.c  ****  *	@brief This API is used to convert the gravity
4018:Src/bno055.c  ****  *	z raw data to meterpersecseq output as float
ARM GAS  /tmp/ccVWLGiI.s 			page 165


4019:Src/bno055.c  ****  *
4020:Src/bno055.c  ****  *	@param gravity_z_f : The float value of gravity z meterpersecseq
4021:Src/bno055.c  ****  *
4022:Src/bno055.c  ****  *	@return results of bus communication function
4023:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4024:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4025:Src/bno055.c  ****  *
4026:Src/bno055.c  ****  */
4027:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_gravity_float_z_msq(
4028:Src/bno055.c  **** float *gravity_z_f)
4029:Src/bno055.c  **** {
 5032              		.loc 1 4029 0
 5033              		.cfi_startproc
 5034              		@ args = 0, pretend = 0, frame = 8
 5035              		@ frame_needed = 0, uses_anonymous_args = 0
 5036              	.LVL566:
 5037 0000 30B5     		push	{r4, r5, lr}
 5038              	.LCFI207:
 5039              		.cfi_def_cfa_offset 12
 5040              		.cfi_offset 4, -12
 5041              		.cfi_offset 5, -8
 5042              		.cfi_offset 14, -4
 5043 0002 83B0     		sub	sp, sp, #12
 5044              	.LCFI208:
 5045              		.cfi_def_cfa_offset 24
4030:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4031:Src/bno055.c  **** 	s16 reg_gravity_z_s16 = BNO055_INIT_VALUE;
 5046              		.loc 1 4031 0
 5047 0004 02AB     		add	r3, sp, #8
 5048 0006 0022     		movs	r2, #0
 5049 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5050              	.LVL567:
4029:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 5051              		.loc 1 4029 0
 5052 000c 0546     		mov	r5, r0
4032:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
4033:Src/bno055.c  **** 	/* Read raw gravity of z */
4034:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_z(&reg_gravity_z_s16);
 5053              		.loc 1 4034 0
 5054 000e 1846     		mov	r0, r3
 5055              	.LVL568:
 5056 0010 FFF7FEFF 		bl	bno055_read_gravity_z
 5057              	.LVL569:
4035:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5058              		.loc 1 4035 0
 5059 0014 0446     		mov	r4, r0
 5060 0016 68B9     		cbnz	r0, .L562
 5061              	.LVL570:
4036:Src/bno055.c  **** 		/* Convert the raw gravity z to m/s2*/
4037:Src/bno055.c  **** 		data_f = (float)(reg_gravity_z_s16/BNO055_GRAVITY_DIV_MSQ);
 5062              		.loc 1 4037 0
 5063 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5064              	.LVL571:
 5065 001c FFF7FEFF 		bl	__aeabi_i2d
 5066              	.LVL572:
 5067 0020 0022     		movs	r2, #0
 5068 0022 054B     		ldr	r3, .L564
ARM GAS  /tmp/ccVWLGiI.s 			page 166


 5069 0024 FFF7FEFF 		bl	__aeabi_ddiv
 5070              	.LVL573:
 5071 0028 FFF7FEFF 		bl	__aeabi_d2f
 5072              	.LVL574:
 5073 002c 2860     		str	r0, [r5]	@ float
 5074              	.L561:
 5075              	.LVL575:
4038:Src/bno055.c  **** 		*gravity_z_f = data_f;
4039:Src/bno055.c  **** 	} else {
4040:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4041:Src/bno055.c  **** 	}
4042:Src/bno055.c  **** 	return com_rslt;
4043:Src/bno055.c  **** }
 5076              		.loc 1 4043 0
 5077 002e 60B2     		sxtb	r0, r4
 5078 0030 03B0     		add	sp, sp, #12
 5079              	.LCFI209:
 5080              		.cfi_remember_state
 5081              		.cfi_def_cfa_offset 12
 5082              		@ sp needed
 5083 0032 30BD     		pop	{r4, r5, pc}
 5084              	.LVL576:
 5085              	.L562:
 5086              	.LCFI210:
 5087              		.cfi_restore_state
4040:Src/bno055.c  **** 	}
 5088              		.loc 1 4040 0
 5089 0034 FF24     		movs	r4, #255
 5090 0036 FAE7     		b	.L561
 5091              	.L565:
 5092              		.align	2
 5093              	.L564:
 5094 0038 00005940 		.word	1079574528
 5095              		.cfi_endproc
 5096              	.LFE75:
 5098              		.section	.text.bno055_convert_float_gravity_xyz_msq,"ax",%progbits
 5099              		.align	2
 5100              		.global	bno055_convert_float_gravity_xyz_msq
 5101              		.thumb
 5102              		.thumb_func
 5104              	bno055_convert_float_gravity_xyz_msq:
 5105              	.LFB76:
4044:Src/bno055.c  **** /*!
4045:Src/bno055.c  ****  *	@brief This API is used to convert the gravity xyz raw data
4046:Src/bno055.c  ****  *	to meterpersecseq output as float
4047:Src/bno055.c  ****  *
4048:Src/bno055.c  ****  *	@param gravity_xyz : The meterpersecseq data of gravity xyz
4049:Src/bno055.c  ****  *
4050:Src/bno055.c  ****  *	Parameter |    result
4051:Src/bno055.c  ****  *  --------- | -----------------
4052:Src/bno055.c  ****  *	  x       | meterpersecseq data of gravity
4053:Src/bno055.c  ****  *	  y       | meterpersecseq data of gravity
4054:Src/bno055.c  ****  *	  z       | meterpersecseq data of gravity
4055:Src/bno055.c  ****  *
4056:Src/bno055.c  ****  *
4057:Src/bno055.c  ****  *	@return results of bus communication function
4058:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
ARM GAS  /tmp/ccVWLGiI.s 			page 167


4059:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4060:Src/bno055.c  ****  *
4061:Src/bno055.c  ****  *
4062:Src/bno055.c  ****  */
4063:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_gravity_xyz_msq(
4064:Src/bno055.c  **** struct bno055_gravity_float_t *gravity_xyz)
4065:Src/bno055.c  **** {
 5106              		.loc 1 4065 0
 5107              		.cfi_startproc
 5108              		@ args = 0, pretend = 0, frame = 8
 5109              		@ frame_needed = 0, uses_anonymous_args = 0
 5110              	.LVL577:
 5111 0000 30B5     		push	{r4, r5, lr}
 5112              	.LCFI211:
 5113              		.cfi_def_cfa_offset 12
 5114              		.cfi_offset 4, -12
 5115              		.cfi_offset 5, -8
 5116              		.cfi_offset 14, -4
 5117 0002 83B0     		sub	sp, sp, #12
 5118              	.LCFI212:
 5119              		.cfi_def_cfa_offset 24
4066:Src/bno055.c  **** 	/* Variable used to return value of
4067:Src/bno055.c  **** 	communication routine*/
4068:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4069:Src/bno055.c  **** 	struct bno055_gravity_t reg_gravity_xyz = {
 5120              		.loc 1 4069 0
 5121 0004 0023     		movs	r3, #0
4065:Src/bno055.c  **** 	/* Variable used to return value of
 5122              		.loc 1 4065 0
 5123 0006 0446     		mov	r4, r0
4070:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
4071:Src/bno055.c  **** 	/* Read raw gravity of xyz */
4072:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_xyz(&reg_gravity_xyz);
 5124              		.loc 1 4072 0
 5125 0008 6846     		mov	r0, sp
 5126              	.LVL578:
4069:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 5127              		.loc 1 4069 0
 5128 000a ADF80030 		strh	r3, [sp]	@ movhi
 5129 000e ADF80230 		strh	r3, [sp, #2]	@ movhi
 5130 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 5131              		.loc 1 4072 0
 5132 0016 FFF7FEFF 		bl	bno055_read_gravity_xyz
 5133              	.LVL579:
4073:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5134              		.loc 1 4073 0
 5135 001a 0546     		mov	r5, r0
 5136 001c 18BB     		cbnz	r0, .L568
4074:Src/bno055.c  **** 		/* Convert raw gravity xyz to meterpersecseq */
4075:Src/bno055.c  **** 		gravity_xyz->x =
4076:Src/bno055.c  **** 		(float)(reg_gravity_xyz.x/BNO055_GRAVITY_DIV_MSQ);
 5137              		.loc 1 4076 0
 5138 001e BDF90000 		ldrsh	r0, [sp]
 5139              	.LVL580:
 5140 0022 FFF7FEFF 		bl	__aeabi_i2d
 5141              	.LVL581:
 5142 0026 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 168


 5143 0028 104B     		ldr	r3, .L570
 5144 002a FFF7FEFF 		bl	__aeabi_ddiv
 5145              	.LVL582:
 5146 002e FFF7FEFF 		bl	__aeabi_d2f
 5147              	.LVL583:
 5148 0032 2060     		str	r0, [r4]	@ float
4077:Src/bno055.c  **** 		gravity_xyz->y =
4078:Src/bno055.c  **** 		(float)(reg_gravity_xyz.y/BNO055_GRAVITY_DIV_MSQ);
 5149              		.loc 1 4078 0
 5150 0034 BDF90200 		ldrsh	r0, [sp, #2]
 5151 0038 FFF7FEFF 		bl	__aeabi_i2d
 5152              	.LVL584:
 5153 003c 0022     		movs	r2, #0
 5154 003e 0B4B     		ldr	r3, .L570
 5155 0040 FFF7FEFF 		bl	__aeabi_ddiv
 5156              	.LVL585:
 5157 0044 FFF7FEFF 		bl	__aeabi_d2f
 5158              	.LVL586:
 5159 0048 6060     		str	r0, [r4, #4]	@ float
4079:Src/bno055.c  **** 		gravity_xyz->z =
4080:Src/bno055.c  **** 		(float)(reg_gravity_xyz.z/BNO055_GRAVITY_DIV_MSQ);
 5160              		.loc 1 4080 0
 5161 004a BDF90400 		ldrsh	r0, [sp, #4]
 5162 004e FFF7FEFF 		bl	__aeabi_i2d
 5163              	.LVL587:
 5164 0052 0022     		movs	r2, #0
 5165 0054 054B     		ldr	r3, .L570
 5166 0056 FFF7FEFF 		bl	__aeabi_ddiv
 5167              	.LVL588:
 5168 005a FFF7FEFF 		bl	__aeabi_d2f
 5169              	.LVL589:
 5170 005e A060     		str	r0, [r4, #8]	@ float
 5171              	.L567:
 5172              	.LVL590:
4081:Src/bno055.c  **** 	} else {
4082:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4083:Src/bno055.c  **** 	}
4084:Src/bno055.c  **** 	return com_rslt;
4085:Src/bno055.c  **** }
 5173              		.loc 1 4085 0
 5174 0060 68B2     		sxtb	r0, r5
 5175 0062 03B0     		add	sp, sp, #12
 5176              	.LCFI213:
 5177              		.cfi_remember_state
 5178              		.cfi_def_cfa_offset 12
 5179              		@ sp needed
 5180 0064 30BD     		pop	{r4, r5, pc}
 5181              	.LVL591:
 5182              	.L568:
 5183              	.LCFI214:
 5184              		.cfi_restore_state
4082:Src/bno055.c  **** 	}
 5185              		.loc 1 4082 0
 5186 0066 FF25     		movs	r5, #255
 5187 0068 FAE7     		b	.L567
 5188              	.L571:
 5189 006a 00BF     		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 169


 5190              	.L570:
 5191 006c 00005940 		.word	1079574528
 5192              		.cfi_endproc
 5193              	.LFE76:
 5195              		.section	.text.bno055_convert_double_mag_x_uT,"ax",%progbits
 5196              		.align	2
 5197              		.global	bno055_convert_double_mag_x_uT
 5198              		.thumb
 5199              		.thumb_func
 5201              	bno055_convert_double_mag_x_uT:
 5202              	.LFB87:
4086:Src/bno055.c  **** /*!
4087:Src/bno055.c  ****  *	@brief This API is used to convert the temperature
4088:Src/bno055.c  ****  *	data to Fahrenheit output as float
4089:Src/bno055.c  ****  *
4090:Src/bno055.c  ****  *	@param temp_f : The float value of temperature Fahrenheit
4091:Src/bno055.c  ****  *
4092:Src/bno055.c  ****  *	@return results of bus communication function
4093:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4094:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4095:Src/bno055.c  ****  *
4096:Src/bno055.c  ****  *
4097:Src/bno055.c  ****  */
4098:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_temp_fahrenheit(
4099:Src/bno055.c  **** float *temp_f)
4100:Src/bno055.c  **** {
4101:Src/bno055.c  **** 	/* Variable used to return value of
4102:Src/bno055.c  **** 	communication routine*/
4103:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4104:Src/bno055.c  **** 	s8 reg_temp_s8 = BNO055_INIT_VALUE;
4105:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
4106:Src/bno055.c  **** 	u8 temp_unit_u8 = BNO055_INIT_VALUE;
4107:Src/bno055.c  **** 	/* Read the current temperature unit and set the
4108:Src/bno055.c  **** 	unit as Fahrenheit if the unit is in Celsius */
4109:Src/bno055.c  **** 	com_rslt = bno055_get_temp_unit(&temp_unit_u8);
4110:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
4111:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_FAHRENHEIT);
4112:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4113:Src/bno055.c  **** 			/* Read the raw temperature data */
4114:Src/bno055.c  **** 			com_rslt += bno055_read_temp_data(&reg_temp_s8);
4115:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4116:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
4117:Src/bno055.c  **** 				data_f = (float)
4118:Src/bno055.c  **** 				(reg_temp_s8/BNO055_TEMP_DIV_FAHRENHEIT);
4119:Src/bno055.c  **** 				*temp_f = data_f;
4120:Src/bno055.c  **** 			} else {
4121:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4122:Src/bno055.c  **** 			}
4123:Src/bno055.c  **** 		} else {
4124:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4125:Src/bno055.c  **** 		}
4126:Src/bno055.c  **** 	return com_rslt;
4127:Src/bno055.c  **** }
4128:Src/bno055.c  **** /*!
4129:Src/bno055.c  ****  *	@brief This API is used to convert the temperature
4130:Src/bno055.c  ****  *	data to Celsius output as float
4131:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 170


4132:Src/bno055.c  ****  *	@param temp_f : The float value of temperature Celsius
4133:Src/bno055.c  ****  *
4134:Src/bno055.c  ****  *	@return results of bus communication function
4135:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4136:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4137:Src/bno055.c  ****  *
4138:Src/bno055.c  ****  *
4139:Src/bno055.c  ****  *
4140:Src/bno055.c  ****  */
4141:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_float_temp_celsius(
4142:Src/bno055.c  **** float *temp_f)
4143:Src/bno055.c  **** {
4144:Src/bno055.c  **** 	/* Variable used to return value of
4145:Src/bno055.c  **** 	communication routine*/
4146:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4147:Src/bno055.c  **** 	s8 reg_temp_s8 = BNO055_INIT_VALUE;
4148:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
4149:Src/bno055.c  **** 	u8 temp_unit_u8 = BNO055_INIT_VALUE;
4150:Src/bno055.c  **** 	/* Read the current temperature unit and set the
4151:Src/bno055.c  **** 	unit as Fahrenheit if the unit is in Celsius */
4152:Src/bno055.c  **** 	com_rslt = bno055_get_temp_unit(&temp_unit_u8);
4153:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
4154:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_CELSIUS);
4155:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
4156:Src/bno055.c  **** 			/* Read the raw temperature data */
4157:Src/bno055.c  **** 			com_rslt += bno055_read_temp_data(&reg_temp_s8);
4158:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4159:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
4160:Src/bno055.c  **** 				data_f =
4161:Src/bno055.c  **** 				(float)(reg_temp_s8/BNO055_TEMP_DIV_CELSIUS);
4162:Src/bno055.c  **** 				*temp_f = data_f;
4163:Src/bno055.c  **** 			} else {
4164:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4165:Src/bno055.c  **** 			}
4166:Src/bno055.c  **** 		} else {
4167:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4168:Src/bno055.c  **** 		}
4169:Src/bno055.c  **** 	return com_rslt;
4170:Src/bno055.c  **** }
4171:Src/bno055.c  **** #endif
4172:Src/bno055.c  **** #ifdef	BNO055_DOUBLE_ENABLE
4173:Src/bno055.c  **** /*!
4174:Src/bno055.c  ****  *	@brief This API is used to convert the accel x raw data
4175:Src/bno055.c  ****  *	to meterpersecseq output as double
4176:Src/bno055.c  ****  *
4177:Src/bno055.c  ****  *	@param accel_x_d : The accel x meterpersecseq data
4178:Src/bno055.c  ****  *
4179:Src/bno055.c  ****  *
4180:Src/bno055.c  ****  *
4181:Src/bno055.c  ****  *	@return results of bus communication function
4182:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4183:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4184:Src/bno055.c  ****  *
4185:Src/bno055.c  ****  *
4186:Src/bno055.c  ****  */
4187:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_x_msq(
4188:Src/bno055.c  **** double *accel_x_d)
ARM GAS  /tmp/ccVWLGiI.s 			page 171


4189:Src/bno055.c  **** {
4190:Src/bno055.c  **** 	/* Variable used to return value of
4191:Src/bno055.c  **** 	communication routine*/
4192:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4193:Src/bno055.c  **** 	s16 reg_accel_x_s16 = BNO055_INIT_VALUE;
4194:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
4195:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4196:Src/bno055.c  **** 	/* Read the current accel unit and set the
4197:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
4198:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4199:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
4200:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
4201:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4202:Src/bno055.c  **** 			/* Read the accel raw y data*/
4203:Src/bno055.c  **** 			com_rslt += bno055_read_accel_x(&reg_accel_x_s16);
4204:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4205:Src/bno055.c  **** 				/* Convert the raw x to m/s2 */
4206:Src/bno055.c  **** 				data_f =
4207:Src/bno055.c  **** 				(double)(reg_accel_x_s16/BNO055_ACCEL_DIV_MSQ);
4208:Src/bno055.c  **** 				*accel_x_d = data_f;
4209:Src/bno055.c  **** 			} else {
4210:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4211:Src/bno055.c  **** 			}
4212:Src/bno055.c  **** 		} else {
4213:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4214:Src/bno055.c  **** 		}
4215:Src/bno055.c  **** 	return com_rslt;
4216:Src/bno055.c  **** }
4217:Src/bno055.c  **** /*!
4218:Src/bno055.c  ****  *	@brief This API is used to convert the accel x raw data
4219:Src/bno055.c  ****  *	to millig output as double
4220:Src/bno055.c  ****  *
4221:Src/bno055.c  ****  *	@param accel_x_d : The accel x millig data
4222:Src/bno055.c  ****  *
4223:Src/bno055.c  ****  *
4224:Src/bno055.c  ****  *
4225:Src/bno055.c  ****  *	@return results of bus communication function
4226:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4227:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4228:Src/bno055.c  ****  *
4229:Src/bno055.c  ****  *
4230:Src/bno055.c  ****  *
4231:Src/bno055.c  ****  */
4232:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_x_mg(
4233:Src/bno055.c  **** double *accel_x_d)
4234:Src/bno055.c  **** {
4235:Src/bno055.c  **** 	/* Variable used to return value of
4236:Src/bno055.c  **** 	communication routine*/
4237:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4238:Src/bno055.c  **** 	s16 reg_accel_x_s16 = BNO055_INIT_VALUE;
4239:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
4240:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4241:Src/bno055.c  **** 	/* Read the current accel unit and set the
4242:Src/bno055.c  **** 	unit as mg if the unit is in m/s2*/
4243:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4244:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
4245:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
ARM GAS  /tmp/ccVWLGiI.s 			page 172


4246:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4247:Src/bno055.c  **** 			/* Read the accel raw y data*/
4248:Src/bno055.c  **** 			com_rslt += bno055_read_accel_x(&reg_accel_x_s16);
4249:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4250:Src/bno055.c  **** 				/* Convert the raw x to mg */
4251:Src/bno055.c  **** 				data_f =
4252:Src/bno055.c  **** 				(double)(reg_accel_x_s16/BNO055_ACCEL_DIV_MG);
4253:Src/bno055.c  **** 				*accel_x_d = data_f;
4254:Src/bno055.c  **** 			} else {
4255:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4256:Src/bno055.c  **** 			}
4257:Src/bno055.c  **** 		} else {
4258:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4259:Src/bno055.c  **** 		}
4260:Src/bno055.c  **** 	return com_rslt;
4261:Src/bno055.c  **** }
4262:Src/bno055.c  **** /*!
4263:Src/bno055.c  ****  *	@brief This API is used to convert the accel y raw data
4264:Src/bno055.c  ****  *	to meterpersecseq output as double
4265:Src/bno055.c  ****  *
4266:Src/bno055.c  ****  *	@param accel_y_d : The accel y meterpersecseq data
4267:Src/bno055.c  ****  *
4268:Src/bno055.c  ****  *
4269:Src/bno055.c  ****  *
4270:Src/bno055.c  ****  *	@return results of bus communication function
4271:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4272:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4273:Src/bno055.c  ****  *
4274:Src/bno055.c  ****  *
4275:Src/bno055.c  ****  *
4276:Src/bno055.c  ****  */
4277:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_y_msq(
4278:Src/bno055.c  **** double *accel_y_d)
4279:Src/bno055.c  **** {
4280:Src/bno055.c  **** 	/* Variable used to return value of
4281:Src/bno055.c  **** 	communication routine*/
4282:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4283:Src/bno055.c  **** 	s16 reg_accel_y_s16 = BNO055_INIT_VALUE;
4284:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
4285:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4286:Src/bno055.c  **** 	/* Read the current accel unit and set the
4287:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
4288:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4289:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
4290:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
4291:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4292:Src/bno055.c  **** 			/* Read the accel raw y data*/
4293:Src/bno055.c  **** 			com_rslt += bno055_read_accel_y(&reg_accel_y_s16);
4294:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4295:Src/bno055.c  **** 				/* Convert the raw x to m/s2 */
4296:Src/bno055.c  **** 				data_f =
4297:Src/bno055.c  **** 				(double)(reg_accel_y_s16/BNO055_ACCEL_DIV_MSQ);
4298:Src/bno055.c  **** 				*accel_y_d = data_f;
4299:Src/bno055.c  **** 			} else {
4300:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4301:Src/bno055.c  **** 			}
4302:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 173


4303:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4304:Src/bno055.c  **** 		}
4305:Src/bno055.c  **** 	return com_rslt;
4306:Src/bno055.c  **** }
4307:Src/bno055.c  **** /*!
4308:Src/bno055.c  ****  *	@brief This API is used to convert the accel y raw data
4309:Src/bno055.c  ****  *	to millig output as double
4310:Src/bno055.c  ****  *
4311:Src/bno055.c  ****  *	@param accel_y_d : The accel y millig data
4312:Src/bno055.c  ****  *
4313:Src/bno055.c  ****  *
4314:Src/bno055.c  ****  *
4315:Src/bno055.c  ****  *	@return results of bus communication function
4316:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4317:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4318:Src/bno055.c  ****  *
4319:Src/bno055.c  ****  *
4320:Src/bno055.c  ****  */
4321:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_y_mg(
4322:Src/bno055.c  **** double *accel_y_d)
4323:Src/bno055.c  **** {
4324:Src/bno055.c  **** 	/* Variable used to return value of
4325:Src/bno055.c  **** 	communication routine*/
4326:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4327:Src/bno055.c  **** 	s16 reg_accel_y_s16 = BNO055_INIT_VALUE;
4328:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4329:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4330:Src/bno055.c  **** 	/* Read the current accel unit and set the
4331:Src/bno055.c  **** 	unit as mg if the unit is in m/s2*/
4332:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4333:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
4334:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
4335:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4336:Src/bno055.c  **** 			/* Read the accel raw y data*/
4337:Src/bno055.c  **** 			com_rslt += bno055_read_accel_y(&reg_accel_y_s16);
4338:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4339:Src/bno055.c  **** 				/* Convert the raw y to mg */
4340:Src/bno055.c  **** 				data_d =
4341:Src/bno055.c  **** 				(double)(reg_accel_y_s16/BNO055_ACCEL_DIV_MG);
4342:Src/bno055.c  **** 				*accel_y_d = data_d;
4343:Src/bno055.c  **** 			} else {
4344:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4345:Src/bno055.c  **** 			}
4346:Src/bno055.c  **** 		} else {
4347:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4348:Src/bno055.c  **** 		}
4349:Src/bno055.c  **** 	return com_rslt;
4350:Src/bno055.c  **** }
4351:Src/bno055.c  **** /*!
4352:Src/bno055.c  ****  *	@brief This API is used to convert the accel z raw data
4353:Src/bno055.c  ****  *	to meterpersecseq output as double
4354:Src/bno055.c  ****  *
4355:Src/bno055.c  ****  *	@param accel_z_d : The accel z meterpersecseq data
4356:Src/bno055.c  ****  *
4357:Src/bno055.c  ****  *
4358:Src/bno055.c  ****  *
4359:Src/bno055.c  ****  *	@return results of bus communication function
ARM GAS  /tmp/ccVWLGiI.s 			page 174


4360:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4361:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4362:Src/bno055.c  ****  */
4363:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_z_msq(
4364:Src/bno055.c  **** double *accel_z_d)
4365:Src/bno055.c  **** {
4366:Src/bno055.c  **** 	/* Variable used to return value of
4367:Src/bno055.c  **** 	communication routine*/
4368:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4369:Src/bno055.c  **** 	s16 reg_accel_z_s16 = BNO055_INIT_VALUE;
4370:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4371:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4372:Src/bno055.c  **** 	/* Read the current accel unit and set the
4373:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
4374:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4375:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
4376:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
4377:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4378:Src/bno055.c  **** 			/* Read the accel raw z data*/
4379:Src/bno055.c  **** 			com_rslt += bno055_read_accel_z(&reg_accel_z_s16);
4380:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4381:Src/bno055.c  **** 				/* Convert the raw z to m/s2 */
4382:Src/bno055.c  **** 				data_d =
4383:Src/bno055.c  **** 				(double)(reg_accel_z_s16/BNO055_ACCEL_DIV_MSQ);
4384:Src/bno055.c  **** 				*accel_z_d = data_d;
4385:Src/bno055.c  **** 			} else {
4386:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4387:Src/bno055.c  **** 			}
4388:Src/bno055.c  **** 		} else {
4389:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4390:Src/bno055.c  **** 		}
4391:Src/bno055.c  **** 	return com_rslt;
4392:Src/bno055.c  **** }
4393:Src/bno055.c  **** /*!
4394:Src/bno055.c  ****  *	@brief This API is used to convert the accel z raw data
4395:Src/bno055.c  ****  *	to millig output as double
4396:Src/bno055.c  ****  *
4397:Src/bno055.c  ****  *	@param accel_z_d : The accel z millig data
4398:Src/bno055.c  ****  *
4399:Src/bno055.c  ****  *
4400:Src/bno055.c  ****  *
4401:Src/bno055.c  ****  *	@return results of bus communication function
4402:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4403:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4404:Src/bno055.c  ****  *
4405:Src/bno055.c  ****  */
4406:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_z_mg(
4407:Src/bno055.c  **** double *accel_z_d)
4408:Src/bno055.c  **** {
4409:Src/bno055.c  **** 	/* Variable used to return value of
4410:Src/bno055.c  **** 	communication routine*/
4411:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4412:Src/bno055.c  **** 	s16 reg_accel_z_s16 = BNO055_INIT_VALUE;
4413:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4414:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4415:Src/bno055.c  **** 	/* Read the current accel unit and set the
4416:Src/bno055.c  **** 	unit as mg if the unit is in m/s2*/
ARM GAS  /tmp/ccVWLGiI.s 			page 175


4417:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4418:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
4419:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
4420:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4421:Src/bno055.c  **** 			/* Read the accel raw z data*/
4422:Src/bno055.c  **** 			com_rslt += bno055_read_accel_z(&reg_accel_z_s16);
4423:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4424:Src/bno055.c  **** 				/* Convert the raw z to mg */
4425:Src/bno055.c  **** 				data_d =
4426:Src/bno055.c  **** 				(double)(reg_accel_z_s16/BNO055_ACCEL_DIV_MG);
4427:Src/bno055.c  **** 				*accel_z_d = data_d;
4428:Src/bno055.c  **** 			} else {
4429:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4430:Src/bno055.c  **** 			}
4431:Src/bno055.c  **** 		} else {
4432:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4433:Src/bno055.c  **** 		}
4434:Src/bno055.c  **** 	return com_rslt;
4435:Src/bno055.c  **** }
4436:Src/bno055.c  **** /*!
4437:Src/bno055.c  ****  *	@brief This API is used to convert the accel xyz raw data
4438:Src/bno055.c  ****  *	to meterpersecseq output as double
4439:Src/bno055.c  ****  *
4440:Src/bno055.c  ****  *	@param accel_xyz : The meterpersecseq data of accel xyz
4441:Src/bno055.c  ****  *
4442:Src/bno055.c  ****  *	Parameter |    result
4443:Src/bno055.c  ****  *  --------- | -----------------
4444:Src/bno055.c  ****  *	 x        | meterpersecseq data of accel
4445:Src/bno055.c  ****  *	 y        | meterpersecseq data of accel
4446:Src/bno055.c  ****  *	 z        | meterpersecseq data of accel
4447:Src/bno055.c  ****  *
4448:Src/bno055.c  ****  *
4449:Src/bno055.c  ****  *	@return results of bus communication function
4450:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4451:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4452:Src/bno055.c  ****  *
4453:Src/bno055.c  ****  *
4454:Src/bno055.c  ****  */
4455:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_xyz_msq(
4456:Src/bno055.c  **** struct bno055_accel_double_t *accel_xyz)
4457:Src/bno055.c  **** {
4458:Src/bno055.c  **** 	/* Variable used to return value of
4459:Src/bno055.c  **** 	communication routine*/
4460:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4461:Src/bno055.c  **** 	struct bno055_accel_t reg_accel_xyz = {
4462:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
4463:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4464:Src/bno055.c  **** 	/* Read the current accel unit and set the
4465:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
4466:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4467:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
4468:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
4469:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4470:Src/bno055.c  **** 			/* Read the accel raw xyz data*/
4471:Src/bno055.c  **** 			com_rslt += bno055_read_accel_xyz(&reg_accel_xyz);
4472:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4473:Src/bno055.c  **** 				/* Convert raw xyz to m/s2*/
ARM GAS  /tmp/ccVWLGiI.s 			page 176


4474:Src/bno055.c  **** 				accel_xyz->x =
4475:Src/bno055.c  **** 				(double)(reg_accel_xyz.x/BNO055_ACCEL_DIV_MSQ);
4476:Src/bno055.c  **** 				accel_xyz->y =
4477:Src/bno055.c  **** 				(double)(reg_accel_xyz.y/BNO055_ACCEL_DIV_MSQ);
4478:Src/bno055.c  **** 				accel_xyz->z =
4479:Src/bno055.c  **** 				(double)(reg_accel_xyz.z/BNO055_ACCEL_DIV_MSQ);
4480:Src/bno055.c  **** 			} else {
4481:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4482:Src/bno055.c  **** 			}
4483:Src/bno055.c  **** 		} else {
4484:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4485:Src/bno055.c  **** 		}
4486:Src/bno055.c  **** 	return com_rslt;
4487:Src/bno055.c  **** }
4488:Src/bno055.c  **** /*!
4489:Src/bno055.c  ****  *	@brief This API is used to convert the accel xyz raw data
4490:Src/bno055.c  ****  *	to millig output as double
4491:Src/bno055.c  ****  *
4492:Src/bno055.c  ****  *	@param accel_xyz : The millig data of accel xyz
4493:Src/bno055.c  ****  *
4494:Src/bno055.c  ****  *	Parameter |    result
4495:Src/bno055.c  ****  *  --------- | -----------------
4496:Src/bno055.c  ****  *	 x        | millig data of accel
4497:Src/bno055.c  ****  *	 y        | millig data of accel
4498:Src/bno055.c  ****  *	 z        | millig data of accel
4499:Src/bno055.c  ****  *
4500:Src/bno055.c  ****  *
4501:Src/bno055.c  ****  *	@return results of bus communication function
4502:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4503:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4504:Src/bno055.c  ****  *
4505:Src/bno055.c  ****  */
4506:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_accel_xyz_mg(
4507:Src/bno055.c  **** struct bno055_accel_double_t *accel_xyz)
4508:Src/bno055.c  **** {
4509:Src/bno055.c  **** 	/* Variable used to return value of
4510:Src/bno055.c  **** 	communication routine*/
4511:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4512:Src/bno055.c  **** 	struct bno055_accel_t reg_accel_xyz = {
4513:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
4514:Src/bno055.c  **** 	u8 accel_unit_u8 = BNO055_INIT_VALUE;
4515:Src/bno055.c  **** 	/* Read the current accel unit and set the
4516:Src/bno055.c  **** 	unit as m/s2 if the unit is in mg*/
4517:Src/bno055.c  **** 	com_rslt = bno055_get_accel_unit(&accel_unit_u8);
4518:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
4519:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
4520:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4521:Src/bno055.c  **** 			/* Read the accel raw xyz data*/
4522:Src/bno055.c  **** 			com_rslt += bno055_read_accel_xyz(&reg_accel_xyz);
4523:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4524:Src/bno055.c  **** 				/* Convert raw xyz to mg*/
4525:Src/bno055.c  **** 				accel_xyz->x =
4526:Src/bno055.c  **** 				(double)(reg_accel_xyz.x/BNO055_ACCEL_DIV_MG);
4527:Src/bno055.c  **** 				accel_xyz->y =
4528:Src/bno055.c  **** 				(double)(reg_accel_xyz.y/BNO055_ACCEL_DIV_MG);
4529:Src/bno055.c  **** 				accel_xyz->z =
4530:Src/bno055.c  **** 				(double)(reg_accel_xyz.z/BNO055_ACCEL_DIV_MG);
ARM GAS  /tmp/ccVWLGiI.s 			page 177


4531:Src/bno055.c  **** 			} else {
4532:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4533:Src/bno055.c  **** 			}
4534:Src/bno055.c  **** 		} else {
4535:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4536:Src/bno055.c  **** 		}
4537:Src/bno055.c  **** 	return com_rslt;
4538:Src/bno055.c  **** }
4539:Src/bno055.c  **** /*!
4540:Src/bno055.c  ****  *	@brief This API is used to convert the mag x raw data
4541:Src/bno055.c  ****  *	to microTesla output as double
4542:Src/bno055.c  ****  *
4543:Src/bno055.c  ****  *	@param mag_x_d : The mag x microTesla data
4544:Src/bno055.c  ****  *
4545:Src/bno055.c  ****  *
4546:Src/bno055.c  ****  *
4547:Src/bno055.c  ****  *	@return results of bus communication function
4548:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4549:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4550:Src/bno055.c  ****  *
4551:Src/bno055.c  ****  *
4552:Src/bno055.c  ****  *
4553:Src/bno055.c  ****  */
4554:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_mag_x_uT(
4555:Src/bno055.c  **** double *mag_x_d)
4556:Src/bno055.c  **** {
 5203              		.loc 1 4556 0
 5204              		.cfi_startproc
 5205              		@ args = 0, pretend = 0, frame = 8
 5206              		@ frame_needed = 0, uses_anonymous_args = 0
 5207              	.LVL592:
 5208 0000 30B5     		push	{r4, r5, lr}
 5209              	.LCFI215:
 5210              		.cfi_def_cfa_offset 12
 5211              		.cfi_offset 4, -12
 5212              		.cfi_offset 5, -8
 5213              		.cfi_offset 14, -4
 5214 0002 83B0     		sub	sp, sp, #12
 5215              	.LCFI216:
 5216              		.cfi_def_cfa_offset 24
4557:Src/bno055.c  **** 	/* Variable used to return value of
4558:Src/bno055.c  **** 	communication routine*/
4559:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4560:Src/bno055.c  **** 	s16 reg_mag_x_s16 = BNO055_INIT_VALUE;
 5217              		.loc 1 4560 0
 5218 0004 02AB     		add	r3, sp, #8
 5219 0006 0022     		movs	r2, #0
 5220 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5221              	.LVL593:
4556:Src/bno055.c  **** 	/* Variable used to return value of
 5222              		.loc 1 4556 0
 5223 000c 0546     		mov	r5, r0
4561:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4562:Src/bno055.c  **** 	/* Read raw mag x data */
4563:Src/bno055.c  **** 	com_rslt = bno055_read_mag_x(&reg_mag_x_s16);
 5224              		.loc 1 4563 0
 5225 000e 1846     		mov	r0, r3
ARM GAS  /tmp/ccVWLGiI.s 			page 178


 5226              	.LVL594:
 5227 0010 FFF7FEFF 		bl	bno055_read_mag_x
 5228              	.LVL595:
4564:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5229              		.loc 1 4564 0
 5230 0014 0446     		mov	r4, r0
 5231 0016 60B9     		cbnz	r0, .L574
 5232              	.LVL596:
4565:Src/bno055.c  **** 		/* Convert raw mag x to microTesla */
4566:Src/bno055.c  **** 		data_d = (double)(reg_mag_x_s16/BNO055_MAG_DIV_UT);
 5233              		.loc 1 4566 0
 5234 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5235              	.LVL597:
 5236 001c FFF7FEFF 		bl	__aeabi_i2d
 5237              	.LVL598:
 5238 0020 0022     		movs	r2, #0
 5239 0022 054B     		ldr	r3, .L576
 5240 0024 FFF7FEFF 		bl	__aeabi_dmul
 5241              	.LVL599:
4567:Src/bno055.c  **** 		*mag_x_d = data_d;
 5242              		.loc 1 4567 0
 5243 0028 C5E90001 		strd	r0, [r5]
 5244              	.L573:
 5245              	.LVL600:
4568:Src/bno055.c  **** 	} else {
4569:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
4570:Src/bno055.c  **** 	}
4571:Src/bno055.c  **** 	return com_rslt;
4572:Src/bno055.c  **** }
 5246              		.loc 1 4572 0
 5247 002c 60B2     		sxtb	r0, r4
 5248 002e 03B0     		add	sp, sp, #12
 5249              	.LCFI217:
 5250              		.cfi_remember_state
 5251              		.cfi_def_cfa_offset 12
 5252              		@ sp needed
 5253 0030 30BD     		pop	{r4, r5, pc}
 5254              	.LVL601:
 5255              	.L574:
 5256              	.LCFI218:
 5257              		.cfi_restore_state
4569:Src/bno055.c  **** 	}
 5258              		.loc 1 4569 0
 5259 0032 FF24     		movs	r4, #255
 5260 0034 FAE7     		b	.L573
 5261              	.L577:
 5262 0036 00BF     		.align	2
 5263              	.L576:
 5264 0038 0000B03F 		.word	1068498944
 5265              		.cfi_endproc
 5266              	.LFE87:
 5268              		.section	.text.bno055_convert_double_mag_y_uT,"ax",%progbits
 5269              		.align	2
 5270              		.global	bno055_convert_double_mag_y_uT
 5271              		.thumb
 5272              		.thumb_func
 5274              	bno055_convert_double_mag_y_uT:
ARM GAS  /tmp/ccVWLGiI.s 			page 179


 5275              	.LFB88:
4573:Src/bno055.c  **** /*!
4574:Src/bno055.c  ****  *	@brief This API is used to convert the mag y raw data
4575:Src/bno055.c  ****  *	to microTesla output as double
4576:Src/bno055.c  ****  *
4577:Src/bno055.c  ****  *	@param mag_y_d : The mag y microTesla data
4578:Src/bno055.c  ****  *
4579:Src/bno055.c  ****  *
4580:Src/bno055.c  ****  *
4581:Src/bno055.c  ****  *	@return results of bus communication function
4582:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4583:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4584:Src/bno055.c  ****  *
4585:Src/bno055.c  ****  *
4586:Src/bno055.c  ****  */
4587:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_mag_y_uT(
4588:Src/bno055.c  **** double *mag_y_d)
4589:Src/bno055.c  **** {
 5276              		.loc 1 4589 0
 5277              		.cfi_startproc
 5278              		@ args = 0, pretend = 0, frame = 8
 5279              		@ frame_needed = 0, uses_anonymous_args = 0
 5280              	.LVL602:
 5281 0000 30B5     		push	{r4, r5, lr}
 5282              	.LCFI219:
 5283              		.cfi_def_cfa_offset 12
 5284              		.cfi_offset 4, -12
 5285              		.cfi_offset 5, -8
 5286              		.cfi_offset 14, -4
 5287 0002 83B0     		sub	sp, sp, #12
 5288              	.LCFI220:
 5289              		.cfi_def_cfa_offset 24
4590:Src/bno055.c  **** 	/* Variable used to return value of
4591:Src/bno055.c  **** 	communication routine*/
4592:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4593:Src/bno055.c  **** 	s16 reg_mag_y_s16 = BNO055_INIT_VALUE;
 5290              		.loc 1 4593 0
 5291 0004 02AB     		add	r3, sp, #8
 5292 0006 0022     		movs	r2, #0
 5293 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5294              	.LVL603:
4589:Src/bno055.c  **** 	/* Variable used to return value of
 5295              		.loc 1 4589 0
 5296 000c 0546     		mov	r5, r0
4594:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4595:Src/bno055.c  **** 	/* Read raw mag y data */
4596:Src/bno055.c  **** 	com_rslt = bno055_read_mag_y(&reg_mag_y_s16);
 5297              		.loc 1 4596 0
 5298 000e 1846     		mov	r0, r3
 5299              	.LVL604:
 5300 0010 FFF7FEFF 		bl	bno055_read_mag_y
 5301              	.LVL605:
4597:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5302              		.loc 1 4597 0
 5303 0014 0446     		mov	r4, r0
 5304 0016 60B9     		cbnz	r0, .L580
 5305              	.LVL606:
ARM GAS  /tmp/ccVWLGiI.s 			page 180


4598:Src/bno055.c  **** 		/* Convert raw mag y to microTesla */
4599:Src/bno055.c  **** 		data_d = (double)(reg_mag_y_s16/BNO055_MAG_DIV_UT);
 5306              		.loc 1 4599 0
 5307 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5308              	.LVL607:
 5309 001c FFF7FEFF 		bl	__aeabi_i2d
 5310              	.LVL608:
 5311 0020 0022     		movs	r2, #0
 5312 0022 054B     		ldr	r3, .L582
 5313 0024 FFF7FEFF 		bl	__aeabi_dmul
 5314              	.LVL609:
4600:Src/bno055.c  **** 		*mag_y_d = data_d;
 5315              		.loc 1 4600 0
 5316 0028 C5E90001 		strd	r0, [r5]
 5317              	.L579:
 5318              	.LVL610:
4601:Src/bno055.c  **** 	} else {
4602:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
4603:Src/bno055.c  **** 	}
4604:Src/bno055.c  **** 	return com_rslt;
4605:Src/bno055.c  **** }
 5319              		.loc 1 4605 0
 5320 002c 60B2     		sxtb	r0, r4
 5321 002e 03B0     		add	sp, sp, #12
 5322              	.LCFI221:
 5323              		.cfi_remember_state
 5324              		.cfi_def_cfa_offset 12
 5325              		@ sp needed
 5326 0030 30BD     		pop	{r4, r5, pc}
 5327              	.LVL611:
 5328              	.L580:
 5329              	.LCFI222:
 5330              		.cfi_restore_state
4602:Src/bno055.c  **** 	}
 5331              		.loc 1 4602 0
 5332 0032 FF24     		movs	r4, #255
 5333 0034 FAE7     		b	.L579
 5334              	.L583:
 5335 0036 00BF     		.align	2
 5336              	.L582:
 5337 0038 0000B03F 		.word	1068498944
 5338              		.cfi_endproc
 5339              	.LFE88:
 5341              		.section	.text.bno055_convert_double_mag_z_uT,"ax",%progbits
 5342              		.align	2
 5343              		.global	bno055_convert_double_mag_z_uT
 5344              		.thumb
 5345              		.thumb_func
 5347              	bno055_convert_double_mag_z_uT:
 5348              	.LFB89:
4606:Src/bno055.c  **** /*!
4607:Src/bno055.c  ****  *	@brief This API is used to convert the mag z raw data
4608:Src/bno055.c  ****  *	to microTesla output as double
4609:Src/bno055.c  ****  *
4610:Src/bno055.c  ****  *	@param mag_z_d : The mag z microTesla data
4611:Src/bno055.c  ****  *
4612:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 181


4613:Src/bno055.c  ****  *
4614:Src/bno055.c  ****  *	@return results of bus communication function
4615:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4616:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4617:Src/bno055.c  ****  *
4618:Src/bno055.c  ****  *
4619:Src/bno055.c  ****  */
4620:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_mag_z_uT(
4621:Src/bno055.c  **** double *mag_z_d)
4622:Src/bno055.c  **** {
 5349              		.loc 1 4622 0
 5350              		.cfi_startproc
 5351              		@ args = 0, pretend = 0, frame = 8
 5352              		@ frame_needed = 0, uses_anonymous_args = 0
 5353              	.LVL612:
 5354 0000 30B5     		push	{r4, r5, lr}
 5355              	.LCFI223:
 5356              		.cfi_def_cfa_offset 12
 5357              		.cfi_offset 4, -12
 5358              		.cfi_offset 5, -8
 5359              		.cfi_offset 14, -4
 5360 0002 83B0     		sub	sp, sp, #12
 5361              	.LCFI224:
 5362              		.cfi_def_cfa_offset 24
4623:Src/bno055.c  **** 	/* Variable used to return value of
4624:Src/bno055.c  **** 	communication routine*/
4625:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4626:Src/bno055.c  **** 	s16 reg_mag_z_s16 = BNO055_INIT_VALUE;
 5363              		.loc 1 4626 0
 5364 0004 02AB     		add	r3, sp, #8
 5365 0006 0022     		movs	r2, #0
 5366 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5367              	.LVL613:
4622:Src/bno055.c  **** 	/* Variable used to return value of
 5368              		.loc 1 4622 0
 5369 000c 0546     		mov	r5, r0
4627:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4628:Src/bno055.c  **** 	/* Read raw mag x */
4629:Src/bno055.c  **** 	com_rslt = bno055_read_mag_z(&reg_mag_z_s16);
 5370              		.loc 1 4629 0
 5371 000e 1846     		mov	r0, r3
 5372              	.LVL614:
 5373 0010 FFF7FEFF 		bl	bno055_read_mag_z
 5374              	.LVL615:
4630:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5375              		.loc 1 4630 0
 5376 0014 0446     		mov	r4, r0
 5377 0016 60B9     		cbnz	r0, .L586
 5378              	.LVL616:
4631:Src/bno055.c  **** 		/* Convert raw mag x to microTesla */
4632:Src/bno055.c  **** 		data_d = (double)(reg_mag_z_s16/BNO055_MAG_DIV_UT);
 5379              		.loc 1 4632 0
 5380 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5381              	.LVL617:
 5382 001c FFF7FEFF 		bl	__aeabi_i2d
 5383              	.LVL618:
 5384 0020 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 182


 5385 0022 054B     		ldr	r3, .L588
 5386 0024 FFF7FEFF 		bl	__aeabi_dmul
 5387              	.LVL619:
4633:Src/bno055.c  **** 		*mag_z_d = data_d;
 5388              		.loc 1 4633 0
 5389 0028 C5E90001 		strd	r0, [r5]
 5390              	.L585:
 5391              	.LVL620:
4634:Src/bno055.c  **** 	} else {
4635:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
4636:Src/bno055.c  **** 	}
4637:Src/bno055.c  **** 	return com_rslt;
4638:Src/bno055.c  **** }
 5392              		.loc 1 4638 0
 5393 002c 60B2     		sxtb	r0, r4
 5394 002e 03B0     		add	sp, sp, #12
 5395              	.LCFI225:
 5396              		.cfi_remember_state
 5397              		.cfi_def_cfa_offset 12
 5398              		@ sp needed
 5399 0030 30BD     		pop	{r4, r5, pc}
 5400              	.LVL621:
 5401              	.L586:
 5402              	.LCFI226:
 5403              		.cfi_restore_state
4635:Src/bno055.c  **** 	}
 5404              		.loc 1 4635 0
 5405 0032 FF24     		movs	r4, #255
 5406 0034 FAE7     		b	.L585
 5407              	.L589:
 5408 0036 00BF     		.align	2
 5409              	.L588:
 5410 0038 0000B03F 		.word	1068498944
 5411              		.cfi_endproc
 5412              	.LFE89:
 5414              		.section	.text.bno055_convert_double_mag_xyz_uT,"ax",%progbits
 5415              		.align	2
 5416              		.global	bno055_convert_double_mag_xyz_uT
 5417              		.thumb
 5418              		.thumb_func
 5420              	bno055_convert_double_mag_xyz_uT:
 5421              	.LFB90:
4639:Src/bno055.c  **** /*!
4640:Src/bno055.c  ****  *	@brief This API is used to convert the mag yz raw data
4641:Src/bno055.c  ****  *	to microTesla output as double
4642:Src/bno055.c  ****  *
4643:Src/bno055.c  ****  *	@param mag_xyz : The microTesla data of mag xyz
4644:Src/bno055.c  ****  *
4645:Src/bno055.c  ****  *	Parameter |    result
4646:Src/bno055.c  ****  *  --------- | -----------------
4647:Src/bno055.c  ****  *	 x        | microTesla data of mag
4648:Src/bno055.c  ****  *	 y        | microTesla data of mag
4649:Src/bno055.c  ****  *	 z        | microTesla data of mag
4650:Src/bno055.c  ****  *
4651:Src/bno055.c  ****  *
4652:Src/bno055.c  ****  *	@return results of bus communication function
4653:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
ARM GAS  /tmp/ccVWLGiI.s 			page 183


4654:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4655:Src/bno055.c  ****  *
4656:Src/bno055.c  ****  */
4657:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_mag_xyz_uT(
4658:Src/bno055.c  **** struct bno055_mag_double_t *mag_xyz)
4659:Src/bno055.c  **** {
 5422              		.loc 1 4659 0
 5423              		.cfi_startproc
 5424              		@ args = 0, pretend = 0, frame = 8
 5425              		@ frame_needed = 0, uses_anonymous_args = 0
 5426              	.LVL622:
 5427 0000 30B5     		push	{r4, r5, lr}
 5428              	.LCFI227:
 5429              		.cfi_def_cfa_offset 12
 5430              		.cfi_offset 4, -12
 5431              		.cfi_offset 5, -8
 5432              		.cfi_offset 14, -4
 5433 0002 83B0     		sub	sp, sp, #12
 5434              	.LCFI228:
 5435              		.cfi_def_cfa_offset 24
4660:Src/bno055.c  **** 	/* Variable used to return value of
4661:Src/bno055.c  **** 	communication routine*/
4662:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4663:Src/bno055.c  **** 	struct bno055_mag_t reg_mag_xyz = {
 5436              		.loc 1 4663 0
 5437 0004 0023     		movs	r3, #0
4659:Src/bno055.c  **** 	/* Variable used to return value of
 5438              		.loc 1 4659 0
 5439 0006 0446     		mov	r4, r0
4664:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
4665:Src/bno055.c  **** 	/* Read raw mag xyz data */
4666:Src/bno055.c  **** 	com_rslt = bno055_read_mag_xyz(&reg_mag_xyz);
 5440              		.loc 1 4666 0
 5441 0008 6846     		mov	r0, sp
 5442              	.LVL623:
4663:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 5443              		.loc 1 4663 0
 5444 000a ADF80030 		strh	r3, [sp]	@ movhi
 5445 000e ADF80230 		strh	r3, [sp, #2]	@ movhi
 5446 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 5447              		.loc 1 4666 0
 5448 0016 FFF7FEFF 		bl	bno055_read_mag_xyz
 5449              	.LVL624:
4667:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5450              		.loc 1 4667 0
 5451 001a 0546     		mov	r5, r0
 5452 001c 00BB     		cbnz	r0, .L592
4668:Src/bno055.c  **** 		/* Convert raw mag xyz to microTesla*/
4669:Src/bno055.c  **** 		mag_xyz->x =
4670:Src/bno055.c  **** 		(double)(reg_mag_xyz.x/BNO055_MAG_DIV_UT);
 5453              		.loc 1 4670 0
 5454 001e BDF90000 		ldrsh	r0, [sp]
 5455              	.LVL625:
 5456 0022 FFF7FEFF 		bl	__aeabi_i2d
 5457              	.LVL626:
 5458 0026 0022     		movs	r2, #0
 5459 0028 0E4B     		ldr	r3, .L594
ARM GAS  /tmp/ccVWLGiI.s 			page 184


 5460 002a FFF7FEFF 		bl	__aeabi_dmul
 5461              	.LVL627:
4669:Src/bno055.c  **** 		(double)(reg_mag_xyz.x/BNO055_MAG_DIV_UT);
 5462              		.loc 1 4669 0
 5463 002e C4E90001 		strd	r0, [r4]
4671:Src/bno055.c  **** 		mag_xyz->y =
4672:Src/bno055.c  **** 		(double)(reg_mag_xyz.y/BNO055_MAG_DIV_UT);
 5464              		.loc 1 4672 0
 5465 0032 BDF90200 		ldrsh	r0, [sp, #2]
 5466 0036 FFF7FEFF 		bl	__aeabi_i2d
 5467              	.LVL628:
 5468 003a 0022     		movs	r2, #0
 5469 003c 094B     		ldr	r3, .L594
 5470 003e FFF7FEFF 		bl	__aeabi_dmul
 5471              	.LVL629:
4671:Src/bno055.c  **** 		mag_xyz->y =
 5472              		.loc 1 4671 0
 5473 0042 C4E90201 		strd	r0, [r4, #8]
4673:Src/bno055.c  **** 		mag_xyz->z =
4674:Src/bno055.c  **** 		(double)(reg_mag_xyz.z/BNO055_MAG_DIV_UT);
 5474              		.loc 1 4674 0
 5475 0046 BDF90400 		ldrsh	r0, [sp, #4]
 5476 004a FFF7FEFF 		bl	__aeabi_i2d
 5477              	.LVL630:
 5478 004e 0022     		movs	r2, #0
 5479 0050 044B     		ldr	r3, .L594
 5480 0052 FFF7FEFF 		bl	__aeabi_dmul
 5481              	.LVL631:
4673:Src/bno055.c  **** 		mag_xyz->z =
 5482              		.loc 1 4673 0
 5483 0056 C4E90401 		strd	r0, [r4, #16]
 5484              	.L591:
 5485              	.LVL632:
4675:Src/bno055.c  **** 	} else {
4676:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
4677:Src/bno055.c  **** 	}
4678:Src/bno055.c  **** 
4679:Src/bno055.c  **** 	return com_rslt;
4680:Src/bno055.c  **** }
 5486              		.loc 1 4680 0
 5487 005a 68B2     		sxtb	r0, r5
 5488 005c 03B0     		add	sp, sp, #12
 5489              	.LCFI229:
 5490              		.cfi_remember_state
 5491              		.cfi_def_cfa_offset 12
 5492              		@ sp needed
 5493 005e 30BD     		pop	{r4, r5, pc}
 5494              	.LVL633:
 5495              	.L592:
 5496              	.LCFI230:
 5497              		.cfi_restore_state
4676:Src/bno055.c  **** 	}
 5498              		.loc 1 4676 0
 5499 0060 FF25     		movs	r5, #255
 5500 0062 FAE7     		b	.L591
 5501              	.L595:
 5502              		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 185


 5503              	.L594:
 5504 0064 0000B03F 		.word	1068498944
 5505              		.cfi_endproc
 5506              	.LFE90:
 5508              		.section	.text.bno055_convert_double_linear_accel_x_msq,"ax",%progbits
 5509              		.align	2
 5510              		.global	bno055_convert_double_linear_accel_x_msq
 5511              		.thumb
 5512              		.thumb_func
 5514              	bno055_convert_double_linear_accel_x_msq:
 5515              	.LFB107:
4681:Src/bno055.c  **** /*!
4682:Src/bno055.c  ****  *	@brief This API is used to convert the gyro x raw data
4683:Src/bno055.c  ****  *	to dps output as double
4684:Src/bno055.c  ****  *
4685:Src/bno055.c  ****  *	@param gyro_x_d : The gyro x dps double data
4686:Src/bno055.c  ****  *
4687:Src/bno055.c  ****  *
4688:Src/bno055.c  ****  *
4689:Src/bno055.c  ****  *	@return results of bus communication function
4690:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4691:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4692:Src/bno055.c  ****  *
4693:Src/bno055.c  ****  *
4694:Src/bno055.c  ****  */
4695:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_x_dps(
4696:Src/bno055.c  **** double *gyro_x_d)
4697:Src/bno055.c  **** {
4698:Src/bno055.c  **** 	/* Variable used to return value of
4699:Src/bno055.c  **** 	communication routine*/
4700:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4701:Src/bno055.c  **** 	s16 reg_gyro_x_s16 = BNO055_INIT_VALUE;
4702:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4703:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4704:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4705:Src/bno055.c  **** 	unit as dps if the unit is in rps */
4706:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4707:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
4708:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
4709:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4710:Src/bno055.c  **** 			/* Read gyro raw x data */
4711:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_x(&reg_gyro_x_s16);
4712:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4713:Src/bno055.c  **** 				/* Convert raw gyro x to dps */
4714:Src/bno055.c  **** 				data_d =
4715:Src/bno055.c  **** 				(double)(reg_gyro_x_s16/BNO055_GYRO_DIV_DPS);
4716:Src/bno055.c  **** 				*gyro_x_d = data_d;
4717:Src/bno055.c  **** 			} else {
4718:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4719:Src/bno055.c  **** 			}
4720:Src/bno055.c  **** 		} else {
4721:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4722:Src/bno055.c  **** 		}
4723:Src/bno055.c  **** 	return com_rslt;
4724:Src/bno055.c  **** }
4725:Src/bno055.c  **** /*!
4726:Src/bno055.c  ****  *	@brief This API is used to convert the gyro x raw data
ARM GAS  /tmp/ccVWLGiI.s 			page 186


4727:Src/bno055.c  ****  *	to rps output as double
4728:Src/bno055.c  ****  *
4729:Src/bno055.c  ****  *	@param gyro_x_d : The gyro x dps double data
4730:Src/bno055.c  ****  *
4731:Src/bno055.c  ****  *
4732:Src/bno055.c  ****  *
4733:Src/bno055.c  ****  *	@return results of bus communication function
4734:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4735:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4736:Src/bno055.c  ****  *
4737:Src/bno055.c  ****  *
4738:Src/bno055.c  ****  */
4739:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_x_rps(
4740:Src/bno055.c  **** double *gyro_x_d)
4741:Src/bno055.c  **** {
4742:Src/bno055.c  **** 	/* Variable used to return value of
4743:Src/bno055.c  **** 	communication routine*/
4744:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4745:Src/bno055.c  **** 	s16 reg_gyro_x_s16 = BNO055_INIT_VALUE;
4746:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4747:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4748:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4749:Src/bno055.c  **** 	unit as rps if the unit is in dps */
4750:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4751:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
4752:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
4753:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4754:Src/bno055.c  **** 			/* Read gyro raw x data */
4755:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_x(&reg_gyro_x_s16);
4756:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4757:Src/bno055.c  **** 				/* Convert raw gyro x to rps */
4758:Src/bno055.c  **** 				data_d =
4759:Src/bno055.c  **** 				(double)(reg_gyro_x_s16/BNO055_GYRO_DIV_RPS);
4760:Src/bno055.c  **** 				*gyro_x_d = data_d;
4761:Src/bno055.c  **** 			} else {
4762:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4763:Src/bno055.c  **** 			}
4764:Src/bno055.c  **** 		} else {
4765:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4766:Src/bno055.c  **** 		}
4767:Src/bno055.c  **** 	return com_rslt;
4768:Src/bno055.c  **** }
4769:Src/bno055.c  **** /*!
4770:Src/bno055.c  ****  *	@brief This API is used to convert the gyro y raw data
4771:Src/bno055.c  ****  *	to dps output as double
4772:Src/bno055.c  ****  *
4773:Src/bno055.c  ****  *	@param gyro_y_d : The gyro y dps double data
4774:Src/bno055.c  ****  *
4775:Src/bno055.c  ****  *
4776:Src/bno055.c  ****  *
4777:Src/bno055.c  ****  *	@return results of bus communication function
4778:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4779:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4780:Src/bno055.c  ****  *
4781:Src/bno055.c  ****  *
4782:Src/bno055.c  ****  */
4783:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_y_dps(
ARM GAS  /tmp/ccVWLGiI.s 			page 187


4784:Src/bno055.c  **** double *gyro_y_d)
4785:Src/bno055.c  **** {
4786:Src/bno055.c  **** 	/* Variable used to return value of
4787:Src/bno055.c  **** 	communication routine*/
4788:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4789:Src/bno055.c  **** 	s16 reg_gyro_y_s16 = BNO055_INIT_VALUE;
4790:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4791:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4792:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4793:Src/bno055.c  **** 	unit as dps if the unit is in rps */
4794:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4795:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
4796:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
4797:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4798:Src/bno055.c  **** 			/* Read gyro raw y data */
4799:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_y(&reg_gyro_y_s16);
4800:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4801:Src/bno055.c  **** 				/* Convert raw gyro y to dps */
4802:Src/bno055.c  **** 				data_d =
4803:Src/bno055.c  **** 				(double)(reg_gyro_y_s16/BNO055_GYRO_DIV_DPS);
4804:Src/bno055.c  **** 				*gyro_y_d = data_d;
4805:Src/bno055.c  **** 			} else {
4806:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4807:Src/bno055.c  **** 			}
4808:Src/bno055.c  **** 		} else {
4809:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4810:Src/bno055.c  **** 		}
4811:Src/bno055.c  **** 	return com_rslt;
4812:Src/bno055.c  **** }
4813:Src/bno055.c  **** /*!
4814:Src/bno055.c  ****  *	@brief This API is used to convert the gyro y raw data
4815:Src/bno055.c  ****  *	to rps output as double
4816:Src/bno055.c  ****  *
4817:Src/bno055.c  ****  *	@param gyro_y_d : The gyro y dps double data
4818:Src/bno055.c  ****  *
4819:Src/bno055.c  ****  *
4820:Src/bno055.c  ****  *
4821:Src/bno055.c  ****  *	@return results of bus communication function
4822:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4823:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4824:Src/bno055.c  ****  *
4825:Src/bno055.c  ****  *
4826:Src/bno055.c  ****  */
4827:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_y_rps(
4828:Src/bno055.c  **** double *gyro_y_d)
4829:Src/bno055.c  **** {
4830:Src/bno055.c  **** 	/* Variable used to return value of
4831:Src/bno055.c  **** 	communication routine*/
4832:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4833:Src/bno055.c  **** 	s16 reg_gyro_y_s16 = BNO055_INIT_VALUE;
4834:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4835:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4836:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4837:Src/bno055.c  **** 	unit as rps if the unit is in dps */
4838:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4839:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
4840:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
ARM GAS  /tmp/ccVWLGiI.s 			page 188


4841:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4842:Src/bno055.c  **** 			/* Read gyro raw y data */
4843:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_y(&reg_gyro_y_s16);
4844:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4845:Src/bno055.c  **** 				/* Convert raw gyro y to rps */
4846:Src/bno055.c  **** 				data_d =
4847:Src/bno055.c  **** 				(double)(reg_gyro_y_s16/BNO055_GYRO_DIV_RPS);
4848:Src/bno055.c  **** 				*gyro_y_d = data_d;
4849:Src/bno055.c  **** 			} else {
4850:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4851:Src/bno055.c  **** 			}
4852:Src/bno055.c  **** 		} else {
4853:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4854:Src/bno055.c  **** 		}
4855:Src/bno055.c  **** 	return com_rslt;
4856:Src/bno055.c  **** }
4857:Src/bno055.c  **** /*!
4858:Src/bno055.c  ****  *	@brief This API is used to convert the gyro z raw data
4859:Src/bno055.c  ****  *	to dps output as double
4860:Src/bno055.c  ****  *
4861:Src/bno055.c  ****  *	@param gyro_z_d : The gyro z dps double data
4862:Src/bno055.c  ****  *
4863:Src/bno055.c  ****  *
4864:Src/bno055.c  ****  *
4865:Src/bno055.c  ****  *	@return results of bus communication function
4866:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4867:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4868:Src/bno055.c  ****  *
4869:Src/bno055.c  ****  *
4870:Src/bno055.c  ****  */
4871:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_z_dps(
4872:Src/bno055.c  **** double *gyro_z_d)
4873:Src/bno055.c  **** {
4874:Src/bno055.c  **** 	/* Variable used to return value of
4875:Src/bno055.c  **** 	communication routine*/
4876:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4877:Src/bno055.c  **** 	s16 reg_gyro_z_s16 = BNO055_INIT_VALUE;
4878:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4879:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4880:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4881:Src/bno055.c  **** 	unit as dps if the unit is in rps */
4882:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4883:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
4884:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
4885:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4886:Src/bno055.c  **** 			/* Read gyro raw z data */
4887:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_z(&reg_gyro_z_s16);
4888:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4889:Src/bno055.c  **** 				/* Convert raw gyro z to dps */
4890:Src/bno055.c  **** 				data_d =
4891:Src/bno055.c  **** 				(double)(reg_gyro_z_s16/BNO055_GYRO_DIV_DPS);
4892:Src/bno055.c  **** 				*gyro_z_d = data_d;
4893:Src/bno055.c  **** 			} else {
4894:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4895:Src/bno055.c  **** 			}
4896:Src/bno055.c  **** 		} else {
4897:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 189


4898:Src/bno055.c  **** 		}
4899:Src/bno055.c  **** 	return com_rslt;
4900:Src/bno055.c  **** }
4901:Src/bno055.c  **** /*!
4902:Src/bno055.c  ****  *	@brief This API is used to convert the gyro z raw data
4903:Src/bno055.c  ****  *	to rps output as double
4904:Src/bno055.c  ****  *
4905:Src/bno055.c  ****  *	@param gyro_z_d : The gyro z rps double data
4906:Src/bno055.c  ****  *
4907:Src/bno055.c  ****  *
4908:Src/bno055.c  ****  *
4909:Src/bno055.c  ****  *	@return results of bus communication function
4910:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4911:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4912:Src/bno055.c  ****  *
4913:Src/bno055.c  ****  *
4914:Src/bno055.c  ****  */
4915:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_z_rps(
4916:Src/bno055.c  **** double *gyro_z_d)
4917:Src/bno055.c  **** {
4918:Src/bno055.c  **** 	/* Variable used to return value of
4919:Src/bno055.c  **** 	communication routine*/
4920:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4921:Src/bno055.c  **** 	s16 reg_gyro_z_s16 = BNO055_INIT_VALUE;
4922:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
4923:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4924:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4925:Src/bno055.c  **** 	unit as rps if the unit is in dps */
4926:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4927:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
4928:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
4929:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4930:Src/bno055.c  **** 			/* Read gyro raw x data */
4931:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_z(&reg_gyro_z_s16);
4932:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4933:Src/bno055.c  **** 				/* Convert raw gyro x to rps */
4934:Src/bno055.c  **** 				data_d =
4935:Src/bno055.c  **** 				(double)(reg_gyro_z_s16/BNO055_GYRO_DIV_RPS);
4936:Src/bno055.c  **** 				*gyro_z_d = data_d;
4937:Src/bno055.c  **** 			} else {
4938:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4939:Src/bno055.c  **** 			}
4940:Src/bno055.c  **** 		} else {
4941:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4942:Src/bno055.c  **** 		}
4943:Src/bno055.c  **** 	return com_rslt;
4944:Src/bno055.c  **** }
4945:Src/bno055.c  **** /*!
4946:Src/bno055.c  ****  *	@brief This API is used to convert the gyro xyz raw data
4947:Src/bno055.c  ****  *	to dps output as double
4948:Src/bno055.c  ****  *
4949:Src/bno055.c  ****  *	@param gyro_xyz : The dps data of gyro xyz
4950:Src/bno055.c  ****  *
4951:Src/bno055.c  ****  *	Parameter |    result
4952:Src/bno055.c  ****  *  --------- | -----------------
4953:Src/bno055.c  ****  *	 x        | dps data of gyro
4954:Src/bno055.c  ****  *	 y        | dps data of gyro
ARM GAS  /tmp/ccVWLGiI.s 			page 190


4955:Src/bno055.c  ****  *	 z        | dps data of gyro
4956:Src/bno055.c  ****  *
4957:Src/bno055.c  ****  *
4958:Src/bno055.c  ****  *	@return results of bus communication function
4959:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
4960:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
4961:Src/bno055.c  ****  *
4962:Src/bno055.c  ****  */
4963:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_xyz_dps(
4964:Src/bno055.c  **** struct bno055_gyro_double_t *gyro_xyz)
4965:Src/bno055.c  **** {
4966:Src/bno055.c  **** 	/* Variable used to return value of
4967:Src/bno055.c  **** 	communication routine*/
4968:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
4969:Src/bno055.c  **** 	struct bno055_gyro_t reg_gyro_xyz = {
4970:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
4971:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
4972:Src/bno055.c  **** 	/* Read the current gyro unit and set the
4973:Src/bno055.c  **** 	unit as dps if the unit is in rps */
4974:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
4975:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
4976:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
4977:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
4978:Src/bno055.c  **** 			/* Read gyro raw xyz data */
4979:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_xyz(&reg_gyro_xyz);
4980:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
4981:Src/bno055.c  **** 				/* Convert gyro raw xyz to dps*/
4982:Src/bno055.c  **** 				gyro_xyz->x =
4983:Src/bno055.c  **** 				(double)(reg_gyro_xyz.x/BNO055_GYRO_DIV_DPS);
4984:Src/bno055.c  **** 				gyro_xyz->y =
4985:Src/bno055.c  **** 				(double)(reg_gyro_xyz.y/BNO055_GYRO_DIV_DPS);
4986:Src/bno055.c  **** 				gyro_xyz->z =
4987:Src/bno055.c  **** 				(double)(reg_gyro_xyz.z/BNO055_GYRO_DIV_DPS);
4988:Src/bno055.c  **** 			} else {
4989:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
4990:Src/bno055.c  **** 			}
4991:Src/bno055.c  **** 		} else {
4992:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
4993:Src/bno055.c  **** 		}
4994:Src/bno055.c  **** 	return com_rslt;
4995:Src/bno055.c  **** }
4996:Src/bno055.c  **** /*!
4997:Src/bno055.c  ****  *	@brief This API is used to convert the gyro xyz raw data
4998:Src/bno055.c  ****  *	to rps output as double
4999:Src/bno055.c  ****  *
5000:Src/bno055.c  ****  *	@param gyro_xyz : The rps data of gyro xyz
5001:Src/bno055.c  ****  *
5002:Src/bno055.c  ****  *	Parameter |    result
5003:Src/bno055.c  ****  *  --------- | -----------------
5004:Src/bno055.c  ****  *	 x        | rps data of gyro
5005:Src/bno055.c  ****  *	 y        | rps data of gyro
5006:Src/bno055.c  ****  *	 z        | rps data of gyro
5007:Src/bno055.c  ****  *
5008:Src/bno055.c  ****  *
5009:Src/bno055.c  ****  *	@return results of bus communication function
5010:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5011:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
ARM GAS  /tmp/ccVWLGiI.s 			page 191


5012:Src/bno055.c  ****  *
5013:Src/bno055.c  ****  */
5014:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gyro_xyz_rps(
5015:Src/bno055.c  **** struct bno055_gyro_double_t *gyro_xyz)
5016:Src/bno055.c  **** {
5017:Src/bno055.c  **** 	/* Variable used to return value of
5018:Src/bno055.c  **** 	communication routine*/
5019:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5020:Src/bno055.c  **** 	struct bno055_gyro_t reg_gyro_xyz = {
5021:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
5022:Src/bno055.c  **** 	u8 gyro_unit_u8 = BNO055_INIT_VALUE;
5023:Src/bno055.c  **** 	/* Read the current gyro unit and set the
5024:Src/bno055.c  **** 	unit as rps if the unit is in dps */
5025:Src/bno055.c  **** 	com_rslt = bno055_get_gyro_unit(&gyro_unit_u8);
5026:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
5027:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
5028:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5029:Src/bno055.c  **** 			/* Read gyro raw x data */
5030:Src/bno055.c  **** 			com_rslt += bno055_read_gyro_xyz(&reg_gyro_xyz);
5031:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5032:Src/bno055.c  **** 				/* Convert the raw gyro xyz to rps*/
5033:Src/bno055.c  **** 				gyro_xyz->x =
5034:Src/bno055.c  **** 				(double)(reg_gyro_xyz.x/BNO055_GYRO_DIV_RPS);
5035:Src/bno055.c  **** 				gyro_xyz->y =
5036:Src/bno055.c  **** 				(double)(reg_gyro_xyz.y/BNO055_GYRO_DIV_RPS);
5037:Src/bno055.c  **** 				gyro_xyz->z =
5038:Src/bno055.c  **** 				(double)(reg_gyro_xyz.z/BNO055_GYRO_DIV_RPS);
5039:Src/bno055.c  **** 			} else {
5040:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5041:Src/bno055.c  **** 			}
5042:Src/bno055.c  **** 		} else {
5043:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5044:Src/bno055.c  **** 		}
5045:Src/bno055.c  **** 	return com_rslt;
5046:Src/bno055.c  **** }
5047:Src/bno055.c  **** /*!
5048:Src/bno055.c  ****  *	@brief This API is used to convert the Euler h raw data
5049:Src/bno055.c  ****  *	to degree output as double
5050:Src/bno055.c  ****  *
5051:Src/bno055.c  ****  *	@param euler_h_d : The double value of Euler h degree
5052:Src/bno055.c  ****  *
5053:Src/bno055.c  ****  *	@return results of bus communication function
5054:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5055:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5056:Src/bno055.c  ****  *
5057:Src/bno055.c  ****  *
5058:Src/bno055.c  ****  */
5059:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_h_deg(
5060:Src/bno055.c  **** double *euler_h_d)
5061:Src/bno055.c  **** {
5062:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5063:Src/bno055.c  **** 	s16 reg_euler_h_s16 = BNO055_INIT_VALUE;
5064:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5065:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5066:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5067:Src/bno055.c  **** 	unit as degree if the unit is in radians */
5068:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 192


5069:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
5070:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
5071:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
5072:Src/bno055.c  **** 			/* Read Euler raw h data*/
5073:Src/bno055.c  **** 			com_rslt += bno055_read_euler_h(&reg_euler_h_s16);
5074:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5075:Src/bno055.c  **** 				/* Convert raw Euler h to degree */
5076:Src/bno055.c  **** 				data_d =
5077:Src/bno055.c  **** 				(double)(reg_euler_h_s16/BNO055_EULER_DIV_DEG);
5078:Src/bno055.c  **** 				*euler_h_d = data_d;
5079:Src/bno055.c  **** 			} else {
5080:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5081:Src/bno055.c  **** 			}
5082:Src/bno055.c  **** 		} else {
5083:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5084:Src/bno055.c  **** 		}
5085:Src/bno055.c  **** 	return com_rslt;
5086:Src/bno055.c  **** }
5087:Src/bno055.c  **** /*!
5088:Src/bno055.c  ****  *	@brief This API is used to convert the Euler h raw data
5089:Src/bno055.c  ****  *	to radians output as double
5090:Src/bno055.c  ****  *
5091:Src/bno055.c  ****  *	@param euler_h_d : The double value of Euler h radians
5092:Src/bno055.c  ****  *
5093:Src/bno055.c  ****  *	@return results of bus communication function
5094:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5095:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5096:Src/bno055.c  ****  *
5097:Src/bno055.c  ****  *
5098:Src/bno055.c  ****  */
5099:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_h_rad(
5100:Src/bno055.c  **** double *euler_h_d)
5101:Src/bno055.c  **** {
5102:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5103:Src/bno055.c  **** 	s16 reg_euler_h_s16 = BNO055_INIT_VALUE;
5104:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5105:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5106:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5107:Src/bno055.c  **** 	unit as radians if the unit is in degree */
5108:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5109:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
5110:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
5111:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5112:Src/bno055.c  **** 			/* Read Euler raw h data*/
5113:Src/bno055.c  **** 			com_rslt += bno055_read_euler_h(&reg_euler_h_s16);
5114:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5115:Src/bno055.c  **** 				/* Convert raw Euler h to radians */
5116:Src/bno055.c  **** 				data_d =
5117:Src/bno055.c  **** 				(double)(reg_euler_h_s16/BNO055_EULER_DIV_RAD);
5118:Src/bno055.c  **** 				*euler_h_d = data_d;
5119:Src/bno055.c  **** 			} else {
5120:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5121:Src/bno055.c  **** 			}
5122:Src/bno055.c  **** 		} else {
5123:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5124:Src/bno055.c  **** 		}
5125:Src/bno055.c  **** 	return com_rslt;
ARM GAS  /tmp/ccVWLGiI.s 			page 193


5126:Src/bno055.c  **** }
5127:Src/bno055.c  **** /*!
5128:Src/bno055.c  ****  *	@brief This API is used to convert the Euler r raw data
5129:Src/bno055.c  ****  *	to degree output as double
5130:Src/bno055.c  ****  *
5131:Src/bno055.c  ****  *	@param euler_r_d : The double value of Euler r degree
5132:Src/bno055.c  ****  *
5133:Src/bno055.c  ****  *	@return results of bus communication function
5134:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5135:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5136:Src/bno055.c  ****  *
5137:Src/bno055.c  ****  *
5138:Src/bno055.c  ****  */
5139:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_r_deg(
5140:Src/bno055.c  **** double *euler_r_d)
5141:Src/bno055.c  **** {
5142:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5143:Src/bno055.c  **** 	s16 reg_euler_r_s16 = BNO055_INIT_VALUE;
5144:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5145:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5146:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5147:Src/bno055.c  **** 	unit as degree if the unit is in radians */
5148:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5149:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
5150:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
5151:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
5152:Src/bno055.c  **** 			/* Read Euler raw r data*/
5153:Src/bno055.c  **** 			com_rslt += bno055_read_euler_r(&reg_euler_r_s16);
5154:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5155:Src/bno055.c  **** 				/* Convert raw Euler r to degree */
5156:Src/bno055.c  **** 				data_d =
5157:Src/bno055.c  **** 				(double)(reg_euler_r_s16/BNO055_EULER_DIV_DEG);
5158:Src/bno055.c  **** 				*euler_r_d = data_d;
5159:Src/bno055.c  **** 			} else {
5160:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5161:Src/bno055.c  **** 			}
5162:Src/bno055.c  **** 		} else {
5163:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5164:Src/bno055.c  **** 		}
5165:Src/bno055.c  **** 	return com_rslt;
5166:Src/bno055.c  **** }
5167:Src/bno055.c  **** /*!
5168:Src/bno055.c  ****  *	@brief This API is used to convert the Euler r raw data
5169:Src/bno055.c  ****  *	to radians output as double
5170:Src/bno055.c  ****  *
5171:Src/bno055.c  ****  *	@param euler_r_d : The double value of Euler r radians
5172:Src/bno055.c  ****  *
5173:Src/bno055.c  ****  *	@return results of bus communication function
5174:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5175:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5176:Src/bno055.c  ****  *
5177:Src/bno055.c  ****  *
5178:Src/bno055.c  ****  */
5179:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_r_rad(
5180:Src/bno055.c  **** double *euler_r_d)
5181:Src/bno055.c  **** {
5182:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 194


5183:Src/bno055.c  **** 	s16 reg_euler_r_s16 = BNO055_INIT_VALUE;
5184:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5185:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5186:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5187:Src/bno055.c  **** 	unit as radians if the unit is in degree */
5188:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5189:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
5190:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
5191:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5192:Src/bno055.c  **** 			/* Read Euler raw r data*/
5193:Src/bno055.c  **** 			com_rslt += bno055_read_euler_r(&reg_euler_r_s16);
5194:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5195:Src/bno055.c  **** 				/* Convert raw Euler r to radians */
5196:Src/bno055.c  **** 				data_d =
5197:Src/bno055.c  **** 				(double)(reg_euler_r_s16/BNO055_EULER_DIV_RAD);
5198:Src/bno055.c  **** 				*euler_r_d = data_d;
5199:Src/bno055.c  **** 			} else {
5200:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5201:Src/bno055.c  **** 			}
5202:Src/bno055.c  **** 		} else {
5203:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5204:Src/bno055.c  **** 		}
5205:Src/bno055.c  **** 	return com_rslt;
5206:Src/bno055.c  **** }
5207:Src/bno055.c  **** /*!
5208:Src/bno055.c  ****  *	@brief This API is used to convert the Euler p raw data
5209:Src/bno055.c  ****  *	to degree output as double
5210:Src/bno055.c  ****  *
5211:Src/bno055.c  ****  *	@param euler_p_d : The double value of Euler p degree
5212:Src/bno055.c  ****  *
5213:Src/bno055.c  ****  *	@return results of bus communication function
5214:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5215:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5216:Src/bno055.c  ****  *
5217:Src/bno055.c  ****  *
5218:Src/bno055.c  ****  */
5219:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_p_deg(
5220:Src/bno055.c  **** double *euler_p_d)
5221:Src/bno055.c  **** {
5222:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5223:Src/bno055.c  **** 	s16 reg_euler_p_s16 = BNO055_INIT_VALUE;
5224:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5225:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5226:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5227:Src/bno055.c  **** 	unit as degree if the unit is in radians */
5228:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5229:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
5230:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
5231:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
5232:Src/bno055.c  **** 			/* Read Euler raw p data*/
5233:Src/bno055.c  **** 			com_rslt += bno055_read_euler_p(&reg_euler_p_s16);
5234:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5235:Src/bno055.c  **** 				/* Convert raw Euler p to degree*/
5236:Src/bno055.c  **** 				data_d =
5237:Src/bno055.c  **** 				(double)(reg_euler_p_s16/BNO055_EULER_DIV_DEG);
5238:Src/bno055.c  **** 				*euler_p_d = data_d;
5239:Src/bno055.c  **** 			} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 195


5240:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5241:Src/bno055.c  **** 			}
5242:Src/bno055.c  **** 		} else {
5243:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5244:Src/bno055.c  **** 		}
5245:Src/bno055.c  **** 	return com_rslt;
5246:Src/bno055.c  **** }
5247:Src/bno055.c  **** /*!
5248:Src/bno055.c  ****  *	@brief This API is used to convert the Euler p raw data
5249:Src/bno055.c  ****  *	to radians output as double
5250:Src/bno055.c  ****  *
5251:Src/bno055.c  ****  *	@param euler_p_d : The double value of Euler p radians
5252:Src/bno055.c  ****  *
5253:Src/bno055.c  ****  *	@return results of bus communication function
5254:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5255:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5256:Src/bno055.c  ****  *
5257:Src/bno055.c  ****  *
5258:Src/bno055.c  ****  */
5259:Src/bno055.c  **** 
5260:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_p_rad(
5261:Src/bno055.c  **** double *euler_p_d)
5262:Src/bno055.c  **** {
5263:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5264:Src/bno055.c  **** 	s16 reg_euler_p_s16 = BNO055_INIT_VALUE;
5265:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5266:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5267:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5268:Src/bno055.c  **** 	unit as radians if the unit is in degree */
5269:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5270:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
5271:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
5272:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5273:Src/bno055.c  **** 			/* Read Euler raw p data*/
5274:Src/bno055.c  **** 			com_rslt += bno055_read_euler_p(&reg_euler_p_s16);
5275:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5276:Src/bno055.c  **** 				/* Convert raw p to radians*/
5277:Src/bno055.c  **** 				data_d =
5278:Src/bno055.c  **** 				(double)(reg_euler_p_s16/BNO055_EULER_DIV_RAD);
5279:Src/bno055.c  **** 				*euler_p_d = data_d;
5280:Src/bno055.c  **** 			} else {
5281:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5282:Src/bno055.c  **** 			}
5283:Src/bno055.c  **** 		} else {
5284:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5285:Src/bno055.c  **** 		}
5286:Src/bno055.c  **** 	return com_rslt;
5287:Src/bno055.c  **** }
5288:Src/bno055.c  **** /*!
5289:Src/bno055.c  ****  *	@brief This API is used to convert the Euler hpr raw data
5290:Src/bno055.c  ****  *	to degree output as double
5291:Src/bno055.c  ****  *
5292:Src/bno055.c  ****  *	@param euler_hpr : The degree data of Euler hpr
5293:Src/bno055.c  ****  *
5294:Src/bno055.c  ****  *	Parameter |    result
5295:Src/bno055.c  ****  *  --------- | -----------------
5296:Src/bno055.c  ****  *	 h        | degree data of Euler
ARM GAS  /tmp/ccVWLGiI.s 			page 196


5297:Src/bno055.c  ****  *	 r        | degree data of Euler
5298:Src/bno055.c  ****  *	 p        | degree data of Euler
5299:Src/bno055.c  ****  *
5300:Src/bno055.c  ****  *
5301:Src/bno055.c  ****  *	@return results of bus communication function
5302:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5303:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5304:Src/bno055.c  ****  *
5305:Src/bno055.c  ****  */
5306:Src/bno055.c  **** 
5307:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_hpr_deg(
5308:Src/bno055.c  **** struct bno055_euler_double_t *euler_hpr)
5309:Src/bno055.c  **** {
5310:Src/bno055.c  **** 	/* Variable used to return value of
5311:Src/bno055.c  **** 	communication routine*/
5312:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5313:Src/bno055.c  **** 	struct bno055_euler_t reg_euler = {BNO055_INIT_VALUE,
5314:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
5315:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5316:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5317:Src/bno055.c  **** 	unit as degree if the unit is in radians */
5318:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5319:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
5320:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
5321:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
5322:Src/bno055.c  **** 		/* Read Euler raw h data*/
5323:Src/bno055.c  **** 			com_rslt += bno055_read_euler_hrp(&reg_euler);
5324:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5325:Src/bno055.c  **** 			/* Convert raw Euler hrp to degree*/
5326:Src/bno055.c  **** 			euler_hpr->h =
5327:Src/bno055.c  **** 			(double)(reg_euler.h/BNO055_EULER_DIV_DEG);
5328:Src/bno055.c  **** 			euler_hpr->p =
5329:Src/bno055.c  **** 			(double)(reg_euler.p/BNO055_EULER_DIV_DEG);
5330:Src/bno055.c  **** 			euler_hpr->r =
5331:Src/bno055.c  **** 			(double)(reg_euler.r/BNO055_EULER_DIV_DEG);
5332:Src/bno055.c  **** 		} else {
5333:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5334:Src/bno055.c  **** 		}
5335:Src/bno055.c  **** 	} else {
5336:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
5337:Src/bno055.c  **** 	}
5338:Src/bno055.c  **** 	return com_rslt;
5339:Src/bno055.c  **** }
5340:Src/bno055.c  **** /*!
5341:Src/bno055.c  ****  *	@brief This API is used to convert the Euler hpr raw data
5342:Src/bno055.c  ****  *	to radians output as double
5343:Src/bno055.c  ****  *
5344:Src/bno055.c  ****  *	@param euler_hpr : The radians data of Euler hpr
5345:Src/bno055.c  ****  *
5346:Src/bno055.c  ****  *	Parameter |    result
5347:Src/bno055.c  ****  *  --------- | -----------------
5348:Src/bno055.c  ****  *	 h        | radians data of Euler
5349:Src/bno055.c  ****  *	 r        | radians data of Euler
5350:Src/bno055.c  ****  *	 p        | radians data of Euler
5351:Src/bno055.c  ****  *
5352:Src/bno055.c  ****  *
5353:Src/bno055.c  ****  *	@return results of bus communication function
ARM GAS  /tmp/ccVWLGiI.s 			page 197


5354:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5355:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5356:Src/bno055.c  ****  *
5357:Src/bno055.c  ****  */
5358:Src/bno055.c  **** 
5359:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_euler_hpr_rad(
5360:Src/bno055.c  **** struct bno055_euler_double_t *euler_hpr)
5361:Src/bno055.c  **** {
5362:Src/bno055.c  **** 	/* Variable used to return value of
5363:Src/bno055.c  **** 	communication routine*/
5364:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5365:Src/bno055.c  **** 	struct bno055_euler_t reg_euler = {BNO055_INIT_VALUE,
5366:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
5367:Src/bno055.c  **** 	u8 euler_unit_u8 = BNO055_INIT_VALUE;
5368:Src/bno055.c  **** 	/* Read the current Euler unit and set the
5369:Src/bno055.c  **** 	unit as radians if the unit is in degree */
5370:Src/bno055.c  **** 	com_rslt = bno055_get_euler_unit(&euler_unit_u8);
5371:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
5372:Src/bno055.c  **** 		com_rslt = bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
5373:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5374:Src/bno055.c  **** 			/* Read the raw hrp */
5375:Src/bno055.c  **** 			com_rslt = bno055_read_euler_hrp(&reg_euler);
5376:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5377:Src/bno055.c  **** 				/* Convert raw Euler hrp to radians*/
5378:Src/bno055.c  **** 				euler_hpr->h =
5379:Src/bno055.c  **** 				(double)(reg_euler.h/BNO055_EULER_DIV_RAD);
5380:Src/bno055.c  **** 				euler_hpr->p =
5381:Src/bno055.c  **** 				(double)(reg_euler.p/BNO055_EULER_DIV_RAD);
5382:Src/bno055.c  **** 				euler_hpr->r =
5383:Src/bno055.c  **** 				(double)(reg_euler.r/BNO055_EULER_DIV_RAD);
5384:Src/bno055.c  **** 			} else {
5385:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5386:Src/bno055.c  **** 			}
5387:Src/bno055.c  **** 		} else {
5388:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
5389:Src/bno055.c  **** 		}
5390:Src/bno055.c  **** 	return com_rslt;
5391:Src/bno055.c  **** }
5392:Src/bno055.c  **** /*!
5393:Src/bno055.c  ****  *	@brief This API is used to convert the linear
5394:Src/bno055.c  ****  *	accel x raw data to meterpersecseq output as double
5395:Src/bno055.c  ****  *
5396:Src/bno055.c  ****  *	@param linear_accel_x_d : The double value of
5397:Src/bno055.c  ****  *	linear accel x meterpersecseq
5398:Src/bno055.c  ****  *
5399:Src/bno055.c  ****  *	@return results of bus communication function
5400:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5401:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5402:Src/bno055.c  ****  *
5403:Src/bno055.c  ****  *
5404:Src/bno055.c  ****  */
5405:Src/bno055.c  **** 
5406:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_linear_accel_x_msq(
5407:Src/bno055.c  **** double *linear_accel_x_d)
5408:Src/bno055.c  **** {
 5516              		.loc 1 5408 0
 5517              		.cfi_startproc
ARM GAS  /tmp/ccVWLGiI.s 			page 198


 5518              		@ args = 0, pretend = 0, frame = 8
 5519              		@ frame_needed = 0, uses_anonymous_args = 0
 5520              	.LVL634:
 5521 0000 30B5     		push	{r4, r5, lr}
 5522              	.LCFI231:
 5523              		.cfi_def_cfa_offset 12
 5524              		.cfi_offset 4, -12
 5525              		.cfi_offset 5, -8
 5526              		.cfi_offset 14, -4
 5527 0002 83B0     		sub	sp, sp, #12
 5528              	.LCFI232:
 5529              		.cfi_def_cfa_offset 24
5409:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5410:Src/bno055.c  **** 	s16 reg_linear_accel_x_s16 = BNO055_INIT_VALUE;
 5530              		.loc 1 5410 0
 5531 0004 02AB     		add	r3, sp, #8
 5532 0006 0022     		movs	r2, #0
 5533 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5534              	.LVL635:
5408:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 5535              		.loc 1 5408 0
 5536 000c 0546     		mov	r5, r0
5411:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5412:Src/bno055.c  **** 	/* Read the raw x of linear accel */
5413:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_x(&reg_linear_accel_x_s16);
 5537              		.loc 1 5413 0
 5538 000e 1846     		mov	r0, r3
 5539              	.LVL636:
 5540 0010 FFF7FEFF 		bl	bno055_read_linear_accel_x
 5541              	.LVL637:
5414:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5542              		.loc 1 5414 0
 5543 0014 0446     		mov	r4, r0
 5544 0016 60B9     		cbnz	r0, .L598
 5545              	.LVL638:
5415:Src/bno055.c  **** 		/* Convert the raw x to m/s2 */
5416:Src/bno055.c  **** 		data_d = (double)
 5546              		.loc 1 5416 0
 5547 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5548              	.LVL639:
 5549 001c FFF7FEFF 		bl	__aeabi_i2d
 5550              	.LVL640:
 5551 0020 0022     		movs	r2, #0
 5552 0022 054B     		ldr	r3, .L600
 5553 0024 FFF7FEFF 		bl	__aeabi_ddiv
 5554              	.LVL641:
5417:Src/bno055.c  **** 		(reg_linear_accel_x_s16/BNO055_LINEAR_ACCEL_DIV_MSQ);
5418:Src/bno055.c  **** 		*linear_accel_x_d = data_d;
 5555              		.loc 1 5418 0
 5556 0028 C5E90001 		strd	r0, [r5]
 5557              	.L597:
 5558              	.LVL642:
5419:Src/bno055.c  **** 	} else {
5420:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5421:Src/bno055.c  **** 	}
5422:Src/bno055.c  **** 	return com_rslt;
5423:Src/bno055.c  **** }
ARM GAS  /tmp/ccVWLGiI.s 			page 199


 5559              		.loc 1 5423 0
 5560 002c 60B2     		sxtb	r0, r4
 5561 002e 03B0     		add	sp, sp, #12
 5562              	.LCFI233:
 5563              		.cfi_remember_state
 5564              		.cfi_def_cfa_offset 12
 5565              		@ sp needed
 5566 0030 30BD     		pop	{r4, r5, pc}
 5567              	.LVL643:
 5568              	.L598:
 5569              	.LCFI234:
 5570              		.cfi_restore_state
5420:Src/bno055.c  **** 	}
 5571              		.loc 1 5420 0
 5572 0032 FF24     		movs	r4, #255
 5573 0034 FAE7     		b	.L597
 5574              	.L601:
 5575 0036 00BF     		.align	2
 5576              	.L600:
 5577 0038 00005940 		.word	1079574528
 5578              		.cfi_endproc
 5579              	.LFE107:
 5581              		.section	.text.bno055_convert_double_linear_accel_y_msq,"ax",%progbits
 5582              		.align	2
 5583              		.global	bno055_convert_double_linear_accel_y_msq
 5584              		.thumb
 5585              		.thumb_func
 5587              	bno055_convert_double_linear_accel_y_msq:
 5588              	.LFB108:
5424:Src/bno055.c  **** /*!
5425:Src/bno055.c  ****  *	@brief This API is used to convert the linear
5426:Src/bno055.c  ****  *	accel y raw data to meterpersecseq output as double
5427:Src/bno055.c  ****  *
5428:Src/bno055.c  ****  *	@param linear_accel_y_d : The double value of
5429:Src/bno055.c  ****  *	linear accel y meterpersecseq
5430:Src/bno055.c  ****  *
5431:Src/bno055.c  ****  *	@return results of bus communication function
5432:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5433:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5434:Src/bno055.c  ****  *
5435:Src/bno055.c  ****  *
5436:Src/bno055.c  ****  */
5437:Src/bno055.c  **** 
5438:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_linear_accel_y_msq(
5439:Src/bno055.c  **** double *linear_accel_y_d)
5440:Src/bno055.c  **** {
 5589              		.loc 1 5440 0
 5590              		.cfi_startproc
 5591              		@ args = 0, pretend = 0, frame = 8
 5592              		@ frame_needed = 0, uses_anonymous_args = 0
 5593              	.LVL644:
 5594 0000 30B5     		push	{r4, r5, lr}
 5595              	.LCFI235:
 5596              		.cfi_def_cfa_offset 12
 5597              		.cfi_offset 4, -12
 5598              		.cfi_offset 5, -8
 5599              		.cfi_offset 14, -4
ARM GAS  /tmp/ccVWLGiI.s 			page 200


 5600 0002 83B0     		sub	sp, sp, #12
 5601              	.LCFI236:
 5602              		.cfi_def_cfa_offset 24
5441:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5442:Src/bno055.c  **** 	s16 reg_linear_accel_y_s16 = BNO055_INIT_VALUE;
 5603              		.loc 1 5442 0
 5604 0004 02AB     		add	r3, sp, #8
 5605 0006 0022     		movs	r2, #0
 5606 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5607              	.LVL645:
5440:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 5608              		.loc 1 5440 0
 5609 000c 0546     		mov	r5, r0
5443:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5444:Src/bno055.c  **** 	/* Read the raw x of linear accel */
5445:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_y(&reg_linear_accel_y_s16);
 5610              		.loc 1 5445 0
 5611 000e 1846     		mov	r0, r3
 5612              	.LVL646:
 5613 0010 FFF7FEFF 		bl	bno055_read_linear_accel_y
 5614              	.LVL647:
5446:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5615              		.loc 1 5446 0
 5616 0014 0446     		mov	r4, r0
 5617 0016 60B9     		cbnz	r0, .L604
 5618              	.LVL648:
5447:Src/bno055.c  **** 		/* Convert the raw y to m/s2 */
5448:Src/bno055.c  **** 		data_d = (double)
 5619              		.loc 1 5448 0
 5620 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5621              	.LVL649:
 5622 001c FFF7FEFF 		bl	__aeabi_i2d
 5623              	.LVL650:
 5624 0020 0022     		movs	r2, #0
 5625 0022 054B     		ldr	r3, .L606
 5626 0024 FFF7FEFF 		bl	__aeabi_ddiv
 5627              	.LVL651:
5449:Src/bno055.c  **** 		(reg_linear_accel_y_s16/BNO055_LINEAR_ACCEL_DIV_MSQ);
5450:Src/bno055.c  **** 		*linear_accel_y_d = data_d;
 5628              		.loc 1 5450 0
 5629 0028 C5E90001 		strd	r0, [r5]
 5630              	.L603:
 5631              	.LVL652:
5451:Src/bno055.c  **** 	} else {
5452:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5453:Src/bno055.c  **** 	}
5454:Src/bno055.c  **** 	return com_rslt;
5455:Src/bno055.c  **** }
 5632              		.loc 1 5455 0
 5633 002c 60B2     		sxtb	r0, r4
 5634 002e 03B0     		add	sp, sp, #12
 5635              	.LCFI237:
 5636              		.cfi_remember_state
 5637              		.cfi_def_cfa_offset 12
 5638              		@ sp needed
 5639 0030 30BD     		pop	{r4, r5, pc}
 5640              	.LVL653:
ARM GAS  /tmp/ccVWLGiI.s 			page 201


 5641              	.L604:
 5642              	.LCFI238:
 5643              		.cfi_restore_state
5452:Src/bno055.c  **** 	}
 5644              		.loc 1 5452 0
 5645 0032 FF24     		movs	r4, #255
 5646 0034 FAE7     		b	.L603
 5647              	.L607:
 5648 0036 00BF     		.align	2
 5649              	.L606:
 5650 0038 00005940 		.word	1079574528
 5651              		.cfi_endproc
 5652              	.LFE108:
 5654              		.section	.text.bno055_convert_double_linear_accel_z_msq,"ax",%progbits
 5655              		.align	2
 5656              		.global	bno055_convert_double_linear_accel_z_msq
 5657              		.thumb
 5658              		.thumb_func
 5660              	bno055_convert_double_linear_accel_z_msq:
 5661              	.LFB109:
5456:Src/bno055.c  **** /*!
5457:Src/bno055.c  ****  *	@brief This API is used to convert the linear
5458:Src/bno055.c  ****  *	accel z raw data to meterpersecseq output as double
5459:Src/bno055.c  ****  *
5460:Src/bno055.c  ****  *	@param linear_accel_z_d : The double value of
5461:Src/bno055.c  ****  *	linear accel z meterpersecseq
5462:Src/bno055.c  ****  *
5463:Src/bno055.c  ****  *	@return results of bus communication function
5464:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5465:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5466:Src/bno055.c  ****  *
5467:Src/bno055.c  ****  *
5468:Src/bno055.c  ****  */
5469:Src/bno055.c  **** 
5470:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_linear_accel_z_msq(
5471:Src/bno055.c  **** double *linear_accel_z_d)
5472:Src/bno055.c  **** {
 5662              		.loc 1 5472 0
 5663              		.cfi_startproc
 5664              		@ args = 0, pretend = 0, frame = 8
 5665              		@ frame_needed = 0, uses_anonymous_args = 0
 5666              	.LVL654:
 5667 0000 30B5     		push	{r4, r5, lr}
 5668              	.LCFI239:
 5669              		.cfi_def_cfa_offset 12
 5670              		.cfi_offset 4, -12
 5671              		.cfi_offset 5, -8
 5672              		.cfi_offset 14, -4
 5673 0002 83B0     		sub	sp, sp, #12
 5674              	.LCFI240:
 5675              		.cfi_def_cfa_offset 24
5473:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5474:Src/bno055.c  **** 	s16 reg_linear_accel_z_s16 = BNO055_INIT_VALUE;
 5676              		.loc 1 5474 0
 5677 0004 02AB     		add	r3, sp, #8
 5678 0006 0022     		movs	r2, #0
 5679 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
ARM GAS  /tmp/ccVWLGiI.s 			page 202


 5680              	.LVL655:
5472:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 5681              		.loc 1 5472 0
 5682 000c 0546     		mov	r5, r0
5475:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5476:Src/bno055.c  **** 	/* Read the raw x of linear accel */
5477:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_z(&reg_linear_accel_z_s16);
 5683              		.loc 1 5477 0
 5684 000e 1846     		mov	r0, r3
 5685              	.LVL656:
 5686 0010 FFF7FEFF 		bl	bno055_read_linear_accel_z
 5687              	.LVL657:
5478:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5688              		.loc 1 5478 0
 5689 0014 0446     		mov	r4, r0
 5690 0016 60B9     		cbnz	r0, .L610
 5691              	.LVL658:
5479:Src/bno055.c  **** 		/* Convert the raw z to m/s2 */
5480:Src/bno055.c  **** 		data_d =
5481:Src/bno055.c  **** 		(double)(reg_linear_accel_z_s16/BNO055_LINEAR_ACCEL_DIV_MSQ);
 5692              		.loc 1 5481 0
 5693 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5694              	.LVL659:
 5695 001c FFF7FEFF 		bl	__aeabi_i2d
 5696              	.LVL660:
5480:Src/bno055.c  **** 		(double)(reg_linear_accel_z_s16/BNO055_LINEAR_ACCEL_DIV_MSQ);
 5697              		.loc 1 5480 0
 5698 0020 0022     		movs	r2, #0
 5699 0022 054B     		ldr	r3, .L612
 5700 0024 FFF7FEFF 		bl	__aeabi_ddiv
 5701              	.LVL661:
5482:Src/bno055.c  **** 		*linear_accel_z_d = data_d;
 5702              		.loc 1 5482 0
 5703 0028 C5E90001 		strd	r0, [r5]
 5704              	.L609:
 5705              	.LVL662:
5483:Src/bno055.c  **** 	} else {
5484:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5485:Src/bno055.c  **** 	}
5486:Src/bno055.c  **** 	return com_rslt;
5487:Src/bno055.c  **** }
 5706              		.loc 1 5487 0
 5707 002c 60B2     		sxtb	r0, r4
 5708 002e 03B0     		add	sp, sp, #12
 5709              	.LCFI241:
 5710              		.cfi_remember_state
 5711              		.cfi_def_cfa_offset 12
 5712              		@ sp needed
 5713 0030 30BD     		pop	{r4, r5, pc}
 5714              	.LVL663:
 5715              	.L610:
 5716              	.LCFI242:
 5717              		.cfi_restore_state
5484:Src/bno055.c  **** 	}
 5718              		.loc 1 5484 0
 5719 0032 FF24     		movs	r4, #255
 5720 0034 FAE7     		b	.L609
ARM GAS  /tmp/ccVWLGiI.s 			page 203


 5721              	.L613:
 5722 0036 00BF     		.align	2
 5723              	.L612:
 5724 0038 00005940 		.word	1079574528
 5725              		.cfi_endproc
 5726              	.LFE109:
 5728              		.section	.text.bno055_convert_double_linear_accel_xyz_msq,"ax",%progbits
 5729              		.align	2
 5730              		.global	bno055_convert_double_linear_accel_xyz_msq
 5731              		.thumb
 5732              		.thumb_func
 5734              	bno055_convert_double_linear_accel_xyz_msq:
 5735              	.LFB110:
5488:Src/bno055.c  **** /*!
5489:Src/bno055.c  ****  *	@brief This API is used to convert the linear accel xyz raw data
5490:Src/bno055.c  ****  *	to meterpersecseq output as double
5491:Src/bno055.c  ****  *
5492:Src/bno055.c  ****  *	@param linear_accel_xyz : The meterpersecseq data of linear accel xyz
5493:Src/bno055.c  ****  *
5494:Src/bno055.c  ****  *	Parameter |    result
5495:Src/bno055.c  ****  *  --------- | -----------------
5496:Src/bno055.c  ****  *	 x        | meterpersecseq data of linear accel
5497:Src/bno055.c  ****  *	 y        | meterpersecseq data of linear accel
5498:Src/bno055.c  ****  *	 z        | meterpersecseq data of linear accel
5499:Src/bno055.c  ****  *
5500:Src/bno055.c  ****  *
5501:Src/bno055.c  ****  *	@return results of bus communication function
5502:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5503:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5504:Src/bno055.c  ****  *
5505:Src/bno055.c  ****  */
5506:Src/bno055.c  **** 
5507:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_linear_accel_xyz_msq(
5508:Src/bno055.c  **** struct bno055_linear_accel_double_t *linear_accel_xyz)
5509:Src/bno055.c  **** {
 5736              		.loc 1 5509 0
 5737              		.cfi_startproc
 5738              		@ args = 0, pretend = 0, frame = 8
 5739              		@ frame_needed = 0, uses_anonymous_args = 0
 5740              	.LVL664:
 5741 0000 30B5     		push	{r4, r5, lr}
 5742              	.LCFI243:
 5743              		.cfi_def_cfa_offset 12
 5744              		.cfi_offset 4, -12
 5745              		.cfi_offset 5, -8
 5746              		.cfi_offset 14, -4
 5747 0002 83B0     		sub	sp, sp, #12
 5748              	.LCFI244:
 5749              		.cfi_def_cfa_offset 24
5510:Src/bno055.c  **** 	/* Variable used to return value of
5511:Src/bno055.c  **** 	communication routine*/
5512:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5513:Src/bno055.c  **** 	struct bno055_linear_accel_t reg_linear_accel_xyz = {
 5750              		.loc 1 5513 0
 5751 0004 0023     		movs	r3, #0
5509:Src/bno055.c  **** 	/* Variable used to return value of
 5752              		.loc 1 5509 0
ARM GAS  /tmp/ccVWLGiI.s 			page 204


 5753 0006 0446     		mov	r4, r0
5514:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
5515:Src/bno055.c  **** 	/* Read the raw xyz of linear accel */
5516:Src/bno055.c  **** 	com_rslt = bno055_read_linear_accel_xyz(&reg_linear_accel_xyz);
 5754              		.loc 1 5516 0
 5755 0008 6846     		mov	r0, sp
 5756              	.LVL665:
5513:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 5757              		.loc 1 5513 0
 5758 000a ADF80030 		strh	r3, [sp]	@ movhi
 5759 000e ADF80230 		strh	r3, [sp, #2]	@ movhi
 5760 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 5761              		.loc 1 5516 0
 5762 0016 FFF7FEFF 		bl	bno055_read_linear_accel_xyz
 5763              	.LVL666:
5517:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5764              		.loc 1 5517 0
 5765 001a 0546     		mov	r5, r0
 5766 001c 00BB     		cbnz	r0, .L616
5518:Src/bno055.c  **** 		/* Convert the raw xyz of linear accel to m/s2 */
5519:Src/bno055.c  **** 		linear_accel_xyz->x =
5520:Src/bno055.c  **** 		(double)(reg_linear_accel_xyz.x/BNO055_LINEAR_ACCEL_DIV_MSQ);
 5767              		.loc 1 5520 0
 5768 001e BDF90000 		ldrsh	r0, [sp]
 5769              	.LVL667:
 5770 0022 FFF7FEFF 		bl	__aeabi_i2d
 5771              	.LVL668:
 5772 0026 0022     		movs	r2, #0
 5773 0028 0E4B     		ldr	r3, .L618
 5774 002a FFF7FEFF 		bl	__aeabi_ddiv
 5775              	.LVL669:
5519:Src/bno055.c  **** 		(double)(reg_linear_accel_xyz.x/BNO055_LINEAR_ACCEL_DIV_MSQ);
 5776              		.loc 1 5519 0
 5777 002e C4E90001 		strd	r0, [r4]
5521:Src/bno055.c  **** 		linear_accel_xyz->y =
5522:Src/bno055.c  **** 		(double)(reg_linear_accel_xyz.y/BNO055_LINEAR_ACCEL_DIV_MSQ);
 5778              		.loc 1 5522 0
 5779 0032 BDF90200 		ldrsh	r0, [sp, #2]
 5780 0036 FFF7FEFF 		bl	__aeabi_i2d
 5781              	.LVL670:
 5782 003a 0022     		movs	r2, #0
 5783 003c 094B     		ldr	r3, .L618
 5784 003e FFF7FEFF 		bl	__aeabi_ddiv
 5785              	.LVL671:
5521:Src/bno055.c  **** 		linear_accel_xyz->y =
 5786              		.loc 1 5521 0
 5787 0042 C4E90201 		strd	r0, [r4, #8]
5523:Src/bno055.c  **** 		linear_accel_xyz->z =
5524:Src/bno055.c  **** 		(double)(reg_linear_accel_xyz.z/BNO055_LINEAR_ACCEL_DIV_MSQ);
 5788              		.loc 1 5524 0
 5789 0046 BDF90400 		ldrsh	r0, [sp, #4]
 5790 004a FFF7FEFF 		bl	__aeabi_i2d
 5791              	.LVL672:
 5792 004e 0022     		movs	r2, #0
 5793 0050 044B     		ldr	r3, .L618
 5794 0052 FFF7FEFF 		bl	__aeabi_ddiv
 5795              	.LVL673:
ARM GAS  /tmp/ccVWLGiI.s 			page 205


5523:Src/bno055.c  **** 		linear_accel_xyz->z =
 5796              		.loc 1 5523 0
 5797 0056 C4E90401 		strd	r0, [r4, #16]
 5798              	.L615:
 5799              	.LVL674:
5525:Src/bno055.c  **** 	} else {
5526:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5527:Src/bno055.c  **** 	}
5528:Src/bno055.c  **** 	return com_rslt;
5529:Src/bno055.c  **** }
 5800              		.loc 1 5529 0
 5801 005a 68B2     		sxtb	r0, r5
 5802 005c 03B0     		add	sp, sp, #12
 5803              	.LCFI245:
 5804              		.cfi_remember_state
 5805              		.cfi_def_cfa_offset 12
 5806              		@ sp needed
 5807 005e 30BD     		pop	{r4, r5, pc}
 5808              	.LVL675:
 5809              	.L616:
 5810              	.LCFI246:
 5811              		.cfi_restore_state
5526:Src/bno055.c  **** 	}
 5812              		.loc 1 5526 0
 5813 0060 FF25     		movs	r5, #255
 5814 0062 FAE7     		b	.L615
 5815              	.L619:
 5816              		.align	2
 5817              	.L618:
 5818 0064 00005940 		.word	1079574528
 5819              		.cfi_endproc
 5820              	.LFE110:
 5822              		.section	.text.bno055_convert_gravity_double_x_msq,"ax",%progbits
 5823              		.align	2
 5824              		.global	bno055_convert_gravity_double_x_msq
 5825              		.thumb
 5826              		.thumb_func
 5828              	bno055_convert_gravity_double_x_msq:
 5829              	.LFB111:
5530:Src/bno055.c  **** /*!
5531:Src/bno055.c  ****  *	@brief This API is used to convert the gravity
5532:Src/bno055.c  ****  *	x raw data to meterpersecseq output as double
5533:Src/bno055.c  ****  *
5534:Src/bno055.c  ****  *	@param gravity_x_d : The double value of gravity x meterpersecseq
5535:Src/bno055.c  ****  *
5536:Src/bno055.c  ****  *	@return results of bus communication function
5537:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5538:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5539:Src/bno055.c  ****  *
5540:Src/bno055.c  ****  *
5541:Src/bno055.c  ****  */
5542:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_gravity_double_x_msq(
5543:Src/bno055.c  **** double *gravity_x_d)
5544:Src/bno055.c  **** {
 5830              		.loc 1 5544 0
 5831              		.cfi_startproc
 5832              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccVWLGiI.s 			page 206


 5833              		@ frame_needed = 0, uses_anonymous_args = 0
 5834              	.LVL676:
 5835 0000 30B5     		push	{r4, r5, lr}
 5836              	.LCFI247:
 5837              		.cfi_def_cfa_offset 12
 5838              		.cfi_offset 4, -12
 5839              		.cfi_offset 5, -8
 5840              		.cfi_offset 14, -4
 5841 0002 83B0     		sub	sp, sp, #12
 5842              	.LCFI248:
 5843              		.cfi_def_cfa_offset 24
5545:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5546:Src/bno055.c  **** 	s16 reg_gravity_x_s16 = BNO055_INIT_VALUE;
 5844              		.loc 1 5546 0
 5845 0004 02AB     		add	r3, sp, #8
 5846 0006 0022     		movs	r2, #0
 5847 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5848              	.LVL677:
5544:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 5849              		.loc 1 5544 0
 5850 000c 0546     		mov	r5, r0
5547:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5548:Src/bno055.c  **** 	/* Read raw gravity of x*/
5549:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_x(&reg_gravity_x_s16);
 5851              		.loc 1 5549 0
 5852 000e 1846     		mov	r0, r3
 5853              	.LVL678:
 5854 0010 FFF7FEFF 		bl	bno055_read_gravity_x
 5855              	.LVL679:
5550:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5856              		.loc 1 5550 0
 5857 0014 0446     		mov	r4, r0
 5858 0016 60B9     		cbnz	r0, .L622
 5859              	.LVL680:
5551:Src/bno055.c  **** 		/* Convert raw gravity of x to m/s2 */
5552:Src/bno055.c  **** 		data_d =
5553:Src/bno055.c  **** 		(double)(reg_gravity_x_s16/BNO055_GRAVITY_DIV_MSQ);
 5860              		.loc 1 5553 0
 5861 0018 BDF90600 		ldrsh	r0, [sp, #6]
 5862              	.LVL681:
 5863 001c FFF7FEFF 		bl	__aeabi_i2d
 5864              	.LVL682:
5552:Src/bno055.c  **** 		(double)(reg_gravity_x_s16/BNO055_GRAVITY_DIV_MSQ);
 5865              		.loc 1 5552 0
 5866 0020 0022     		movs	r2, #0
 5867 0022 054B     		ldr	r3, .L624
 5868 0024 FFF7FEFF 		bl	__aeabi_ddiv
 5869              	.LVL683:
5554:Src/bno055.c  **** 		*gravity_x_d = data_d;
 5870              		.loc 1 5554 0
 5871 0028 C5E90001 		strd	r0, [r5]
 5872              	.L621:
 5873              	.LVL684:
5555:Src/bno055.c  **** 	} else {
5556:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5557:Src/bno055.c  **** 	}
5558:Src/bno055.c  **** 	return com_rslt;
ARM GAS  /tmp/ccVWLGiI.s 			page 207


5559:Src/bno055.c  **** }
 5874              		.loc 1 5559 0
 5875 002c 60B2     		sxtb	r0, r4
 5876 002e 03B0     		add	sp, sp, #12
 5877              	.LCFI249:
 5878              		.cfi_remember_state
 5879              		.cfi_def_cfa_offset 12
 5880              		@ sp needed
 5881 0030 30BD     		pop	{r4, r5, pc}
 5882              	.LVL685:
 5883              	.L622:
 5884              	.LCFI250:
 5885              		.cfi_restore_state
5556:Src/bno055.c  **** 	}
 5886              		.loc 1 5556 0
 5887 0032 FF24     		movs	r4, #255
 5888 0034 FAE7     		b	.L621
 5889              	.L625:
 5890 0036 00BF     		.align	2
 5891              	.L624:
 5892 0038 00005940 		.word	1079574528
 5893              		.cfi_endproc
 5894              	.LFE111:
 5896              		.section	.text.bno055_convert_gravity_double_y_msq,"ax",%progbits
 5897              		.align	2
 5898              		.global	bno055_convert_gravity_double_y_msq
 5899              		.thumb
 5900              		.thumb_func
 5902              	bno055_convert_gravity_double_y_msq:
 5903              	.LFB112:
5560:Src/bno055.c  **** /*!
5561:Src/bno055.c  ****  *	@brief This API is used to convert the gravity
5562:Src/bno055.c  ****  *	y raw data to meterpersecseq output as double
5563:Src/bno055.c  ****  *
5564:Src/bno055.c  ****  *	@param gravity_y_d : The double value of gravity y meterpersecseq
5565:Src/bno055.c  ****  *
5566:Src/bno055.c  ****  *	@return results of bus communication function
5567:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5568:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5569:Src/bno055.c  ****  *
5570:Src/bno055.c  ****  *
5571:Src/bno055.c  ****  */
5572:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_gravity_double_y_msq(
5573:Src/bno055.c  **** double *gravity_y_d)
5574:Src/bno055.c  **** {
 5904              		.loc 1 5574 0
 5905              		.cfi_startproc
 5906              		@ args = 0, pretend = 0, frame = 8
 5907              		@ frame_needed = 0, uses_anonymous_args = 0
 5908              	.LVL686:
 5909 0000 30B5     		push	{r4, r5, lr}
 5910              	.LCFI251:
 5911              		.cfi_def_cfa_offset 12
 5912              		.cfi_offset 4, -12
 5913              		.cfi_offset 5, -8
 5914              		.cfi_offset 14, -4
 5915 0002 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 208


 5916              	.LCFI252:
 5917              		.cfi_def_cfa_offset 24
5575:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5576:Src/bno055.c  **** 	s16 reg_gravity_y_s16 = BNO055_INIT_VALUE;
 5918              		.loc 1 5576 0
 5919 0004 02AB     		add	r3, sp, #8
 5920 0006 0022     		movs	r2, #0
 5921 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 5922              	.LVL687:
5574:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 5923              		.loc 1 5574 0
 5924 000c 0546     		mov	r5, r0
5577:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5578:Src/bno055.c  **** 	/* Read raw gravity of y */
5579:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_y(&reg_gravity_y_s16);
 5925              		.loc 1 5579 0
 5926 000e 1846     		mov	r0, r3
 5927              	.LVL688:
 5928 0010 FFF7FEFF 		bl	bno055_read_gravity_y
 5929              	.LVL689:
5580:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 5930              		.loc 1 5580 0
 5931 0014 0446     		mov	r4, r0
 5932 0016 20B1     		cbz	r0, .L630
5581:Src/bno055.c  **** 		/* convert raw gravity of y to m/s2 */
5582:Src/bno055.c  **** 		data_d =
5583:Src/bno055.c  **** 		(double)(reg_gravity_y_s16/BNO055_GRAVITY_DIV_MSQ);
5584:Src/bno055.c  **** 		*gravity_y_d = data_d;
5585:Src/bno055.c  **** 	} else {
5586:Src/bno055.c  **** 		com_rslt += BNO055_ERROR;
 5933              		.loc 1 5586 0
 5934 0018 441E     		subs	r4, r0, #1
 5935 001a E4B2     		uxtb	r4, r4
 5936              	.LVL690:
5587:Src/bno055.c  **** 	}
5588:Src/bno055.c  **** 	return com_rslt;
5589:Src/bno055.c  **** }
 5937              		.loc 1 5589 0
 5938 001c 60B2     		sxtb	r0, r4
 5939 001e 03B0     		add	sp, sp, #12
 5940              	.LCFI253:
 5941              		.cfi_remember_state
 5942              		.cfi_def_cfa_offset 12
 5943              		@ sp needed
 5944 0020 30BD     		pop	{r4, r5, pc}
 5945              	.LVL691:
 5946              	.L630:
 5947              	.LCFI254:
 5948              		.cfi_restore_state
5583:Src/bno055.c  **** 		*gravity_y_d = data_d;
 5949              		.loc 1 5583 0
 5950 0022 BDF90600 		ldrsh	r0, [sp, #6]
 5951              	.LVL692:
 5952 0026 FFF7FEFF 		bl	__aeabi_i2d
 5953              	.LVL693:
5582:Src/bno055.c  **** 		(double)(reg_gravity_y_s16/BNO055_GRAVITY_DIV_MSQ);
 5954              		.loc 1 5582 0
ARM GAS  /tmp/ccVWLGiI.s 			page 209


 5955 002a 0022     		movs	r2, #0
 5956 002c 034B     		ldr	r3, .L631
 5957 002e FFF7FEFF 		bl	__aeabi_ddiv
 5958              	.LVL694:
5584:Src/bno055.c  **** 	} else {
 5959              		.loc 1 5584 0
 5960 0032 C5E90001 		strd	r0, [r5]
 5961              	.LVL695:
 5962              		.loc 1 5589 0
 5963 0036 60B2     		sxtb	r0, r4
 5964 0038 03B0     		add	sp, sp, #12
 5965              	.LCFI255:
 5966              		.cfi_def_cfa_offset 12
 5967              		@ sp needed
 5968 003a 30BD     		pop	{r4, r5, pc}
 5969              	.LVL696:
 5970              	.L632:
 5971              		.align	2
 5972              	.L631:
 5973 003c 00005940 		.word	1079574528
 5974              		.cfi_endproc
 5975              	.LFE112:
 5977              		.section	.text.bno055_convert_gravity_double_z_msq,"ax",%progbits
 5978              		.align	2
 5979              		.global	bno055_convert_gravity_double_z_msq
 5980              		.thumb
 5981              		.thumb_func
 5983              	bno055_convert_gravity_double_z_msq:
 5984              	.LFB113:
5590:Src/bno055.c  **** /*!
5591:Src/bno055.c  ****  *	@brief This API is used to convert the gravity
5592:Src/bno055.c  ****  *	z raw data to meterpersecseq output as double
5593:Src/bno055.c  ****  *
5594:Src/bno055.c  ****  *	@param gravity_z_d : The double value of gravity z meterpersecseq
5595:Src/bno055.c  ****  *
5596:Src/bno055.c  ****  *	@return results of bus communication function
5597:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5598:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5599:Src/bno055.c  ****  *
5600:Src/bno055.c  ****  *
5601:Src/bno055.c  ****  */
5602:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_gravity_double_z_msq(
5603:Src/bno055.c  **** double *gravity_z_d)
5604:Src/bno055.c  **** {
 5985              		.loc 1 5604 0
 5986              		.cfi_startproc
 5987              		@ args = 0, pretend = 0, frame = 8
 5988              		@ frame_needed = 0, uses_anonymous_args = 0
 5989              	.LVL697:
 5990 0000 30B5     		push	{r4, r5, lr}
 5991              	.LCFI256:
 5992              		.cfi_def_cfa_offset 12
 5993              		.cfi_offset 4, -12
 5994              		.cfi_offset 5, -8
 5995              		.cfi_offset 14, -4
 5996 0002 83B0     		sub	sp, sp, #12
 5997              	.LCFI257:
ARM GAS  /tmp/ccVWLGiI.s 			page 210


 5998              		.cfi_def_cfa_offset 24
5605:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5606:Src/bno055.c  **** 	s16 reg_gravity_z_s16 = BNO055_INIT_VALUE;
 5999              		.loc 1 5606 0
 6000 0004 02AB     		add	r3, sp, #8
 6001 0006 0022     		movs	r2, #0
 6002 0008 23F8022D 		strh	r2, [r3, #-2]!	@ movhi
 6003              	.LVL698:
5604:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 6004              		.loc 1 5604 0
 6005 000c 0546     		mov	r5, r0
5607:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5608:Src/bno055.c  **** 	/* Read raw gravity of z */
5609:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_z(&reg_gravity_z_s16);
 6006              		.loc 1 5609 0
 6007 000e 1846     		mov	r0, r3
 6008              	.LVL699:
 6009 0010 FFF7FEFF 		bl	bno055_read_gravity_z
 6010              	.LVL700:
5610:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 6011              		.loc 1 5610 0
 6012 0014 0446     		mov	r4, r0
 6013 0016 20B1     		cbz	r0, .L637
5611:Src/bno055.c  **** 		/* Convert raw gravity of z to m/s2 */
5612:Src/bno055.c  **** 		data_d =
5613:Src/bno055.c  **** 		(double)(reg_gravity_z_s16/BNO055_GRAVITY_DIV_MSQ);
5614:Src/bno055.c  **** 		*gravity_z_d = data_d;
5615:Src/bno055.c  **** 	} else {
5616:Src/bno055.c  **** 		com_rslt += BNO055_ERROR;
 6014              		.loc 1 5616 0
 6015 0018 441E     		subs	r4, r0, #1
 6016 001a E4B2     		uxtb	r4, r4
 6017              	.LVL701:
5617:Src/bno055.c  **** 	}
5618:Src/bno055.c  **** 	return com_rslt;
5619:Src/bno055.c  **** }
 6018              		.loc 1 5619 0
 6019 001c 60B2     		sxtb	r0, r4
 6020 001e 03B0     		add	sp, sp, #12
 6021              	.LCFI258:
 6022              		.cfi_remember_state
 6023              		.cfi_def_cfa_offset 12
 6024              		@ sp needed
 6025 0020 30BD     		pop	{r4, r5, pc}
 6026              	.LVL702:
 6027              	.L637:
 6028              	.LCFI259:
 6029              		.cfi_restore_state
5613:Src/bno055.c  **** 		*gravity_z_d = data_d;
 6030              		.loc 1 5613 0
 6031 0022 BDF90600 		ldrsh	r0, [sp, #6]
 6032              	.LVL703:
 6033 0026 FFF7FEFF 		bl	__aeabi_i2d
 6034              	.LVL704:
5612:Src/bno055.c  **** 		(double)(reg_gravity_z_s16/BNO055_GRAVITY_DIV_MSQ);
 6035              		.loc 1 5612 0
 6036 002a 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 211


 6037 002c 034B     		ldr	r3, .L638
 6038 002e FFF7FEFF 		bl	__aeabi_ddiv
 6039              	.LVL705:
5614:Src/bno055.c  **** 	} else {
 6040              		.loc 1 5614 0
 6041 0032 C5E90001 		strd	r0, [r5]
 6042              	.LVL706:
 6043              		.loc 1 5619 0
 6044 0036 60B2     		sxtb	r0, r4
 6045 0038 03B0     		add	sp, sp, #12
 6046              	.LCFI260:
 6047              		.cfi_def_cfa_offset 12
 6048              		@ sp needed
 6049 003a 30BD     		pop	{r4, r5, pc}
 6050              	.LVL707:
 6051              	.L639:
 6052              		.align	2
 6053              	.L638:
 6054 003c 00005940 		.word	1079574528
 6055              		.cfi_endproc
 6056              	.LFE113:
 6058              		.section	.text.bno055_convert_double_gravity_xyz_msq,"ax",%progbits
 6059              		.align	2
 6060              		.global	bno055_convert_double_gravity_xyz_msq
 6061              		.thumb
 6062              		.thumb_func
 6064              	bno055_convert_double_gravity_xyz_msq:
 6065              	.LFB114:
5620:Src/bno055.c  **** /*!
5621:Src/bno055.c  ****  *	@brief This API is used to convert the gravity xyz raw data
5622:Src/bno055.c  ****  *	to meterpersecseq output as double
5623:Src/bno055.c  ****  *
5624:Src/bno055.c  ****  *	@param gravity_xyz : The meterpersecseq data of gravity xyz
5625:Src/bno055.c  ****  *
5626:Src/bno055.c  ****  *	Parameter |    result
5627:Src/bno055.c  ****  *  --------- | -----------------
5628:Src/bno055.c  ****  *	 x        | meterpersecseq data of gravity
5629:Src/bno055.c  ****  *	 y        | meterpersecseq data of gravity
5630:Src/bno055.c  ****  *	 z        | meterpersecseq data of gravity
5631:Src/bno055.c  ****  *
5632:Src/bno055.c  ****  *
5633:Src/bno055.c  ****  *	@return results of bus communication function
5634:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5635:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5636:Src/bno055.c  ****  *
5637:Src/bno055.c  ****  */
5638:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_gravity_xyz_msq(
5639:Src/bno055.c  **** struct bno055_gravity_double_t *gravity_xyz)
5640:Src/bno055.c  **** {
 6066              		.loc 1 5640 0
 6067              		.cfi_startproc
 6068              		@ args = 0, pretend = 0, frame = 8
 6069              		@ frame_needed = 0, uses_anonymous_args = 0
 6070              	.LVL708:
 6071 0000 30B5     		push	{r4, r5, lr}
 6072              	.LCFI261:
 6073              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 212


 6074              		.cfi_offset 4, -12
 6075              		.cfi_offset 5, -8
 6076              		.cfi_offset 14, -4
 6077 0002 83B0     		sub	sp, sp, #12
 6078              	.LCFI262:
 6079              		.cfi_def_cfa_offset 24
5641:Src/bno055.c  **** 	/* Variable used to return value of
5642:Src/bno055.c  **** 	communication routine*/
5643:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5644:Src/bno055.c  **** 	struct bno055_gravity_t reg_gravity_xyz = {
 6080              		.loc 1 5644 0
 6081 0004 0023     		movs	r3, #0
5640:Src/bno055.c  **** 	/* Variable used to return value of
 6082              		.loc 1 5640 0
 6083 0006 0546     		mov	r5, r0
5645:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
5646:Src/bno055.c  **** 	/* Read raw gravity of xyz */
5647:Src/bno055.c  **** 	com_rslt = bno055_read_gravity_xyz(&reg_gravity_xyz);
 6084              		.loc 1 5647 0
 6085 0008 6846     		mov	r0, sp
 6086              	.LVL709:
5644:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 6087              		.loc 1 5644 0
 6088 000a ADF80030 		strh	r3, [sp]	@ movhi
 6089 000e ADF80230 		strh	r3, [sp, #2]	@ movhi
 6090 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 6091              		.loc 1 5647 0
 6092 0016 FFF7FEFF 		bl	bno055_read_gravity_xyz
 6093              	.LVL710:
5648:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 6094              		.loc 1 5648 0
 6095 001a 0446     		mov	r4, r0
 6096 001c 20B1     		cbz	r0, .L644
5649:Src/bno055.c  **** 		/* Convert raw gravity of xyz to m/s2 */
5650:Src/bno055.c  **** 		gravity_xyz->x =
5651:Src/bno055.c  **** 		(double)(reg_gravity_xyz.x/BNO055_GRAVITY_DIV_MSQ);
5652:Src/bno055.c  **** 		gravity_xyz->y =
5653:Src/bno055.c  **** 		(double)(reg_gravity_xyz.y/BNO055_GRAVITY_DIV_MSQ);
5654:Src/bno055.c  **** 		gravity_xyz->z =
5655:Src/bno055.c  **** 		(double)(reg_gravity_xyz.z/BNO055_GRAVITY_DIV_MSQ);
5656:Src/bno055.c  **** 	} else {
5657:Src/bno055.c  **** 		com_rslt += BNO055_ERROR;
 6097              		.loc 1 5657 0
 6098 001e 441E     		subs	r4, r0, #1
 6099 0020 E4B2     		uxtb	r4, r4
 6100              	.LVL711:
5658:Src/bno055.c  **** 	}
5659:Src/bno055.c  **** 	return com_rslt;
5660:Src/bno055.c  **** }
 6101              		.loc 1 5660 0
 6102 0022 60B2     		sxtb	r0, r4
 6103 0024 03B0     		add	sp, sp, #12
 6104              	.LCFI263:
 6105              		.cfi_remember_state
 6106              		.cfi_def_cfa_offset 12
 6107              		@ sp needed
 6108 0026 30BD     		pop	{r4, r5, pc}
ARM GAS  /tmp/ccVWLGiI.s 			page 213


 6109              	.LVL712:
 6110              	.L644:
 6111              	.LCFI264:
 6112              		.cfi_restore_state
5651:Src/bno055.c  **** 		gravity_xyz->y =
 6113              		.loc 1 5651 0
 6114 0028 BDF90000 		ldrsh	r0, [sp]
 6115              	.LVL713:
 6116 002c FFF7FEFF 		bl	__aeabi_i2d
 6117              	.LVL714:
 6118 0030 0022     		movs	r2, #0
 6119 0032 0E4B     		ldr	r3, .L645
 6120 0034 FFF7FEFF 		bl	__aeabi_ddiv
 6121              	.LVL715:
5650:Src/bno055.c  **** 		(double)(reg_gravity_xyz.x/BNO055_GRAVITY_DIV_MSQ);
 6122              		.loc 1 5650 0
 6123 0038 C5E90001 		strd	r0, [r5]
5653:Src/bno055.c  **** 		gravity_xyz->z =
 6124              		.loc 1 5653 0
 6125 003c BDF90200 		ldrsh	r0, [sp, #2]
 6126 0040 FFF7FEFF 		bl	__aeabi_i2d
 6127              	.LVL716:
 6128 0044 0022     		movs	r2, #0
 6129 0046 094B     		ldr	r3, .L645
 6130 0048 FFF7FEFF 		bl	__aeabi_ddiv
 6131              	.LVL717:
5652:Src/bno055.c  **** 		(double)(reg_gravity_xyz.y/BNO055_GRAVITY_DIV_MSQ);
 6132              		.loc 1 5652 0
 6133 004c C5E90201 		strd	r0, [r5, #8]
5655:Src/bno055.c  **** 	} else {
 6134              		.loc 1 5655 0
 6135 0050 BDF90400 		ldrsh	r0, [sp, #4]
 6136 0054 FFF7FEFF 		bl	__aeabi_i2d
 6137              	.LVL718:
 6138 0058 0022     		movs	r2, #0
 6139 005a 044B     		ldr	r3, .L645
 6140 005c FFF7FEFF 		bl	__aeabi_ddiv
 6141              	.LVL719:
5654:Src/bno055.c  **** 		(double)(reg_gravity_xyz.z/BNO055_GRAVITY_DIV_MSQ);
 6142              		.loc 1 5654 0
 6143 0060 C5E90401 		strd	r0, [r5, #16]
 6144              	.LVL720:
 6145              		.loc 1 5660 0
 6146 0064 60B2     		sxtb	r0, r4
 6147 0066 03B0     		add	sp, sp, #12
 6148              	.LCFI265:
 6149              		.cfi_def_cfa_offset 12
 6150              		@ sp needed
 6151 0068 30BD     		pop	{r4, r5, pc}
 6152              	.LVL721:
 6153              	.L646:
 6154 006a 00BF     		.align	2
 6155              	.L645:
 6156 006c 00005940 		.word	1079574528
 6157              		.cfi_endproc
 6158              	.LFE114:
 6160              		.section	.text.bno055_get_mag_calib_stat,"ax",%progbits
ARM GAS  /tmp/ccVWLGiI.s 			page 214


 6161              		.align	2
 6162              		.global	bno055_get_mag_calib_stat
 6163              		.thumb
 6164              		.thumb_func
 6166              	bno055_get_mag_calib_stat:
 6167              	.LFB117:
5661:Src/bno055.c  **** /*!
5662:Src/bno055.c  ****  *	@brief This API is used to convert the temperature
5663:Src/bno055.c  ****  *	data to Fahrenheit output as double
5664:Src/bno055.c  ****  *
5665:Src/bno055.c  ****  *	@param temp_d : The double value of temperature Fahrenheit
5666:Src/bno055.c  ****  *
5667:Src/bno055.c  ****  *	@return results of bus communication function
5668:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5669:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5670:Src/bno055.c  ****  *
5671:Src/bno055.c  ****  *
5672:Src/bno055.c  ****  */
5673:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_temp_fahrenheit(
5674:Src/bno055.c  **** double *temp_d)
5675:Src/bno055.c  **** {
5676:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5677:Src/bno055.c  **** 	s8 reg_temp_s8 = BNO055_INIT_VALUE;
5678:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5679:Src/bno055.c  **** 	u8 temp_unit_u8 = BNO055_INIT_VALUE;
5680:Src/bno055.c  **** 	/* Read the current temperature unit and set the
5681:Src/bno055.c  **** 	unit as Fahrenheit if the unit is in Celsius */
5682:Src/bno055.c  **** 	com_rslt = bno055_get_temp_unit(&temp_unit_u8);
5683:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
5684:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_FAHRENHEIT);
5685:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5686:Src/bno055.c  **** 			/* Read the raw temperature data */
5687:Src/bno055.c  **** 			com_rslt += bno055_read_temp_data(&reg_temp_s8);
5688:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5689:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
5690:Src/bno055.c  **** 				data_d = (double)(reg_temp_s8/
5691:Src/bno055.c  **** 				BNO055_TEMP_DIV_FAHRENHEIT);
5692:Src/bno055.c  **** 				*temp_d = data_d;
5693:Src/bno055.c  **** 			} else {
5694:Src/bno055.c  **** 			com_rslt += BNO055_ERROR;
5695:Src/bno055.c  **** 			}
5696:Src/bno055.c  **** 		} else {
5697:Src/bno055.c  **** 		com_rslt += BNO055_ERROR;
5698:Src/bno055.c  **** 		}
5699:Src/bno055.c  **** 	return com_rslt;
5700:Src/bno055.c  **** }
5701:Src/bno055.c  **** /*!
5702:Src/bno055.c  ****  *	@brief This API is used to convert the temperature
5703:Src/bno055.c  ****  *	data to Celsius output as double
5704:Src/bno055.c  ****  *
5705:Src/bno055.c  ****  *	@param temp_d : The double value of temperature Celsius
5706:Src/bno055.c  ****  *
5707:Src/bno055.c  ****  *	@return results of bus communication function
5708:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5709:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5710:Src/bno055.c  ****  *
5711:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 215


5712:Src/bno055.c  ****  */
5713:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_convert_double_temp_celsius(
5714:Src/bno055.c  **** double *temp_d)
5715:Src/bno055.c  **** {
5716:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5717:Src/bno055.c  **** 	s8 reg_temp_s8 = BNO055_INIT_VALUE;
5718:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
5719:Src/bno055.c  **** 	u8 temp_unit_u8 = BNO055_INIT_VALUE;
5720:Src/bno055.c  **** 	/* Read the current temperature unit and set the
5721:Src/bno055.c  **** 	unit as Fahrenheit if the unit is in Celsius */
5722:Src/bno055.c  **** 	com_rslt = bno055_get_temp_unit(&temp_unit_u8);
5723:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
5724:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_CELSIUS);
5725:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
5726:Src/bno055.c  **** 			/* Read the raw temperature data */
5727:Src/bno055.c  **** 			com_rslt += bno055_read_temp_data(&reg_temp_s8);
5728:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
5729:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
5730:Src/bno055.c  **** 				data_d =
5731:Src/bno055.c  **** 				(double)(reg_temp_s8/BNO055_TEMP_DIV_CELSIUS);
5732:Src/bno055.c  **** 				*temp_d = data_d;
5733:Src/bno055.c  **** 			} else {
5734:Src/bno055.c  **** 			com_rslt += BNO055_ERROR;
5735:Src/bno055.c  **** 			}
5736:Src/bno055.c  **** 		} else {
5737:Src/bno055.c  **** 		com_rslt += BNO055_ERROR;
5738:Src/bno055.c  **** 		}
5739:Src/bno055.c  **** 	return com_rslt;
5740:Src/bno055.c  **** }
5741:Src/bno055.c  **** #endif
5742:Src/bno055.c  **** /*!
5743:Src/bno055.c  ****  *	@brief This API used to read
5744:Src/bno055.c  ****  *	mag calibration status from register from 0x35 bit 0 and 1
5745:Src/bno055.c  ****  *
5746:Src/bno055.c  ****  *	@param mag_calib_u8 : The value of mag calib status
5747:Src/bno055.c  ****  *
5748:Src/bno055.c  ****  *
5749:Src/bno055.c  ****  *	@return results of bus communication function
5750:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5751:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5752:Src/bno055.c  ****  *
5753:Src/bno055.c  ****  */
5754:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_mag_calib_stat(
5755:Src/bno055.c  **** u8 *mag_calib_u8)
5756:Src/bno055.c  **** {
 6168              		.loc 1 5756 0
 6169              		.cfi_startproc
 6170              		@ args = 0, pretend = 0, frame = 8
 6171              		@ frame_needed = 0, uses_anonymous_args = 0
 6172              	.LVL722:
 6173 0000 30B5     		push	{r4, r5, lr}
 6174              	.LCFI266:
 6175              		.cfi_def_cfa_offset 12
 6176              		.cfi_offset 4, -12
 6177              		.cfi_offset 5, -8
 6178              		.cfi_offset 14, -4
5757:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 216


5758:Src/bno055.c  **** 	communication routine*/
5759:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5760:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
5761:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
5762:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
5763:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6179              		.loc 1 5763 0
 6180 0002 134C     		ldr	r4, .L658
5756:Src/bno055.c  **** 	/* Variable used to return value of
 6181              		.loc 1 5756 0
 6182 0004 83B0     		sub	sp, sp, #12
 6183              	.LCFI267:
 6184              		.cfi_def_cfa_offset 24
 6185              		.loc 1 5763 0
 6186 0006 2368     		ldr	r3, [r4]
5760:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6187              		.loc 1 5760 0
 6188 0008 0022     		movs	r2, #0
 6189 000a 8DF80720 		strb	r2, [sp, #7]
 6190              	.LVL723:
 6191              		.loc 1 5763 0
 6192 000e E3B1     		cbz	r3, .L651
5764:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
5765:Src/bno055.c  **** 		} else {
5766:Src/bno055.c  **** 		/*condition check for page, mag calib
5767:Src/bno055.c  **** 		available in the page zero*/
5768:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6193              		.loc 1 5768 0
 6194 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6195 0012 0546     		mov	r5, r0
 6196 0014 71B9     		cbnz	r1, .L657
 6197              	.LVL724:
 6198              	.L649:
5769:Src/bno055.c  **** 			/* Write the page zero*/
5770:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
5771:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
5772:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
5773:Src/bno055.c  **** 			/* Read the mag calib stat_s8 */
5774:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6199              		.loc 1 5774 0
 6200 0016 1C69     		ldr	r4, [r3, #16]
 6201 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6202 001a 3521     		movs	r1, #53
 6203 001c 0123     		movs	r3, #1
 6204 001e 0DF10702 		add	r2, sp, #7
 6205 0022 A047     		blx	r4
 6206              	.LVL725:
5775:Src/bno055.c  **** 			(p_bno055->dev_addr,
5776:Src/bno055.c  **** 			BNO055_MAG_CALIB_STAT_REG,
5777:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
5778:Src/bno055.c  **** 			*mag_calib_u8 =
 6207              		.loc 1 5778 0
 6208 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6209 0028 03F00303 		and	r3, r3, #3
 6210 002c 2B70     		strb	r3, [r5]
 6211              	.LVL726:
 6212              	.L648:
ARM GAS  /tmp/ccVWLGiI.s 			page 217


5779:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
5780:Src/bno055.c  **** 			BNO055_MAG_CALIB_STAT);
5781:Src/bno055.c  **** 		} else {
5782:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5783:Src/bno055.c  **** 		}
5784:Src/bno055.c  **** 	}
5785:Src/bno055.c  **** 	return com_rslt;
5786:Src/bno055.c  **** }
 6213              		.loc 1 5786 0
 6214 002e 40B2     		sxtb	r0, r0
 6215 0030 03B0     		add	sp, sp, #12
 6216              	.LCFI268:
 6217              		.cfi_remember_state
 6218              		.cfi_def_cfa_offset 12
 6219              		@ sp needed
 6220 0032 30BD     		pop	{r4, r5, pc}
 6221              	.LVL727:
 6222              	.L657:
 6223              	.LCFI269:
 6224              		.cfi_restore_state
5770:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6225              		.loc 1 5770 0
 6226 0034 1046     		mov	r0, r2
 6227              	.LVL728:
 6228 0036 FFF7FEFF 		bl	bno055_write_page_id
 6229              	.LVL729:
 6230 003a 2368     		ldr	r3, [r4]
5771:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6231              		.loc 1 5771 0
 6232 003c 0028     		cmp	r0, #0
 6233 003e EAD0     		beq	.L649
 6234              	.LVL730:
5771:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6235              		.loc 1 5771 0 is_stmt 0 discriminator 1
 6236 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
5782:Src/bno055.c  **** 		}
 6237              		.loc 1 5782 0 is_stmt 1 discriminator 1
 6238 0042 FF20     		movs	r0, #255
5771:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6239              		.loc 1 5771 0 discriminator 1
 6240 0044 002A     		cmp	r2, #0
 6241 0046 F2D1     		bne	.L648
 6242 0048 E5E7     		b	.L649
 6243              	.LVL731:
 6244              	.L651:
5764:Src/bno055.c  **** 		} else {
 6245              		.loc 1 5764 0
 6246 004a 8120     		movs	r0, #129
 6247              	.LVL732:
 6248 004c EFE7     		b	.L648
 6249              	.L659:
 6250 004e 00BF     		.align	2
 6251              	.L658:
 6252 0050 00000000 		.word	.LANCHOR0
 6253              		.cfi_endproc
 6254              	.LFE117:
 6256              		.section	.text.bno055_get_accel_calib_stat,"ax",%progbits
ARM GAS  /tmp/ccVWLGiI.s 			page 218


 6257              		.align	2
 6258              		.global	bno055_get_accel_calib_stat
 6259              		.thumb
 6260              		.thumb_func
 6262              	bno055_get_accel_calib_stat:
 6263              	.LFB118:
5787:Src/bno055.c  **** /*!
5788:Src/bno055.c  ****  *	@brief This API used to read
5789:Src/bno055.c  ****  *	accel calibration status from register from 0x35 bit 2 and 3
5790:Src/bno055.c  ****  *
5791:Src/bno055.c  ****  *	@param accel_calib_u8 : The value of accel calib status
5792:Src/bno055.c  ****  *
5793:Src/bno055.c  ****  *
5794:Src/bno055.c  ****  *	@return results of bus communication function
5795:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5796:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5797:Src/bno055.c  ****  *
5798:Src/bno055.c  ****  */
5799:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_calib_stat(
5800:Src/bno055.c  **** u8 *accel_calib_u8)
5801:Src/bno055.c  **** {
 6264              		.loc 1 5801 0
 6265              		.cfi_startproc
 6266              		@ args = 0, pretend = 0, frame = 8
 6267              		@ frame_needed = 0, uses_anonymous_args = 0
 6268              	.LVL733:
 6269 0000 30B5     		push	{r4, r5, lr}
 6270              	.LCFI270:
 6271              		.cfi_def_cfa_offset 12
 6272              		.cfi_offset 4, -12
 6273              		.cfi_offset 5, -8
 6274              		.cfi_offset 14, -4
5802:Src/bno055.c  **** 	/* Variable used to return value of
5803:Src/bno055.c  **** 	communication routine*/
5804:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5805:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
5806:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
5807:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty*/
5808:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6275              		.loc 1 5808 0
 6276 0002 134C     		ldr	r4, .L671
5801:Src/bno055.c  **** 	/* Variable used to return value of
 6277              		.loc 1 5801 0
 6278 0004 83B0     		sub	sp, sp, #12
 6279              	.LCFI271:
 6280              		.cfi_def_cfa_offset 24
 6281              		.loc 1 5808 0
 6282 0006 2368     		ldr	r3, [r4]
5805:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6283              		.loc 1 5805 0
 6284 0008 0022     		movs	r2, #0
 6285 000a 8DF80720 		strb	r2, [sp, #7]
 6286              	.LVL734:
 6287              		.loc 1 5808 0
 6288 000e E3B1     		cbz	r3, .L664
5809:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
5810:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 219


5811:Src/bno055.c  **** 		/*condition check for page, accel calib
5812:Src/bno055.c  **** 		available in the page zero*/
5813:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6289              		.loc 1 5813 0
 6290 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6291 0012 0546     		mov	r5, r0
 6292 0014 71B9     		cbnz	r1, .L670
 6293              	.LVL735:
 6294              	.L662:
5814:Src/bno055.c  **** 			/* Write the page zero*/
5815:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
5816:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
5817:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
5818:Src/bno055.c  **** 			/* Read the accel calib stat_s8 */
5819:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6295              		.loc 1 5819 0
 6296 0016 1C69     		ldr	r4, [r3, #16]
 6297 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6298 001a 3521     		movs	r1, #53
 6299 001c 0123     		movs	r3, #1
 6300 001e 0DF10702 		add	r2, sp, #7
 6301 0022 A047     		blx	r4
 6302              	.LVL736:
5820:Src/bno055.c  **** 			(p_bno055->dev_addr,
5821:Src/bno055.c  **** 			BNO055_ACCEL_CALIB_STAT_REG,
5822:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
5823:Src/bno055.c  **** 			*accel_calib_u8 =
5824:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 6303              		.loc 1 5824 0
 6304 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6305 0028 C3F38103 		ubfx	r3, r3, #2, #2
5823:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 6306              		.loc 1 5823 0
 6307 002c 2B70     		strb	r3, [r5]
 6308              	.LVL737:
 6309              	.L661:
5825:Src/bno055.c  **** 			BNO055_ACCEL_CALIB_STAT);
5826:Src/bno055.c  **** 		} else {
5827:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5828:Src/bno055.c  **** 		}
5829:Src/bno055.c  **** 	}
5830:Src/bno055.c  **** 	return com_rslt;
5831:Src/bno055.c  **** }
 6310              		.loc 1 5831 0
 6311 002e 40B2     		sxtb	r0, r0
 6312 0030 03B0     		add	sp, sp, #12
 6313              	.LCFI272:
 6314              		.cfi_remember_state
 6315              		.cfi_def_cfa_offset 12
 6316              		@ sp needed
 6317 0032 30BD     		pop	{r4, r5, pc}
 6318              	.LVL738:
 6319              	.L670:
 6320              	.LCFI273:
 6321              		.cfi_restore_state
5815:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6322              		.loc 1 5815 0
ARM GAS  /tmp/ccVWLGiI.s 			page 220


 6323 0034 1046     		mov	r0, r2
 6324              	.LVL739:
 6325 0036 FFF7FEFF 		bl	bno055_write_page_id
 6326              	.LVL740:
 6327 003a 2368     		ldr	r3, [r4]
5816:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6328              		.loc 1 5816 0
 6329 003c 0028     		cmp	r0, #0
 6330 003e EAD0     		beq	.L662
 6331              	.LVL741:
5816:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6332              		.loc 1 5816 0 is_stmt 0 discriminator 1
 6333 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
5827:Src/bno055.c  **** 		}
 6334              		.loc 1 5827 0 is_stmt 1 discriminator 1
 6335 0042 FF20     		movs	r0, #255
5816:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6336              		.loc 1 5816 0 discriminator 1
 6337 0044 002A     		cmp	r2, #0
 6338 0046 F2D1     		bne	.L661
 6339 0048 E5E7     		b	.L662
 6340              	.LVL742:
 6341              	.L664:
5809:Src/bno055.c  **** 		} else {
 6342              		.loc 1 5809 0
 6343 004a 8120     		movs	r0, #129
 6344              	.LVL743:
 6345 004c EFE7     		b	.L661
 6346              	.L672:
 6347 004e 00BF     		.align	2
 6348              	.L671:
 6349 0050 00000000 		.word	.LANCHOR0
 6350              		.cfi_endproc
 6351              	.LFE118:
 6353              		.section	.text.bno055_get_gyro_calib_stat,"ax",%progbits
 6354              		.align	2
 6355              		.global	bno055_get_gyro_calib_stat
 6356              		.thumb
 6357              		.thumb_func
 6359              	bno055_get_gyro_calib_stat:
 6360              	.LFB119:
5832:Src/bno055.c  **** /*!
5833:Src/bno055.c  ****  *	@brief This API used to read
5834:Src/bno055.c  ****  *	gyro calibration status from register from 0x35 bit 4 and 5
5835:Src/bno055.c  ****  *
5836:Src/bno055.c  ****  *	@param gyro_calib_u8 : The value of gyro calib status
5837:Src/bno055.c  ****  *
5838:Src/bno055.c  ****  *
5839:Src/bno055.c  ****  *	@return results of bus communication function
5840:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5841:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5842:Src/bno055.c  ****  *
5843:Src/bno055.c  ****  */
5844:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_calib_stat(
5845:Src/bno055.c  **** u8 *gyro_calib_u8)
5846:Src/bno055.c  **** {
 6361              		.loc 1 5846 0
ARM GAS  /tmp/ccVWLGiI.s 			page 221


 6362              		.cfi_startproc
 6363              		@ args = 0, pretend = 0, frame = 8
 6364              		@ frame_needed = 0, uses_anonymous_args = 0
 6365              	.LVL744:
 6366 0000 30B5     		push	{r4, r5, lr}
 6367              	.LCFI274:
 6368              		.cfi_def_cfa_offset 12
 6369              		.cfi_offset 4, -12
 6370              		.cfi_offset 5, -8
 6371              		.cfi_offset 14, -4
5847:Src/bno055.c  **** 	/* Variable used to return value of
5848:Src/bno055.c  **** 	communication routine*/
5849:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5850:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
5851:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
5852:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
5853:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6372              		.loc 1 5853 0
 6373 0002 134C     		ldr	r4, .L684
5846:Src/bno055.c  **** 	/* Variable used to return value of
 6374              		.loc 1 5846 0
 6375 0004 83B0     		sub	sp, sp, #12
 6376              	.LCFI275:
 6377              		.cfi_def_cfa_offset 24
 6378              		.loc 1 5853 0
 6379 0006 2368     		ldr	r3, [r4]
5850:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6380              		.loc 1 5850 0
 6381 0008 0022     		movs	r2, #0
 6382 000a 8DF80720 		strb	r2, [sp, #7]
 6383              	.LVL745:
 6384              		.loc 1 5853 0
 6385 000e E3B1     		cbz	r3, .L677
5854:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
5855:Src/bno055.c  **** 		} else {
5856:Src/bno055.c  **** 		/*condition check for page, gyro calib
5857:Src/bno055.c  **** 		available in the page zero*/
5858:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6386              		.loc 1 5858 0
 6387 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6388 0012 0546     		mov	r5, r0
 6389 0014 71B9     		cbnz	r1, .L683
 6390              	.LVL746:
 6391              	.L675:
5859:Src/bno055.c  **** 			/* Write the page zero*/
5860:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
5861:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
5862:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
5863:Src/bno055.c  **** 			/* Read the gyro calib status */
5864:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6392              		.loc 1 5864 0
 6393 0016 1C69     		ldr	r4, [r3, #16]
 6394 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6395 001a 3521     		movs	r1, #53
 6396 001c 0123     		movs	r3, #1
 6397 001e 0DF10702 		add	r2, sp, #7
 6398 0022 A047     		blx	r4
ARM GAS  /tmp/ccVWLGiI.s 			page 222


 6399              	.LVL747:
5865:Src/bno055.c  **** 			(p_bno055->dev_addr,
5866:Src/bno055.c  **** 			BNO055_GYRO_CALIB_STAT_REG,
5867:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
5868:Src/bno055.c  **** 			*gyro_calib_u8 =
5869:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 6400              		.loc 1 5869 0
 6401 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6402 0028 C3F30113 		ubfx	r3, r3, #4, #2
5868:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 6403              		.loc 1 5868 0
 6404 002c 2B70     		strb	r3, [r5]
 6405              	.LVL748:
 6406              	.L674:
5870:Src/bno055.c  **** 			BNO055_GYRO_CALIB_STAT);
5871:Src/bno055.c  **** 		} else {
5872:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5873:Src/bno055.c  **** 		}
5874:Src/bno055.c  **** 	}
5875:Src/bno055.c  **** 	return com_rslt;
5876:Src/bno055.c  **** }
 6407              		.loc 1 5876 0
 6408 002e 40B2     		sxtb	r0, r0
 6409 0030 03B0     		add	sp, sp, #12
 6410              	.LCFI276:
 6411              		.cfi_remember_state
 6412              		.cfi_def_cfa_offset 12
 6413              		@ sp needed
 6414 0032 30BD     		pop	{r4, r5, pc}
 6415              	.LVL749:
 6416              	.L683:
 6417              	.LCFI277:
 6418              		.cfi_restore_state
5860:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6419              		.loc 1 5860 0
 6420 0034 1046     		mov	r0, r2
 6421              	.LVL750:
 6422 0036 FFF7FEFF 		bl	bno055_write_page_id
 6423              	.LVL751:
 6424 003a 2368     		ldr	r3, [r4]
5861:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6425              		.loc 1 5861 0
 6426 003c 0028     		cmp	r0, #0
 6427 003e EAD0     		beq	.L675
 6428              	.LVL752:
5861:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6429              		.loc 1 5861 0 is_stmt 0 discriminator 1
 6430 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
5872:Src/bno055.c  **** 		}
 6431              		.loc 1 5872 0 is_stmt 1 discriminator 1
 6432 0042 FF20     		movs	r0, #255
5861:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6433              		.loc 1 5861 0 discriminator 1
 6434 0044 002A     		cmp	r2, #0
 6435 0046 F2D1     		bne	.L674
 6436 0048 E5E7     		b	.L675
 6437              	.LVL753:
ARM GAS  /tmp/ccVWLGiI.s 			page 223


 6438              	.L677:
5854:Src/bno055.c  **** 		} else {
 6439              		.loc 1 5854 0
 6440 004a 8120     		movs	r0, #129
 6441              	.LVL754:
 6442 004c EFE7     		b	.L674
 6443              	.L685:
 6444 004e 00BF     		.align	2
 6445              	.L684:
 6446 0050 00000000 		.word	.LANCHOR0
 6447              		.cfi_endproc
 6448              	.LFE119:
 6450              		.section	.text.bno055_get_sys_calib_stat,"ax",%progbits
 6451              		.align	2
 6452              		.global	bno055_get_sys_calib_stat
 6453              		.thumb
 6454              		.thumb_func
 6456              	bno055_get_sys_calib_stat:
 6457              	.LFB120:
5877:Src/bno055.c  **** /*!
5878:Src/bno055.c  ****  *	@brief This API used to read
5879:Src/bno055.c  ****  *	system calibration status from register from 0x35 bit 6 and 7
5880:Src/bno055.c  ****  *
5881:Src/bno055.c  ****  *	@param sys_calib_u8 : The value of system calib status
5882:Src/bno055.c  ****  *
5883:Src/bno055.c  ****  *
5884:Src/bno055.c  ****  *	@return results of bus communication function
5885:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5886:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5887:Src/bno055.c  ****  *
5888:Src/bno055.c  ****  */
5889:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_sys_calib_stat(
5890:Src/bno055.c  **** u8 *sys_calib_u8)
5891:Src/bno055.c  **** {
 6458              		.loc 1 5891 0
 6459              		.cfi_startproc
 6460              		@ args = 0, pretend = 0, frame = 8
 6461              		@ frame_needed = 0, uses_anonymous_args = 0
 6462              	.LVL755:
 6463 0000 30B5     		push	{r4, r5, lr}
 6464              	.LCFI278:
 6465              		.cfi_def_cfa_offset 12
 6466              		.cfi_offset 4, -12
 6467              		.cfi_offset 5, -8
 6468              		.cfi_offset 14, -4
5892:Src/bno055.c  **** 	/* Variable used to return value of
5893:Src/bno055.c  **** 	communication routine*/
5894:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5895:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
5896:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
5897:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty*/
5898:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6469              		.loc 1 5898 0
 6470 0002 124C     		ldr	r4, .L697
5891:Src/bno055.c  **** 	/* Variable used to return value of
 6471              		.loc 1 5891 0
 6472 0004 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 224


 6473              	.LCFI279:
 6474              		.cfi_def_cfa_offset 24
 6475              		.loc 1 5898 0
 6476 0006 2368     		ldr	r3, [r4]
5895:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6477              		.loc 1 5895 0
 6478 0008 0022     		movs	r2, #0
 6479 000a 8DF80720 		strb	r2, [sp, #7]
 6480              	.LVL756:
 6481              		.loc 1 5898 0
 6482 000e DBB1     		cbz	r3, .L690
5899:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
5900:Src/bno055.c  **** 		} else {
5901:Src/bno055.c  **** 		/*condition check for page,system calib
5902:Src/bno055.c  **** 		available in the page zero*/
5903:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6483              		.loc 1 5903 0
 6484 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6485 0012 0546     		mov	r5, r0
 6486 0014 69B9     		cbnz	r1, .L696
 6487              	.LVL757:
 6488              	.L688:
5904:Src/bno055.c  **** 			/* Write the page zero*/
5905:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
5906:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
5907:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
5908:Src/bno055.c  **** 			/* Read the system calib */
5909:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6489              		.loc 1 5909 0
 6490 0016 1C69     		ldr	r4, [r3, #16]
 6491 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6492 001a 3521     		movs	r1, #53
 6493 001c 0123     		movs	r3, #1
 6494 001e 0DF10702 		add	r2, sp, #7
 6495 0022 A047     		blx	r4
 6496              	.LVL758:
5910:Src/bno055.c  **** 			(p_bno055->dev_addr,
5911:Src/bno055.c  **** 			BNO055_SYS_CALIB_STAT_REG,
5912:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
5913:Src/bno055.c  **** 			*sys_calib_u8 =
5914:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SYS_CALIB_STAT);
 6497              		.loc 1 5914 0
 6498 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6499 0028 9B09     		lsrs	r3, r3, #6
5913:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SYS_CALIB_STAT);
 6500              		.loc 1 5913 0
 6501 002a 2B70     		strb	r3, [r5]
 6502              	.LVL759:
 6503              	.L687:
5915:Src/bno055.c  **** 		} else {
5916:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5917:Src/bno055.c  **** 		}
5918:Src/bno055.c  **** 	}
5919:Src/bno055.c  **** 	return com_rslt;
5920:Src/bno055.c  **** }
 6504              		.loc 1 5920 0
 6505 002c 40B2     		sxtb	r0, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 225


 6506 002e 03B0     		add	sp, sp, #12
 6507              	.LCFI280:
 6508              		.cfi_remember_state
 6509              		.cfi_def_cfa_offset 12
 6510              		@ sp needed
 6511 0030 30BD     		pop	{r4, r5, pc}
 6512              	.LVL760:
 6513              	.L696:
 6514              	.LCFI281:
 6515              		.cfi_restore_state
5905:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6516              		.loc 1 5905 0
 6517 0032 1046     		mov	r0, r2
 6518              	.LVL761:
 6519 0034 FFF7FEFF 		bl	bno055_write_page_id
 6520              	.LVL762:
 6521 0038 2368     		ldr	r3, [r4]
5906:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6522              		.loc 1 5906 0
 6523 003a 0028     		cmp	r0, #0
 6524 003c EBD0     		beq	.L688
 6525              	.LVL763:
5906:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6526              		.loc 1 5906 0 is_stmt 0 discriminator 1
 6527 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
5916:Src/bno055.c  **** 		}
 6528              		.loc 1 5916 0 is_stmt 1 discriminator 1
 6529 0040 FF20     		movs	r0, #255
5906:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6530              		.loc 1 5906 0 discriminator 1
 6531 0042 002A     		cmp	r2, #0
 6532 0044 F2D1     		bne	.L687
 6533 0046 E6E7     		b	.L688
 6534              	.LVL764:
 6535              	.L690:
5899:Src/bno055.c  **** 		} else {
 6536              		.loc 1 5899 0
 6537 0048 8120     		movs	r0, #129
 6538              	.LVL765:
 6539 004a EFE7     		b	.L687
 6540              	.L698:
 6541              		.align	2
 6542              	.L697:
 6543 004c 00000000 		.word	.LANCHOR0
 6544              		.cfi_endproc
 6545              	.LFE120:
 6547              		.section	.text.bno055_get_selftest_accel,"ax",%progbits
 6548              		.align	2
 6549              		.global	bno055_get_selftest_accel
 6550              		.thumb
 6551              		.thumb_func
 6553              	bno055_get_selftest_accel:
 6554              	.LFB121:
5921:Src/bno055.c  **** /*!
5922:Src/bno055.c  ****  *	@brief This API used to read
5923:Src/bno055.c  ****  *	self test of accel from register from 0x36 bit 0
5924:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 226


5925:Src/bno055.c  ****  *	@param selftest_accel_u8 : The value of self test of accel
5926:Src/bno055.c  ****  *
5927:Src/bno055.c  ****  *    selftest_accel_u8 |  result
5928:Src/bno055.c  ****  *   -------------------- | ---------------------
5929:Src/bno055.c  ****  *     0x00               | indicates test failed
5930:Src/bno055.c  ****  *     0x01               | indicated test passed
5931:Src/bno055.c  ****  *
5932:Src/bno055.c  ****  *	@return results of bus communication function
5933:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5934:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5935:Src/bno055.c  ****  *
5936:Src/bno055.c  ****  */
5937:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_selftest_accel(
5938:Src/bno055.c  **** u8 *selftest_accel_u8)
5939:Src/bno055.c  **** {
 6555              		.loc 1 5939 0
 6556              		.cfi_startproc
 6557              		@ args = 0, pretend = 0, frame = 8
 6558              		@ frame_needed = 0, uses_anonymous_args = 0
 6559              	.LVL766:
 6560 0000 30B5     		push	{r4, r5, lr}
 6561              	.LCFI282:
 6562              		.cfi_def_cfa_offset 12
 6563              		.cfi_offset 4, -12
 6564              		.cfi_offset 5, -8
 6565              		.cfi_offset 14, -4
5940:Src/bno055.c  **** 	/* Variable used to return value of
5941:Src/bno055.c  **** 	communication routine*/
5942:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5943:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
5944:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
5945:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
5946:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6566              		.loc 1 5946 0
 6567 0002 134C     		ldr	r4, .L710
5939:Src/bno055.c  **** 	/* Variable used to return value of
 6568              		.loc 1 5939 0
 6569 0004 83B0     		sub	sp, sp, #12
 6570              	.LCFI283:
 6571              		.cfi_def_cfa_offset 24
 6572              		.loc 1 5946 0
 6573 0006 2368     		ldr	r3, [r4]
5943:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6574              		.loc 1 5943 0
 6575 0008 0022     		movs	r2, #0
 6576 000a 8DF80720 		strb	r2, [sp, #7]
 6577              	.LVL767:
 6578              		.loc 1 5946 0
 6579 000e E3B1     		cbz	r3, .L703
5947:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
5948:Src/bno055.c  **** 		} else {
5949:Src/bno055.c  **** 		/*condition check for page, accel self test is
5950:Src/bno055.c  **** 		available in the page zero*/
5951:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6580              		.loc 1 5951 0
 6581 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6582 0012 0546     		mov	r5, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 227


 6583 0014 71B9     		cbnz	r1, .L709
 6584              	.LVL768:
 6585              	.L701:
5952:Src/bno055.c  **** 			/* Write the page zero*/
5953:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
5954:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
5955:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
5956:Src/bno055.c  **** 			/* Read the accel self test */
5957:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6586              		.loc 1 5957 0
 6587 0016 1C69     		ldr	r4, [r3, #16]
 6588 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6589 001a 3621     		movs	r1, #54
 6590 001c 0123     		movs	r3, #1
 6591 001e 0DF10702 		add	r2, sp, #7
 6592 0022 A047     		blx	r4
 6593              	.LVL769:
5958:Src/bno055.c  **** 			(p_bno055->dev_addr,
5959:Src/bno055.c  **** 			BNO055_SELFTEST_ACCEL_REG,
5960:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
5961:Src/bno055.c  **** 			*selftest_accel_u8 =
 6594              		.loc 1 5961 0
 6595 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6596 0028 03F00103 		and	r3, r3, #1
 6597 002c 2B70     		strb	r3, [r5]
 6598              	.LVL770:
 6599              	.L700:
5962:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
5963:Src/bno055.c  **** 			BNO055_SELFTEST_ACCEL);
5964:Src/bno055.c  **** 		} else {
5965:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
5966:Src/bno055.c  **** 		}
5967:Src/bno055.c  **** 	}
5968:Src/bno055.c  **** 	return com_rslt;
5969:Src/bno055.c  **** }
 6600              		.loc 1 5969 0
 6601 002e 40B2     		sxtb	r0, r0
 6602 0030 03B0     		add	sp, sp, #12
 6603              	.LCFI284:
 6604              		.cfi_remember_state
 6605              		.cfi_def_cfa_offset 12
 6606              		@ sp needed
 6607 0032 30BD     		pop	{r4, r5, pc}
 6608              	.LVL771:
 6609              	.L709:
 6610              	.LCFI285:
 6611              		.cfi_restore_state
5953:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6612              		.loc 1 5953 0
 6613 0034 1046     		mov	r0, r2
 6614              	.LVL772:
 6615 0036 FFF7FEFF 		bl	bno055_write_page_id
 6616              	.LVL773:
 6617 003a 2368     		ldr	r3, [r4]
5954:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6618              		.loc 1 5954 0
 6619 003c 0028     		cmp	r0, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 228


 6620 003e EAD0     		beq	.L701
 6621              	.LVL774:
5954:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6622              		.loc 1 5954 0 is_stmt 0 discriminator 1
 6623 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
5965:Src/bno055.c  **** 		}
 6624              		.loc 1 5965 0 is_stmt 1 discriminator 1
 6625 0042 FF20     		movs	r0, #255
5954:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6626              		.loc 1 5954 0 discriminator 1
 6627 0044 002A     		cmp	r2, #0
 6628 0046 F2D1     		bne	.L700
 6629 0048 E5E7     		b	.L701
 6630              	.LVL775:
 6631              	.L703:
5947:Src/bno055.c  **** 		} else {
 6632              		.loc 1 5947 0
 6633 004a 8120     		movs	r0, #129
 6634              	.LVL776:
 6635 004c EFE7     		b	.L700
 6636              	.L711:
 6637 004e 00BF     		.align	2
 6638              	.L710:
 6639 0050 00000000 		.word	.LANCHOR0
 6640              		.cfi_endproc
 6641              	.LFE121:
 6643              		.section	.text.bno055_get_selftest_mag,"ax",%progbits
 6644              		.align	2
 6645              		.global	bno055_get_selftest_mag
 6646              		.thumb
 6647              		.thumb_func
 6649              	bno055_get_selftest_mag:
 6650              	.LFB122:
5970:Src/bno055.c  **** /*!
5971:Src/bno055.c  ****  *	@brief This API used to read
5972:Src/bno055.c  ****  *	self test of mag from register from 0x36 bit 1
5973:Src/bno055.c  ****  *
5974:Src/bno055.c  ****  *	@param selftest_mag_u8 : The value of self test of mag
5975:Src/bno055.c  ****  *
5976:Src/bno055.c  ****  *     selftest_mag_u8  |  result
5977:Src/bno055.c  ****  *   -------------------- | ---------------------
5978:Src/bno055.c  ****  *     0x00               | indicates test failed
5979:Src/bno055.c  ****  *     0x01               | indicated test passed
5980:Src/bno055.c  ****  *
5981:Src/bno055.c  ****  *	@return results of bus communication function
5982:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
5983:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
5984:Src/bno055.c  ****  *
5985:Src/bno055.c  ****  */
5986:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_selftest_mag(
5987:Src/bno055.c  **** u8 *selftest_mag_u8)
5988:Src/bno055.c  **** {
 6651              		.loc 1 5988 0
 6652              		.cfi_startproc
 6653              		@ args = 0, pretend = 0, frame = 8
 6654              		@ frame_needed = 0, uses_anonymous_args = 0
 6655              	.LVL777:
ARM GAS  /tmp/ccVWLGiI.s 			page 229


 6656 0000 30B5     		push	{r4, r5, lr}
 6657              	.LCFI286:
 6658              		.cfi_def_cfa_offset 12
 6659              		.cfi_offset 4, -12
 6660              		.cfi_offset 5, -8
 6661              		.cfi_offset 14, -4
5989:Src/bno055.c  **** 	/* Variable used to return value of
5990:Src/bno055.c  **** 	communication routine*/
5991:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
5992:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
5993:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
5994:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
5995:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6662              		.loc 1 5995 0
 6663 0002 134C     		ldr	r4, .L723
5988:Src/bno055.c  **** 	/* Variable used to return value of
 6664              		.loc 1 5988 0
 6665 0004 83B0     		sub	sp, sp, #12
 6666              	.LCFI287:
 6667              		.cfi_def_cfa_offset 24
 6668              		.loc 1 5995 0
 6669 0006 2368     		ldr	r3, [r4]
5992:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6670              		.loc 1 5992 0
 6671 0008 0022     		movs	r2, #0
 6672 000a 8DF80720 		strb	r2, [sp, #7]
 6673              	.LVL778:
 6674              		.loc 1 5995 0
 6675 000e E3B1     		cbz	r3, .L716
5996:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
5997:Src/bno055.c  **** 		} else {
5998:Src/bno055.c  **** 		/*condition check for page, self test of mag is
5999:Src/bno055.c  **** 		available in the page zero*/
6000:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6676              		.loc 1 6000 0
 6677 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6678 0012 0546     		mov	r5, r0
 6679 0014 71B9     		cbnz	r1, .L722
 6680              	.LVL779:
 6681              	.L714:
6001:Src/bno055.c  **** 			/* Write the page zero*/
6002:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6003:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6004:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6005:Src/bno055.c  **** 			/* Read the mag self test */
6006:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6682              		.loc 1 6006 0
 6683 0016 1C69     		ldr	r4, [r3, #16]
 6684 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6685 001a 3621     		movs	r1, #54
 6686 001c 0123     		movs	r3, #1
 6687 001e 0DF10702 		add	r2, sp, #7
 6688 0022 A047     		blx	r4
 6689              	.LVL780:
6007:Src/bno055.c  **** 			(p_bno055->dev_addr,
6008:Src/bno055.c  **** 			BNO055_SELFTEST_MAG_REG, &data_u8r,
6009:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 230


6010:Src/bno055.c  **** 			*selftest_mag_u8 =
6011:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SELFTEST_MAG);
 6690              		.loc 1 6011 0
 6691 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6692 0028 C3F34003 		ubfx	r3, r3, #1, #1
6010:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SELFTEST_MAG);
 6693              		.loc 1 6010 0
 6694 002c 2B70     		strb	r3, [r5]
 6695              	.LVL781:
 6696              	.L713:
6012:Src/bno055.c  **** 		} else {
6013:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6014:Src/bno055.c  **** 		}
6015:Src/bno055.c  **** 	}
6016:Src/bno055.c  **** 	return com_rslt;
6017:Src/bno055.c  **** }
 6697              		.loc 1 6017 0
 6698 002e 40B2     		sxtb	r0, r0
 6699 0030 03B0     		add	sp, sp, #12
 6700              	.LCFI288:
 6701              		.cfi_remember_state
 6702              		.cfi_def_cfa_offset 12
 6703              		@ sp needed
 6704 0032 30BD     		pop	{r4, r5, pc}
 6705              	.LVL782:
 6706              	.L722:
 6707              	.LCFI289:
 6708              		.cfi_restore_state
6002:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6709              		.loc 1 6002 0
 6710 0034 1046     		mov	r0, r2
 6711              	.LVL783:
 6712 0036 FFF7FEFF 		bl	bno055_write_page_id
 6713              	.LVL784:
 6714 003a 2368     		ldr	r3, [r4]
6003:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6715              		.loc 1 6003 0
 6716 003c 0028     		cmp	r0, #0
 6717 003e EAD0     		beq	.L714
 6718              	.LVL785:
6003:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6719              		.loc 1 6003 0 is_stmt 0 discriminator 1
 6720 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6013:Src/bno055.c  **** 		}
 6721              		.loc 1 6013 0 is_stmt 1 discriminator 1
 6722 0042 FF20     		movs	r0, #255
6003:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6723              		.loc 1 6003 0 discriminator 1
 6724 0044 002A     		cmp	r2, #0
 6725 0046 F2D1     		bne	.L713
 6726 0048 E5E7     		b	.L714
 6727              	.LVL786:
 6728              	.L716:
5996:Src/bno055.c  **** 		} else {
 6729              		.loc 1 5996 0
 6730 004a 8120     		movs	r0, #129
 6731              	.LVL787:
ARM GAS  /tmp/ccVWLGiI.s 			page 231


 6732 004c EFE7     		b	.L713
 6733              	.L724:
 6734 004e 00BF     		.align	2
 6735              	.L723:
 6736 0050 00000000 		.word	.LANCHOR0
 6737              		.cfi_endproc
 6738              	.LFE122:
 6740              		.section	.text.bno055_get_selftest_gyro,"ax",%progbits
 6741              		.align	2
 6742              		.global	bno055_get_selftest_gyro
 6743              		.thumb
 6744              		.thumb_func
 6746              	bno055_get_selftest_gyro:
 6747              	.LFB123:
6018:Src/bno055.c  **** /*!
6019:Src/bno055.c  ****  *	@brief This API used to read
6020:Src/bno055.c  ****  *	self test of gyro from register from 0x36 bit 2
6021:Src/bno055.c  ****  *
6022:Src/bno055.c  ****  *	@param selftest_gyro_u8 : The value of self test of gyro
6023:Src/bno055.c  ****  *
6024:Src/bno055.c  ****  *     selftest_gyro_u8 |  result
6025:Src/bno055.c  ****  *   -------------------- | ---------------------
6026:Src/bno055.c  ****  *     0x00               | indicates test failed
6027:Src/bno055.c  ****  *     0x01               | indicated test passed
6028:Src/bno055.c  ****  *
6029:Src/bno055.c  ****  *	@return results of bus communication function
6030:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6031:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6032:Src/bno055.c  ****  *
6033:Src/bno055.c  ****  */
6034:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_selftest_gyro(
6035:Src/bno055.c  **** u8 *selftest_gyro_u8)
6036:Src/bno055.c  **** {
 6748              		.loc 1 6036 0
 6749              		.cfi_startproc
 6750              		@ args = 0, pretend = 0, frame = 8
 6751              		@ frame_needed = 0, uses_anonymous_args = 0
 6752              	.LVL788:
 6753 0000 30B5     		push	{r4, r5, lr}
 6754              	.LCFI290:
 6755              		.cfi_def_cfa_offset 12
 6756              		.cfi_offset 4, -12
 6757              		.cfi_offset 5, -8
 6758              		.cfi_offset 14, -4
6037:Src/bno055.c  **** 	/* Variable used to return value of
6038:Src/bno055.c  **** 	communication routine*/
6039:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6040:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6041:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6042:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6043:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6759              		.loc 1 6043 0
 6760 0002 134C     		ldr	r4, .L736
6036:Src/bno055.c  **** 	/* Variable used to return value of
 6761              		.loc 1 6036 0
 6762 0004 83B0     		sub	sp, sp, #12
 6763              	.LCFI291:
ARM GAS  /tmp/ccVWLGiI.s 			page 232


 6764              		.cfi_def_cfa_offset 24
 6765              		.loc 1 6043 0
 6766 0006 2368     		ldr	r3, [r4]
6040:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6767              		.loc 1 6040 0
 6768 0008 0022     		movs	r2, #0
 6769 000a 8DF80720 		strb	r2, [sp, #7]
 6770              	.LVL789:
 6771              		.loc 1 6043 0
 6772 000e E3B1     		cbz	r3, .L729
6044:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6045:Src/bno055.c  **** 		} else {
6046:Src/bno055.c  **** 		/*condition check for page self test of gyro is
6047:Src/bno055.c  **** 		available in the page zero*/
6048:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6773              		.loc 1 6048 0
 6774 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6775 0012 0546     		mov	r5, r0
 6776 0014 71B9     		cbnz	r1, .L735
 6777              	.LVL790:
 6778              	.L727:
6049:Src/bno055.c  **** 			/* Write the page zero*/
6050:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6051:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6052:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6053:Src/bno055.c  **** 			/* Read the gyro self test */
6054:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6779              		.loc 1 6054 0
 6780 0016 1C69     		ldr	r4, [r3, #16]
 6781 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6782 001a 3621     		movs	r1, #54
 6783 001c 0123     		movs	r3, #1
 6784 001e 0DF10702 		add	r2, sp, #7
 6785 0022 A047     		blx	r4
 6786              	.LVL791:
6055:Src/bno055.c  **** 			(p_bno055->dev_addr,
6056:Src/bno055.c  **** 			BNO055_SELFTEST_GYRO_REG, &data_u8r,
6057:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
6058:Src/bno055.c  **** 			*selftest_gyro_u8 =
6059:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SELFTEST_GYRO);
 6787              		.loc 1 6059 0
 6788 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6789 0028 C3F38003 		ubfx	r3, r3, #2, #1
6058:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SELFTEST_GYRO);
 6790              		.loc 1 6058 0
 6791 002c 2B70     		strb	r3, [r5]
 6792              	.LVL792:
 6793              	.L726:
6060:Src/bno055.c  **** 		} else {
6061:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6062:Src/bno055.c  **** 		}
6063:Src/bno055.c  **** 	}
6064:Src/bno055.c  **** 	return com_rslt;
6065:Src/bno055.c  **** }
 6794              		.loc 1 6065 0
 6795 002e 40B2     		sxtb	r0, r0
 6796 0030 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 233


 6797              	.LCFI292:
 6798              		.cfi_remember_state
 6799              		.cfi_def_cfa_offset 12
 6800              		@ sp needed
 6801 0032 30BD     		pop	{r4, r5, pc}
 6802              	.LVL793:
 6803              	.L735:
 6804              	.LCFI293:
 6805              		.cfi_restore_state
6050:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6806              		.loc 1 6050 0
 6807 0034 1046     		mov	r0, r2
 6808              	.LVL794:
 6809 0036 FFF7FEFF 		bl	bno055_write_page_id
 6810              	.LVL795:
 6811 003a 2368     		ldr	r3, [r4]
6051:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6812              		.loc 1 6051 0
 6813 003c 0028     		cmp	r0, #0
 6814 003e EAD0     		beq	.L727
 6815              	.LVL796:
6051:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6816              		.loc 1 6051 0 is_stmt 0 discriminator 1
 6817 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6061:Src/bno055.c  **** 		}
 6818              		.loc 1 6061 0 is_stmt 1 discriminator 1
 6819 0042 FF20     		movs	r0, #255
6051:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6820              		.loc 1 6051 0 discriminator 1
 6821 0044 002A     		cmp	r2, #0
 6822 0046 F2D1     		bne	.L726
 6823 0048 E5E7     		b	.L727
 6824              	.LVL797:
 6825              	.L729:
6044:Src/bno055.c  **** 		} else {
 6826              		.loc 1 6044 0
 6827 004a 8120     		movs	r0, #129
 6828              	.LVL798:
 6829 004c EFE7     		b	.L726
 6830              	.L737:
 6831 004e 00BF     		.align	2
 6832              	.L736:
 6833 0050 00000000 		.word	.LANCHOR0
 6834              		.cfi_endproc
 6835              	.LFE123:
 6837              		.section	.text.bno055_get_selftest_mcu,"ax",%progbits
 6838              		.align	2
 6839              		.global	bno055_get_selftest_mcu
 6840              		.thumb
 6841              		.thumb_func
 6843              	bno055_get_selftest_mcu:
 6844              	.LFB124:
6066:Src/bno055.c  **** /*!
6067:Src/bno055.c  ****  *	@brief This API used to read
6068:Src/bno055.c  ****  *	self test of micro controller from register from 0x36 bit 3
6069:Src/bno055.c  ****  *
6070:Src/bno055.c  ****  *	@param selftest_mcu_u8 : The value of self test of micro controller
ARM GAS  /tmp/ccVWLGiI.s 			page 234


6071:Src/bno055.c  ****  *
6072:Src/bno055.c  ****  *     selftest_mcu_u8  |  result
6073:Src/bno055.c  ****  *   -------------------- | ---------------------
6074:Src/bno055.c  ****  *     0x00               | indicates test failed
6075:Src/bno055.c  ****  *     0x01               | indicated test passed
6076:Src/bno055.c  ****  *
6077:Src/bno055.c  ****  *	@return results of bus communication function
6078:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6079:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6080:Src/bno055.c  ****  *
6081:Src/bno055.c  ****  */
6082:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_selftest_mcu(
6083:Src/bno055.c  **** u8 *selftest_mcu_u8)
6084:Src/bno055.c  **** {
 6845              		.loc 1 6084 0
 6846              		.cfi_startproc
 6847              		@ args = 0, pretend = 0, frame = 8
 6848              		@ frame_needed = 0, uses_anonymous_args = 0
 6849              	.LVL799:
 6850 0000 30B5     		push	{r4, r5, lr}
 6851              	.LCFI294:
 6852              		.cfi_def_cfa_offset 12
 6853              		.cfi_offset 4, -12
 6854              		.cfi_offset 5, -8
 6855              		.cfi_offset 14, -4
6085:Src/bno055.c  **** 	/* Variable used to return value of
6086:Src/bno055.c  **** 	communication routine*/
6087:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6088:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6089:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6090:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6091:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6856              		.loc 1 6091 0
 6857 0002 134C     		ldr	r4, .L749
6084:Src/bno055.c  **** 	/* Variable used to return value of
 6858              		.loc 1 6084 0
 6859 0004 83B0     		sub	sp, sp, #12
 6860              	.LCFI295:
 6861              		.cfi_def_cfa_offset 24
 6862              		.loc 1 6091 0
 6863 0006 2368     		ldr	r3, [r4]
6088:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6864              		.loc 1 6088 0
 6865 0008 0022     		movs	r2, #0
 6866 000a 8DF80720 		strb	r2, [sp, #7]
 6867              	.LVL800:
 6868              		.loc 1 6091 0
 6869 000e E3B1     		cbz	r3, .L742
6092:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6093:Src/bno055.c  **** 		} else {
6094:Src/bno055.c  **** 		/*condition check for page self test of micro controller
6095:Src/bno055.c  **** 		is available in the page zero*/
6096:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6870              		.loc 1 6096 0
 6871 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6872 0012 0546     		mov	r5, r0
 6873 0014 71B9     		cbnz	r1, .L748
ARM GAS  /tmp/ccVWLGiI.s 			page 235


 6874              	.LVL801:
 6875              	.L740:
6097:Src/bno055.c  **** 			/* Write the page zero*/
6098:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6099:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6100:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6101:Src/bno055.c  **** 			/* Read the self test of micro controller*/
6102:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6876              		.loc 1 6102 0
 6877 0016 1C69     		ldr	r4, [r3, #16]
 6878 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6879 001a 3621     		movs	r1, #54
 6880 001c 0123     		movs	r3, #1
 6881 001e 0DF10702 		add	r2, sp, #7
 6882 0022 A047     		blx	r4
 6883              	.LVL802:
6103:Src/bno055.c  **** 			(p_bno055->dev_addr,
6104:Src/bno055.c  **** 			BNO055_SELFTEST_MCU_REG, &data_u8r,
6105:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
6106:Src/bno055.c  **** 			*selftest_mcu_u8 =
6107:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SELFTEST_MCU);
 6884              		.loc 1 6107 0
 6885 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6886 0028 C3F3C003 		ubfx	r3, r3, #3, #1
6106:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SELFTEST_MCU);
 6887              		.loc 1 6106 0
 6888 002c 2B70     		strb	r3, [r5]
 6889              	.LVL803:
 6890              	.L739:
6108:Src/bno055.c  **** 		} else {
6109:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6110:Src/bno055.c  **** 		}
6111:Src/bno055.c  **** 	}
6112:Src/bno055.c  **** 	return com_rslt;
6113:Src/bno055.c  **** }
 6891              		.loc 1 6113 0
 6892 002e 40B2     		sxtb	r0, r0
 6893 0030 03B0     		add	sp, sp, #12
 6894              	.LCFI296:
 6895              		.cfi_remember_state
 6896              		.cfi_def_cfa_offset 12
 6897              		@ sp needed
 6898 0032 30BD     		pop	{r4, r5, pc}
 6899              	.LVL804:
 6900              	.L748:
 6901              	.LCFI297:
 6902              		.cfi_restore_state
6098:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 6903              		.loc 1 6098 0
 6904 0034 1046     		mov	r0, r2
 6905              	.LVL805:
 6906 0036 FFF7FEFF 		bl	bno055_write_page_id
 6907              	.LVL806:
 6908 003a 2368     		ldr	r3, [r4]
6099:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6909              		.loc 1 6099 0
 6910 003c 0028     		cmp	r0, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 236


 6911 003e EAD0     		beq	.L740
 6912              	.LVL807:
6099:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6913              		.loc 1 6099 0 is_stmt 0 discriminator 1
 6914 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6109:Src/bno055.c  **** 		}
 6915              		.loc 1 6109 0 is_stmt 1 discriminator 1
 6916 0042 FF20     		movs	r0, #255
6099:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 6917              		.loc 1 6099 0 discriminator 1
 6918 0044 002A     		cmp	r2, #0
 6919 0046 F2D1     		bne	.L739
 6920 0048 E5E7     		b	.L740
 6921              	.LVL808:
 6922              	.L742:
6092:Src/bno055.c  **** 		} else {
 6923              		.loc 1 6092 0
 6924 004a 8120     		movs	r0, #129
 6925              	.LVL809:
 6926 004c EFE7     		b	.L739
 6927              	.L750:
 6928 004e 00BF     		.align	2
 6929              	.L749:
 6930 0050 00000000 		.word	.LANCHOR0
 6931              		.cfi_endproc
 6932              	.LFE124:
 6934              		.section	.text.bno055_get_intr_stat_gyro_any_motion,"ax",%progbits
 6935              		.align	2
 6936              		.global	bno055_get_intr_stat_gyro_any_motion
 6937              		.thumb
 6938              		.thumb_func
 6940              	bno055_get_intr_stat_gyro_any_motion:
 6941              	.LFB125:
6114:Src/bno055.c  **** /*!
6115:Src/bno055.c  ****  *	@brief This API used to read the stat_s8 of
6116:Src/bno055.c  ****  *	gyro anymotion interrupt from register from 0x37 bit 2
6117:Src/bno055.c  ****  *
6118:Src/bno055.c  ****  *	@param gyro_any_motion_u8 : The value of gyro anymotion interrupt
6119:Src/bno055.c  ****  *
6120:Src/bno055.c  ****  *     gyro_any_motion_u8  |  result
6121:Src/bno055.c  ****  *    --------------------   | ---------------------
6122:Src/bno055.c  ****  *     0x00                  | indicates no interrupt triggered
6123:Src/bno055.c  ****  *     0x01                  | indicates interrupt triggered
6124:Src/bno055.c  ****  *
6125:Src/bno055.c  ****  *	@return results of bus communication function
6126:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6127:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6128:Src/bno055.c  ****  *
6129:Src/bno055.c  ****  *	@note Gyro anymotion interrupt can be BNO055_BIT_ENABLE
6130:Src/bno055.c  ****  *	by the following APIs
6131:Src/bno055.c  ****  *
6132:Src/bno055.c  ****  *	bno055_set_intr_mask_gyro_any_motion()
6133:Src/bno055.c  ****  *
6134:Src/bno055.c  ****  *	bno055_set_intr_gyro_any_motion()
6135:Src/bno055.c  ****  *
6136:Src/bno055.c  ****  */
6137:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_stat_gyro_any_motion(
ARM GAS  /tmp/ccVWLGiI.s 			page 237


6138:Src/bno055.c  **** u8 *gyro_any_motion_u8)
6139:Src/bno055.c  **** {
 6942              		.loc 1 6139 0
 6943              		.cfi_startproc
 6944              		@ args = 0, pretend = 0, frame = 8
 6945              		@ frame_needed = 0, uses_anonymous_args = 0
 6946              	.LVL810:
 6947 0000 30B5     		push	{r4, r5, lr}
 6948              	.LCFI298:
 6949              		.cfi_def_cfa_offset 12
 6950              		.cfi_offset 4, -12
 6951              		.cfi_offset 5, -8
 6952              		.cfi_offset 14, -4
6140:Src/bno055.c  **** 	/* Variable used to return value of
6141:Src/bno055.c  **** 	communication routine*/
6142:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6143:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6144:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6145:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6146:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 6953              		.loc 1 6146 0
 6954 0002 134C     		ldr	r4, .L762
6139:Src/bno055.c  **** 	/* Variable used to return value of
 6955              		.loc 1 6139 0
 6956 0004 83B0     		sub	sp, sp, #12
 6957              	.LCFI299:
 6958              		.cfi_def_cfa_offset 24
 6959              		.loc 1 6146 0
 6960 0006 2368     		ldr	r3, [r4]
6143:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 6961              		.loc 1 6143 0
 6962 0008 0022     		movs	r2, #0
 6963 000a 8DF80720 		strb	r2, [sp, #7]
 6964              	.LVL811:
 6965              		.loc 1 6146 0
 6966 000e E3B1     		cbz	r3, .L755
6147:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6148:Src/bno055.c  **** 		} else {
6149:Src/bno055.c  **** 		/*condition check for page, gyro anymotion interrupt
6150:Src/bno055.c  **** 		status is available in the page zero*/
6151:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 6967              		.loc 1 6151 0
 6968 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 6969 0012 0546     		mov	r5, r0
 6970 0014 71B9     		cbnz	r1, .L761
 6971              	.LVL812:
 6972              	.L753:
6152:Src/bno055.c  **** 			/* Write the page zero*/
6153:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6154:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6155:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6156:Src/bno055.c  **** 			/* Read the gyro anymotion interrupt stat_s8*/
6157:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 6973              		.loc 1 6157 0
 6974 0016 1C69     		ldr	r4, [r3, #16]
 6975 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 6976 001a 3721     		movs	r1, #55
ARM GAS  /tmp/ccVWLGiI.s 			page 238


 6977 001c 0123     		movs	r3, #1
 6978 001e 0DF10702 		add	r2, sp, #7
 6979 0022 A047     		blx	r4
 6980              	.LVL813:
6158:Src/bno055.c  **** 			(p_bno055->dev_addr,
6159:Src/bno055.c  **** 			BNO055_INTR_STAT_GYRO_ANY_MOTION_REG,
6160:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6161:Src/bno055.c  **** 			*gyro_any_motion_u8 =
6162:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 6981              		.loc 1 6162 0
 6982 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 6983 0028 C3F38003 		ubfx	r3, r3, #2, #1
6161:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 6984              		.loc 1 6161 0
 6985 002c 2B70     		strb	r3, [r5]
 6986              	.LVL814:
 6987              	.L752:
6163:Src/bno055.c  **** 			BNO055_INTR_STAT_GYRO_ANY_MOTION);
6164:Src/bno055.c  **** 		} else {
6165:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6166:Src/bno055.c  **** 		}
6167:Src/bno055.c  **** 	}
6168:Src/bno055.c  **** 	return com_rslt;
6169:Src/bno055.c  **** }
 6988              		.loc 1 6169 0
 6989 002e 40B2     		sxtb	r0, r0
 6990 0030 03B0     		add	sp, sp, #12
 6991              	.LCFI300:
 6992              		.cfi_remember_state
 6993              		.cfi_def_cfa_offset 12
 6994              		@ sp needed
 6995 0032 30BD     		pop	{r4, r5, pc}
 6996              	.LVL815:
 6997              	.L761:
 6998              	.LCFI301:
 6999              		.cfi_restore_state
6153:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7000              		.loc 1 6153 0
 7001 0034 1046     		mov	r0, r2
 7002              	.LVL816:
 7003 0036 FFF7FEFF 		bl	bno055_write_page_id
 7004              	.LVL817:
 7005 003a 2368     		ldr	r3, [r4]
6154:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7006              		.loc 1 6154 0
 7007 003c 0028     		cmp	r0, #0
 7008 003e EAD0     		beq	.L753
 7009              	.LVL818:
6154:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7010              		.loc 1 6154 0 is_stmt 0 discriminator 1
 7011 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6165:Src/bno055.c  **** 		}
 7012              		.loc 1 6165 0 is_stmt 1 discriminator 1
 7013 0042 FF20     		movs	r0, #255
6154:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7014              		.loc 1 6154 0 discriminator 1
 7015 0044 002A     		cmp	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 239


 7016 0046 F2D1     		bne	.L752
 7017 0048 E5E7     		b	.L753
 7018              	.LVL819:
 7019              	.L755:
6147:Src/bno055.c  **** 		} else {
 7020              		.loc 1 6147 0
 7021 004a 8120     		movs	r0, #129
 7022              	.LVL820:
 7023 004c EFE7     		b	.L752
 7024              	.L763:
 7025 004e 00BF     		.align	2
 7026              	.L762:
 7027 0050 00000000 		.word	.LANCHOR0
 7028              		.cfi_endproc
 7029              	.LFE125:
 7031              		.section	.text.bno055_get_intr_stat_gyro_highrate,"ax",%progbits
 7032              		.align	2
 7033              		.global	bno055_get_intr_stat_gyro_highrate
 7034              		.thumb
 7035              		.thumb_func
 7037              	bno055_get_intr_stat_gyro_highrate:
 7038              	.LFB126:
6170:Src/bno055.c  **** /*!
6171:Src/bno055.c  ****  *	@brief This API used to read the stat_s8 of
6172:Src/bno055.c  ****  *	gyro highrate interrupt from register from 0x37 bit 3
6173:Src/bno055.c  ****  *
6174:Src/bno055.c  ****  *	@param gyro_highrate_u8 : The value of gyro highrate interrupt
6175:Src/bno055.c  ****  *
6176:Src/bno055.c  ****  *     gyro_highrate_u8   |  result
6177:Src/bno055.c  ****  *    -------------------   | ---------------------
6178:Src/bno055.c  ****  *     0x00                 | indicates no interrupt triggered
6179:Src/bno055.c  ****  *     0x01                 | indicates interrupt triggered
6180:Src/bno055.c  ****  *
6181:Src/bno055.c  ****  *	@return results of bus communication function
6182:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6183:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6184:Src/bno055.c  ****  *
6185:Src/bno055.c  ****  *	@note Gyro highrate interrupt can be configured
6186:Src/bno055.c  ****  *			by the following APIs
6187:Src/bno055.c  ****  *
6188:Src/bno055.c  ****  *	bno055_set_intr_mask_gyro_highrate()
6189:Src/bno055.c  ****  *
6190:Src/bno055.c  ****  *	bno055_set_intr_gyro_highrate()
6191:Src/bno055.c  ****  */
6192:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_stat_gyro_highrate(
6193:Src/bno055.c  **** u8 *gyro_highrate_u8)
6194:Src/bno055.c  **** {
 7039              		.loc 1 6194 0
 7040              		.cfi_startproc
 7041              		@ args = 0, pretend = 0, frame = 8
 7042              		@ frame_needed = 0, uses_anonymous_args = 0
 7043              	.LVL821:
 7044 0000 30B5     		push	{r4, r5, lr}
 7045              	.LCFI302:
 7046              		.cfi_def_cfa_offset 12
 7047              		.cfi_offset 4, -12
 7048              		.cfi_offset 5, -8
ARM GAS  /tmp/ccVWLGiI.s 			page 240


 7049              		.cfi_offset 14, -4
6195:Src/bno055.c  **** 	/* Variable used to return value of
6196:Src/bno055.c  **** 	communication routine*/
6197:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6198:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6199:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6200:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6201:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7050              		.loc 1 6201 0
 7051 0002 134C     		ldr	r4, .L775
6194:Src/bno055.c  **** 	/* Variable used to return value of
 7052              		.loc 1 6194 0
 7053 0004 83B0     		sub	sp, sp, #12
 7054              	.LCFI303:
 7055              		.cfi_def_cfa_offset 24
 7056              		.loc 1 6201 0
 7057 0006 2368     		ldr	r3, [r4]
6198:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7058              		.loc 1 6198 0
 7059 0008 0022     		movs	r2, #0
 7060 000a 8DF80720 		strb	r2, [sp, #7]
 7061              	.LVL822:
 7062              		.loc 1 6201 0
 7063 000e E3B1     		cbz	r3, .L768
6202:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6203:Src/bno055.c  **** 		} else {
6204:Src/bno055.c  **** 		/*condition check for page, gyro highrate is
6205:Src/bno055.c  **** 		available in the page zero*/
6206:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7064              		.loc 1 6206 0
 7065 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7066 0012 0546     		mov	r5, r0
 7067 0014 71B9     		cbnz	r1, .L774
 7068              	.LVL823:
 7069              	.L766:
6207:Src/bno055.c  **** 			/* Write the page zero*/
6208:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6209:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6210:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6211:Src/bno055.c  **** 			/* Read the gyro highrate interrupt stat_s8*/
6212:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7070              		.loc 1 6212 0
 7071 0016 1C69     		ldr	r4, [r3, #16]
 7072 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7073 001a 3721     		movs	r1, #55
 7074 001c 0123     		movs	r3, #1
 7075 001e 0DF10702 		add	r2, sp, #7
 7076 0022 A047     		blx	r4
 7077              	.LVL824:
6213:Src/bno055.c  **** 			(p_bno055->dev_addr,
6214:Src/bno055.c  **** 			BNO055_INTR_STAT_GYRO_HIGHRATE_REG,
6215:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6216:Src/bno055.c  **** 			*gyro_highrate_u8 =
6217:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7078              		.loc 1 6217 0
 7079 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7080 0028 C3F3C003 		ubfx	r3, r3, #3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 241


6216:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7081              		.loc 1 6216 0
 7082 002c 2B70     		strb	r3, [r5]
 7083              	.LVL825:
 7084              	.L765:
6218:Src/bno055.c  **** 			BNO055_INTR_STAT_GYRO_HIGHRATE);
6219:Src/bno055.c  **** 		} else {
6220:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6221:Src/bno055.c  **** 		}
6222:Src/bno055.c  **** 	}
6223:Src/bno055.c  **** 	return com_rslt;
6224:Src/bno055.c  **** }
 7085              		.loc 1 6224 0
 7086 002e 40B2     		sxtb	r0, r0
 7087 0030 03B0     		add	sp, sp, #12
 7088              	.LCFI304:
 7089              		.cfi_remember_state
 7090              		.cfi_def_cfa_offset 12
 7091              		@ sp needed
 7092 0032 30BD     		pop	{r4, r5, pc}
 7093              	.LVL826:
 7094              	.L774:
 7095              	.LCFI305:
 7096              		.cfi_restore_state
6208:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7097              		.loc 1 6208 0
 7098 0034 1046     		mov	r0, r2
 7099              	.LVL827:
 7100 0036 FFF7FEFF 		bl	bno055_write_page_id
 7101              	.LVL828:
 7102 003a 2368     		ldr	r3, [r4]
6209:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7103              		.loc 1 6209 0
 7104 003c 0028     		cmp	r0, #0
 7105 003e EAD0     		beq	.L766
 7106              	.LVL829:
6209:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7107              		.loc 1 6209 0 is_stmt 0 discriminator 1
 7108 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6220:Src/bno055.c  **** 		}
 7109              		.loc 1 6220 0 is_stmt 1 discriminator 1
 7110 0042 FF20     		movs	r0, #255
6209:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7111              		.loc 1 6209 0 discriminator 1
 7112 0044 002A     		cmp	r2, #0
 7113 0046 F2D1     		bne	.L765
 7114 0048 E5E7     		b	.L766
 7115              	.LVL830:
 7116              	.L768:
6202:Src/bno055.c  **** 		} else {
 7117              		.loc 1 6202 0
 7118 004a 8120     		movs	r0, #129
 7119              	.LVL831:
 7120 004c EFE7     		b	.L765
 7121              	.L776:
 7122 004e 00BF     		.align	2
 7123              	.L775:
ARM GAS  /tmp/ccVWLGiI.s 			page 242


 7124 0050 00000000 		.word	.LANCHOR0
 7125              		.cfi_endproc
 7126              	.LFE126:
 7128              		.section	.text.bno055_get_intr_stat_accel_high_g,"ax",%progbits
 7129              		.align	2
 7130              		.global	bno055_get_intr_stat_accel_high_g
 7131              		.thumb
 7132              		.thumb_func
 7134              	bno055_get_intr_stat_accel_high_g:
 7135              	.LFB127:
6225:Src/bno055.c  **** /*!
6226:Src/bno055.c  ****  *	@brief This API used to read the stat_s8 of
6227:Src/bno055.c  ****  *	accel highg interrupt from register from 0x37 bit 5
6228:Src/bno055.c  ****  *
6229:Src/bno055.c  ****  *	@param accel_high_g_u8 : The value of accel highg interrupt
6230:Src/bno055.c  ****  *
6231:Src/bno055.c  ****  *     accel_high_g_u8    |  result
6232:Src/bno055.c  ****  *    -------------------   | ---------------------
6233:Src/bno055.c  ****  *     0x00                 | indicates no interrupt triggered
6234:Src/bno055.c  ****  *     0x01                 | indicates interrupt triggered
6235:Src/bno055.c  ****  *
6236:Src/bno055.c  ****  *	@return results of bus communication function
6237:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6238:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6239:Src/bno055.c  ****  *
6240:Src/bno055.c  ****  *	@note Accel highg interrupt can be configured
6241:Src/bno055.c  ****  *			by the following APIs
6242:Src/bno055.c  ****  *
6243:Src/bno055.c  ****  *	bno055_set_intr_mask_accel_high_g()
6244:Src/bno055.c  ****  *
6245:Src/bno055.c  ****  *	bno055_set_intr_accel_high_g()
6246:Src/bno055.c  ****  *
6247:Src/bno055.c  ****  */
6248:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_stat_accel_high_g(
6249:Src/bno055.c  **** u8 *accel_high_g_u8)
6250:Src/bno055.c  **** {
 7136              		.loc 1 6250 0
 7137              		.cfi_startproc
 7138              		@ args = 0, pretend = 0, frame = 8
 7139              		@ frame_needed = 0, uses_anonymous_args = 0
 7140              	.LVL832:
 7141 0000 30B5     		push	{r4, r5, lr}
 7142              	.LCFI306:
 7143              		.cfi_def_cfa_offset 12
 7144              		.cfi_offset 4, -12
 7145              		.cfi_offset 5, -8
 7146              		.cfi_offset 14, -4
6251:Src/bno055.c  **** 	/* Variable used to return value of
6252:Src/bno055.c  **** 	communication routine*/
6253:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6254:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6255:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6256:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6257:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7147              		.loc 1 6257 0
 7148 0002 134C     		ldr	r4, .L788
6250:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 243


 7149              		.loc 1 6250 0
 7150 0004 83B0     		sub	sp, sp, #12
 7151              	.LCFI307:
 7152              		.cfi_def_cfa_offset 24
 7153              		.loc 1 6257 0
 7154 0006 2368     		ldr	r3, [r4]
6254:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7155              		.loc 1 6254 0
 7156 0008 0022     		movs	r2, #0
 7157 000a 8DF80720 		strb	r2, [sp, #7]
 7158              	.LVL833:
 7159              		.loc 1 6257 0
 7160 000e E3B1     		cbz	r3, .L781
6258:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6259:Src/bno055.c  **** 		} else {
6260:Src/bno055.c  **** 		/*condition check for page, accel highg is
6261:Src/bno055.c  **** 		available in the page zero*/
6262:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7161              		.loc 1 6262 0
 7162 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7163 0012 0546     		mov	r5, r0
 7164 0014 71B9     		cbnz	r1, .L787
 7165              	.LVL834:
 7166              	.L779:
6263:Src/bno055.c  **** 			/* Write the page zero*/
6264:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6265:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6266:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6267:Src/bno055.c  **** 			/* Read the accel highg interrupt stat_s8 */
6268:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7167              		.loc 1 6268 0
 7168 0016 1C69     		ldr	r4, [r3, #16]
 7169 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7170 001a 3721     		movs	r1, #55
 7171 001c 0123     		movs	r3, #1
 7172 001e 0DF10702 		add	r2, sp, #7
 7173 0022 A047     		blx	r4
 7174              	.LVL835:
6269:Src/bno055.c  **** 			(p_bno055->dev_addr,
6270:Src/bno055.c  **** 			BNO055_INTR_STAT_ACCEL_HIGH_G_REG,
6271:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6272:Src/bno055.c  **** 			*accel_high_g_u8 =
6273:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7175              		.loc 1 6273 0
 7176 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7177 0028 C3F34013 		ubfx	r3, r3, #5, #1
6272:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7178              		.loc 1 6272 0
 7179 002c 2B70     		strb	r3, [r5]
 7180              	.LVL836:
 7181              	.L778:
6274:Src/bno055.c  **** 			BNO055_INTR_STAT_ACCEL_HIGH_G);
6275:Src/bno055.c  **** 		} else {
6276:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6277:Src/bno055.c  **** 		}
6278:Src/bno055.c  **** 	}
6279:Src/bno055.c  **** 	return com_rslt;
ARM GAS  /tmp/ccVWLGiI.s 			page 244


6280:Src/bno055.c  **** }
 7182              		.loc 1 6280 0
 7183 002e 40B2     		sxtb	r0, r0
 7184 0030 03B0     		add	sp, sp, #12
 7185              	.LCFI308:
 7186              		.cfi_remember_state
 7187              		.cfi_def_cfa_offset 12
 7188              		@ sp needed
 7189 0032 30BD     		pop	{r4, r5, pc}
 7190              	.LVL837:
 7191              	.L787:
 7192              	.LCFI309:
 7193              		.cfi_restore_state
6264:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7194              		.loc 1 6264 0
 7195 0034 1046     		mov	r0, r2
 7196              	.LVL838:
 7197 0036 FFF7FEFF 		bl	bno055_write_page_id
 7198              	.LVL839:
 7199 003a 2368     		ldr	r3, [r4]
6265:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7200              		.loc 1 6265 0
 7201 003c 0028     		cmp	r0, #0
 7202 003e EAD0     		beq	.L779
 7203              	.LVL840:
6265:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7204              		.loc 1 6265 0 is_stmt 0 discriminator 1
 7205 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6276:Src/bno055.c  **** 		}
 7206              		.loc 1 6276 0 is_stmt 1 discriminator 1
 7207 0042 FF20     		movs	r0, #255
6265:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7208              		.loc 1 6265 0 discriminator 1
 7209 0044 002A     		cmp	r2, #0
 7210 0046 F2D1     		bne	.L778
 7211 0048 E5E7     		b	.L779
 7212              	.LVL841:
 7213              	.L781:
6258:Src/bno055.c  **** 		} else {
 7214              		.loc 1 6258 0
 7215 004a 8120     		movs	r0, #129
 7216              	.LVL842:
 7217 004c EFE7     		b	.L778
 7218              	.L789:
 7219 004e 00BF     		.align	2
 7220              	.L788:
 7221 0050 00000000 		.word	.LANCHOR0
 7222              		.cfi_endproc
 7223              	.LFE127:
 7225              		.section	.text.bno055_get_intr_stat_accel_any_motion,"ax",%progbits
 7226              		.align	2
 7227              		.global	bno055_get_intr_stat_accel_any_motion
 7228              		.thumb
 7229              		.thumb_func
 7231              	bno055_get_intr_stat_accel_any_motion:
 7232              	.LFB128:
6281:Src/bno055.c  **** /*!
ARM GAS  /tmp/ccVWLGiI.s 			page 245


6282:Src/bno055.c  ****  *	@brief This API used to read the stat_s8 of
6283:Src/bno055.c  ****  *	accel anymotion interrupt from register from 0x37 bit 6
6284:Src/bno055.c  ****  *
6285:Src/bno055.c  ****  *	@param accel_any_motion_u8 : The value of accel anymotion interrupt
6286:Src/bno055.c  ****  *
6287:Src/bno055.c  ****  *     accel_any_motion_u8 |  result
6288:Src/bno055.c  ****  *    -------------------   | ---------------------
6289:Src/bno055.c  ****  *     0x00                 | indicates no interrupt triggered
6290:Src/bno055.c  ****  *     0x01                 | indicates interrupt triggered
6291:Src/bno055.c  ****  *
6292:Src/bno055.c  ****  *	@return results of bus communication function
6293:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6294:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6295:Src/bno055.c  ****  *
6296:Src/bno055.c  ****  *	@note Accel anymotion interrupt can be configured
6297:Src/bno055.c  ****  *			by the following APIs
6298:Src/bno055.c  ****  *
6299:Src/bno055.c  ****  *	bno055_set_intr_mask_accel_any_motion()
6300:Src/bno055.c  ****  *
6301:Src/bno055.c  ****  *	bno055_set_intr_accel_any_motion()
6302:Src/bno055.c  ****  */
6303:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_stat_accel_any_motion(
6304:Src/bno055.c  **** u8 *accel_any_motion_u8)
6305:Src/bno055.c  **** {
 7233              		.loc 1 6305 0
 7234              		.cfi_startproc
 7235              		@ args = 0, pretend = 0, frame = 8
 7236              		@ frame_needed = 0, uses_anonymous_args = 0
 7237              	.LVL843:
 7238 0000 30B5     		push	{r4, r5, lr}
 7239              	.LCFI310:
 7240              		.cfi_def_cfa_offset 12
 7241              		.cfi_offset 4, -12
 7242              		.cfi_offset 5, -8
 7243              		.cfi_offset 14, -4
6306:Src/bno055.c  **** 	/* Variable used to return value of
6307:Src/bno055.c  **** 	communication routine*/
6308:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6309:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6310:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6311:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6312:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7244              		.loc 1 6312 0
 7245 0002 134C     		ldr	r4, .L801
6305:Src/bno055.c  **** 	/* Variable used to return value of
 7246              		.loc 1 6305 0
 7247 0004 83B0     		sub	sp, sp, #12
 7248              	.LCFI311:
 7249              		.cfi_def_cfa_offset 24
 7250              		.loc 1 6312 0
 7251 0006 2368     		ldr	r3, [r4]
6309:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7252              		.loc 1 6309 0
 7253 0008 0022     		movs	r2, #0
 7254 000a 8DF80720 		strb	r2, [sp, #7]
 7255              	.LVL844:
 7256              		.loc 1 6312 0
ARM GAS  /tmp/ccVWLGiI.s 			page 246


 7257 000e E3B1     		cbz	r3, .L794
6313:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6314:Src/bno055.c  **** 		} else {
6315:Src/bno055.c  **** 		/*condition check for page, accel anymotion is
6316:Src/bno055.c  **** 		available in the page zero*/
6317:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7258              		.loc 1 6317 0
 7259 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7260 0012 0546     		mov	r5, r0
 7261 0014 71B9     		cbnz	r1, .L800
 7262              	.LVL845:
 7263              	.L792:
6318:Src/bno055.c  **** 			/* Write the page zero*/
6319:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6320:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6321:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6322:Src/bno055.c  **** 			/* Read the accel anymotion interrupt stat_s8 */
6323:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7264              		.loc 1 6323 0
 7265 0016 1C69     		ldr	r4, [r3, #16]
 7266 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7267 001a 3721     		movs	r1, #55
 7268 001c 0123     		movs	r3, #1
 7269 001e 0DF10702 		add	r2, sp, #7
 7270 0022 A047     		blx	r4
 7271              	.LVL846:
6324:Src/bno055.c  **** 			(p_bno055->dev_addr,
6325:Src/bno055.c  **** 			BNO055_INTR_STAT_ACCEL_ANY_MOTION_REG,
6326:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6327:Src/bno055.c  **** 			*accel_any_motion_u8 =
6328:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7272              		.loc 1 6328 0
 7273 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7274 0028 C3F38013 		ubfx	r3, r3, #6, #1
6327:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7275              		.loc 1 6327 0
 7276 002c 2B70     		strb	r3, [r5]
 7277              	.LVL847:
 7278              	.L791:
6329:Src/bno055.c  **** 			BNO055_INTR_STAT_ACCEL_ANY_MOTION);
6330:Src/bno055.c  **** 		} else {
6331:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6332:Src/bno055.c  **** 		}
6333:Src/bno055.c  **** 	}
6334:Src/bno055.c  **** 	return com_rslt;
6335:Src/bno055.c  **** }
 7279              		.loc 1 6335 0
 7280 002e 40B2     		sxtb	r0, r0
 7281 0030 03B0     		add	sp, sp, #12
 7282              	.LCFI312:
 7283              		.cfi_remember_state
 7284              		.cfi_def_cfa_offset 12
 7285              		@ sp needed
 7286 0032 30BD     		pop	{r4, r5, pc}
 7287              	.LVL848:
 7288              	.L800:
 7289              	.LCFI313:
ARM GAS  /tmp/ccVWLGiI.s 			page 247


 7290              		.cfi_restore_state
6319:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7291              		.loc 1 6319 0
 7292 0034 1046     		mov	r0, r2
 7293              	.LVL849:
 7294 0036 FFF7FEFF 		bl	bno055_write_page_id
 7295              	.LVL850:
 7296 003a 2368     		ldr	r3, [r4]
6320:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7297              		.loc 1 6320 0
 7298 003c 0028     		cmp	r0, #0
 7299 003e EAD0     		beq	.L792
 7300              	.LVL851:
6320:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7301              		.loc 1 6320 0 is_stmt 0 discriminator 1
 7302 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6331:Src/bno055.c  **** 		}
 7303              		.loc 1 6331 0 is_stmt 1 discriminator 1
 7304 0042 FF20     		movs	r0, #255
6320:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7305              		.loc 1 6320 0 discriminator 1
 7306 0044 002A     		cmp	r2, #0
 7307 0046 F2D1     		bne	.L791
 7308 0048 E5E7     		b	.L792
 7309              	.LVL852:
 7310              	.L794:
6313:Src/bno055.c  **** 		} else {
 7311              		.loc 1 6313 0
 7312 004a 8120     		movs	r0, #129
 7313              	.LVL853:
 7314 004c EFE7     		b	.L791
 7315              	.L802:
 7316 004e 00BF     		.align	2
 7317              	.L801:
 7318 0050 00000000 		.word	.LANCHOR0
 7319              		.cfi_endproc
 7320              	.LFE128:
 7322              		.section	.text.bno055_get_intr_stat_accel_no_motion,"ax",%progbits
 7323              		.align	2
 7324              		.global	bno055_get_intr_stat_accel_no_motion
 7325              		.thumb
 7326              		.thumb_func
 7328              	bno055_get_intr_stat_accel_no_motion:
 7329              	.LFB129:
6336:Src/bno055.c  **** /*!
6337:Src/bno055.c  ****  *	@brief This API used to read the stat_s8 of
6338:Src/bno055.c  ****  *	accel nomotion/slowmotion interrupt from register from 0x37 bit 6
6339:Src/bno055.c  ****  *
6340:Src/bno055.c  ****  *	@param accel_no_motion_u8 : The value of accel
6341:Src/bno055.c  ****  *	nomotion/slowmotion interrupt
6342:Src/bno055.c  ****  *
6343:Src/bno055.c  ****  *     accel_no_motion_u8 |  result
6344:Src/bno055.c  ****  *    -------------------   | ---------------------
6345:Src/bno055.c  ****  *     0x00                 | indicates no interrupt triggered
6346:Src/bno055.c  ****  *     0x01                 | indicates interrupt triggered
6347:Src/bno055.c  ****  *
6348:Src/bno055.c  ****  *	@return results of bus communication function
ARM GAS  /tmp/ccVWLGiI.s 			page 248


6349:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6350:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6351:Src/bno055.c  ****  *
6352:Src/bno055.c  ****  *	@note Accel nomotion/slowmotion interrupt can be configured
6353:Src/bno055.c  ****  *			by the following APIs
6354:Src/bno055.c  ****  *
6355:Src/bno055.c  ****  *	bno055_set_intr_mask_accel_nomotion()
6356:Src/bno055.c  ****  *
6357:Src/bno055.c  ****  *	bno055_set_intr_accel_nomotion()
6358:Src/bno055.c  ****  */
6359:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_stat_accel_no_motion(
6360:Src/bno055.c  **** u8 *accel_no_motion_u8)
6361:Src/bno055.c  **** {
 7330              		.loc 1 6361 0
 7331              		.cfi_startproc
 7332              		@ args = 0, pretend = 0, frame = 8
 7333              		@ frame_needed = 0, uses_anonymous_args = 0
 7334              	.LVL854:
 7335 0000 30B5     		push	{r4, r5, lr}
 7336              	.LCFI314:
 7337              		.cfi_def_cfa_offset 12
 7338              		.cfi_offset 4, -12
 7339              		.cfi_offset 5, -8
 7340              		.cfi_offset 14, -4
6362:Src/bno055.c  **** 	/* Variable used to return value of
6363:Src/bno055.c  **** 	communication routine*/
6364:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6365:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6366:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6367:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6368:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7341              		.loc 1 6368 0
 7342 0002 124C     		ldr	r4, .L814
6361:Src/bno055.c  **** 	/* Variable used to return value of
 7343              		.loc 1 6361 0
 7344 0004 83B0     		sub	sp, sp, #12
 7345              	.LCFI315:
 7346              		.cfi_def_cfa_offset 24
 7347              		.loc 1 6368 0
 7348 0006 2368     		ldr	r3, [r4]
6365:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7349              		.loc 1 6365 0
 7350 0008 0022     		movs	r2, #0
 7351 000a 8DF80720 		strb	r2, [sp, #7]
 7352              	.LVL855:
 7353              		.loc 1 6368 0
 7354 000e DBB1     		cbz	r3, .L807
6369:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6370:Src/bno055.c  **** 		} else {
6371:Src/bno055.c  **** 		/*condition check for page, accel
6372:Src/bno055.c  **** 		nomotion/slowmotion interrupt
6373:Src/bno055.c  **** 		is available in the page zero*/
6374:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7355              		.loc 1 6374 0
 7356 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7357 0012 0546     		mov	r5, r0
 7358 0014 69B9     		cbnz	r1, .L813
ARM GAS  /tmp/ccVWLGiI.s 			page 249


 7359              	.LVL856:
 7360              	.L805:
6375:Src/bno055.c  **** 			/* Write the page zero*/
6376:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6377:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6378:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6379:Src/bno055.c  **** 			/* Read the stat_s8 of accel
6380:Src/bno055.c  **** 			nomotion/slowmotion interrupt*/
6381:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7361              		.loc 1 6381 0
 7362 0016 1C69     		ldr	r4, [r3, #16]
 7363 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7364 001a 3721     		movs	r1, #55
 7365 001c 0123     		movs	r3, #1
 7366 001e 0DF10702 		add	r2, sp, #7
 7367 0022 A047     		blx	r4
 7368              	.LVL857:
6382:Src/bno055.c  **** 			(p_bno055->dev_addr,
6383:Src/bno055.c  **** 			BNO055_INTR_STAT_ACCEL_NO_MOTION_REG,
6384:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6385:Src/bno055.c  **** 			*accel_no_motion_u8 =
6386:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7369              		.loc 1 6386 0
 7370 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7371 0028 DB09     		lsrs	r3, r3, #7
6385:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7372              		.loc 1 6385 0
 7373 002a 2B70     		strb	r3, [r5]
 7374              	.LVL858:
 7375              	.L804:
6387:Src/bno055.c  **** 			BNO055_INTR_STAT_ACCEL_NO_MOTION);
6388:Src/bno055.c  **** 		} else {
6389:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6390:Src/bno055.c  **** 		}
6391:Src/bno055.c  **** 	}
6392:Src/bno055.c  **** 	return com_rslt;
6393:Src/bno055.c  **** }
 7376              		.loc 1 6393 0
 7377 002c 40B2     		sxtb	r0, r0
 7378 002e 03B0     		add	sp, sp, #12
 7379              	.LCFI316:
 7380              		.cfi_remember_state
 7381              		.cfi_def_cfa_offset 12
 7382              		@ sp needed
 7383 0030 30BD     		pop	{r4, r5, pc}
 7384              	.LVL859:
 7385              	.L813:
 7386              	.LCFI317:
 7387              		.cfi_restore_state
6376:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7388              		.loc 1 6376 0
 7389 0032 1046     		mov	r0, r2
 7390              	.LVL860:
 7391 0034 FFF7FEFF 		bl	bno055_write_page_id
 7392              	.LVL861:
 7393 0038 2368     		ldr	r3, [r4]
6377:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 250


 7394              		.loc 1 6377 0
 7395 003a 0028     		cmp	r0, #0
 7396 003c EBD0     		beq	.L805
 7397              	.LVL862:
6377:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7398              		.loc 1 6377 0 is_stmt 0 discriminator 1
 7399 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6389:Src/bno055.c  **** 		}
 7400              		.loc 1 6389 0 is_stmt 1 discriminator 1
 7401 0040 FF20     		movs	r0, #255
6377:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7402              		.loc 1 6377 0 discriminator 1
 7403 0042 002A     		cmp	r2, #0
 7404 0044 F2D1     		bne	.L804
 7405 0046 E6E7     		b	.L805
 7406              	.LVL863:
 7407              	.L807:
6369:Src/bno055.c  **** 		} else {
 7408              		.loc 1 6369 0
 7409 0048 8120     		movs	r0, #129
 7410              	.LVL864:
 7411 004a EFE7     		b	.L804
 7412              	.L815:
 7413              		.align	2
 7414              	.L814:
 7415 004c 00000000 		.word	.LANCHOR0
 7416              		.cfi_endproc
 7417              	.LFE129:
 7419              		.section	.text.bno055_get_stat_main_clk,"ax",%progbits
 7420              		.align	2
 7421              		.global	bno055_get_stat_main_clk
 7422              		.thumb
 7423              		.thumb_func
 7425              	bno055_get_stat_main_clk:
 7426              	.LFB130:
6394:Src/bno055.c  **** /*!
6395:Src/bno055.c  ****  *	@brief This API is used to read status of main clock
6396:Src/bno055.c  ****  *	from the register 0x38 bit 0
6397:Src/bno055.c  ****  *
6398:Src/bno055.c  ****  *	@param stat_main_clk_u8 : the status of main clock
6399:Src/bno055.c  ****  *
6400:Src/bno055.c  ****  *
6401:Src/bno055.c  ****  *	@return results of bus communication function
6402:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6403:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6404:Src/bno055.c  ****  *
6405:Src/bno055.c  ****  */
6406:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_stat_main_clk(
6407:Src/bno055.c  **** u8 *stat_main_clk_u8)
6408:Src/bno055.c  **** {
 7427              		.loc 1 6408 0
 7428              		.cfi_startproc
 7429              		@ args = 0, pretend = 0, frame = 8
 7430              		@ frame_needed = 0, uses_anonymous_args = 0
 7431              	.LVL865:
 7432 0000 30B5     		push	{r4, r5, lr}
 7433              	.LCFI318:
ARM GAS  /tmp/ccVWLGiI.s 			page 251


 7434              		.cfi_def_cfa_offset 12
 7435              		.cfi_offset 4, -12
 7436              		.cfi_offset 5, -8
 7437              		.cfi_offset 14, -4
6409:Src/bno055.c  **** 	/* Variable used to return value of
6410:Src/bno055.c  **** 	communication routine*/
6411:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6412:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6413:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6414:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6415:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7438              		.loc 1 6415 0
 7439 0002 134C     		ldr	r4, .L827
6408:Src/bno055.c  **** 	/* Variable used to return value of
 7440              		.loc 1 6408 0
 7441 0004 83B0     		sub	sp, sp, #12
 7442              	.LCFI319:
 7443              		.cfi_def_cfa_offset 24
 7444              		.loc 1 6415 0
 7445 0006 2368     		ldr	r3, [r4]
6412:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7446              		.loc 1 6412 0
 7447 0008 0022     		movs	r2, #0
 7448 000a 8DF80720 		strb	r2, [sp, #7]
 7449              	.LVL866:
 7450              		.loc 1 6415 0
 7451 000e E3B1     		cbz	r3, .L820
6416:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6417:Src/bno055.c  **** 		} else {
6418:Src/bno055.c  **** 		/*condition check for page, status of main clk is
6419:Src/bno055.c  **** 		available in the page zero*/
6420:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7452              		.loc 1 6420 0
 7453 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7454 0012 0546     		mov	r5, r0
 7455 0014 71B9     		cbnz	r1, .L826
 7456              	.LVL867:
 7457              	.L818:
6421:Src/bno055.c  **** 			/* Write the page zero*/
6422:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6423:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6424:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6425:Src/bno055.c  **** 			/* Read the status of main clk */
6426:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7458              		.loc 1 6426 0
 7459 0016 1C69     		ldr	r4, [r3, #16]
 7460 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7461 001a 3821     		movs	r1, #56
 7462 001c 0123     		movs	r3, #1
 7463 001e 0DF10702 		add	r2, sp, #7
 7464 0022 A047     		blx	r4
 7465              	.LVL868:
6427:Src/bno055.c  **** 			(p_bno055->dev_addr,
6428:Src/bno055.c  **** 			BNO055_SYS_MAIN_CLK_REG,
6429:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6430:Src/bno055.c  **** 			*stat_main_clk_u8 =
 7466              		.loc 1 6430 0
ARM GAS  /tmp/ccVWLGiI.s 			page 252


 7467 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7468 0028 03F01003 		and	r3, r3, #16
 7469 002c 2B70     		strb	r3, [r5]
 7470              	.LVL869:
 7471              	.L817:
6431:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_SYS_MAIN_CLK);
6432:Src/bno055.c  **** 		} else {
6433:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6434:Src/bno055.c  **** 		}
6435:Src/bno055.c  **** 	}
6436:Src/bno055.c  **** 	return com_rslt;
6437:Src/bno055.c  **** }
 7472              		.loc 1 6437 0
 7473 002e 40B2     		sxtb	r0, r0
 7474 0030 03B0     		add	sp, sp, #12
 7475              	.LCFI320:
 7476              		.cfi_remember_state
 7477              		.cfi_def_cfa_offset 12
 7478              		@ sp needed
 7479 0032 30BD     		pop	{r4, r5, pc}
 7480              	.LVL870:
 7481              	.L826:
 7482              	.LCFI321:
 7483              		.cfi_restore_state
6422:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7484              		.loc 1 6422 0
 7485 0034 1046     		mov	r0, r2
 7486              	.LVL871:
 7487 0036 FFF7FEFF 		bl	bno055_write_page_id
 7488              	.LVL872:
 7489 003a 2368     		ldr	r3, [r4]
6423:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7490              		.loc 1 6423 0
 7491 003c 0028     		cmp	r0, #0
 7492 003e EAD0     		beq	.L818
 7493              	.LVL873:
6423:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7494              		.loc 1 6423 0 is_stmt 0 discriminator 1
 7495 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6433:Src/bno055.c  **** 		}
 7496              		.loc 1 6433 0 is_stmt 1 discriminator 1
 7497 0042 FF20     		movs	r0, #255
6423:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7498              		.loc 1 6423 0 discriminator 1
 7499 0044 002A     		cmp	r2, #0
 7500 0046 F2D1     		bne	.L817
 7501 0048 E5E7     		b	.L818
 7502              	.LVL874:
 7503              	.L820:
6416:Src/bno055.c  **** 		} else {
 7504              		.loc 1 6416 0
 7505 004a 8120     		movs	r0, #129
 7506              	.LVL875:
 7507 004c EFE7     		b	.L817
 7508              	.L828:
 7509 004e 00BF     		.align	2
 7510              	.L827:
ARM GAS  /tmp/ccVWLGiI.s 			page 253


 7511 0050 00000000 		.word	.LANCHOR0
 7512              		.cfi_endproc
 7513              	.LFE130:
 7515              		.section	.text.bno055_get_sys_stat_code,"ax",%progbits
 7516              		.align	2
 7517              		.global	bno055_get_sys_stat_code
 7518              		.thumb
 7519              		.thumb_func
 7521              	bno055_get_sys_stat_code:
 7522              	.LFB131:
6438:Src/bno055.c  **** /*!
6439:Src/bno055.c  ****  *	@brief This API is used to read system status
6440:Src/bno055.c  ****  *	code from the register 0x39 it is a byte of data
6441:Src/bno055.c  ****  *
6442:Src/bno055.c  ****  *	@param sys_stat_u8 : the status of system
6443:Src/bno055.c  ****  *
6444:Src/bno055.c  ****  *
6445:Src/bno055.c  ****  *	@return results of bus communication function
6446:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6447:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6448:Src/bno055.c  ****  *
6449:Src/bno055.c  ****  */
6450:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_sys_stat_code(
6451:Src/bno055.c  **** u8 *sys_stat_u8)
6452:Src/bno055.c  **** {
 7523              		.loc 1 6452 0
 7524              		.cfi_startproc
 7525              		@ args = 0, pretend = 0, frame = 8
 7526              		@ frame_needed = 0, uses_anonymous_args = 0
 7527              	.LVL876:
 7528 0000 30B5     		push	{r4, r5, lr}
 7529              	.LCFI322:
 7530              		.cfi_def_cfa_offset 12
 7531              		.cfi_offset 4, -12
 7532              		.cfi_offset 5, -8
 7533              		.cfi_offset 14, -4
6453:Src/bno055.c  **** 	/* Variable used to return value of
6454:Src/bno055.c  **** 	communication routine*/
6455:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6456:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6457:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6458:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6459:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7534              		.loc 1 6459 0
 7535 0002 124C     		ldr	r4, .L840
6452:Src/bno055.c  **** 	/* Variable used to return value of
 7536              		.loc 1 6452 0
 7537 0004 83B0     		sub	sp, sp, #12
 7538              	.LCFI323:
 7539              		.cfi_def_cfa_offset 24
 7540              		.loc 1 6459 0
 7541 0006 2368     		ldr	r3, [r4]
6456:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7542              		.loc 1 6456 0
 7543 0008 0022     		movs	r2, #0
 7544 000a 8DF80720 		strb	r2, [sp, #7]
 7545              	.LVL877:
ARM GAS  /tmp/ccVWLGiI.s 			page 254


 7546              		.loc 1 6459 0
 7547 000e D3B1     		cbz	r3, .L833
6460:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6461:Src/bno055.c  **** 		} else {
6462:Src/bno055.c  **** 		/*condition check for page, the status of system is
6463:Src/bno055.c  **** 		available in the page zero*/
6464:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7548              		.loc 1 6464 0
 7549 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7550 0012 0546     		mov	r5, r0
 7551 0014 61B9     		cbnz	r1, .L839
 7552              	.LVL878:
 7553              	.L831:
6465:Src/bno055.c  **** 			/* Write the page zero*/
6466:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6467:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6468:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6469:Src/bno055.c  **** 			/* Read the the status of system*/
6470:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7554              		.loc 1 6470 0
 7555 0016 1C69     		ldr	r4, [r3, #16]
 7556 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7557 001a 3921     		movs	r1, #57
 7558 001c 0123     		movs	r3, #1
 7559 001e 0DF10702 		add	r2, sp, #7
 7560 0022 A047     		blx	r4
 7561              	.LVL879:
6471:Src/bno055.c  **** 			(p_bno055->dev_addr,
6472:Src/bno055.c  **** 			BNO055_SYS_STAT_CODE_REG,
6473:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6474:Src/bno055.c  **** 			*sys_stat_u8 =
 7562              		.loc 1 6474 0
 7563 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7564 0028 2B70     		strb	r3, [r5]
 7565              	.LVL880:
 7566              	.L830:
6475:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
6476:Src/bno055.c  **** 			BNO055_SYS_STAT_CODE);
6477:Src/bno055.c  **** 		} else {
6478:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6479:Src/bno055.c  **** 		}
6480:Src/bno055.c  **** 	}
6481:Src/bno055.c  **** 	return com_rslt;
6482:Src/bno055.c  **** }
 7567              		.loc 1 6482 0
 7568 002a 40B2     		sxtb	r0, r0
 7569 002c 03B0     		add	sp, sp, #12
 7570              	.LCFI324:
 7571              		.cfi_remember_state
 7572              		.cfi_def_cfa_offset 12
 7573              		@ sp needed
 7574 002e 30BD     		pop	{r4, r5, pc}
 7575              	.LVL881:
 7576              	.L839:
 7577              	.LCFI325:
 7578              		.cfi_restore_state
6466:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
ARM GAS  /tmp/ccVWLGiI.s 			page 255


 7579              		.loc 1 6466 0
 7580 0030 1046     		mov	r0, r2
 7581              	.LVL882:
 7582 0032 FFF7FEFF 		bl	bno055_write_page_id
 7583              	.LVL883:
 7584 0036 2368     		ldr	r3, [r4]
6467:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7585              		.loc 1 6467 0
 7586 0038 0028     		cmp	r0, #0
 7587 003a ECD0     		beq	.L831
 7588              	.LVL884:
6467:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7589              		.loc 1 6467 0 is_stmt 0 discriminator 1
 7590 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6478:Src/bno055.c  **** 		}
 7591              		.loc 1 6478 0 is_stmt 1 discriminator 1
 7592 003e FF20     		movs	r0, #255
6467:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7593              		.loc 1 6467 0 discriminator 1
 7594 0040 002A     		cmp	r2, #0
 7595 0042 F2D1     		bne	.L830
 7596 0044 E7E7     		b	.L831
 7597              	.LVL885:
 7598              	.L833:
6460:Src/bno055.c  **** 		} else {
 7599              		.loc 1 6460 0
 7600 0046 8120     		movs	r0, #129
 7601              	.LVL886:
 7602 0048 EFE7     		b	.L830
 7603              	.L841:
 7604 004a 00BF     		.align	2
 7605              	.L840:
 7606 004c 00000000 		.word	.LANCHOR0
 7607              		.cfi_endproc
 7608              	.LFE131:
 7610              		.section	.text.bno055_get_sys_error_code,"ax",%progbits
 7611              		.align	2
 7612              		.global	bno055_get_sys_error_code
 7613              		.thumb
 7614              		.thumb_func
 7616              	bno055_get_sys_error_code:
 7617              	.LFB132:
6483:Src/bno055.c  **** /*!
6484:Src/bno055.c  ****  *	@brief This API is used to read system BNO055_ERROR
6485:Src/bno055.c  ****  *	code from the register 0x3A it is a byte of data
6486:Src/bno055.c  ****  *
6487:Src/bno055.c  ****  *	@param sys_error_u8 : The value of system BNO055_ERROR code
6488:Src/bno055.c  ****  *
6489:Src/bno055.c  ****  *
6490:Src/bno055.c  ****  *	@return results of bus communication function
6491:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6492:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6493:Src/bno055.c  ****  *
6494:Src/bno055.c  ****  *
6495:Src/bno055.c  ****  */
6496:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_sys_error_code(
6497:Src/bno055.c  **** u8 *sys_error_u8)
ARM GAS  /tmp/ccVWLGiI.s 			page 256


6498:Src/bno055.c  **** {
 7618              		.loc 1 6498 0
 7619              		.cfi_startproc
 7620              		@ args = 0, pretend = 0, frame = 8
 7621              		@ frame_needed = 0, uses_anonymous_args = 0
 7622              	.LVL887:
 7623 0000 30B5     		push	{r4, r5, lr}
 7624              	.LCFI326:
 7625              		.cfi_def_cfa_offset 12
 7626              		.cfi_offset 4, -12
 7627              		.cfi_offset 5, -8
 7628              		.cfi_offset 14, -4
6499:Src/bno055.c  **** 	/* Variable used to return value of
6500:Src/bno055.c  **** 	communication routine*/
6501:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6502:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6503:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6504:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6505:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7629              		.loc 1 6505 0
 7630 0002 124C     		ldr	r4, .L853
6498:Src/bno055.c  **** 	/* Variable used to return value of
 7631              		.loc 1 6498 0
 7632 0004 83B0     		sub	sp, sp, #12
 7633              	.LCFI327:
 7634              		.cfi_def_cfa_offset 24
 7635              		.loc 1 6505 0
 7636 0006 2368     		ldr	r3, [r4]
6502:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7637              		.loc 1 6502 0
 7638 0008 0022     		movs	r2, #0
 7639 000a 8DF80720 		strb	r2, [sp, #7]
 7640              	.LVL888:
 7641              		.loc 1 6505 0
 7642 000e D3B1     		cbz	r3, .L846
6506:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6507:Src/bno055.c  **** 		} else {
6508:Src/bno055.c  **** 		/*condition check for page, system BNO055_ERROR code is
6509:Src/bno055.c  **** 		available in the page zero*/
6510:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7643              		.loc 1 6510 0
 7644 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7645 0012 0546     		mov	r5, r0
 7646 0014 61B9     		cbnz	r1, .L852
 7647              	.LVL889:
 7648              	.L844:
6511:Src/bno055.c  **** 			/* Write the page zero*/
6512:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6513:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6514:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6515:Src/bno055.c  **** 			/* Read the system BNO055_ERROR code*/
6516:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7649              		.loc 1 6516 0
 7650 0016 1C69     		ldr	r4, [r3, #16]
 7651 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7652 001a 3A21     		movs	r1, #58
 7653 001c 0123     		movs	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 257


 7654 001e 0DF10702 		add	r2, sp, #7
 7655 0022 A047     		blx	r4
 7656              	.LVL890:
6517:Src/bno055.c  **** 			(p_bno055->dev_addr,
6518:Src/bno055.c  **** 			BNO055_SYS_ERROR_CODE_REG,
6519:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6520:Src/bno055.c  **** 			*sys_error_u8 =
 7657              		.loc 1 6520 0
 7658 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7659 0028 2B70     		strb	r3, [r5]
 7660              	.LVL891:
 7661              	.L843:
6521:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
6522:Src/bno055.c  **** 			BNO055_SYS_ERROR_CODE);
6523:Src/bno055.c  **** 		} else {
6524:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6525:Src/bno055.c  **** 		}
6526:Src/bno055.c  **** 	}
6527:Src/bno055.c  **** 	return com_rslt;
6528:Src/bno055.c  **** }
 7662              		.loc 1 6528 0
 7663 002a 40B2     		sxtb	r0, r0
 7664 002c 03B0     		add	sp, sp, #12
 7665              	.LCFI328:
 7666              		.cfi_remember_state
 7667              		.cfi_def_cfa_offset 12
 7668              		@ sp needed
 7669 002e 30BD     		pop	{r4, r5, pc}
 7670              	.LVL892:
 7671              	.L852:
 7672              	.LCFI329:
 7673              		.cfi_restore_state
6512:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7674              		.loc 1 6512 0
 7675 0030 1046     		mov	r0, r2
 7676              	.LVL893:
 7677 0032 FFF7FEFF 		bl	bno055_write_page_id
 7678              	.LVL894:
 7679 0036 2368     		ldr	r3, [r4]
6513:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7680              		.loc 1 6513 0
 7681 0038 0028     		cmp	r0, #0
 7682 003a ECD0     		beq	.L844
 7683              	.LVL895:
6513:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7684              		.loc 1 6513 0 is_stmt 0 discriminator 1
 7685 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6524:Src/bno055.c  **** 		}
 7686              		.loc 1 6524 0 is_stmt 1 discriminator 1
 7687 003e FF20     		movs	r0, #255
6513:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7688              		.loc 1 6513 0 discriminator 1
 7689 0040 002A     		cmp	r2, #0
 7690 0042 F2D1     		bne	.L843
 7691 0044 E7E7     		b	.L844
 7692              	.LVL896:
 7693              	.L846:
ARM GAS  /tmp/ccVWLGiI.s 			page 258


6506:Src/bno055.c  **** 		} else {
 7694              		.loc 1 6506 0
 7695 0046 8120     		movs	r0, #129
 7696              	.LVL897:
 7697 0048 EFE7     		b	.L843
 7698              	.L854:
 7699 004a 00BF     		.align	2
 7700              	.L853:
 7701 004c 00000000 		.word	.LANCHOR0
 7702              		.cfi_endproc
 7703              	.LFE132:
 7705              		.section	.text.bno055_get_accel_unit,"ax",%progbits
 7706              		.align	2
 7707              		.global	bno055_get_accel_unit
 7708              		.thumb
 7709              		.thumb_func
 7711              	bno055_get_accel_unit:
 7712              	.LFB133:
6529:Src/bno055.c  **** /*!
6530:Src/bno055.c  ****  *	@brief This API used to read the accel unit
6531:Src/bno055.c  ****  *	from register from 0x3B bit 0
6532:Src/bno055.c  ****  *
6533:Src/bno055.c  ****  *	@param accel_unit_u8 : The value of accel unit
6534:Src/bno055.c  ****  *
6535:Src/bno055.c  ****  *    accel_unit_u8 |   result
6536:Src/bno055.c  ****  *   -------------    | ---------------
6537:Src/bno055.c  ****  *        0x00        | BNO055_ACCEL_UNIT_MSQ
6538:Src/bno055.c  ****  *        0x01        | BNO055_ACCEL_UNIT_MG
6539:Src/bno055.c  ****  *
6540:Src/bno055.c  ****  *	@return results of bus communication function
6541:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6542:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6543:Src/bno055.c  ****  *
6544:Src/bno055.c  ****  */
6545:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_unit(
6546:Src/bno055.c  **** u8 *accel_unit_u8)
6547:Src/bno055.c  **** {
 7713              		.loc 1 6547 0
 7714              		.cfi_startproc
 7715              		@ args = 0, pretend = 0, frame = 8
 7716              		@ frame_needed = 0, uses_anonymous_args = 0
 7717              	.LVL898:
 7718 0000 30B5     		push	{r4, r5, lr}
 7719              	.LCFI330:
 7720              		.cfi_def_cfa_offset 12
 7721              		.cfi_offset 4, -12
 7722              		.cfi_offset 5, -8
 7723              		.cfi_offset 14, -4
6548:Src/bno055.c  **** 	/* Variable used to return value of
6549:Src/bno055.c  **** 	communication routine*/
6550:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6551:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6552:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6553:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6554:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7724              		.loc 1 6554 0
 7725 0002 134C     		ldr	r4, .L866
ARM GAS  /tmp/ccVWLGiI.s 			page 259


6547:Src/bno055.c  **** 	/* Variable used to return value of
 7726              		.loc 1 6547 0
 7727 0004 83B0     		sub	sp, sp, #12
 7728              	.LCFI331:
 7729              		.cfi_def_cfa_offset 24
 7730              		.loc 1 6554 0
 7731 0006 2368     		ldr	r3, [r4]
6551:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7732              		.loc 1 6551 0
 7733 0008 0022     		movs	r2, #0
 7734 000a 8DF80720 		strb	r2, [sp, #7]
 7735              	.LVL899:
 7736              		.loc 1 6554 0
 7737 000e E3B1     		cbz	r3, .L859
6555:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6556:Src/bno055.c  **** 		} else {
6557:Src/bno055.c  **** 		/*condition check for page, accel unit is
6558:Src/bno055.c  **** 		available in the page zero*/
6559:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7738              		.loc 1 6559 0
 7739 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7740 0012 0546     		mov	r5, r0
 7741 0014 71B9     		cbnz	r1, .L865
 7742              	.LVL900:
 7743              	.L857:
6560:Src/bno055.c  **** 			/* Write the page zero*/
6561:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6562:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6563:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6564:Src/bno055.c  **** 			/* Read the accel unit */
6565:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7744              		.loc 1 6565 0
 7745 0016 1C69     		ldr	r4, [r3, #16]
 7746 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7747 001a 3B21     		movs	r1, #59
 7748 001c 0123     		movs	r3, #1
 7749 001e 0DF10702 		add	r2, sp, #7
 7750 0022 A047     		blx	r4
 7751              	.LVL901:
6566:Src/bno055.c  **** 			(p_bno055->dev_addr,
6567:Src/bno055.c  **** 			BNO055_ACCEL_UNIT_REG,
6568:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6569:Src/bno055.c  **** 			*accel_unit_u8 =
 7752              		.loc 1 6569 0
 7753 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7754 0028 03F00103 		and	r3, r3, #1
 7755 002c 2B70     		strb	r3, [r5]
 7756              	.LVL902:
 7757              	.L856:
6570:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_ACCEL_UNIT);
6571:Src/bno055.c  **** 		} else {
6572:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6573:Src/bno055.c  **** 		}
6574:Src/bno055.c  **** 	}
6575:Src/bno055.c  **** 	return com_rslt;
6576:Src/bno055.c  **** }
 7758              		.loc 1 6576 0
ARM GAS  /tmp/ccVWLGiI.s 			page 260


 7759 002e 40B2     		sxtb	r0, r0
 7760 0030 03B0     		add	sp, sp, #12
 7761              	.LCFI332:
 7762              		.cfi_remember_state
 7763              		.cfi_def_cfa_offset 12
 7764              		@ sp needed
 7765 0032 30BD     		pop	{r4, r5, pc}
 7766              	.LVL903:
 7767              	.L865:
 7768              	.LCFI333:
 7769              		.cfi_restore_state
6561:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7770              		.loc 1 6561 0
 7771 0034 1046     		mov	r0, r2
 7772              	.LVL904:
 7773 0036 FFF7FEFF 		bl	bno055_write_page_id
 7774              	.LVL905:
 7775 003a 2368     		ldr	r3, [r4]
6562:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7776              		.loc 1 6562 0
 7777 003c 0028     		cmp	r0, #0
 7778 003e EAD0     		beq	.L857
 7779              	.LVL906:
6562:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7780              		.loc 1 6562 0 is_stmt 0 discriminator 1
 7781 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6572:Src/bno055.c  **** 		}
 7782              		.loc 1 6572 0 is_stmt 1 discriminator 1
 7783 0042 FF20     		movs	r0, #255
6562:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7784              		.loc 1 6562 0 discriminator 1
 7785 0044 002A     		cmp	r2, #0
 7786 0046 F2D1     		bne	.L856
 7787 0048 E5E7     		b	.L857
 7788              	.LVL907:
 7789              	.L859:
6555:Src/bno055.c  **** 		} else {
 7790              		.loc 1 6555 0
 7791 004a 8120     		movs	r0, #129
 7792              	.LVL908:
 7793 004c EFE7     		b	.L856
 7794              	.L867:
 7795 004e 00BF     		.align	2
 7796              	.L866:
 7797 0050 00000000 		.word	.LANCHOR0
 7798              		.cfi_endproc
 7799              	.LFE133:
 7801              		.section	.text.bno055_get_gyro_unit,"ax",%progbits
 7802              		.align	2
 7803              		.global	bno055_get_gyro_unit
 7804              		.thumb
 7805              		.thumb_func
 7807              	bno055_get_gyro_unit:
 7808              	.LFB135:
6577:Src/bno055.c  **** /*!
6578:Src/bno055.c  ****  *	@brief This API used to write the accel unit
6579:Src/bno055.c  ****  *	from register from 0x3B bit 0
ARM GAS  /tmp/ccVWLGiI.s 			page 261


6580:Src/bno055.c  ****  *
6581:Src/bno055.c  ****  *	@param accel_unit_u8 : The value of accel unit
6582:Src/bno055.c  ****  *
6583:Src/bno055.c  ****  *    accel_unit_u8 |   result
6584:Src/bno055.c  ****  *   -------------    | ---------------
6585:Src/bno055.c  ****  *        0x00        | BNO055_ACCEL_UNIT_MSQ
6586:Src/bno055.c  ****  *        0x01        | BNO055_ACCEL_UNIT_MG
6587:Src/bno055.c  ****  *
6588:Src/bno055.c  ****  *	@return results of bus communication function
6589:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6590:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6591:Src/bno055.c  ****  *
6592:Src/bno055.c  ****  *
6593:Src/bno055.c  ****  */
6594:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_unit(
6595:Src/bno055.c  **** u8 accel_unit_u8)
6596:Src/bno055.c  **** {
6597:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6598:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
6599:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
6600:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
6601:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6602:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
6603:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
6604:Src/bno055.c  **** 	} else {
6605:Src/bno055.c  **** 	/* The write operation effective only if the operation
6606:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
6607:Src/bno055.c  **** 	current operation mode and set the config mode */
6608:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
6609:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
6610:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6611:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
6612:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
6613:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
6614:Src/bno055.c  **** 				/* Write the accel unit */
6615:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
6616:Src/bno055.c  **** 				(p_bno055->dev_addr,
6617:Src/bno055.c  **** 				BNO055_ACCEL_UNIT_REG,
6618:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6619:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
6620:Src/bno055.c  **** 					data_u8r =
6621:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
6622:Src/bno055.c  **** 					BNO055_ACCEL_UNIT, accel_unit_u8);
6623:Src/bno055.c  **** 					com_rslt +=
6624:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
6625:Src/bno055.c  **** 					(p_bno055->dev_addr,
6626:Src/bno055.c  **** 					BNO055_ACCEL_UNIT_REG,
6627:Src/bno055.c  **** 					&data_u8r,
6628:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
6629:Src/bno055.c  **** 				}
6630:Src/bno055.c  **** 			} else {
6631:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
6632:Src/bno055.c  **** 			}
6633:Src/bno055.c  **** 		} else {
6634:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6635:Src/bno055.c  **** 		}
6636:Src/bno055.c  **** 	}
ARM GAS  /tmp/ccVWLGiI.s 			page 262


6637:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6638:Src/bno055.c  **** 		/* set the operation mode
6639:Src/bno055.c  **** 		of previous operation mode*/
6640:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
6641:Src/bno055.c  **** 		(prev_opmode_u8);
6642:Src/bno055.c  **** 	return com_rslt;
6643:Src/bno055.c  **** }
6644:Src/bno055.c  **** /*!
6645:Src/bno055.c  ****  *	@brief This API used to read the gyro unit
6646:Src/bno055.c  ****  *	from register from 0x3B bit 1
6647:Src/bno055.c  ****  *
6648:Src/bno055.c  ****  *	@param gyro_unit_u8 : The value of accel unit
6649:Src/bno055.c  ****  *
6650:Src/bno055.c  ****  *	gyro_unit_u8  |  result
6651:Src/bno055.c  ****  *	-------------   | -----------
6652:Src/bno055.c  ****  *    0x00          | BNO055_GYRO_UNIT_DPS
6653:Src/bno055.c  ****  *    0x01          | BNO055_GYRO_UNIT_RPS
6654:Src/bno055.c  ****  *
6655:Src/bno055.c  ****  *	@return results of bus communication function
6656:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6657:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6658:Src/bno055.c  ****  *
6659:Src/bno055.c  ****  *
6660:Src/bno055.c  ****  */
6661:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_unit(
6662:Src/bno055.c  **** u8 *gyro_unit_u8)
6663:Src/bno055.c  **** {
 7809              		.loc 1 6663 0
 7810              		.cfi_startproc
 7811              		@ args = 0, pretend = 0, frame = 8
 7812              		@ frame_needed = 0, uses_anonymous_args = 0
 7813              	.LVL909:
 7814 0000 30B5     		push	{r4, r5, lr}
 7815              	.LCFI334:
 7816              		.cfi_def_cfa_offset 12
 7817              		.cfi_offset 4, -12
 7818              		.cfi_offset 5, -8
 7819              		.cfi_offset 14, -4
6664:Src/bno055.c  **** 	/* Variable used to return value of
6665:Src/bno055.c  **** 	communication routine*/
6666:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6667:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6668:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6669:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6670:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7820              		.loc 1 6670 0
 7821 0002 134C     		ldr	r4, .L879
6663:Src/bno055.c  **** 	/* Variable used to return value of
 7822              		.loc 1 6663 0
 7823 0004 83B0     		sub	sp, sp, #12
 7824              	.LCFI335:
 7825              		.cfi_def_cfa_offset 24
 7826              		.loc 1 6670 0
 7827 0006 2368     		ldr	r3, [r4]
6667:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7828              		.loc 1 6667 0
 7829 0008 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 263


 7830 000a 8DF80720 		strb	r2, [sp, #7]
 7831              	.LVL910:
 7832              		.loc 1 6670 0
 7833 000e E3B1     		cbz	r3, .L872
6671:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6672:Src/bno055.c  **** 		} else {
6673:Src/bno055.c  **** 		/*condition check for page, gyro unit is
6674:Src/bno055.c  **** 		available in the page zero*/
6675:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 7834              		.loc 1 6675 0
 7835 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7836 0012 0546     		mov	r5, r0
 7837 0014 71B9     		cbnz	r1, .L878
 7838              	.LVL911:
 7839              	.L870:
6676:Src/bno055.c  **** 			/* Write the page zero*/
6677:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6678:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6679:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6680:Src/bno055.c  **** 			/* Read the gyro unit */
6681:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7840              		.loc 1 6681 0
 7841 0016 1C69     		ldr	r4, [r3, #16]
 7842 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7843 001a 3B21     		movs	r1, #59
 7844 001c 0123     		movs	r3, #1
 7845 001e 0DF10702 		add	r2, sp, #7
 7846 0022 A047     		blx	r4
 7847              	.LVL912:
6682:Src/bno055.c  **** 			(p_bno055->dev_addr,
6683:Src/bno055.c  **** 			BNO055_GYRO_UNIT_REG,
6684:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6685:Src/bno055.c  **** 			*gyro_unit_u8 =
6686:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_GYRO_UNIT);
 7848              		.loc 1 6686 0
 7849 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7850 0028 C3F34003 		ubfx	r3, r3, #1, #1
6685:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_GYRO_UNIT);
 7851              		.loc 1 6685 0
 7852 002c 2B70     		strb	r3, [r5]
 7853              	.LVL913:
 7854              	.L869:
6687:Src/bno055.c  **** 		} else {
6688:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6689:Src/bno055.c  **** 		}
6690:Src/bno055.c  **** 	}
6691:Src/bno055.c  **** 	return com_rslt;
6692:Src/bno055.c  **** }
 7855              		.loc 1 6692 0
 7856 002e 40B2     		sxtb	r0, r0
 7857 0030 03B0     		add	sp, sp, #12
 7858              	.LCFI336:
 7859              		.cfi_remember_state
 7860              		.cfi_def_cfa_offset 12
 7861              		@ sp needed
 7862 0032 30BD     		pop	{r4, r5, pc}
 7863              	.LVL914:
ARM GAS  /tmp/ccVWLGiI.s 			page 264


 7864              	.L878:
 7865              	.LCFI337:
 7866              		.cfi_restore_state
6677:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7867              		.loc 1 6677 0
 7868 0034 1046     		mov	r0, r2
 7869              	.LVL915:
 7870 0036 FFF7FEFF 		bl	bno055_write_page_id
 7871              	.LVL916:
 7872 003a 2368     		ldr	r3, [r4]
6678:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7873              		.loc 1 6678 0
 7874 003c 0028     		cmp	r0, #0
 7875 003e EAD0     		beq	.L870
 7876              	.LVL917:
6678:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7877              		.loc 1 6678 0 is_stmt 0 discriminator 1
 7878 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6688:Src/bno055.c  **** 		}
 7879              		.loc 1 6688 0 is_stmt 1 discriminator 1
 7880 0042 FF20     		movs	r0, #255
6678:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7881              		.loc 1 6678 0 discriminator 1
 7882 0044 002A     		cmp	r2, #0
 7883 0046 F2D1     		bne	.L869
 7884 0048 E5E7     		b	.L870
 7885              	.LVL918:
 7886              	.L872:
6671:Src/bno055.c  **** 		} else {
 7887              		.loc 1 6671 0
 7888 004a 8120     		movs	r0, #129
 7889              	.LVL919:
 7890 004c EFE7     		b	.L869
 7891              	.L880:
 7892 004e 00BF     		.align	2
 7893              	.L879:
 7894 0050 00000000 		.word	.LANCHOR0
 7895              		.cfi_endproc
 7896              	.LFE135:
 7898              		.section	.text.bno055_get_euler_unit,"ax",%progbits
 7899              		.align	2
 7900              		.global	bno055_get_euler_unit
 7901              		.thumb
 7902              		.thumb_func
 7904              	bno055_get_euler_unit:
 7905              	.LFB137:
6693:Src/bno055.c  **** /*!
6694:Src/bno055.c  ****  *	@brief This API used to write the gyro unit
6695:Src/bno055.c  ****  *	from register from 0x3B bit 1
6696:Src/bno055.c  ****  *
6697:Src/bno055.c  ****  *	@param gyro_unit_u8 : The value of accel unit
6698:Src/bno055.c  ****  *
6699:Src/bno055.c  ****  *	gyro_unit_u8  |  result
6700:Src/bno055.c  ****  *	-------------   | -----------
6701:Src/bno055.c  ****  *    0x00          | BNO055_GYRO_UNIT_DPS
6702:Src/bno055.c  ****  *    0x01          | BNO055_GYRO_UNIT_RPS
6703:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 265


6704:Src/bno055.c  ****  *	@return results of bus communication function
6705:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6706:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6707:Src/bno055.c  ****  *
6708:Src/bno055.c  ****  *
6709:Src/bno055.c  ****  */
6710:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_unit(u8 gyro_unit_u8)
6711:Src/bno055.c  **** {
6712:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6713:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
6714:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
6715:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
6716:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
6717:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
6718:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
6719:Src/bno055.c  **** 	} else {
6720:Src/bno055.c  **** 	/* The write operation effective only if the operation
6721:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
6722:Src/bno055.c  **** 	current operation mode and set the config mode */
6723:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
6724:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
6725:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6726:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
6727:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
6728:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
6729:Src/bno055.c  **** 				/* Write the gyro unit */
6730:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
6731:Src/bno055.c  **** 				(p_bno055->dev_addr,
6732:Src/bno055.c  **** 				BNO055_GYRO_UNIT_REG,
6733:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6734:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
6735:Src/bno055.c  **** 					data_u8r =
6736:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
6737:Src/bno055.c  **** 					BNO055_GYRO_UNIT, gyro_unit_u8);
6738:Src/bno055.c  **** 					com_rslt +=
6739:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
6740:Src/bno055.c  **** 					(p_bno055->dev_addr,
6741:Src/bno055.c  **** 					BNO055_GYRO_UNIT_REG,
6742:Src/bno055.c  **** 					&data_u8r,
6743:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
6744:Src/bno055.c  **** 				}
6745:Src/bno055.c  **** 			} else {
6746:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
6747:Src/bno055.c  **** 			}
6748:Src/bno055.c  **** 		} else {
6749:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6750:Src/bno055.c  **** 		}
6751:Src/bno055.c  **** 	}
6752:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6753:Src/bno055.c  **** 		/* set the operation mode
6754:Src/bno055.c  **** 		of previous operation mode*/
6755:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
6756:Src/bno055.c  **** 		(prev_opmode_u8);
6757:Src/bno055.c  **** 	return com_rslt;
6758:Src/bno055.c  **** }
6759:Src/bno055.c  **** /*!
6760:Src/bno055.c  ****  *	@brief This API used to read the Euler unit
ARM GAS  /tmp/ccVWLGiI.s 			page 266


6761:Src/bno055.c  ****  *	from register from 0x3B bit 2
6762:Src/bno055.c  ****  *
6763:Src/bno055.c  ****  *	@param euler_unit_u8 : The value of accel unit
6764:Src/bno055.c  ****  *
6765:Src/bno055.c  ****  *    euler_unit_u8 | result
6766:Src/bno055.c  ****  *   --------------   | -----------
6767:Src/bno055.c  ****  *      0x00          | BNO055_EULER_UNIT_DEG
6768:Src/bno055.c  ****  *      0x01          | BNO055_EULER_UNIT_RAD
6769:Src/bno055.c  ****  *
6770:Src/bno055.c  ****  *	@return results of bus communication function
6771:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6772:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6773:Src/bno055.c  ****  *
6774:Src/bno055.c  ****  *
6775:Src/bno055.c  ****  */
6776:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_euler_unit(
6777:Src/bno055.c  **** u8 *euler_unit_u8)
6778:Src/bno055.c  **** {
 7906              		.loc 1 6778 0
 7907              		.cfi_startproc
 7908              		@ args = 0, pretend = 0, frame = 8
 7909              		@ frame_needed = 0, uses_anonymous_args = 0
 7910              	.LVL920:
 7911 0000 30B5     		push	{r4, r5, lr}
 7912              	.LCFI338:
 7913              		.cfi_def_cfa_offset 12
 7914              		.cfi_offset 4, -12
 7915              		.cfi_offset 5, -8
 7916              		.cfi_offset 14, -4
6779:Src/bno055.c  **** 	/* Variable used to return value of
6780:Src/bno055.c  **** 	communication routine*/
6781:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6782:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6783:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6784:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6785:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 7917              		.loc 1 6785 0
 7918 0002 134C     		ldr	r4, .L892
6778:Src/bno055.c  **** 	/* Variable used to return value of
 7919              		.loc 1 6778 0
 7920 0004 83B0     		sub	sp, sp, #12
 7921              	.LCFI339:
 7922              		.cfi_def_cfa_offset 24
 7923              		.loc 1 6785 0
 7924 0006 2368     		ldr	r3, [r4]
6782:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 7925              		.loc 1 6782 0
 7926 0008 0022     		movs	r2, #0
 7927 000a 8DF80720 		strb	r2, [sp, #7]
 7928              	.LVL921:
 7929              		.loc 1 6785 0
 7930 000e E3B1     		cbz	r3, .L885
6786:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6787:Src/bno055.c  **** 		} else {
6788:Src/bno055.c  **** 		/*condition check for page, Euler unit is
6789:Src/bno055.c  **** 		available in the page zero*/
6790:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
ARM GAS  /tmp/ccVWLGiI.s 			page 267


 7931              		.loc 1 6790 0
 7932 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7933 0012 0546     		mov	r5, r0
 7934 0014 71B9     		cbnz	r1, .L891
 7935              	.LVL922:
 7936              	.L883:
6791:Src/bno055.c  **** 			/* Write the page zero*/
6792:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
6793:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6794:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6795:Src/bno055.c  **** 			/* Read the Euler unit */
6796:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 7937              		.loc 1 6796 0
 7938 0016 1C69     		ldr	r4, [r3, #16]
 7939 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 7940 001a 3B21     		movs	r1, #59
 7941 001c 0123     		movs	r3, #1
 7942 001e 0DF10702 		add	r2, sp, #7
 7943 0022 A047     		blx	r4
 7944              	.LVL923:
6797:Src/bno055.c  **** 			(p_bno055->dev_addr,
6798:Src/bno055.c  **** 			BNO055_EULER_UNIT_REG,
6799:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6800:Src/bno055.c  **** 			*euler_unit_u8 =
6801:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7945              		.loc 1 6801 0
 7946 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 7947 0028 C3F38003 		ubfx	r3, r3, #2, #1
6800:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 7948              		.loc 1 6800 0
 7949 002c 2B70     		strb	r3, [r5]
 7950              	.LVL924:
 7951              	.L882:
6802:Src/bno055.c  **** 			BNO055_EULER_UNIT);
6803:Src/bno055.c  **** 		} else {
6804:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6805:Src/bno055.c  **** 		}
6806:Src/bno055.c  **** 	}
6807:Src/bno055.c  **** 	return com_rslt;
6808:Src/bno055.c  **** }
 7952              		.loc 1 6808 0
 7953 002e 40B2     		sxtb	r0, r0
 7954 0030 03B0     		add	sp, sp, #12
 7955              	.LCFI340:
 7956              		.cfi_remember_state
 7957              		.cfi_def_cfa_offset 12
 7958              		@ sp needed
 7959 0032 30BD     		pop	{r4, r5, pc}
 7960              	.LVL925:
 7961              	.L891:
 7962              	.LCFI341:
 7963              		.cfi_restore_state
6792:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 7964              		.loc 1 6792 0
 7965 0034 1046     		mov	r0, r2
 7966              	.LVL926:
 7967 0036 FFF7FEFF 		bl	bno055_write_page_id
ARM GAS  /tmp/ccVWLGiI.s 			page 268


 7968              	.LVL927:
 7969 003a 2368     		ldr	r3, [r4]
6793:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7970              		.loc 1 6793 0
 7971 003c 0028     		cmp	r0, #0
 7972 003e EAD0     		beq	.L883
 7973              	.LVL928:
6793:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7974              		.loc 1 6793 0 is_stmt 0 discriminator 1
 7975 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
6804:Src/bno055.c  **** 		}
 7976              		.loc 1 6804 0 is_stmt 1 discriminator 1
 7977 0042 FF20     		movs	r0, #255
6793:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 7978              		.loc 1 6793 0 discriminator 1
 7979 0044 002A     		cmp	r2, #0
 7980 0046 F2D1     		bne	.L882
 7981 0048 E5E7     		b	.L883
 7982              	.LVL929:
 7983              	.L885:
6786:Src/bno055.c  **** 		} else {
 7984              		.loc 1 6786 0
 7985 004a 8120     		movs	r0, #129
 7986              	.LVL930:
 7987 004c EFE7     		b	.L882
 7988              	.L893:
 7989 004e 00BF     		.align	2
 7990              	.L892:
 7991 0050 00000000 		.word	.LANCHOR0
 7992              		.cfi_endproc
 7993              	.LFE137:
 7995              		.section	.text.bno055_get_tilt_unit,"ax",%progbits
 7996              		.align	2
 7997              		.global	bno055_get_tilt_unit
 7998              		.thumb
 7999              		.thumb_func
 8001              	bno055_get_tilt_unit:
 8002              	.LFB139:
6809:Src/bno055.c  **** /*!
6810:Src/bno055.c  ****  *	@brief This API used to write the Euler unit
6811:Src/bno055.c  ****  *	from register from 0x3B bit 2
6812:Src/bno055.c  ****  *
6813:Src/bno055.c  ****  *	@param euler_unit_u8 : The value of Euler unit
6814:Src/bno055.c  ****  *
6815:Src/bno055.c  ****  *    euler_unit_u8 | result
6816:Src/bno055.c  ****  *   --------------   | -----------
6817:Src/bno055.c  ****  *      0x00          | BNO055_EULER_UNIT_DEG
6818:Src/bno055.c  ****  *      0x01          | BNO055_EULER_UNIT_RAD
6819:Src/bno055.c  ****  *
6820:Src/bno055.c  ****  *	@return results of bus communication function
6821:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6822:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6823:Src/bno055.c  ****  *
6824:Src/bno055.c  ****  *
6825:Src/bno055.c  ****  */
6826:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_euler_unit(u8 euler_unit_u8)
6827:Src/bno055.c  **** {
ARM GAS  /tmp/ccVWLGiI.s 			page 269


6828:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6829:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
6830:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
6831:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
6832:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
6833:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
6834:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
6835:Src/bno055.c  **** 	} else {
6836:Src/bno055.c  **** 		/* The write operation effective only if the operation
6837:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
6838:Src/bno055.c  **** 		current operation mode and set the config mode */
6839:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
6840:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
6841:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6842:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
6843:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
6844:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
6845:Src/bno055.c  **** 				/* Write the Euler unit*/
6846:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
6847:Src/bno055.c  **** 				(p_bno055->dev_addr,
6848:Src/bno055.c  **** 				BNO055_EULER_UNIT_REG,
6849:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6850:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
6851:Src/bno055.c  **** 					data_u8r =
6852:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
6853:Src/bno055.c  **** 					BNO055_EULER_UNIT, euler_unit_u8);
6854:Src/bno055.c  **** 					com_rslt +=
6855:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
6856:Src/bno055.c  **** 					(p_bno055->dev_addr,
6857:Src/bno055.c  **** 					BNO055_EULER_UNIT_REG,
6858:Src/bno055.c  **** 					&data_u8r,
6859:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
6860:Src/bno055.c  **** 				}
6861:Src/bno055.c  **** 			} else {
6862:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
6863:Src/bno055.c  **** 			}
6864:Src/bno055.c  **** 		} else {
6865:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6866:Src/bno055.c  **** 		}
6867:Src/bno055.c  **** 	}
6868:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6869:Src/bno055.c  **** 		/* set the operation mode
6870:Src/bno055.c  **** 		of previous operation mode*/
6871:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
6872:Src/bno055.c  **** 		(prev_opmode_u8);
6873:Src/bno055.c  **** 	return com_rslt;
6874:Src/bno055.c  **** }
6875:Src/bno055.c  **** /*!
6876:Src/bno055.c  ****  *	@brief This API used to write the tilt unit
6877:Src/bno055.c  ****  *	from register from 0x3B bit 3
6878:Src/bno055.c  ****  *
6879:Src/bno055.c  ****  *	@param tilt_unit_u8 : The value of tilt unit
6880:Src/bno055.c  ****  *
6881:Src/bno055.c  ****  *    tilt_unit_u8  | result
6882:Src/bno055.c  ****  *   ---------------  | ---------
6883:Src/bno055.c  ****  *     0x00           | degrees
6884:Src/bno055.c  ****  *     0x01           | radians
ARM GAS  /tmp/ccVWLGiI.s 			page 270


6885:Src/bno055.c  ****  *
6886:Src/bno055.c  ****  *	@return results of bus communication function
6887:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6888:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6889:Src/bno055.c  ****  *
6890:Src/bno055.c  ****  *
6891:Src/bno055.c  ****  */
6892:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_tilt_unit(
6893:Src/bno055.c  **** u8 *tilt_unit_u8)
6894:Src/bno055.c  **** {
 8003              		.loc 1 6894 0
 8004              		.cfi_startproc
 8005              		@ args = 0, pretend = 0, frame = 8
 8006              		@ frame_needed = 0, uses_anonymous_args = 0
 8007              	.LVL931:
 8008 0000 30B5     		push	{r4, r5, lr}
 8009              	.LCFI342:
 8010              		.cfi_def_cfa_offset 12
 8011              		.cfi_offset 4, -12
 8012              		.cfi_offset 5, -8
 8013              		.cfi_offset 14, -4
6895:Src/bno055.c  **** 	/* Variable used to return value of
6896:Src/bno055.c  **** 	communication routine*/
6897:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6898:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
6899:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
6900:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
6901:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 8014              		.loc 1 6901 0
 8015 0002 134C     		ldr	r4, .L905
6894:Src/bno055.c  **** 	/* Variable used to return value of
 8016              		.loc 1 6894 0
 8017 0004 83B0     		sub	sp, sp, #12
 8018              	.LCFI343:
 8019              		.cfi_def_cfa_offset 24
 8020              		.loc 1 6901 0
 8021 0006 2368     		ldr	r3, [r4]
6898:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 8022              		.loc 1 6898 0
 8023 0008 0022     		movs	r2, #0
 8024 000a 8DF80720 		strb	r2, [sp, #7]
 8025              	.LVL932:
 8026              		.loc 1 6901 0
 8027 000e E3B1     		cbz	r3, .L898
6902:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
6903:Src/bno055.c  **** 		} else {
6904:Src/bno055.c  **** 		/*condition check for page, chip id is
6905:Src/bno055.c  **** 		available in the page zero*/
6906:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 8028              		.loc 1 6906 0
 8029 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 8030 0012 0546     		mov	r5, r0
 8031 0014 71B9     		cbnz	r1, .L904
 8032              	.LVL933:
 8033              	.L896:
6907:Src/bno055.c  **** 			/* Write the page zero*/
6908:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
ARM GAS  /tmp/ccVWLGiI.s 			page 271


6909:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
6910:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
6911:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 8034              		.loc 1 6911 0
 8035 0016 1C69     		ldr	r4, [r3, #16]
 8036 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8037 001a 3B21     		movs	r1, #59
 8038 001c 0123     		movs	r3, #1
 8039 001e 0DF10702 		add	r2, sp, #7
 8040 0022 A047     		blx	r4
 8041              	.LVL934:
6912:Src/bno055.c  **** 			(p_bno055->dev_addr,
6913:Src/bno055.c  **** 			BNO055_TILT_UNIT_REG,
6914:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6915:Src/bno055.c  **** 			*tilt_unit_u8 =
6916:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_TILT_UNIT);
 8042              		.loc 1 6916 0
 8043 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 8044 0028 C3F3C003 		ubfx	r3, r3, #3, #1
6915:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_TILT_UNIT);
 8045              		.loc 1 6915 0
 8046 002c 2B70     		strb	r3, [r5]
 8047              	.LVL935:
 8048              	.L895:
6917:Src/bno055.c  **** 		} else {
6918:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6919:Src/bno055.c  **** 		}
6920:Src/bno055.c  **** 	}
6921:Src/bno055.c  **** 	return com_rslt;
6922:Src/bno055.c  **** }
 8049              		.loc 1 6922 0
 8050 002e 40B2     		sxtb	r0, r0
 8051 0030 03B0     		add	sp, sp, #12
 8052              	.LCFI344:
 8053              		.cfi_remember_state
 8054              		.cfi_def_cfa_offset 12
 8055              		@ sp needed
 8056 0032 30BD     		pop	{r4, r5, pc}
 8057              	.LVL936:
 8058              	.L904:
 8059              	.LCFI345:
 8060              		.cfi_restore_state
6908:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 8061              		.loc 1 6908 0
 8062 0034 1046     		mov	r0, r2
 8063              	.LVL937:
 8064 0036 FFF7FEFF 		bl	bno055_write_page_id
 8065              	.LVL938:
 8066 003a 2368     		ldr	r3, [r4]
6909:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8067              		.loc 1 6909 0
 8068 003c 0028     		cmp	r0, #0
 8069 003e EAD0     		beq	.L896
 8070              	.LVL939:
6909:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8071              		.loc 1 6909 0 is_stmt 0 discriminator 1
 8072 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 272


6918:Src/bno055.c  **** 		}
 8073              		.loc 1 6918 0 is_stmt 1 discriminator 1
 8074 0042 FF20     		movs	r0, #255
6909:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8075              		.loc 1 6909 0 discriminator 1
 8076 0044 002A     		cmp	r2, #0
 8077 0046 F2D1     		bne	.L895
 8078 0048 E5E7     		b	.L896
 8079              	.LVL940:
 8080              	.L898:
6902:Src/bno055.c  **** 		} else {
 8081              		.loc 1 6902 0
 8082 004a 8120     		movs	r0, #129
 8083              	.LVL941:
 8084 004c EFE7     		b	.L895
 8085              	.L906:
 8086 004e 00BF     		.align	2
 8087              	.L905:
 8088 0050 00000000 		.word	.LANCHOR0
 8089              		.cfi_endproc
 8090              	.LFE139:
 8092              		.section	.text.bno055_get_temp_unit,"ax",%progbits
 8093              		.align	2
 8094              		.global	bno055_get_temp_unit
 8095              		.thumb
 8096              		.thumb_func
 8098              	bno055_get_temp_unit:
 8099              	.LFB141:
6923:Src/bno055.c  **** /*!
6924:Src/bno055.c  ****  *	@brief This API used to write the tilt unit
6925:Src/bno055.c  ****  *	from register from 0x3B bit 3
6926:Src/bno055.c  ****  *
6927:Src/bno055.c  ****  *	@param tilt_unit_u8 : The value of tilt unit
6928:Src/bno055.c  ****  *
6929:Src/bno055.c  ****  *    tilt_unit_u8  | result
6930:Src/bno055.c  ****  *   ---------------  | ---------
6931:Src/bno055.c  ****  *     0x00           | degrees
6932:Src/bno055.c  ****  *     0x01           | radians
6933:Src/bno055.c  ****  *
6934:Src/bno055.c  ****  *	@return results of bus communication function
6935:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
6936:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
6937:Src/bno055.c  ****  *
6938:Src/bno055.c  ****  *
6939:Src/bno055.c  ****  *
6940:Src/bno055.c  ****  *  \return Communication results
6941:Src/bno055.c  ****  *
6942:Src/bno055.c  ****  *
6943:Src/bno055.c  ****  */
6944:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_tilt_unit(u8 tilt_unit_u8)
6945:Src/bno055.c  **** {
6946:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
6947:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
6948:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
6949:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
6950:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
6951:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
ARM GAS  /tmp/ccVWLGiI.s 			page 273


6952:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
6953:Src/bno055.c  **** 	} else {
6954:Src/bno055.c  **** 		/* The write operation effective only if the operation
6955:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
6956:Src/bno055.c  **** 		current operation mode and set the config mode */
6957:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
6958:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
6959:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6960:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
6961:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
6962:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
6963:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
6964:Src/bno055.c  **** 				(p_bno055->dev_addr,
6965:Src/bno055.c  **** 				BNO055_TILT_UNIT_REG,
6966:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
6967:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
6968:Src/bno055.c  **** 					data_u8r =
6969:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
6970:Src/bno055.c  **** 					BNO055_TILT_UNIT, tilt_unit_u8);
6971:Src/bno055.c  **** 					com_rslt +=
6972:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
6973:Src/bno055.c  **** 					(p_bno055->dev_addr,
6974:Src/bno055.c  **** 					BNO055_TILT_UNIT_REG,
6975:Src/bno055.c  **** 					&data_u8r,
6976:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
6977:Src/bno055.c  **** 				}
6978:Src/bno055.c  **** 			} else {
6979:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
6980:Src/bno055.c  **** 			}
6981:Src/bno055.c  **** 		} else {
6982:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
6983:Src/bno055.c  **** 		}
6984:Src/bno055.c  **** 	}
6985:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
6986:Src/bno055.c  **** 		/* set the operation mode
6987:Src/bno055.c  **** 		of previous operation mode*/
6988:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
6989:Src/bno055.c  **** 		(prev_opmode_u8);
6990:Src/bno055.c  **** 	return com_rslt;
6991:Src/bno055.c  **** }
6992:Src/bno055.c  **** /*!
6993:Src/bno055.c  ****  *	@brief This API used to read the temperature unit
6994:Src/bno055.c  ****  *	from register from 0x3B bit 4
6995:Src/bno055.c  ****  *
6996:Src/bno055.c  ****  *	@param temp_unit_u8 : The value of temperature unit
6997:Src/bno055.c  ****  *
6998:Src/bno055.c  ****  *    temp_unit_u8  |  result
6999:Src/bno055.c  ****  *   -----------      | --------------
7000:Src/bno055.c  ****  *      0x00          | BNO055_TEMP_UNIT_CELSIUS
7001:Src/bno055.c  ****  *      0x01          | BNO055_TEMP_UNIT_FAHRENHEIT
7002:Src/bno055.c  ****  *
7003:Src/bno055.c  ****  *	@return results of bus communication function
7004:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7005:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7006:Src/bno055.c  ****  *
7007:Src/bno055.c  ****  */
7008:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_temp_unit(
ARM GAS  /tmp/ccVWLGiI.s 			page 274


7009:Src/bno055.c  **** u8 *temp_unit_u8)
7010:Src/bno055.c  **** {
 8100              		.loc 1 7010 0
 8101              		.cfi_startproc
 8102              		@ args = 0, pretend = 0, frame = 8
 8103              		@ frame_needed = 0, uses_anonymous_args = 0
 8104              	.LVL942:
 8105 0000 30B5     		push	{r4, r5, lr}
 8106              	.LCFI346:
 8107              		.cfi_def_cfa_offset 12
 8108              		.cfi_offset 4, -12
 8109              		.cfi_offset 5, -8
 8110              		.cfi_offset 14, -4
7011:Src/bno055.c  **** 	/* Variable used to return value of
7012:Src/bno055.c  **** 	communication routine*/
7013:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7014:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7015:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7016:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7017:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 8111              		.loc 1 7017 0
 8112 0002 134C     		ldr	r4, .L918
7010:Src/bno055.c  **** 	/* Variable used to return value of
 8113              		.loc 1 7010 0
 8114 0004 83B0     		sub	sp, sp, #12
 8115              	.LCFI347:
 8116              		.cfi_def_cfa_offset 24
 8117              		.loc 1 7017 0
 8118 0006 2368     		ldr	r3, [r4]
7014:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 8119              		.loc 1 7014 0
 8120 0008 0022     		movs	r2, #0
 8121 000a 8DF80720 		strb	r2, [sp, #7]
 8122              	.LVL943:
 8123              		.loc 1 7017 0
 8124 000e E3B1     		cbz	r3, .L911
7018:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7019:Src/bno055.c  **** 		} else {
7020:Src/bno055.c  **** 		/*condition check for page, temperature unit is
7021:Src/bno055.c  **** 		available in the page zero*/
7022:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 8125              		.loc 1 7022 0
 8126 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 8127 0012 0546     		mov	r5, r0
 8128 0014 71B9     		cbnz	r1, .L917
 8129              	.LVL944:
 8130              	.L909:
7023:Src/bno055.c  **** 			/* Write the page zero*/
7024:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7025:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7026:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7027:Src/bno055.c  **** 			/* Read the temperature unit */
7028:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 8131              		.loc 1 7028 0
 8132 0016 1C69     		ldr	r4, [r3, #16]
 8133 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8134 001a 3B21     		movs	r1, #59
ARM GAS  /tmp/ccVWLGiI.s 			page 275


 8135 001c 0123     		movs	r3, #1
 8136 001e 0DF10702 		add	r2, sp, #7
 8137 0022 A047     		blx	r4
 8138              	.LVL945:
7029:Src/bno055.c  **** 			(p_bno055->dev_addr,
7030:Src/bno055.c  **** 			BNO055_TEMP_UNIT_REG,
7031:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7032:Src/bno055.c  **** 			*temp_unit_u8 =
7033:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 8139              		.loc 1 7033 0
 8140 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 8141 0028 C3F30013 		ubfx	r3, r3, #4, #1
7032:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 8142              		.loc 1 7032 0
 8143 002c 2B70     		strb	r3, [r5]
 8144              	.LVL946:
 8145              	.L908:
7034:Src/bno055.c  **** 			BNO055_TEMP_UNIT);
7035:Src/bno055.c  **** 		} else {
7036:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7037:Src/bno055.c  **** 		}
7038:Src/bno055.c  **** 	}
7039:Src/bno055.c  **** 	return com_rslt;
7040:Src/bno055.c  **** }
 8146              		.loc 1 7040 0
 8147 002e 40B2     		sxtb	r0, r0
 8148 0030 03B0     		add	sp, sp, #12
 8149              	.LCFI348:
 8150              		.cfi_remember_state
 8151              		.cfi_def_cfa_offset 12
 8152              		@ sp needed
 8153 0032 30BD     		pop	{r4, r5, pc}
 8154              	.LVL947:
 8155              	.L917:
 8156              	.LCFI349:
 8157              		.cfi_restore_state
7024:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 8158              		.loc 1 7024 0
 8159 0034 1046     		mov	r0, r2
 8160              	.LVL948:
 8161 0036 FFF7FEFF 		bl	bno055_write_page_id
 8162              	.LVL949:
 8163 003a 2368     		ldr	r3, [r4]
7025:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8164              		.loc 1 7025 0
 8165 003c 0028     		cmp	r0, #0
 8166 003e EAD0     		beq	.L909
 8167              	.LVL950:
7025:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8168              		.loc 1 7025 0 is_stmt 0 discriminator 1
 8169 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7036:Src/bno055.c  **** 		}
 8170              		.loc 1 7036 0 is_stmt 1 discriminator 1
 8171 0042 FF20     		movs	r0, #255
7025:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8172              		.loc 1 7025 0 discriminator 1
 8173 0044 002A     		cmp	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 276


 8174 0046 F2D1     		bne	.L908
 8175 0048 E5E7     		b	.L909
 8176              	.LVL951:
 8177              	.L911:
7018:Src/bno055.c  **** 		} else {
 8178              		.loc 1 7018 0
 8179 004a 8120     		movs	r0, #129
 8180              	.LVL952:
 8181 004c EFE7     		b	.L908
 8182              	.L919:
 8183 004e 00BF     		.align	2
 8184              	.L918:
 8185 0050 00000000 		.word	.LANCHOR0
 8186              		.cfi_endproc
 8187              	.LFE141:
 8189              		.section	.text.bno055_get_data_output_format,"ax",%progbits
 8190              		.align	2
 8191              		.global	bno055_get_data_output_format
 8192              		.thumb
 8193              		.thumb_func
 8195              	bno055_get_data_output_format:
 8196              	.LFB143:
7041:Src/bno055.c  **** /*!
7042:Src/bno055.c  ****  *	@brief This API used to write the temperature unit
7043:Src/bno055.c  ****  *	from register from 0x3B bit 4
7044:Src/bno055.c  ****  *
7045:Src/bno055.c  ****  *	@param temp_unit_u8 : The value of temperature unit
7046:Src/bno055.c  ****  *
7047:Src/bno055.c  ****  *    temp_unit_u8  |  result
7048:Src/bno055.c  ****  *   -----------      | --------------
7049:Src/bno055.c  ****  *      0x00          | BNO055_TEMP_UNIT_CELSIUS
7050:Src/bno055.c  ****  *      0x01          | BNO055_TEMP_UNIT_FAHRENHEIT
7051:Src/bno055.c  ****  *
7052:Src/bno055.c  ****  *	@return results of bus communication function
7053:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7054:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7055:Src/bno055.c  ****  *
7056:Src/bno055.c  ****  *
7057:Src/bno055.c  ****  */
7058:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_temp_unit(
7059:Src/bno055.c  **** u8 temp_unit_u8)
7060:Src/bno055.c  **** {
7061:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7062:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
7063:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
7064:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
7065:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
7066:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
7067:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
7068:Src/bno055.c  **** 	} else {
7069:Src/bno055.c  **** 		/* The write operation effective only if the operation
7070:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
7071:Src/bno055.c  **** 		current operation mode and set the config mode */
7072:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
7073:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
7074:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
7075:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
ARM GAS  /tmp/ccVWLGiI.s 			page 277


7076:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
7077:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
7078:Src/bno055.c  **** 				/* Write the temperature unit */
7079:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
7080:Src/bno055.c  **** 				(p_bno055->dev_addr,
7081:Src/bno055.c  **** 				BNO055_TEMP_UNIT_REG,
7082:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7083:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
7084:Src/bno055.c  **** 					data_u8r =
7085:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
7086:Src/bno055.c  **** 					BNO055_TEMP_UNIT,
7087:Src/bno055.c  **** 					temp_unit_u8);
7088:Src/bno055.c  **** 					com_rslt +=
7089:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
7090:Src/bno055.c  **** 					(p_bno055->dev_addr,
7091:Src/bno055.c  **** 					BNO055_TEMP_UNIT_REG,
7092:Src/bno055.c  **** 					&data_u8r,
7093:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7094:Src/bno055.c  **** 				}
7095:Src/bno055.c  **** 			} else {
7096:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
7097:Src/bno055.c  **** 			}
7098:Src/bno055.c  **** 		} else {
7099:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7100:Src/bno055.c  **** 		}
7101:Src/bno055.c  **** 	}
7102:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
7103:Src/bno055.c  **** 		/* set the operation mode
7104:Src/bno055.c  **** 		of previous operation mode*/
7105:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
7106:Src/bno055.c  **** 		(prev_opmode_u8);
7107:Src/bno055.c  **** 	return com_rslt;
7108:Src/bno055.c  **** }
7109:Src/bno055.c  **** /*!
7110:Src/bno055.c  ****  *	@brief This API used to read the current selected orientation mode
7111:Src/bno055.c  ****  *	from register from 0x3B bit 7
7112:Src/bno055.c  ****  *
7113:Src/bno055.c  ****  *	@param data_output_format_u8 : The value of data output format
7114:Src/bno055.c  ****  *
7115:Src/bno055.c  ****  *	  data_output_format_u8  | result
7116:Src/bno055.c  ****  *   --------------------      | --------
7117:Src/bno055.c  ****  *    0x00                     | Windows
7118:Src/bno055.c  ****  *    0x01                     | Android
7119:Src/bno055.c  ****  *
7120:Src/bno055.c  ****  *	@return results of bus communication function
7121:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7122:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7123:Src/bno055.c  ****  *
7124:Src/bno055.c  ****  */
7125:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_data_output_format(
7126:Src/bno055.c  **** u8 *data_output_format_u8)
7127:Src/bno055.c  **** {
 8197              		.loc 1 7127 0
 8198              		.cfi_startproc
 8199              		@ args = 0, pretend = 0, frame = 8
 8200              		@ frame_needed = 0, uses_anonymous_args = 0
 8201              	.LVL953:
ARM GAS  /tmp/ccVWLGiI.s 			page 278


 8202 0000 30B5     		push	{r4, r5, lr}
 8203              	.LCFI350:
 8204              		.cfi_def_cfa_offset 12
 8205              		.cfi_offset 4, -12
 8206              		.cfi_offset 5, -8
 8207              		.cfi_offset 14, -4
7128:Src/bno055.c  **** 	/* Variable used to return value of
7129:Src/bno055.c  **** 	communication routine*/
7130:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7131:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7132:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7133:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7134:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 8208              		.loc 1 7134 0
 8209 0002 124C     		ldr	r4, .L931
7127:Src/bno055.c  **** 	/* Variable used to return value of
 8210              		.loc 1 7127 0
 8211 0004 83B0     		sub	sp, sp, #12
 8212              	.LCFI351:
 8213              		.cfi_def_cfa_offset 24
 8214              		.loc 1 7134 0
 8215 0006 2368     		ldr	r3, [r4]
7131:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 8216              		.loc 1 7131 0
 8217 0008 0022     		movs	r2, #0
 8218 000a 8DF80720 		strb	r2, [sp, #7]
 8219              	.LVL954:
 8220              		.loc 1 7134 0
 8221 000e DBB1     		cbz	r3, .L924
7135:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7136:Src/bno055.c  **** 		} else {
7137:Src/bno055.c  **** 		/*condition check for page, data output format is
7138:Src/bno055.c  **** 		available in the page zero*/
7139:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 8222              		.loc 1 7139 0
 8223 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 8224 0012 0546     		mov	r5, r0
 8225 0014 69B9     		cbnz	r1, .L930
 8226              	.LVL955:
 8227              	.L922:
7140:Src/bno055.c  **** 			/* Write the page zero*/
7141:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7142:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7143:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7144:Src/bno055.c  **** 			/* Read the data output format */
7145:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 8228              		.loc 1 7145 0
 8229 0016 1C69     		ldr	r4, [r3, #16]
 8230 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8231 001a 3B21     		movs	r1, #59
 8232 001c 0123     		movs	r3, #1
 8233 001e 0DF10702 		add	r2, sp, #7
 8234 0022 A047     		blx	r4
 8235              	.LVL956:
7146:Src/bno055.c  **** 			(p_bno055->dev_addr,
7147:Src/bno055.c  **** 			BNO055_DATA_OUTPUT_FORMAT_REG,
7148:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 279


7149:Src/bno055.c  **** 			*data_output_format_u8 =
7150:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 8236              		.loc 1 7150 0
 8237 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 8238 0028 DB09     		lsrs	r3, r3, #7
7149:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 8239              		.loc 1 7149 0
 8240 002a 2B70     		strb	r3, [r5]
 8241              	.LVL957:
 8242              	.L921:
7151:Src/bno055.c  **** 			BNO055_DATA_OUTPUT_FORMAT);
7152:Src/bno055.c  **** 		} else {
7153:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7154:Src/bno055.c  **** 		}
7155:Src/bno055.c  **** 	}
7156:Src/bno055.c  **** 	return com_rslt;
7157:Src/bno055.c  **** }
 8243              		.loc 1 7157 0
 8244 002c 40B2     		sxtb	r0, r0
 8245 002e 03B0     		add	sp, sp, #12
 8246              	.LCFI352:
 8247              		.cfi_remember_state
 8248              		.cfi_def_cfa_offset 12
 8249              		@ sp needed
 8250 0030 30BD     		pop	{r4, r5, pc}
 8251              	.LVL958:
 8252              	.L930:
 8253              	.LCFI353:
 8254              		.cfi_restore_state
7141:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 8255              		.loc 1 7141 0
 8256 0032 1046     		mov	r0, r2
 8257              	.LVL959:
 8258 0034 FFF7FEFF 		bl	bno055_write_page_id
 8259              	.LVL960:
 8260 0038 2368     		ldr	r3, [r4]
7142:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8261              		.loc 1 7142 0
 8262 003a 0028     		cmp	r0, #0
 8263 003c EBD0     		beq	.L922
 8264              	.LVL961:
7142:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8265              		.loc 1 7142 0 is_stmt 0 discriminator 1
 8266 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7153:Src/bno055.c  **** 		}
 8267              		.loc 1 7153 0 is_stmt 1 discriminator 1
 8268 0040 FF20     		movs	r0, #255
7142:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8269              		.loc 1 7142 0 discriminator 1
 8270 0042 002A     		cmp	r2, #0
 8271 0044 F2D1     		bne	.L921
 8272 0046 E6E7     		b	.L922
 8273              	.LVL962:
 8274              	.L924:
7135:Src/bno055.c  **** 		} else {
 8275              		.loc 1 7135 0
 8276 0048 8120     		movs	r0, #129
ARM GAS  /tmp/ccVWLGiI.s 			page 280


 8277              	.LVL963:
 8278 004a EFE7     		b	.L921
 8279              	.L932:
 8280              		.align	2
 8281              	.L931:
 8282 004c 00000000 		.word	.LANCHOR0
 8283              		.cfi_endproc
 8284              	.LFE143:
 8286              		.section	.text.bno055_get_operation_mode,"ax",%progbits
 8287              		.align	2
 8288              		.global	bno055_get_operation_mode
 8289              		.thumb
 8290              		.thumb_func
 8292              	bno055_get_operation_mode:
 8293              	.LFB145:
7158:Src/bno055.c  **** /*!
7159:Src/bno055.c  ****  *	@brief This API used to write the current selected orientation mode
7160:Src/bno055.c  ****  *	from register from 0x3B bit 7
7161:Src/bno055.c  ****  *
7162:Src/bno055.c  ****  *	@param data_output_format_u8 : The value of data output format
7163:Src/bno055.c  ****  *
7164:Src/bno055.c  ****  *	  data_output_format_u8  | result
7165:Src/bno055.c  ****  *   --------------------      | --------
7166:Src/bno055.c  ****  *    0x00                     | Windows
7167:Src/bno055.c  ****  *    0x01                     | Android
7168:Src/bno055.c  ****  *
7169:Src/bno055.c  ****  *	@return results of bus communication function
7170:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7171:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7172:Src/bno055.c  ****  *
7173:Src/bno055.c  ****  *
7174:Src/bno055.c  ****  */
7175:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_data_output_format(
7176:Src/bno055.c  **** u8 data_output_format_u8)
7177:Src/bno055.c  **** {
7178:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7179:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
7180:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
7181:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
7182:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
7183:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
7184:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
7185:Src/bno055.c  **** 	} else {
7186:Src/bno055.c  **** 		/* The write operation effective only if the operation
7187:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
7188:Src/bno055.c  **** 		current operation mode and set the config mode */
7189:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
7190:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
7191:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
7192:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
7193:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
7194:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
7195:Src/bno055.c  **** 				/* Write the data output format */
7196:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
7197:Src/bno055.c  **** 				(p_bno055->dev_addr,
7198:Src/bno055.c  **** 				BNO055_DATA_OUTPUT_FORMAT_REG,
7199:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 281


7200:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
7201:Src/bno055.c  **** 					data_u8r =
7202:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
7203:Src/bno055.c  **** 					BNO055_DATA_OUTPUT_FORMAT,
7204:Src/bno055.c  **** 					data_output_format_u8);
7205:Src/bno055.c  **** 					com_rslt +=
7206:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
7207:Src/bno055.c  **** 					(p_bno055->dev_addr,
7208:Src/bno055.c  **** 					BNO055_DATA_OUTPUT_FORMAT_REG,
7209:Src/bno055.c  **** 					&data_u8r,
7210:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7211:Src/bno055.c  **** 				}
7212:Src/bno055.c  **** 			} else {
7213:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
7214:Src/bno055.c  **** 			}
7215:Src/bno055.c  **** 		} else {
7216:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7217:Src/bno055.c  **** 		}
7218:Src/bno055.c  **** 	}
7219:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
7220:Src/bno055.c  **** 		/* set the operation mode
7221:Src/bno055.c  **** 		of previous operation mode*/
7222:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
7223:Src/bno055.c  **** 		(prev_opmode_u8);
7224:Src/bno055.c  **** 	return com_rslt;
7225:Src/bno055.c  **** }
7226:Src/bno055.c  **** /*!	@brief This API used to read the operation mode
7227:Src/bno055.c  ****  *	from register from 0x3D bit 0 to 3
7228:Src/bno055.c  ****  *
7229:Src/bno055.c  ****  *	@param operation_mode_u8 : The value of operation mode
7230:Src/bno055.c  ****  *
7231:Src/bno055.c  ****  * operation_mode_u8 |      result      | comments
7232:Src/bno055.c  ****  * ----------|----------------------------|----------------------------
7233:Src/bno055.c  ****  *  0x00     | BNO055_OPERATION_MODE_CONFIG      | Configuration mode
7234:Src/bno055.c  ****  *  0x01     | BNO055_OPERATION_MODE_ACCONLY     | Reads accel data alone
7235:Src/bno055.c  ****  *  0x02     | BNO055_OPERATION_MODE_MAGONLY     | Reads mag data alone
7236:Src/bno055.c  ****  *  0x03     | BNO055_OPERATION_MODE_GYRONLY     | Reads gyro data alone
7237:Src/bno055.c  ****  *  0x04     | BNO055_OPERATION_MODE_ACCMAG      | Reads accel and mag data
7238:Src/bno055.c  ****  *  0x05     | BNO055_OPERATION_MODE_ACCGYRO     | Reads accel and gyro data
7239:Src/bno055.c  ****  *  0x06     | BNO055_OPERATION_MODE_MAGGYRO     | Reads accel and mag data
7240:Src/bno055.c  ****  *  0x07     | OPERATION_MODE_ANY_MOTION  | Reads accel mag and gyro data
7241:Src/bno055.c  ****  *  0x08     | BNO055_OPERATION_MODE_IMUPLUS     | Inertial measurement unit
7242:Src/bno055.c  ****  *   -       |       -                    | Reads accel,gyro and fusion data
7243:Src/bno055.c  ****  *  0x09     | BNO055_OPERATION_MODE_COMPASS     | Reads accel, mag data
7244:Src/bno055.c  ****  *   -       |       -                    | and fusion data
7245:Src/bno055.c  ****  *  0x0A     | BNO055_OPERATION_MODE_M4G         | Reads accel, mag data
7246:Src/bno055.c  ****  *    -      |       -                    | and fusion data
7247:Src/bno055.c  ****  *  0x0B     | BNO055_OPERATION_MODE_NDOF_FMC_OFF| Nine degrees of freedom with
7248:Src/bno055.c  ****  *   -       |       -                    | fast magnetic calibration
7249:Src/bno055.c  ****  *   -       |       -                    | Reads accel,mag, gyro
7250:Src/bno055.c  ****  *   -       |       -                    | and fusion data
7251:Src/bno055.c  ****  *  0x0C     | BNO055_OPERATION_MODE_NDOF        | Nine degrees of freedom
7252:Src/bno055.c  ****  *   -       |       -                    | Reads accel,mag, gyro
7253:Src/bno055.c  ****  *   -       |       -                    | and fusion data
7254:Src/bno055.c  ****  *
7255:Src/bno055.c  ****  *	@return results of bus communication function
7256:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
ARM GAS  /tmp/ccVWLGiI.s 			page 282


7257:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7258:Src/bno055.c  ****  *
7259:Src/bno055.c  ****  *	@note In the config mode, all sensor and fusion data
7260:Src/bno055.c  ****  *	becomes zero and it is mainly derived
7261:Src/bno055.c  ****  *	to configure the various settings of the BNO
7262:Src/bno055.c  ****  *
7263:Src/bno055.c  ****  */
7264:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_operation_mode(
7265:Src/bno055.c  **** u8 *operation_mode_u8)
7266:Src/bno055.c  **** {
 8294              		.loc 1 7266 0
 8295              		.cfi_startproc
 8296              		@ args = 0, pretend = 0, frame = 8
 8297              		@ frame_needed = 0, uses_anonymous_args = 0
 8298              	.LVL964:
 8299 0000 30B5     		push	{r4, r5, lr}
 8300              	.LCFI354:
 8301              		.cfi_def_cfa_offset 12
 8302              		.cfi_offset 4, -12
 8303              		.cfi_offset 5, -8
 8304              		.cfi_offset 14, -4
7267:Src/bno055.c  **** 	/* Variable used to return value of
7268:Src/bno055.c  **** 	communication routine*/
7269:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7270:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7271:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7272:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7273:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 8305              		.loc 1 7273 0
 8306 0002 134C     		ldr	r4, .L944
7266:Src/bno055.c  **** 	/* Variable used to return value of
 8307              		.loc 1 7266 0
 8308 0004 83B0     		sub	sp, sp, #12
 8309              	.LCFI355:
 8310              		.cfi_def_cfa_offset 24
 8311              		.loc 1 7273 0
 8312 0006 2368     		ldr	r3, [r4]
7270:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 8313              		.loc 1 7270 0
 8314 0008 0022     		movs	r2, #0
 8315 000a 8DF80720 		strb	r2, [sp, #7]
 8316              	.LVL965:
 8317              		.loc 1 7273 0
 8318 000e E3B1     		cbz	r3, .L937
7274:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7275:Src/bno055.c  **** 		} else {
7276:Src/bno055.c  **** 		/*condition check for page, operation mode is
7277:Src/bno055.c  **** 		available in the page zero*/
7278:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 8319              		.loc 1 7278 0
 8320 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 8321 0012 0546     		mov	r5, r0
 8322 0014 71B9     		cbnz	r1, .L943
 8323              	.LVL966:
 8324              	.L935:
7279:Src/bno055.c  **** 			/* Write the page zero*/
7280:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
ARM GAS  /tmp/ccVWLGiI.s 			page 283


7281:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7282:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7283:Src/bno055.c  **** 			/* Read the value of operation mode*/
7284:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 8325              		.loc 1 7284 0
 8326 0016 1C69     		ldr	r4, [r3, #16]
 8327 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8328 001a 3D21     		movs	r1, #61
 8329 001c 0123     		movs	r3, #1
 8330 001e 0DF10702 		add	r2, sp, #7
 8331 0022 A047     		blx	r4
 8332              	.LVL967:
7285:Src/bno055.c  **** 			(p_bno055->dev_addr,
7286:Src/bno055.c  **** 			BNO055_OPERATION_MODE_REG,
7287:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7288:Src/bno055.c  **** 			*operation_mode_u8 =
 8333              		.loc 1 7288 0
 8334 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 8335 0028 03F00F03 		and	r3, r3, #15
 8336 002c 2B70     		strb	r3, [r5]
 8337              	.LVL968:
 8338              	.L934:
7289:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
7290:Src/bno055.c  **** 			BNO055_OPERATION_MODE);
7291:Src/bno055.c  **** 		} else {
7292:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7293:Src/bno055.c  **** 		}
7294:Src/bno055.c  **** 	}
7295:Src/bno055.c  **** 	return com_rslt;
7296:Src/bno055.c  **** }
 8339              		.loc 1 7296 0
 8340 002e 40B2     		sxtb	r0, r0
 8341 0030 03B0     		add	sp, sp, #12
 8342              	.LCFI356:
 8343              		.cfi_remember_state
 8344              		.cfi_def_cfa_offset 12
 8345              		@ sp needed
 8346 0032 30BD     		pop	{r4, r5, pc}
 8347              	.LVL969:
 8348              	.L943:
 8349              	.LCFI357:
 8350              		.cfi_restore_state
7280:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 8351              		.loc 1 7280 0
 8352 0034 1046     		mov	r0, r2
 8353              	.LVL970:
 8354 0036 FFF7FEFF 		bl	bno055_write_page_id
 8355              	.LVL971:
 8356 003a 2368     		ldr	r3, [r4]
7281:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8357              		.loc 1 7281 0
 8358 003c 0028     		cmp	r0, #0
 8359 003e EAD0     		beq	.L935
 8360              	.LVL972:
7281:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8361              		.loc 1 7281 0 is_stmt 0 discriminator 1
 8362 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 284


7292:Src/bno055.c  **** 		}
 8363              		.loc 1 7292 0 is_stmt 1 discriminator 1
 8364 0042 FF20     		movs	r0, #255
7281:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 8365              		.loc 1 7281 0 discriminator 1
 8366 0044 002A     		cmp	r2, #0
 8367 0046 F2D1     		bne	.L934
 8368 0048 E5E7     		b	.L935
 8369              	.LVL973:
 8370              	.L937:
7274:Src/bno055.c  **** 		} else {
 8371              		.loc 1 7274 0
 8372 004a 8120     		movs	r0, #129
 8373              	.LVL974:
 8374 004c EFE7     		b	.L934
 8375              	.L945:
 8376 004e 00BF     		.align	2
 8377              	.L944:
 8378 0050 00000000 		.word	.LANCHOR0
 8379              		.cfi_endproc
 8380              	.LFE145:
 8382              		.section	.text.bno055_set_operation_mode,"ax",%progbits
 8383              		.align	2
 8384              		.global	bno055_set_operation_mode
 8385              		.thumb
 8386              		.thumb_func
 8388              	bno055_set_operation_mode:
 8389              	.LFB146:
7297:Src/bno055.c  **** /*!	@brief This API used to write the operation mode
7298:Src/bno055.c  ****  *	from register from 0x3D bit 0 to 3
7299:Src/bno055.c  ****  *
7300:Src/bno055.c  ****  *	@param operation_mode_u8 : The value of operation mode
7301:Src/bno055.c  ****  *
7302:Src/bno055.c  ****  *  operation_mode_u8  |      result            | comments
7303:Src/bno055.c  ****  * ---------|-----------------------------------|--------------------------
7304:Src/bno055.c  ****  *  0x00    | BNO055_OPERATION_MODE_CONFIG      | Configuration mode
7305:Src/bno055.c  ****  *  0x01    | BNO055_OPERATION_MODE_ACCONLY     | Reads accel data alone
7306:Src/bno055.c  ****  *  0x02    | BNO055_OPERATION_MODE_MAGONLY     | Reads mag data alone
7307:Src/bno055.c  ****  *  0x03    | BNO055_OPERATION_MODE_GYRONLY     | Reads gyro data alone
7308:Src/bno055.c  ****  *  0x04    | BNO055_OPERATION_MODE_ACCMAG      | Reads accel and mag data
7309:Src/bno055.c  ****  *  0x05    | BNO055_OPERATION_MODE_ACCGYRO     | Reads accel and gyro data
7310:Src/bno055.c  ****  *  0x06    | BNO055_OPERATION_MODE_MAGGYRO     | Reads accel and mag data
7311:Src/bno055.c  ****  *  0x07    | OPERATION_MODE_ANY_MOTION         | Reads accel mag and
7312:Src/bno055.c  ****  *			|		-                           | gyro data
7313:Src/bno055.c  ****  *  0x08    | BNO055_OPERATION_MODE_IMUPLUS     | Inertial measurement unit
7314:Src/bno055.c  ****  *   -      |                                   | Reads accel,gyro and
7315:Src/bno055.c  ****  *          |       -                           | fusion data
7316:Src/bno055.c  ****  *  0x09    | BNO055_OPERATION_MODE_COMPASS     | Reads accel, mag data
7317:Src/bno055.c  ****  *   -      |       -                           | and fusion data
7318:Src/bno055.c  ****  *  0x0A    | BNO055_OPERATION_MODE_M4G         | Reads accel, mag data
7319:Src/bno055.c  ****  *    -     |       -                           | and fusion data
7320:Src/bno055.c  ****  *  0x0B    | BNO055_OPERATION_MODE_NDOF_FMC_OFF| Nine degrees of freedom with
7321:Src/bno055.c  ****  *   -      |       -                           | fast magnetic calibration
7322:Src/bno055.c  ****  *   -      |       -                           | Reads accel,mag, gyro
7323:Src/bno055.c  ****  *   -      |       -                           | and fusion data
7324:Src/bno055.c  ****  *  0x0C    | BNO055_OPERATION_MODE_NDOF        | Nine degrees of freedom
7325:Src/bno055.c  ****  *   -      |       -                           | Reads accel,mag, gyro
ARM GAS  /tmp/ccVWLGiI.s 			page 285


7326:Src/bno055.c  ****  *   -      |       -                           | and fusion data
7327:Src/bno055.c  ****  *
7328:Src/bno055.c  ****  *	@return results of bus communication function
7329:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7330:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7331:Src/bno055.c  ****  *
7332:Src/bno055.c  ****  *	@note In the config mode, all sensor and fusion data
7333:Src/bno055.c  ****  *	becomes zero and it is mainly derived
7334:Src/bno055.c  ****  *	to configure the various settings of the BNO
7335:Src/bno055.c  ****  *
7336:Src/bno055.c  ****  */
7337:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_operation_mode(u8 operation_mode_u8)
7338:Src/bno055.c  **** {
 8390              		.loc 1 7338 0
 8391              		.cfi_startproc
 8392              		@ args = 0, pretend = 0, frame = 8
 8393              		@ frame_needed = 0, uses_anonymous_args = 0
 8394              	.LVL975:
 8395 0000 70B5     		push	{r4, r5, r6, lr}
 8396              	.LCFI358:
 8397              		.cfi_def_cfa_offset 16
 8398              		.cfi_offset 4, -16
 8399              		.cfi_offset 5, -12
 8400              		.cfi_offset 6, -8
 8401              		.cfi_offset 14, -4
7339:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7340:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
7341:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
7342:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
7343:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
7344:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 8402              		.loc 1 7344 0
 8403 0002 3E4E     		ldr	r6, .L960
7338:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 8404              		.loc 1 7338 0
 8405 0004 82B0     		sub	sp, sp, #8
 8406              	.LCFI359:
 8407              		.cfi_def_cfa_offset 24
 8408              		.loc 1 7344 0
 8409 0006 3268     		ldr	r2, [r6]
7340:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 8410              		.loc 1 7340 0
 8411 0008 0023     		movs	r3, #0
 8412 000a 8DF80630 		strb	r3, [sp, #6]
7341:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 8413              		.loc 1 7341 0
 8414 000e 8DF80730 		strb	r3, [sp, #7]
 8415              	.LVL976:
 8416              		.loc 1 7344 0
 8417 0012 002A     		cmp	r2, #0
 8418 0014 6FD0     		beq	.L951
 8419 0016 0546     		mov	r5, r0
7345:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
7346:Src/bno055.c  **** 	} else {
7347:Src/bno055.c  **** 		/* The write operation effective only if the operation
7348:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
7349:Src/bno055.c  **** 		current operation mode and set the config mode */
ARM GAS  /tmp/ccVWLGiI.s 			page 286


7350:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 8420              		.loc 1 7350 0
 8421 0018 0DF10700 		add	r0, sp, #7
 8422              	.LVL977:
 8423 001c FFF7FEFF 		bl	bno055_get_operation_mode
 8424              	.LVL978:
7351:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 8425              		.loc 1 7351 0
 8426 0020 80B9     		cbnz	r0, .L952
7352:Src/bno055.c  **** 			/* If the previous operation mode is config it is
7353:Src/bno055.c  **** 				directly write the operation mode */
7354:Src/bno055.c  **** 			if (prev_opmode_u8 == BNO055_OPERATION_MODE_CONFIG) {
 8427              		.loc 1 7354 0
 8428 0022 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 8429 0026 8BB9     		cbnz	r3, .L948
7355:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 8430              		.loc 1 7355 0
 8431 0028 3368     		ldr	r3, [r6]
 8432 002a 0DF10602 		add	r2, sp, #6
 8433 002e 1C69     		ldr	r4, [r3, #16]
 8434 0030 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8435              	.LVL979:
 8436 0032 3D21     		movs	r1, #61
 8437 0034 0123     		movs	r3, #1
 8438 0036 A047     		blx	r4
 8439              	.LVL980:
7356:Src/bno055.c  **** 				(p_bno055->dev_addr,
7357:Src/bno055.c  **** 				BNO055_OPERATION_MODE_REG,
7358:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7359:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
 8440              		.loc 1 7359 0
 8441 0038 0028     		cmp	r0, #0
 8442 003a 42D0     		beq	.L959
 8443              	.L956:
 8444 003c 0446     		mov	r4, r0
7360:Src/bno055.c  **** 					data_u8r =
7361:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
7362:Src/bno055.c  **** 					BNO055_OPERATION_MODE,
7363:Src/bno055.c  **** 					operation_mode_u8);
7364:Src/bno055.c  **** 					com_rslt +=
7365:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
7366:Src/bno055.c  **** 					(p_bno055->dev_addr,
7367:Src/bno055.c  **** 					BNO055_OPERATION_MODE_REG,
7368:Src/bno055.c  **** 					&data_u8r,
7369:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7370:Src/bno055.c  **** 					/* Config mode to other
7371:Src/bno055.c  **** 					operation mode switching
7372:Src/bno055.c  **** 					required delay of 600ms*/
7373:Src/bno055.c  **** 					p_bno055->delay_msec(
7374:Src/bno055.c  **** 					BNO055_MODE_SWITCHING_DELAY);
7375:Src/bno055.c  **** 				}
7376:Src/bno055.c  **** 			} else {
7377:Src/bno055.c  **** 				/* If the previous operation
7378:Src/bno055.c  **** 				mode is not config it is
7379:Src/bno055.c  **** 				 write the config mode */
7380:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
7381:Src/bno055.c  **** 				(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 287


7382:Src/bno055.c  **** 				BNO055_OPERATION_MODE_REG,
7383:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7384:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
7385:Src/bno055.c  **** 					data_u8r =
7386:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
7387:Src/bno055.c  **** 					BNO055_OPERATION_MODE,
7388:Src/bno055.c  **** 					BNO055_OPERATION_MODE_CONFIG);
7389:Src/bno055.c  **** 					com_rslt += bno055_write_register(
7390:Src/bno055.c  **** 					BNO055_OPERATION_MODE_REG,
7391:Src/bno055.c  **** 					&data_u8r,
7392:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7393:Src/bno055.c  **** 					/* other mode to config mode switching
7394:Src/bno055.c  **** 					required delay of 20ms*/
7395:Src/bno055.c  **** 					p_bno055->delay_msec(
7396:Src/bno055.c  **** 					BNO055_CONFIG_MODE_SWITCHING_DELAY);
7397:Src/bno055.c  **** 				}
7398:Src/bno055.c  **** 				/* Write the operation mode */
7399:Src/bno055.c  **** 				if (operation_mode_u8 !=
7400:Src/bno055.c  **** 				BNO055_OPERATION_MODE_CONFIG) {
7401:Src/bno055.c  **** 					com_rslt =
7402:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
7403:Src/bno055.c  **** 					(p_bno055->dev_addr,
7404:Src/bno055.c  **** 					BNO055_OPERATION_MODE_REG,
7405:Src/bno055.c  **** 					&data_u8r,
7406:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7407:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
7408:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
7409:Src/bno055.c  **** 						(data_u8r,
7410:Src/bno055.c  **** 						BNO055_OPERATION_MODE,
7411:Src/bno055.c  **** 						operation_mode_u8);
7412:Src/bno055.c  **** 						com_rslt +=
7413:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
7414:Src/bno055.c  **** 						(p_bno055->dev_addr,
7415:Src/bno055.c  **** 						BNO055_OPERATION_MODE_REG,
7416:Src/bno055.c  **** 						&data_u8r,
7417:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
7418:Src/bno055.c  **** 						/* Config mode to other
7419:Src/bno055.c  **** 						operation mode switching
7420:Src/bno055.c  **** 						required delay of 600ms*/
7421:Src/bno055.c  **** 						p_bno055->delay_msec(
7422:Src/bno055.c  **** 						BNO055_MODE_SWITCHING_DELAY);
7423:Src/bno055.c  **** 					}
7424:Src/bno055.c  **** 				}
7425:Src/bno055.c  **** 			}
7426:Src/bno055.c  **** 		} else {
7427:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7428:Src/bno055.c  **** 		}
7429:Src/bno055.c  **** 	}
7430:Src/bno055.c  **** 	return com_rslt;
7431:Src/bno055.c  **** }
 8445              		.loc 1 7431 0
 8446 003e 60B2     		sxtb	r0, r4
 8447              	.LVL981:
 8448 0040 02B0     		add	sp, sp, #8
 8449              	.LCFI360:
 8450              		.cfi_remember_state
 8451              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccVWLGiI.s 			page 288


 8452              		@ sp needed
 8453 0042 70BD     		pop	{r4, r5, r6, pc}
 8454              	.LVL982:
 8455              	.L952:
 8456              	.LCFI361:
 8457              		.cfi_restore_state
7427:Src/bno055.c  **** 		}
 8458              		.loc 1 7427 0
 8459 0044 FF24     		movs	r4, #255
 8460              	.LVL983:
 8461              	.L947:
 8462              		.loc 1 7431 0
 8463 0046 60B2     		sxtb	r0, r4
 8464 0048 02B0     		add	sp, sp, #8
 8465              	.LCFI362:
 8466              		.cfi_remember_state
 8467              		.cfi_def_cfa_offset 16
 8468              		@ sp needed
 8469 004a 70BD     		pop	{r4, r5, r6, pc}
 8470              	.LVL984:
 8471              	.L948:
 8472              	.LCFI363:
 8473              		.cfi_restore_state
7380:Src/bno055.c  **** 				(p_bno055->dev_addr,
 8474              		.loc 1 7380 0
 8475 004c 3368     		ldr	r3, [r6]
 8476 004e 0DF10602 		add	r2, sp, #6
 8477 0052 1C69     		ldr	r4, [r3, #16]
 8478 0054 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8479              	.LVL985:
 8480 0056 3D21     		movs	r1, #61
 8481 0058 0123     		movs	r3, #1
 8482 005a A047     		blx	r4
 8483              	.LVL986:
7384:Src/bno055.c  **** 					data_u8r =
 8484              		.loc 1 7384 0
 8485 005c 0446     		mov	r4, r0
 8486 005e A0B9     		cbnz	r0, .L949
7385:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8487              		.loc 1 7385 0
 8488 0060 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 8489              	.LBB4:
 8490              	.LBB5:
 176:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 8491              		.loc 1 176 0
 8492 0064 3368     		ldr	r3, [r6]
 8493              	.LBE5:
 8494              	.LBE4:
7385:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8495              		.loc 1 7385 0
 8496 0066 22F00F02 		bic	r2, r2, #15
 8497 006a 8DF80620 		strb	r2, [sp, #6]
 8498              	.LVL987:
 8499              	.LBB8:
 8500              	.LBB6:
 176:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
 8501              		.loc 1 176 0
ARM GAS  /tmp/ccVWLGiI.s 			page 289


 8502 006e 002B     		cmp	r3, #0
 8503 0070 3FD0     		beq	.L954
 180:Src/bno055.c  **** 			(p_bno055->dev_addr, addr_u8, data_u8, len_u8);
 8504              		.loc 1 180 0
 8505 0072 DC68     		ldr	r4, [r3, #12]
 8506 0074 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8507              	.LVL988:
 8508 0076 3D21     		movs	r1, #61
 8509 0078 0123     		movs	r3, #1
 8510 007a 0DF10602 		add	r2, sp, #6
 8511              	.LVL989:
 8512 007e A047     		blx	r4
 8513              	.LVL990:
 183:Src/bno055.c  **** }
 8514              		.loc 1 183 0
 8515 0080 0446     		mov	r4, r0
 8516 0082 3368     		ldr	r3, [r6]
 8517              	.LVL991:
 8518              	.L950:
 8519              	.LBE6:
 8520              	.LBE8:
7395:Src/bno055.c  **** 					BNO055_CONFIG_MODE_SWITCHING_DELAY);
 8521              		.loc 1 7395 0
 8522 0084 5B69     		ldr	r3, [r3, #20]
 8523 0086 1420     		movs	r0, #20
 8524 0088 9847     		blx	r3
 8525              	.LVL992:
 8526              	.L949:
7399:Src/bno055.c  **** 				BNO055_OPERATION_MODE_CONFIG) {
 8527              		.loc 1 7399 0
 8528 008a 002D     		cmp	r5, #0
 8529 008c DBD0     		beq	.L947
7402:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8530              		.loc 1 7402 0
 8531 008e 3368     		ldr	r3, [r6]
7401:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 8532              		.loc 1 7401 0
 8533 0090 3D21     		movs	r1, #61
 8534 0092 1C69     		ldr	r4, [r3, #16]
 8535              	.LVL993:
 8536 0094 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8537 0096 0DF10602 		add	r2, sp, #6
 8538 009a 0123     		movs	r3, #1
 8539 009c A047     		blx	r4
 8540              	.LVL994:
7402:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8541              		.loc 1 7402 0
 8542 009e 174E     		ldr	r6, .L960
7407:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 8543              		.loc 1 7407 0
 8544 00a0 0028     		cmp	r0, #0
 8545 00a2 CBD1     		bne	.L956
7408:Src/bno055.c  **** 						(data_u8r,
 8546              		.loc 1 7408 0
 8547 00a4 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 8548 00a8 05F00F00 		and	r0, r5, #15
 8549              	.LVL995:
ARM GAS  /tmp/ccVWLGiI.s 			page 290


 8550 00ac 23F00F05 		bic	r5, r3, #15
7413:Src/bno055.c  **** 						(p_bno055->dev_addr,
 8551              		.loc 1 7413 0
 8552 00b0 3368     		ldr	r3, [r6]
7408:Src/bno055.c  **** 						(data_u8r,
 8553              		.loc 1 7408 0
 8554 00b2 2843     		orrs	r0, r0, r5
 8555 00b4 8DF80600 		strb	r0, [sp, #6]
7413:Src/bno055.c  **** 						(p_bno055->dev_addr,
 8556              		.loc 1 7413 0
 8557 00b8 0DF10602 		add	r2, sp, #6
 8558 00bc DC68     		ldr	r4, [r3, #12]
 8559 00be 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8560 00c0 0DE0     		b	.L958
 8561              	.LVL996:
 8562              	.L959:
7360:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8563              		.loc 1 7360 0
 8564 00c2 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
7365:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8565              		.loc 1 7365 0
 8566 00c6 3168     		ldr	r1, [r6]
7360:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8567              		.loc 1 7360 0
 8568 00c8 05F00F00 		and	r0, r5, #15
 8569              	.LVL997:
 8570 00cc 23F00F03 		bic	r3, r3, #15
 8571 00d0 1843     		orrs	r0, r0, r3
 8572 00d2 8DF80600 		strb	r0, [sp, #6]
7365:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8573              		.loc 1 7365 0
 8574 00d6 CC68     		ldr	r4, [r1, #12]
 8575 00d8 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 8576 00da 0DF10602 		add	r2, sp, #6
 8577              	.L958:
7413:Src/bno055.c  **** 						(p_bno055->dev_addr,
 8578              		.loc 1 7413 0
 8579 00de 3D21     		movs	r1, #61
 8580 00e0 0123     		movs	r3, #1
 8581 00e2 A047     		blx	r4
 8582              	.LVL998:
7421:Src/bno055.c  **** 						BNO055_MODE_SWITCHING_DELAY);
 8583              		.loc 1 7421 0
 8584 00e4 3368     		ldr	r3, [r6]
7413:Src/bno055.c  **** 						(p_bno055->dev_addr,
 8585              		.loc 1 7413 0
 8586 00e6 0446     		mov	r4, r0
 8587              	.LVL999:
7421:Src/bno055.c  **** 						BNO055_MODE_SWITCHING_DELAY);
 8588              		.loc 1 7421 0
 8589 00e8 5B69     		ldr	r3, [r3, #20]
 8590 00ea 4FF41670 		mov	r0, #600
 8591 00ee 9847     		blx	r3
 8592              	.LVL1000:
 8593 00f0 A9E7     		b	.L947
 8594              	.LVL1001:
 8595              	.L954:
ARM GAS  /tmp/ccVWLGiI.s 			page 291


 8596              	.LBB9:
 8597              	.LBB7:
 177:Src/bno055.c  **** 		} else {
 8598              		.loc 1 177 0
 8599 00f2 8124     		movs	r4, #129
 8600 00f4 C6E7     		b	.L950
 8601              	.LVL1002:
 8602              	.L951:
 8603              	.LBE7:
 8604              	.LBE9:
7345:Src/bno055.c  **** 	} else {
 8605              		.loc 1 7345 0
 8606 00f6 8124     		movs	r4, #129
 8607 00f8 A5E7     		b	.L947
 8608              	.L961:
 8609 00fa 00BF     		.align	2
 8610              	.L960:
 8611 00fc 00000000 		.word	.LANCHOR0
 8612              		.cfi_endproc
 8613              	.LFE146:
 8615              		.section	.text.bno055_set_accel_unit,"ax",%progbits
 8616              		.align	2
 8617              		.global	bno055_set_accel_unit
 8618              		.thumb
 8619              		.thumb_func
 8621              	bno055_set_accel_unit:
 8622              	.LFB134:
6596:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 8623              		.loc 1 6596 0
 8624              		.cfi_startproc
 8625              		@ args = 0, pretend = 0, frame = 8
 8626              		@ frame_needed = 0, uses_anonymous_args = 0
 8627              	.LVL1003:
 8628 0000 30B5     		push	{r4, r5, lr}
 8629              	.LCFI364:
 8630              		.cfi_def_cfa_offset 12
 8631              		.cfi_offset 4, -12
 8632              		.cfi_offset 5, -8
 8633              		.cfi_offset 14, -4
6602:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 8634              		.loc 1 6602 0
 8635 0002 244C     		ldr	r4, .L978
6596:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 8636              		.loc 1 6596 0
 8637 0004 83B0     		sub	sp, sp, #12
 8638              	.LCFI365:
 8639              		.cfi_def_cfa_offset 24
6602:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 8640              		.loc 1 6602 0
 8641 0006 2268     		ldr	r2, [r4]
6598:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 8642              		.loc 1 6598 0
 8643 0008 0023     		movs	r3, #0
 8644 000a 8DF80630 		strb	r3, [sp, #6]
6599:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 8645              		.loc 1 6599 0
 8646 000e 8DF80730 		strb	r3, [sp, #7]
ARM GAS  /tmp/ccVWLGiI.s 			page 292


 8647              	.LVL1004:
6602:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 8648              		.loc 1 6602 0
 8649 0012 002A     		cmp	r2, #0
 8650 0014 3BD0     		beq	.L970
 8651 0016 0546     		mov	r5, r0
6608:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 8652              		.loc 1 6608 0
 8653 0018 0DF10700 		add	r0, sp, #7
 8654              	.LVL1005:
 8655 001c FFF7FEFF 		bl	bno055_get_operation_mode
 8656              	.LVL1006:
6609:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 8657              		.loc 1 6609 0
 8658 0020 38B1     		cbz	r0, .L964
 8659              	.L969:
6634:Src/bno055.c  **** 		}
 8660              		.loc 1 6634 0
 8661 0022 FF24     		movs	r4, #255
 8662              	.LVL1007:
 8663              	.L965:
6637:Src/bno055.c  **** 		/* set the operation mode
 8664              		.loc 1 6637 0
 8665 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 8666 0028 28BB     		cbnz	r0, .L977
 8667 002a 2046     		mov	r0, r4
 8668              	.LVL1008:
 8669              	.L963:
6643:Src/bno055.c  **** /*!
 8670              		.loc 1 6643 0
 8671 002c 40B2     		sxtb	r0, r0
 8672 002e 03B0     		add	sp, sp, #12
 8673              	.LCFI366:
 8674              		.cfi_remember_state
 8675              		.cfi_def_cfa_offset 12
 8676              		@ sp needed
 8677 0030 30BD     		pop	{r4, r5, pc}
 8678              	.LVL1009:
 8679              	.L964:
 8680              	.LCFI367:
 8681              		.cfi_restore_state
6610:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 8682              		.loc 1 6610 0
 8683 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 8684 0036 2BBB     		cbnz	r3, .L966
 8685              	.L968:
 8686              	.LVL1010:
6615:Src/bno055.c  **** 				(p_bno055->dev_addr,
 8687              		.loc 1 6615 0
 8688 0038 2368     		ldr	r3, [r4]
 8689 003a 0DF10602 		add	r2, sp, #6
 8690 003e 1C69     		ldr	r4, [r3, #16]
 8691 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8692 0042 3B21     		movs	r1, #59
 8693 0044 0123     		movs	r3, #1
 8694 0046 A047     		blx	r4
 8695              	.LVL1011:
ARM GAS  /tmp/ccVWLGiI.s 			page 293


 8696 0048 124B     		ldr	r3, .L978
6619:Src/bno055.c  **** 					data_u8r =
 8697              		.loc 1 6619 0
 8698 004a 0446     		mov	r4, r0
 8699 004c 0028     		cmp	r0, #0
 8700 004e E9D1     		bne	.L965
6620:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8701              		.loc 1 6620 0
 8702 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
6624:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8703              		.loc 1 6624 0
 8704 0054 1B68     		ldr	r3, [r3]
6620:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8705              		.loc 1 6620 0
 8706 0056 05F00100 		and	r0, r5, #1
 8707              	.LVL1012:
 8708 005a 22F00105 		bic	r5, r2, #1
 8709 005e 2843     		orrs	r0, r0, r5
6624:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8710              		.loc 1 6624 0
 8711 0060 DC68     		ldr	r4, [r3, #12]
6620:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 8712              		.loc 1 6620 0
 8713 0062 8DF80600 		strb	r0, [sp, #6]
6624:Src/bno055.c  **** 					(p_bno055->dev_addr,
 8714              		.loc 1 6624 0
 8715 0066 0DF10602 		add	r2, sp, #6
 8716 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 8717 006c 3B21     		movs	r1, #59
 8718 006e 0123     		movs	r3, #1
 8719 0070 A047     		blx	r4
 8720              	.LVL1013:
 8721 0072 0446     		mov	r4, r0
 8722              	.LVL1014:
 8723 0074 D6E7     		b	.L965
 8724              	.L977:
6640:Src/bno055.c  **** 		(prev_opmode_u8);
 8725              		.loc 1 6640 0
 8726 0076 FFF7FEFF 		bl	bno055_set_operation_mode
 8727              	.LVL1015:
 8728 007a 2044     		add	r0, r0, r4
 8729 007c C0B2     		uxtb	r0, r0
 8730              	.LVL1016:
6643:Src/bno055.c  **** /*!
 8731              		.loc 1 6643 0
 8732 007e 40B2     		sxtb	r0, r0
 8733 0080 03B0     		add	sp, sp, #12
 8734              	.LCFI368:
 8735              		.cfi_remember_state
 8736              		.cfi_def_cfa_offset 12
 8737              		@ sp needed
 8738 0082 30BD     		pop	{r4, r5, pc}
 8739              	.LVL1017:
 8740              	.L966:
 8741              	.LCFI369:
 8742              		.cfi_restore_state
6611:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
ARM GAS  /tmp/ccVWLGiI.s 			page 294


 8743              		.loc 1 6611 0
 8744 0084 FFF7FEFF 		bl	bno055_set_operation_mode
 8745              	.LVL1018:
6613:Src/bno055.c  **** 				/* Write the accel unit */
 8746              		.loc 1 6613 0
 8747 0088 0028     		cmp	r0, #0
 8748 008a CAD1     		bne	.L969
 8749 008c D4E7     		b	.L968
 8750              	.LVL1019:
 8751              	.L970:
6603:Src/bno055.c  **** 	} else {
 8752              		.loc 1 6603 0
 8753 008e 8120     		movs	r0, #129
 8754              	.LVL1020:
 8755 0090 CCE7     		b	.L963
 8756              	.L979:
 8757 0092 00BF     		.align	2
 8758              	.L978:
 8759 0094 00000000 		.word	.LANCHOR0
 8760              		.cfi_endproc
 8761              	.LFE134:
 8763              		.section	.text.bno055_convert_float_accel_x_msq,"ax",%progbits
 8764              		.align	2
 8765              		.global	bno055_convert_float_accel_x_msq
 8766              		.thumb
 8767              		.thumb_func
 8769              	bno055_convert_float_accel_x_msq:
 8770              	.LFB41:
2637:Src/bno055.c  **** 	/* Variable used to return value of
 8771              		.loc 1 2637 0
 8772              		.cfi_startproc
 8773              		@ args = 0, pretend = 0, frame = 8
 8774              		@ frame_needed = 0, uses_anonymous_args = 0
 8775              	.LVL1021:
 8776 0000 70B5     		push	{r4, r5, r6, lr}
 8777              	.LCFI370:
 8778              		.cfi_def_cfa_offset 16
 8779              		.cfi_offset 4, -16
 8780              		.cfi_offset 5, -12
 8781              		.cfi_offset 6, -8
 8782              		.cfi_offset 14, -4
 8783 0002 82B0     		sub	sp, sp, #8
 8784              	.LCFI371:
 8785              		.cfi_def_cfa_offset 24
2643:Src/bno055.c  **** 	/* Read the current accel unit and set the
 8786              		.loc 1 2643 0
 8787 0004 02AB     		add	r3, sp, #8
2641:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 8788              		.loc 1 2641 0
 8789 0006 0025     		movs	r5, #0
2643:Src/bno055.c  **** 	/* Read the current accel unit and set the
 8790              		.loc 1 2643 0
 8791 0008 03F8035D 		strb	r5, [r3, #-3]!
2637:Src/bno055.c  **** 	/* Variable used to return value of
 8792              		.loc 1 2637 0
 8793 000c 0646     		mov	r6, r0
2646:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
ARM GAS  /tmp/ccVWLGiI.s 			page 295


 8794              		.loc 1 2646 0
 8795 000e 1846     		mov	r0, r3
 8796              	.LVL1022:
2641:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 8797              		.loc 1 2641 0
 8798 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 8799              	.LVL1023:
2646:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 8800              		.loc 1 2646 0
 8801 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 8802              	.LVL1024:
2647:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 8803              		.loc 1 2647 0
 8804 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
2646:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 8805              		.loc 1 2646 0
 8806 001c 0446     		mov	r4, r0
 8807              	.LVL1025:
2647:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 8808              		.loc 1 2647 0
 8809 001e CBB9     		cbnz	r3, .L989
 8810              	.L981:
2649:Src/bno055.c  **** 			/* Read the accel raw x data*/
 8811              		.loc 1 2649 0
 8812 0020 F4B9     		cbnz	r4, .L984
2651:Src/bno055.c  **** 			p_bno055->delay_msec(BNO055_GEN_READ_WRITE_LENGTH);
 8813              		.loc 1 2651 0
 8814 0022 0DF10600 		add	r0, sp, #6
 8815 0026 FFF7FEFF 		bl	bno055_read_accel_x
 8816              	.LVL1026:
 8817 002a 0546     		mov	r5, r0
 8818              	.LVL1027:
2652:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 8819              		.loc 1 2652 0
 8820 002c 0E4B     		ldr	r3, .L990
 8821 002e 0120     		movs	r0, #1
 8822 0030 1B68     		ldr	r3, [r3]
 8823 0032 5B69     		ldr	r3, [r3, #20]
 8824 0034 9847     		blx	r3
 8825              	.LVL1028:
2653:Src/bno055.c  **** 				/* Convert the raw accel x to m/s2*/
 8826              		.loc 1 2653 0
 8827 0036 9DB9     		cbnz	r5, .L984
 8828              	.LVL1029:
2656:Src/bno055.c  **** 				*accel_x_f = data_f;
 8829              		.loc 1 2656 0
 8830 0038 BDF90600 		ldrsh	r0, [sp, #6]
 8831 003c FFF7FEFF 		bl	__aeabi_i2d
 8832              	.LVL1030:
 8833 0040 0022     		movs	r2, #0
 8834 0042 0A4B     		ldr	r3, .L990+4
 8835 0044 FFF7FEFF 		bl	__aeabi_ddiv
 8836              	.LVL1031:
2655:Src/bno055.c  **** 				(float)(reg_accel_x_s16/BNO055_ACCEL_DIV_MSQ);
 8837              		.loc 1 2655 0
 8838 0048 FFF7FEFF 		bl	__aeabi_d2f
 8839              	.LVL1032:
ARM GAS  /tmp/ccVWLGiI.s 			page 296


 8840 004c 3060     		str	r0, [r6]	@ float
2665:Src/bno055.c  **** /*!
 8841              		.loc 1 2665 0
 8842 004e 60B2     		sxtb	r0, r4
 8843 0050 02B0     		add	sp, sp, #8
 8844              	.LCFI372:
 8845              		.cfi_remember_state
 8846              		.cfi_def_cfa_offset 16
 8847              		@ sp needed
 8848 0052 70BD     		pop	{r4, r5, r6, pc}
 8849              	.LVL1033:
 8850              	.L989:
 8851              	.LCFI373:
 8852              		.cfi_restore_state
2648:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 8853              		.loc 1 2648 0
 8854 0054 2846     		mov	r0, r5
 8855 0056 FFF7FEFF 		bl	bno055_set_accel_unit
 8856              	.LVL1034:
 8857 005a 2044     		add	r0, r0, r4
 8858 005c C4B2     		uxtb	r4, r0
 8859              	.LVL1035:
 8860 005e DFE7     		b	.L981
 8861              	.LVL1036:
 8862              	.L984:
2662:Src/bno055.c  **** 		}
 8863              		.loc 1 2662 0
 8864 0060 FF24     		movs	r4, #255
 8865              	.LVL1037:
2665:Src/bno055.c  **** /*!
 8866              		.loc 1 2665 0
 8867 0062 60B2     		sxtb	r0, r4
 8868 0064 02B0     		add	sp, sp, #8
 8869              	.LCFI374:
 8870              		.cfi_def_cfa_offset 16
 8871              		@ sp needed
 8872 0066 70BD     		pop	{r4, r5, r6, pc}
 8873              	.LVL1038:
 8874              	.L991:
 8875              		.align	2
 8876              	.L990:
 8877 0068 00000000 		.word	.LANCHOR0
 8878 006c 00005940 		.word	1079574528
 8879              		.cfi_endproc
 8880              	.LFE41:
 8882              		.global	__aeabi_i2f
 8883              		.section	.text.bno055_convert_float_accel_x_mg,"ax",%progbits
 8884              		.align	2
 8885              		.global	bno055_convert_float_accel_x_mg
 8886              		.thumb
 8887              		.thumb_func
 8889              	bno055_convert_float_accel_x_mg:
 8890              	.LFB42:
2683:Src/bno055.c  **** 	/* Variable used to return value of
 8891              		.loc 1 2683 0
 8892              		.cfi_startproc
 8893              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccVWLGiI.s 			page 297


 8894              		@ frame_needed = 0, uses_anonymous_args = 0
 8895              	.LVL1039:
 8896 0000 30B5     		push	{r4, r5, lr}
 8897              	.LCFI375:
 8898              		.cfi_def_cfa_offset 12
 8899              		.cfi_offset 4, -12
 8900              		.cfi_offset 5, -8
 8901              		.cfi_offset 14, -4
 8902 0002 83B0     		sub	sp, sp, #12
 8903              	.LCFI376:
 8904              		.cfi_def_cfa_offset 24
2689:Src/bno055.c  **** 	/* Read the current accel unit and set the
 8905              		.loc 1 2689 0
 8906 0004 02AB     		add	r3, sp, #8
2687:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 8907              		.loc 1 2687 0
 8908 0006 0022     		movs	r2, #0
2689:Src/bno055.c  **** 	/* Read the current accel unit and set the
 8909              		.loc 1 2689 0
 8910 0008 03F8032D 		strb	r2, [r3, #-3]!
2683:Src/bno055.c  **** 	/* Variable used to return value of
 8911              		.loc 1 2683 0
 8912 000c 0546     		mov	r5, r0
2692:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 8913              		.loc 1 2692 0
 8914 000e 1846     		mov	r0, r3
 8915              	.LVL1040:
2687:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 8916              		.loc 1 2687 0
 8917 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 8918              	.LVL1041:
2692:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 8919              		.loc 1 2692 0
 8920 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 8921              	.LVL1042:
2693:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 8922              		.loc 1 2693 0
 8923 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
2692:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 8924              		.loc 1 2692 0
 8925 001c 0446     		mov	r4, r0
 8926              	.LVL1043:
2693:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 8927              		.loc 1 2693 0
 8928 001e 012B     		cmp	r3, #1
 8929 0020 04D0     		beq	.L993
2694:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 8930              		.loc 1 2694 0
 8931 0022 0120     		movs	r0, #1
 8932 0024 FFF7FEFF 		bl	bno055_set_accel_unit
 8933              	.LVL1044:
 8934 0028 2044     		add	r0, r0, r4
 8935 002a C4B2     		uxtb	r4, r0
 8936              	.LVL1045:
 8937              	.L993:
2695:Src/bno055.c  **** 			/* Read the accel raw x data*/
 8938              		.loc 1 2695 0
ARM GAS  /tmp/ccVWLGiI.s 			page 298


 8939 002c 64B9     		cbnz	r4, .L996
2697:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 8940              		.loc 1 2697 0
 8941 002e 0DF10600 		add	r0, sp, #6
 8942 0032 FFF7FEFF 		bl	bno055_read_accel_x
 8943              	.LVL1046:
2698:Src/bno055.c  **** 				/* Convert the raw accel x to m/s2*/
 8944              		.loc 1 2698 0
 8945 0036 38B9     		cbnz	r0, .L996
 8946              	.LVL1047:
2700:Src/bno055.c  **** 				(float)(reg_accel_x_s16/BNO055_ACCEL_DIV_MG);
 8947              		.loc 1 2700 0
 8948 0038 BDF90600 		ldrsh	r0, [sp, #6]
 8949              	.LVL1048:
 8950 003c FFF7FEFF 		bl	__aeabi_i2f
 8951              	.LVL1049:
 8952 0040 2860     		str	r0, [r5]	@ float
2710:Src/bno055.c  **** /*!
 8953              		.loc 1 2710 0
 8954 0042 60B2     		sxtb	r0, r4
 8955 0044 03B0     		add	sp, sp, #12
 8956              	.LCFI377:
 8957              		.cfi_remember_state
 8958              		.cfi_def_cfa_offset 12
 8959              		@ sp needed
 8960 0046 30BD     		pop	{r4, r5, pc}
 8961              	.LVL1050:
 8962              	.L996:
 8963              	.LCFI378:
 8964              		.cfi_restore_state
2707:Src/bno055.c  **** 		}
 8965              		.loc 1 2707 0
 8966 0048 FF24     		movs	r4, #255
 8967              	.LVL1051:
2710:Src/bno055.c  **** /*!
 8968              		.loc 1 2710 0
 8969 004a 60B2     		sxtb	r0, r4
 8970 004c 03B0     		add	sp, sp, #12
 8971              	.LCFI379:
 8972              		.cfi_def_cfa_offset 12
 8973              		@ sp needed
 8974 004e 30BD     		pop	{r4, r5, pc}
 8975              		.cfi_endproc
 8976              	.LFE42:
 8978              		.section	.text.bno055_convert_float_accel_y_msq,"ax",%progbits
 8979              		.align	2
 8980              		.global	bno055_convert_float_accel_y_msq
 8981              		.thumb
 8982              		.thumb_func
 8984              	bno055_convert_float_accel_y_msq:
 8985              	.LFB43:
2727:Src/bno055.c  **** 	/* Variable used to return value of
 8986              		.loc 1 2727 0
 8987              		.cfi_startproc
 8988              		@ args = 0, pretend = 0, frame = 8
 8989              		@ frame_needed = 0, uses_anonymous_args = 0
 8990              	.LVL1052:
ARM GAS  /tmp/ccVWLGiI.s 			page 299


 8991 0000 70B5     		push	{r4, r5, r6, lr}
 8992              	.LCFI380:
 8993              		.cfi_def_cfa_offset 16
 8994              		.cfi_offset 4, -16
 8995              		.cfi_offset 5, -12
 8996              		.cfi_offset 6, -8
 8997              		.cfi_offset 14, -4
 8998 0002 82B0     		sub	sp, sp, #8
 8999              	.LCFI381:
 9000              		.cfi_def_cfa_offset 24
2733:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9001              		.loc 1 2733 0
 9002 0004 02AB     		add	r3, sp, #8
2731:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 9003              		.loc 1 2731 0
 9004 0006 0025     		movs	r5, #0
2733:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9005              		.loc 1 2733 0
 9006 0008 03F8035D 		strb	r5, [r3, #-3]!
2727:Src/bno055.c  **** 	/* Variable used to return value of
 9007              		.loc 1 2727 0
 9008 000c 0646     		mov	r6, r0
2736:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9009              		.loc 1 2736 0
 9010 000e 1846     		mov	r0, r3
 9011              	.LVL1053:
2731:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 9012              		.loc 1 2731 0
 9013 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 9014              	.LVL1054:
2736:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9015              		.loc 1 2736 0
 9016 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9017              	.LVL1055:
2737:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9018              		.loc 1 2737 0
 9019 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
2736:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9020              		.loc 1 2736 0
 9021 001c 0446     		mov	r4, r0
 9022              	.LVL1056:
2737:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9023              		.loc 1 2737 0
 9024 001e CBB9     		cbnz	r3, .L1010
 9025              	.L1002:
2739:Src/bno055.c  **** 			com_rslt += bno055_read_accel_y(&reg_accel_y_s16);
 9026              		.loc 1 2739 0
 9027 0020 F4B9     		cbnz	r4, .L1005
2740:Src/bno055.c  **** 			p_bno055->delay_msec(BNO055_GEN_READ_WRITE_LENGTH);
 9028              		.loc 1 2740 0
 9029 0022 0DF10600 		add	r0, sp, #6
 9030 0026 FFF7FEFF 		bl	bno055_read_accel_y
 9031              	.LVL1057:
 9032 002a 0546     		mov	r5, r0
 9033              	.LVL1058:
2741:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9034              		.loc 1 2741 0
ARM GAS  /tmp/ccVWLGiI.s 			page 300


 9035 002c 0E4B     		ldr	r3, .L1011
 9036 002e 0120     		movs	r0, #1
 9037 0030 1B68     		ldr	r3, [r3]
 9038 0032 5B69     		ldr	r3, [r3, #20]
 9039 0034 9847     		blx	r3
 9040              	.LVL1059:
2742:Src/bno055.c  **** 				/* Convert the raw accel y to m/s2*/
 9041              		.loc 1 2742 0
 9042 0036 9DB9     		cbnz	r5, .L1005
 9043              	.LVL1060:
2745:Src/bno055.c  **** 				*accel_y_f = data_f;
 9044              		.loc 1 2745 0
 9045 0038 BDF90600 		ldrsh	r0, [sp, #6]
 9046 003c FFF7FEFF 		bl	__aeabi_i2d
 9047              	.LVL1061:
 9048 0040 0022     		movs	r2, #0
 9049 0042 0A4B     		ldr	r3, .L1011+4
 9050 0044 FFF7FEFF 		bl	__aeabi_ddiv
 9051              	.LVL1062:
2744:Src/bno055.c  **** 				(float)(reg_accel_y_s16/BNO055_ACCEL_DIV_MSQ);
 9052              		.loc 1 2744 0
 9053 0048 FFF7FEFF 		bl	__aeabi_d2f
 9054              	.LVL1063:
 9055 004c 3060     		str	r0, [r6]	@ float
2754:Src/bno055.c  **** /*!
 9056              		.loc 1 2754 0
 9057 004e 60B2     		sxtb	r0, r4
 9058 0050 02B0     		add	sp, sp, #8
 9059              	.LCFI382:
 9060              		.cfi_remember_state
 9061              		.cfi_def_cfa_offset 16
 9062              		@ sp needed
 9063 0052 70BD     		pop	{r4, r5, r6, pc}
 9064              	.LVL1064:
 9065              	.L1010:
 9066              	.LCFI383:
 9067              		.cfi_restore_state
2738:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9068              		.loc 1 2738 0
 9069 0054 2846     		mov	r0, r5
 9070 0056 FFF7FEFF 		bl	bno055_set_accel_unit
 9071              	.LVL1065:
 9072 005a 2044     		add	r0, r0, r4
 9073 005c C4B2     		uxtb	r4, r0
 9074              	.LVL1066:
 9075 005e DFE7     		b	.L1002
 9076              	.LVL1067:
 9077              	.L1005:
2751:Src/bno055.c  **** 		}
 9078              		.loc 1 2751 0
 9079 0060 FF24     		movs	r4, #255
 9080              	.LVL1068:
2754:Src/bno055.c  **** /*!
 9081              		.loc 1 2754 0
 9082 0062 60B2     		sxtb	r0, r4
 9083 0064 02B0     		add	sp, sp, #8
 9084              	.LCFI384:
ARM GAS  /tmp/ccVWLGiI.s 			page 301


 9085              		.cfi_def_cfa_offset 16
 9086              		@ sp needed
 9087 0066 70BD     		pop	{r4, r5, r6, pc}
 9088              	.LVL1069:
 9089              	.L1012:
 9090              		.align	2
 9091              	.L1011:
 9092 0068 00000000 		.word	.LANCHOR0
 9093 006c 00005940 		.word	1079574528
 9094              		.cfi_endproc
 9095              	.LFE43:
 9097              		.section	.text.bno055_convert_float_accel_y_mg,"ax",%progbits
 9098              		.align	2
 9099              		.global	bno055_convert_float_accel_y_mg
 9100              		.thumb
 9101              		.thumb_func
 9103              	bno055_convert_float_accel_y_mg:
 9104              	.LFB44:
2770:Src/bno055.c  **** 	/* Variable used to return value of
 9105              		.loc 1 2770 0
 9106              		.cfi_startproc
 9107              		@ args = 0, pretend = 0, frame = 8
 9108              		@ frame_needed = 0, uses_anonymous_args = 0
 9109              	.LVL1070:
 9110 0000 30B5     		push	{r4, r5, lr}
 9111              	.LCFI385:
 9112              		.cfi_def_cfa_offset 12
 9113              		.cfi_offset 4, -12
 9114              		.cfi_offset 5, -8
 9115              		.cfi_offset 14, -4
 9116 0002 83B0     		sub	sp, sp, #12
 9117              	.LCFI386:
 9118              		.cfi_def_cfa_offset 24
2776:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9119              		.loc 1 2776 0
 9120 0004 02AB     		add	r3, sp, #8
2774:Src/bno055.c  **** 	float data = BNO055_INIT_VALUE;
 9121              		.loc 1 2774 0
 9122 0006 0022     		movs	r2, #0
2776:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9123              		.loc 1 2776 0
 9124 0008 03F8032D 		strb	r2, [r3, #-3]!
2770:Src/bno055.c  **** 	/* Variable used to return value of
 9125              		.loc 1 2770 0
 9126 000c 0546     		mov	r5, r0
2779:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9127              		.loc 1 2779 0
 9128 000e 1846     		mov	r0, r3
 9129              	.LVL1071:
2774:Src/bno055.c  **** 	float data = BNO055_INIT_VALUE;
 9130              		.loc 1 2774 0
 9131 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 9132              	.LVL1072:
2779:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9133              		.loc 1 2779 0
 9134 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9135              	.LVL1073:
ARM GAS  /tmp/ccVWLGiI.s 			page 302


2780:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9136              		.loc 1 2780 0
 9137 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
2779:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9138              		.loc 1 2779 0
 9139 001c 0446     		mov	r4, r0
 9140              	.LVL1074:
2780:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9141              		.loc 1 2780 0
 9142 001e 012B     		cmp	r3, #1
 9143 0020 04D0     		beq	.L1014
2781:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9144              		.loc 1 2781 0
 9145 0022 0120     		movs	r0, #1
 9146 0024 FFF7FEFF 		bl	bno055_set_accel_unit
 9147              	.LVL1075:
 9148 0028 2044     		add	r0, r0, r4
 9149 002a C4B2     		uxtb	r4, r0
 9150              	.LVL1076:
 9151              	.L1014:
2782:Src/bno055.c  **** 			/* Read the accel raw z data*/
 9152              		.loc 1 2782 0
 9153 002c 64B9     		cbnz	r4, .L1017
2784:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9154              		.loc 1 2784 0
 9155 002e 0DF10600 		add	r0, sp, #6
 9156 0032 FFF7FEFF 		bl	bno055_read_accel_y
 9157              	.LVL1077:
2785:Src/bno055.c  **** 				/* Convert the raw accel z to mg*/
 9158              		.loc 1 2785 0
 9159 0036 38B9     		cbnz	r0, .L1017
 9160              	.LVL1078:
2787:Src/bno055.c  **** 				reg_accel_y_s16/BNO055_ACCEL_DIV_MG);
 9161              		.loc 1 2787 0
 9162 0038 BDF90600 		ldrsh	r0, [sp, #6]
 9163              	.LVL1079:
 9164 003c FFF7FEFF 		bl	__aeabi_i2f
 9165              	.LVL1080:
 9166 0040 2860     		str	r0, [r5]	@ float
2797:Src/bno055.c  **** /*!
 9167              		.loc 1 2797 0
 9168 0042 60B2     		sxtb	r0, r4
 9169 0044 03B0     		add	sp, sp, #12
 9170              	.LCFI387:
 9171              		.cfi_remember_state
 9172              		.cfi_def_cfa_offset 12
 9173              		@ sp needed
 9174 0046 30BD     		pop	{r4, r5, pc}
 9175              	.LVL1081:
 9176              	.L1017:
 9177              	.LCFI388:
 9178              		.cfi_restore_state
2794:Src/bno055.c  **** 		}
 9179              		.loc 1 2794 0
 9180 0048 FF24     		movs	r4, #255
 9181              	.LVL1082:
2797:Src/bno055.c  **** /*!
ARM GAS  /tmp/ccVWLGiI.s 			page 303


 9182              		.loc 1 2797 0
 9183 004a 60B2     		sxtb	r0, r4
 9184 004c 03B0     		add	sp, sp, #12
 9185              	.LCFI389:
 9186              		.cfi_def_cfa_offset 12
 9187              		@ sp needed
 9188 004e 30BD     		pop	{r4, r5, pc}
 9189              		.cfi_endproc
 9190              	.LFE44:
 9192              		.section	.text.bno055_convert_float_accel_z_msq,"ax",%progbits
 9193              		.align	2
 9194              		.global	bno055_convert_float_accel_z_msq
 9195              		.thumb
 9196              		.thumb_func
 9198              	bno055_convert_float_accel_z_msq:
 9199              	.LFB45:
2814:Src/bno055.c  **** 	/* Variable used to return value of
 9200              		.loc 1 2814 0
 9201              		.cfi_startproc
 9202              		@ args = 0, pretend = 0, frame = 8
 9203              		@ frame_needed = 0, uses_anonymous_args = 0
 9204              	.LVL1083:
 9205 0000 70B5     		push	{r4, r5, r6, lr}
 9206              	.LCFI390:
 9207              		.cfi_def_cfa_offset 16
 9208              		.cfi_offset 4, -16
 9209              		.cfi_offset 5, -12
 9210              		.cfi_offset 6, -8
 9211              		.cfi_offset 14, -4
 9212 0002 82B0     		sub	sp, sp, #8
 9213              	.LCFI391:
 9214              		.cfi_def_cfa_offset 24
2820:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9215              		.loc 1 2820 0
 9216 0004 02AB     		add	r3, sp, #8
2818:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 9217              		.loc 1 2818 0
 9218 0006 0025     		movs	r5, #0
2820:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9219              		.loc 1 2820 0
 9220 0008 03F8035D 		strb	r5, [r3, #-3]!
2814:Src/bno055.c  **** 	/* Variable used to return value of
 9221              		.loc 1 2814 0
 9222 000c 0646     		mov	r6, r0
2823:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9223              		.loc 1 2823 0
 9224 000e 1846     		mov	r0, r3
 9225              	.LVL1084:
2818:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 9226              		.loc 1 2818 0
 9227 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 9228              	.LVL1085:
2823:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9229              		.loc 1 2823 0
 9230 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9231              	.LVL1086:
2824:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
ARM GAS  /tmp/ccVWLGiI.s 			page 304


 9232              		.loc 1 2824 0
 9233 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
2823:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9234              		.loc 1 2823 0
 9235 001c 0446     		mov	r4, r0
 9236              	.LVL1087:
2824:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9237              		.loc 1 2824 0
 9238 001e CBB9     		cbnz	r3, .L1031
 9239              	.L1023:
2826:Src/bno055.c  **** 			/* Read the accel raw z data*/
 9240              		.loc 1 2826 0
 9241 0020 F4B9     		cbnz	r4, .L1026
2828:Src/bno055.c  **** 			p_bno055->delay_msec(BNO055_GEN_READ_WRITE_LENGTH);
 9242              		.loc 1 2828 0
 9243 0022 0DF10600 		add	r0, sp, #6
 9244 0026 FFF7FEFF 		bl	bno055_read_accel_z
 9245              	.LVL1088:
 9246 002a 0546     		mov	r5, r0
 9247              	.LVL1089:
2829:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9248              		.loc 1 2829 0
 9249 002c 0E4B     		ldr	r3, .L1032
 9250 002e 0120     		movs	r0, #1
 9251 0030 1B68     		ldr	r3, [r3]
 9252 0032 5B69     		ldr	r3, [r3, #20]
 9253 0034 9847     		blx	r3
 9254              	.LVL1090:
2830:Src/bno055.c  **** 				/* Convert the raw accel z to m/s2*/
 9255              		.loc 1 2830 0
 9256 0036 9DB9     		cbnz	r5, .L1026
 9257              	.LVL1091:
2833:Src/bno055.c  **** 				*accel_z_f = data_f;
 9258              		.loc 1 2833 0
 9259 0038 BDF90600 		ldrsh	r0, [sp, #6]
 9260 003c FFF7FEFF 		bl	__aeabi_i2d
 9261              	.LVL1092:
 9262 0040 0022     		movs	r2, #0
 9263 0042 0A4B     		ldr	r3, .L1032+4
 9264 0044 FFF7FEFF 		bl	__aeabi_ddiv
 9265              	.LVL1093:
2832:Src/bno055.c  **** 				(float)(reg_accel_z_s16/BNO055_ACCEL_DIV_MSQ);
 9266              		.loc 1 2832 0
 9267 0048 FFF7FEFF 		bl	__aeabi_d2f
 9268              	.LVL1094:
 9269 004c 3060     		str	r0, [r6]	@ float
2842:Src/bno055.c  **** /*!
 9270              		.loc 1 2842 0
 9271 004e 60B2     		sxtb	r0, r4
 9272 0050 02B0     		add	sp, sp, #8
 9273              	.LCFI392:
 9274              		.cfi_remember_state
 9275              		.cfi_def_cfa_offset 16
 9276              		@ sp needed
 9277 0052 70BD     		pop	{r4, r5, r6, pc}
 9278              	.LVL1095:
 9279              	.L1031:
ARM GAS  /tmp/ccVWLGiI.s 			page 305


 9280              	.LCFI393:
 9281              		.cfi_restore_state
2825:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9282              		.loc 1 2825 0
 9283 0054 2846     		mov	r0, r5
 9284 0056 FFF7FEFF 		bl	bno055_set_accel_unit
 9285              	.LVL1096:
 9286 005a 2044     		add	r0, r0, r4
 9287 005c C4B2     		uxtb	r4, r0
 9288              	.LVL1097:
 9289 005e DFE7     		b	.L1023
 9290              	.LVL1098:
 9291              	.L1026:
2839:Src/bno055.c  **** 		}
 9292              		.loc 1 2839 0
 9293 0060 FF24     		movs	r4, #255
 9294              	.LVL1099:
2842:Src/bno055.c  **** /*!
 9295              		.loc 1 2842 0
 9296 0062 60B2     		sxtb	r0, r4
 9297 0064 02B0     		add	sp, sp, #8
 9298              	.LCFI394:
 9299              		.cfi_def_cfa_offset 16
 9300              		@ sp needed
 9301 0066 70BD     		pop	{r4, r5, r6, pc}
 9302              	.LVL1100:
 9303              	.L1033:
 9304              		.align	2
 9305              	.L1032:
 9306 0068 00000000 		.word	.LANCHOR0
 9307 006c 00005940 		.word	1079574528
 9308              		.cfi_endproc
 9309              	.LFE45:
 9311              		.section	.text.bno055_convert_float_accel_z_mg,"ax",%progbits
 9312              		.align	2
 9313              		.global	bno055_convert_float_accel_z_mg
 9314              		.thumb
 9315              		.thumb_func
 9317              	bno055_convert_float_accel_z_mg:
 9318              	.LFB46:
2859:Src/bno055.c  **** 	/* Variable used to return value of
 9319              		.loc 1 2859 0
 9320              		.cfi_startproc
 9321              		@ args = 0, pretend = 0, frame = 8
 9322              		@ frame_needed = 0, uses_anonymous_args = 0
 9323              	.LVL1101:
 9324 0000 30B5     		push	{r4, r5, lr}
 9325              	.LCFI395:
 9326              		.cfi_def_cfa_offset 12
 9327              		.cfi_offset 4, -12
 9328              		.cfi_offset 5, -8
 9329              		.cfi_offset 14, -4
 9330 0002 83B0     		sub	sp, sp, #12
 9331              	.LCFI396:
 9332              		.cfi_def_cfa_offset 24
2865:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9333              		.loc 1 2865 0
ARM GAS  /tmp/ccVWLGiI.s 			page 306


 9334 0004 02AB     		add	r3, sp, #8
2863:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 9335              		.loc 1 2863 0
 9336 0006 0022     		movs	r2, #0
2865:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9337              		.loc 1 2865 0
 9338 0008 03F8032D 		strb	r2, [r3, #-3]!
2859:Src/bno055.c  **** 	/* Variable used to return value of
 9339              		.loc 1 2859 0
 9340 000c 0546     		mov	r5, r0
2868:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9341              		.loc 1 2868 0
 9342 000e 1846     		mov	r0, r3
 9343              	.LVL1102:
2863:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 9344              		.loc 1 2863 0
 9345 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 9346              	.LVL1103:
2868:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9347              		.loc 1 2868 0
 9348 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9349              	.LVL1104:
2869:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9350              		.loc 1 2869 0
 9351 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
2868:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9352              		.loc 1 2868 0
 9353 001c 0446     		mov	r4, r0
 9354              	.LVL1105:
2869:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9355              		.loc 1 2869 0
 9356 001e 012B     		cmp	r3, #1
 9357 0020 04D0     		beq	.L1035
2870:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9358              		.loc 1 2870 0
 9359 0022 0120     		movs	r0, #1
 9360 0024 FFF7FEFF 		bl	bno055_set_accel_unit
 9361              	.LVL1106:
 9362 0028 2044     		add	r0, r0, r4
 9363 002a C4B2     		uxtb	r4, r0
 9364              	.LVL1107:
 9365              	.L1035:
2871:Src/bno055.c  **** 			/* Read the accel raw z data*/
 9366              		.loc 1 2871 0
 9367 002c 64B9     		cbnz	r4, .L1038
2873:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9368              		.loc 1 2873 0
 9369 002e 0DF10600 		add	r0, sp, #6
 9370 0032 FFF7FEFF 		bl	bno055_read_accel_z
 9371              	.LVL1108:
2874:Src/bno055.c  **** 				/* Convert the raw accel x to mg*/
 9372              		.loc 1 2874 0
 9373 0036 38B9     		cbnz	r0, .L1038
 9374              	.LVL1109:
2876:Src/bno055.c  **** 				(float)(reg_accel_z_s16/BNO055_ACCEL_DIV_MG);
 9375              		.loc 1 2876 0
 9376 0038 BDF90600 		ldrsh	r0, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 307


 9377              	.LVL1110:
 9378 003c FFF7FEFF 		bl	__aeabi_i2f
 9379              	.LVL1111:
 9380 0040 2860     		str	r0, [r5]	@ float
2886:Src/bno055.c  **** /*!
 9381              		.loc 1 2886 0
 9382 0042 60B2     		sxtb	r0, r4
 9383 0044 03B0     		add	sp, sp, #12
 9384              	.LCFI397:
 9385              		.cfi_remember_state
 9386              		.cfi_def_cfa_offset 12
 9387              		@ sp needed
 9388 0046 30BD     		pop	{r4, r5, pc}
 9389              	.LVL1112:
 9390              	.L1038:
 9391              	.LCFI398:
 9392              		.cfi_restore_state
2883:Src/bno055.c  **** 		}
 9393              		.loc 1 2883 0
 9394 0048 FF24     		movs	r4, #255
 9395              	.LVL1113:
2886:Src/bno055.c  **** /*!
 9396              		.loc 1 2886 0
 9397 004a 60B2     		sxtb	r0, r4
 9398 004c 03B0     		add	sp, sp, #12
 9399              	.LCFI399:
 9400              		.cfi_def_cfa_offset 12
 9401              		@ sp needed
 9402 004e 30BD     		pop	{r4, r5, pc}
 9403              		.cfi_endproc
 9404              	.LFE46:
 9406              		.section	.text.bno055_convert_float_accel_xyz_msq,"ax",%progbits
 9407              		.align	2
 9408              		.global	bno055_convert_float_accel_xyz_msq
 9409              		.thumb
 9410              		.thumb_func
 9412              	bno055_convert_float_accel_xyz_msq:
 9413              	.LFB47:
2907:Src/bno055.c  **** 	/* Variable used to return value of
 9414              		.loc 1 2907 0
 9415              		.cfi_startproc
 9416              		@ args = 0, pretend = 0, frame = 16
 9417              		@ frame_needed = 0, uses_anonymous_args = 0
 9418              	.LVL1114:
 9419 0000 70B5     		push	{r4, r5, r6, lr}
 9420              	.LCFI400:
 9421              		.cfi_def_cfa_offset 16
 9422              		.cfi_offset 4, -16
 9423              		.cfi_offset 5, -12
 9424              		.cfi_offset 6, -8
 9425              		.cfi_offset 14, -4
 9426 0002 84B0     		sub	sp, sp, #16
 9427              	.LCFI401:
 9428              		.cfi_def_cfa_offset 32
2913:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9429              		.loc 1 2913 0
 9430 0004 04AB     		add	r3, sp, #16
ARM GAS  /tmp/ccVWLGiI.s 			page 308


2911:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 9431              		.loc 1 2911 0
 9432 0006 0024     		movs	r4, #0
2913:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9433              		.loc 1 2913 0
 9434 0008 03F8094D 		strb	r4, [r3, #-9]!
2907:Src/bno055.c  **** 	/* Variable used to return value of
 9435              		.loc 1 2907 0
 9436 000c 0646     		mov	r6, r0
2916:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9437              		.loc 1 2916 0
 9438 000e 1846     		mov	r0, r3
 9439              	.LVL1115:
2911:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 9440              		.loc 1 2911 0
 9441 0010 ADF80840 		strh	r4, [sp, #8]	@ movhi
 9442 0014 ADF80A40 		strh	r4, [sp, #10]	@ movhi
 9443 0018 ADF80C40 		strh	r4, [sp, #12]	@ movhi
2916:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9444              		.loc 1 2916 0
 9445 001c FFF7FEFF 		bl	bno055_get_accel_unit
 9446              	.LVL1116:
2917:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9447              		.loc 1 2917 0
 9448 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
2916:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9449              		.loc 1 2916 0
 9450 0024 0546     		mov	r5, r0
 9451              	.LVL1117:
2917:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9452              		.loc 1 2917 0
 9453 0026 43BB     		cbnz	r3, .L1052
 9454              	.L1044:
2919:Src/bno055.c  **** 			/* Read the accel raw xyz data*/
 9455              		.loc 1 2919 0
 9456 0028 6DBB     		cbnz	r5, .L1047
2921:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9457              		.loc 1 2921 0
 9458 002a 02A8     		add	r0, sp, #8
 9459 002c FFF7FEFF 		bl	bno055_read_accel_xyz
 9460              	.LVL1118:
2922:Src/bno055.c  **** 				/* Convert the accel raw xyz to meterpersecseq*/
 9461              		.loc 1 2922 0
 9462 0030 48BB     		cbnz	r0, .L1047
2925:Src/bno055.c  **** 				accel_xyz->y =
 9463              		.loc 1 2925 0
 9464 0032 BDF90800 		ldrsh	r0, [sp, #8]
 9465              	.LVL1119:
 9466 0036 FFF7FEFF 		bl	__aeabi_i2d
 9467              	.LVL1120:
 9468 003a 0022     		movs	r2, #0
 9469 003c 144B     		ldr	r3, .L1053
 9470 003e FFF7FEFF 		bl	__aeabi_ddiv
 9471              	.LVL1121:
 9472 0042 FFF7FEFF 		bl	__aeabi_d2f
 9473              	.LVL1122:
 9474 0046 3060     		str	r0, [r6]	@ float
ARM GAS  /tmp/ccVWLGiI.s 			page 309


2927:Src/bno055.c  **** 				accel_xyz->z =
 9475              		.loc 1 2927 0
 9476 0048 BDF90A00 		ldrsh	r0, [sp, #10]
 9477 004c FFF7FEFF 		bl	__aeabi_i2d
 9478              	.LVL1123:
 9479 0050 0022     		movs	r2, #0
 9480 0052 0F4B     		ldr	r3, .L1053
 9481 0054 FFF7FEFF 		bl	__aeabi_ddiv
 9482              	.LVL1124:
 9483 0058 FFF7FEFF 		bl	__aeabi_d2f
 9484              	.LVL1125:
 9485 005c 7060     		str	r0, [r6, #4]	@ float
2929:Src/bno055.c  **** 			} else {
 9486              		.loc 1 2929 0
 9487 005e BDF90C00 		ldrsh	r0, [sp, #12]
 9488 0062 FFF7FEFF 		bl	__aeabi_i2d
 9489              	.LVL1126:
 9490 0066 0022     		movs	r2, #0
 9491 0068 094B     		ldr	r3, .L1053
 9492 006a FFF7FEFF 		bl	__aeabi_ddiv
 9493              	.LVL1127:
 9494 006e FFF7FEFF 		bl	__aeabi_d2f
 9495              	.LVL1128:
 9496 0072 B060     		str	r0, [r6, #8]	@ float
2937:Src/bno055.c  **** /*!
 9497              		.loc 1 2937 0
 9498 0074 68B2     		sxtb	r0, r5
 9499 0076 04B0     		add	sp, sp, #16
 9500              	.LCFI402:
 9501              		.cfi_remember_state
 9502              		.cfi_def_cfa_offset 16
 9503              		@ sp needed
 9504 0078 70BD     		pop	{r4, r5, r6, pc}
 9505              	.LVL1129:
 9506              	.L1052:
 9507              	.LCFI403:
 9508              		.cfi_restore_state
2918:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9509              		.loc 1 2918 0
 9510 007a 2046     		mov	r0, r4
 9511 007c FFF7FEFF 		bl	bno055_set_accel_unit
 9512              	.LVL1130:
 9513 0080 2844     		add	r0, r0, r5
 9514 0082 C5B2     		uxtb	r5, r0
 9515              	.LVL1131:
 9516 0084 D0E7     		b	.L1044
 9517              	.LVL1132:
 9518              	.L1047:
2934:Src/bno055.c  **** 		}
 9519              		.loc 1 2934 0
 9520 0086 FF25     		movs	r5, #255
 9521              	.LVL1133:
2937:Src/bno055.c  **** /*!
 9522              		.loc 1 2937 0
 9523 0088 68B2     		sxtb	r0, r5
 9524 008a 04B0     		add	sp, sp, #16
 9525              	.LCFI404:
ARM GAS  /tmp/ccVWLGiI.s 			page 310


 9526              		.cfi_def_cfa_offset 16
 9527              		@ sp needed
 9528 008c 70BD     		pop	{r4, r5, r6, pc}
 9529              	.LVL1134:
 9530              	.L1054:
 9531 008e 00BF     		.align	2
 9532              	.L1053:
 9533 0090 00005940 		.word	1079574528
 9534              		.cfi_endproc
 9535              	.LFE47:
 9537              		.section	.text.bno055_convert_float_accel_xyz_mg,"ax",%progbits
 9538              		.align	2
 9539              		.global	bno055_convert_float_accel_xyz_mg
 9540              		.thumb
 9541              		.thumb_func
 9543              	bno055_convert_float_accel_xyz_mg:
 9544              	.LFB48:
2959:Src/bno055.c  **** 	/* Variable used to return value of
 9545              		.loc 1 2959 0
 9546              		.cfi_startproc
 9547              		@ args = 0, pretend = 0, frame = 16
 9548              		@ frame_needed = 0, uses_anonymous_args = 0
 9549              	.LVL1135:
 9550 0000 30B5     		push	{r4, r5, lr}
 9551              	.LCFI405:
 9552              		.cfi_def_cfa_offset 12
 9553              		.cfi_offset 4, -12
 9554              		.cfi_offset 5, -8
 9555              		.cfi_offset 14, -4
 9556 0002 85B0     		sub	sp, sp, #20
 9557              	.LCFI406:
 9558              		.cfi_def_cfa_offset 32
2963:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 9559              		.loc 1 2963 0
 9560 0004 0023     		movs	r3, #0
2965:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9561              		.loc 1 2965 0
 9562 0006 04AA     		add	r2, sp, #16
 9563 0008 02F8093D 		strb	r3, [r2, #-9]!
2959:Src/bno055.c  **** 	/* Variable used to return value of
 9564              		.loc 1 2959 0
 9565 000c 0546     		mov	r5, r0
2968:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9566              		.loc 1 2968 0
 9567 000e 1046     		mov	r0, r2
 9568              	.LVL1136:
2963:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 9569              		.loc 1 2963 0
 9570 0010 ADF80830 		strh	r3, [sp, #8]	@ movhi
 9571 0014 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 9572 0018 ADF80C30 		strh	r3, [sp, #12]	@ movhi
2968:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9573              		.loc 1 2968 0
 9574 001c FFF7FEFF 		bl	bno055_get_accel_unit
 9575              	.LVL1137:
2969:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9576              		.loc 1 2969 0
ARM GAS  /tmp/ccVWLGiI.s 			page 311


 9577 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
2968:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9578              		.loc 1 2968 0
 9579 0024 0446     		mov	r4, r0
 9580              	.LVL1138:
2969:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9581              		.loc 1 2969 0
 9582 0026 012B     		cmp	r3, #1
 9583 0028 04D0     		beq	.L1056
2970:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9584              		.loc 1 2970 0
 9585 002a 0120     		movs	r0, #1
 9586 002c FFF7FEFF 		bl	bno055_set_accel_unit
 9587              	.LVL1139:
 9588 0030 2044     		add	r0, r0, r4
 9589 0032 C4B2     		uxtb	r4, r0
 9590              	.LVL1140:
 9591              	.L1056:
2971:Src/bno055.c  **** 			/* Read the accel raw y data*/
 9592              		.loc 1 2971 0
 9593 0034 ACB9     		cbnz	r4, .L1059
2973:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9594              		.loc 1 2973 0
 9595 0036 02A8     		add	r0, sp, #8
 9596 0038 FFF7FEFF 		bl	bno055_read_accel_xyz
 9597              	.LVL1141:
2974:Src/bno055.c  **** 				/*Convert the accel raw xyz to millig */
 9598              		.loc 1 2974 0
 9599 003c 88B9     		cbnz	r0, .L1059
2977:Src/bno055.c  **** 				accel_xyz->y =
 9600              		.loc 1 2977 0
 9601 003e BDF90800 		ldrsh	r0, [sp, #8]
 9602              	.LVL1142:
 9603 0042 FFF7FEFF 		bl	__aeabi_i2f
 9604              	.LVL1143:
 9605 0046 2860     		str	r0, [r5]	@ float
2979:Src/bno055.c  **** 				accel_xyz->z =
 9606              		.loc 1 2979 0
 9607 0048 BDF90A00 		ldrsh	r0, [sp, #10]
 9608 004c FFF7FEFF 		bl	__aeabi_i2f
 9609              	.LVL1144:
 9610 0050 6860     		str	r0, [r5, #4]	@ float
2981:Src/bno055.c  **** 			} else {
 9611              		.loc 1 2981 0
 9612 0052 BDF90C00 		ldrsh	r0, [sp, #12]
 9613 0056 FFF7FEFF 		bl	__aeabi_i2f
 9614              	.LVL1145:
 9615 005a A860     		str	r0, [r5, #8]	@ float
2989:Src/bno055.c  **** /*!
 9616              		.loc 1 2989 0
 9617 005c 60B2     		sxtb	r0, r4
 9618 005e 05B0     		add	sp, sp, #20
 9619              	.LCFI407:
 9620              		.cfi_remember_state
 9621              		.cfi_def_cfa_offset 12
 9622              		@ sp needed
 9623 0060 30BD     		pop	{r4, r5, pc}
ARM GAS  /tmp/ccVWLGiI.s 			page 312


 9624              	.LVL1146:
 9625              	.L1059:
 9626              	.LCFI408:
 9627              		.cfi_restore_state
2986:Src/bno055.c  **** 		}
 9628              		.loc 1 2986 0
 9629 0062 FF24     		movs	r4, #255
 9630              	.LVL1147:
2989:Src/bno055.c  **** /*!
 9631              		.loc 1 2989 0
 9632 0064 60B2     		sxtb	r0, r4
 9633 0066 05B0     		add	sp, sp, #20
 9634              	.LCFI409:
 9635              		.cfi_def_cfa_offset 12
 9636              		@ sp needed
 9637 0068 30BD     		pop	{r4, r5, pc}
 9638              		.cfi_endproc
 9639              	.LFE48:
 9641 006a 00BF     		.section	.text.bno055_convert_double_accel_x_msq,"ax",%progbits
 9642              		.align	2
 9643              		.global	bno055_convert_double_accel_x_msq
 9644              		.thumb
 9645              		.thumb_func
 9647              	bno055_convert_double_accel_x_msq:
 9648              	.LFB79:
4189:Src/bno055.c  **** 	/* Variable used to return value of
 9649              		.loc 1 4189 0
 9650              		.cfi_startproc
 9651              		@ args = 0, pretend = 0, frame = 8
 9652              		@ frame_needed = 0, uses_anonymous_args = 0
 9653              	.LVL1148:
 9654 0000 70B5     		push	{r4, r5, r6, lr}
 9655              	.LCFI410:
 9656              		.cfi_def_cfa_offset 16
 9657              		.cfi_offset 4, -16
 9658              		.cfi_offset 5, -12
 9659              		.cfi_offset 6, -8
 9660              		.cfi_offset 14, -4
 9661 0002 82B0     		sub	sp, sp, #8
 9662              	.LCFI411:
 9663              		.cfi_def_cfa_offset 24
4195:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9664              		.loc 1 4195 0
 9665 0004 02AB     		add	r3, sp, #8
4193:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
 9666              		.loc 1 4193 0
 9667 0006 0025     		movs	r5, #0
4195:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9668              		.loc 1 4195 0
 9669 0008 03F8035D 		strb	r5, [r3, #-3]!
4189:Src/bno055.c  **** 	/* Variable used to return value of
 9670              		.loc 1 4189 0
 9671 000c 0646     		mov	r6, r0
4198:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9672              		.loc 1 4198 0
 9673 000e 1846     		mov	r0, r3
 9674              	.LVL1149:
ARM GAS  /tmp/ccVWLGiI.s 			page 313


4193:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
 9675              		.loc 1 4193 0
 9676 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 9677              	.LVL1150:
4198:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9678              		.loc 1 4198 0
 9679 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9680              	.LVL1151:
4199:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9681              		.loc 1 4199 0
 9682 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4198:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9683              		.loc 1 4198 0
 9684 001c 0446     		mov	r4, r0
 9685              	.LVL1152:
4199:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9686              		.loc 1 4199 0
 9687 001e 93B9     		cbnz	r3, .L1073
 9688              	.L1065:
4201:Src/bno055.c  **** 			/* Read the accel raw y data*/
 9689              		.loc 1 4201 0
 9690 0020 BCB9     		cbnz	r4, .L1068
4203:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9691              		.loc 1 4203 0
 9692 0022 0DF10600 		add	r0, sp, #6
 9693 0026 FFF7FEFF 		bl	bno055_read_accel_x
 9694              	.LVL1153:
4204:Src/bno055.c  **** 				/* Convert the raw x to m/s2 */
 9695              		.loc 1 4204 0
 9696 002a 90B9     		cbnz	r0, .L1068
 9697              	.LVL1154:
4207:Src/bno055.c  **** 				*accel_x_d = data_f;
 9698              		.loc 1 4207 0
 9699 002c BDF90600 		ldrsh	r0, [sp, #6]
 9700              	.LVL1155:
 9701 0030 FFF7FEFF 		bl	__aeabi_i2d
 9702              	.LVL1156:
4206:Src/bno055.c  **** 				(double)(reg_accel_x_s16/BNO055_ACCEL_DIV_MSQ);
 9703              		.loc 1 4206 0
 9704 0034 0022     		movs	r2, #0
 9705 0036 094B     		ldr	r3, .L1074
 9706 0038 FFF7FEFF 		bl	__aeabi_ddiv
 9707              	.LVL1157:
4208:Src/bno055.c  **** 			} else {
 9708              		.loc 1 4208 0
 9709 003c C6E90001 		strd	r0, [r6]
4216:Src/bno055.c  **** /*!
 9710              		.loc 1 4216 0
 9711 0040 60B2     		sxtb	r0, r4
 9712 0042 02B0     		add	sp, sp, #8
 9713              	.LCFI412:
 9714              		.cfi_remember_state
 9715              		.cfi_def_cfa_offset 16
 9716              		@ sp needed
 9717 0044 70BD     		pop	{r4, r5, r6, pc}
 9718              	.LVL1158:
 9719              	.L1073:
ARM GAS  /tmp/ccVWLGiI.s 			page 314


 9720              	.LCFI413:
 9721              		.cfi_restore_state
4200:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9722              		.loc 1 4200 0
 9723 0046 2846     		mov	r0, r5
 9724 0048 FFF7FEFF 		bl	bno055_set_accel_unit
 9725              	.LVL1159:
 9726 004c 2044     		add	r0, r0, r4
 9727 004e C4B2     		uxtb	r4, r0
 9728              	.LVL1160:
 9729 0050 E6E7     		b	.L1065
 9730              	.LVL1161:
 9731              	.L1068:
4213:Src/bno055.c  **** 		}
 9732              		.loc 1 4213 0
 9733 0052 FF24     		movs	r4, #255
 9734              	.LVL1162:
4216:Src/bno055.c  **** /*!
 9735              		.loc 1 4216 0
 9736 0054 60B2     		sxtb	r0, r4
 9737 0056 02B0     		add	sp, sp, #8
 9738              	.LCFI414:
 9739              		.cfi_def_cfa_offset 16
 9740              		@ sp needed
 9741 0058 70BD     		pop	{r4, r5, r6, pc}
 9742              	.LVL1163:
 9743              	.L1075:
 9744 005a 00BF     		.align	2
 9745              	.L1074:
 9746 005c 00005940 		.word	1079574528
 9747              		.cfi_endproc
 9748              	.LFE79:
 9750              		.section	.text.bno055_convert_double_accel_x_mg,"ax",%progbits
 9751              		.align	2
 9752              		.global	bno055_convert_double_accel_x_mg
 9753              		.thumb
 9754              		.thumb_func
 9756              	bno055_convert_double_accel_x_mg:
 9757              	.LFB80:
4234:Src/bno055.c  **** 	/* Variable used to return value of
 9758              		.loc 1 4234 0
 9759              		.cfi_startproc
 9760              		@ args = 0, pretend = 0, frame = 8
 9761              		@ frame_needed = 0, uses_anonymous_args = 0
 9762              	.LVL1164:
 9763 0000 30B5     		push	{r4, r5, lr}
 9764              	.LCFI415:
 9765              		.cfi_def_cfa_offset 12
 9766              		.cfi_offset 4, -12
 9767              		.cfi_offset 5, -8
 9768              		.cfi_offset 14, -4
 9769 0002 83B0     		sub	sp, sp, #12
 9770              	.LCFI416:
 9771              		.cfi_def_cfa_offset 24
4240:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9772              		.loc 1 4240 0
 9773 0004 02AB     		add	r3, sp, #8
ARM GAS  /tmp/ccVWLGiI.s 			page 315


4238:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
 9774              		.loc 1 4238 0
 9775 0006 0022     		movs	r2, #0
4240:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9776              		.loc 1 4240 0
 9777 0008 03F8032D 		strb	r2, [r3, #-3]!
4234:Src/bno055.c  **** 	/* Variable used to return value of
 9778              		.loc 1 4234 0
 9779 000c 0546     		mov	r5, r0
4243:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9780              		.loc 1 4243 0
 9781 000e 1846     		mov	r0, r3
 9782              	.LVL1165:
4238:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
 9783              		.loc 1 4238 0
 9784 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 9785              	.LVL1166:
4243:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9786              		.loc 1 4243 0
 9787 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9788              	.LVL1167:
4244:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9789              		.loc 1 4244 0
 9790 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4243:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9791              		.loc 1 4243 0
 9792 001c 0446     		mov	r4, r0
 9793              	.LVL1168:
4244:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9794              		.loc 1 4244 0
 9795 001e 012B     		cmp	r3, #1
 9796 0020 04D0     		beq	.L1077
4245:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9797              		.loc 1 4245 0
 9798 0022 0120     		movs	r0, #1
 9799 0024 FFF7FEFF 		bl	bno055_set_accel_unit
 9800              	.LVL1169:
 9801 0028 2044     		add	r0, r0, r4
 9802 002a C4B2     		uxtb	r4, r0
 9803              	.LVL1170:
 9804              	.L1077:
4246:Src/bno055.c  **** 			/* Read the accel raw y data*/
 9805              		.loc 1 4246 0
 9806 002c 6CB9     		cbnz	r4, .L1080
4248:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9807              		.loc 1 4248 0
 9808 002e 0DF10600 		add	r0, sp, #6
 9809 0032 FFF7FEFF 		bl	bno055_read_accel_x
 9810              	.LVL1171:
4249:Src/bno055.c  **** 				/* Convert the raw x to mg */
 9811              		.loc 1 4249 0
 9812 0036 40B9     		cbnz	r0, .L1080
 9813              	.LVL1172:
4251:Src/bno055.c  **** 				(double)(reg_accel_x_s16/BNO055_ACCEL_DIV_MG);
 9814              		.loc 1 4251 0
 9815 0038 BDF90600 		ldrsh	r0, [sp, #6]
 9816              	.LVL1173:
ARM GAS  /tmp/ccVWLGiI.s 			page 316


 9817 003c FFF7FEFF 		bl	__aeabi_i2d
 9818              	.LVL1174:
 9819 0040 C5E90001 		strd	r0, [r5]
4261:Src/bno055.c  **** /*!
 9820              		.loc 1 4261 0
 9821 0044 60B2     		sxtb	r0, r4
 9822 0046 03B0     		add	sp, sp, #12
 9823              	.LCFI417:
 9824              		.cfi_remember_state
 9825              		.cfi_def_cfa_offset 12
 9826              		@ sp needed
 9827 0048 30BD     		pop	{r4, r5, pc}
 9828              	.LVL1175:
 9829              	.L1080:
 9830              	.LCFI418:
 9831              		.cfi_restore_state
4258:Src/bno055.c  **** 		}
 9832              		.loc 1 4258 0
 9833 004a FF24     		movs	r4, #255
 9834              	.LVL1176:
4261:Src/bno055.c  **** /*!
 9835              		.loc 1 4261 0
 9836 004c 60B2     		sxtb	r0, r4
 9837 004e 03B0     		add	sp, sp, #12
 9838              	.LCFI419:
 9839              		.cfi_def_cfa_offset 12
 9840              		@ sp needed
 9841 0050 30BD     		pop	{r4, r5, pc}
 9842              		.cfi_endproc
 9843              	.LFE80:
 9845 0052 00BF     		.section	.text.bno055_convert_double_accel_y_msq,"ax",%progbits
 9846              		.align	2
 9847              		.global	bno055_convert_double_accel_y_msq
 9848              		.thumb
 9849              		.thumb_func
 9851              	bno055_convert_double_accel_y_msq:
 9852              	.LFB81:
4279:Src/bno055.c  **** 	/* Variable used to return value of
 9853              		.loc 1 4279 0
 9854              		.cfi_startproc
 9855              		@ args = 0, pretend = 0, frame = 8
 9856              		@ frame_needed = 0, uses_anonymous_args = 0
 9857              	.LVL1177:
 9858 0000 70B5     		push	{r4, r5, r6, lr}
 9859              	.LCFI420:
 9860              		.cfi_def_cfa_offset 16
 9861              		.cfi_offset 4, -16
 9862              		.cfi_offset 5, -12
 9863              		.cfi_offset 6, -8
 9864              		.cfi_offset 14, -4
 9865 0002 82B0     		sub	sp, sp, #8
 9866              	.LCFI421:
 9867              		.cfi_def_cfa_offset 24
4285:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9868              		.loc 1 4285 0
 9869 0004 02AB     		add	r3, sp, #8
4283:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
ARM GAS  /tmp/ccVWLGiI.s 			page 317


 9870              		.loc 1 4283 0
 9871 0006 0025     		movs	r5, #0
4285:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9872              		.loc 1 4285 0
 9873 0008 03F8035D 		strb	r5, [r3, #-3]!
4279:Src/bno055.c  **** 	/* Variable used to return value of
 9874              		.loc 1 4279 0
 9875 000c 0646     		mov	r6, r0
4288:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9876              		.loc 1 4288 0
 9877 000e 1846     		mov	r0, r3
 9878              	.LVL1178:
4283:Src/bno055.c  **** 	double data_f = BNO055_INIT_VALUE;
 9879              		.loc 1 4283 0
 9880 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 9881              	.LVL1179:
4288:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9882              		.loc 1 4288 0
 9883 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9884              	.LVL1180:
4289:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9885              		.loc 1 4289 0
 9886 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4288:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 9887              		.loc 1 4288 0
 9888 001c 0446     		mov	r4, r0
 9889              	.LVL1181:
4289:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 9890              		.loc 1 4289 0
 9891 001e 93B9     		cbnz	r3, .L1094
 9892              	.L1086:
4291:Src/bno055.c  **** 			/* Read the accel raw y data*/
 9893              		.loc 1 4291 0
 9894 0020 BCB9     		cbnz	r4, .L1089
4293:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 9895              		.loc 1 4293 0
 9896 0022 0DF10600 		add	r0, sp, #6
 9897 0026 FFF7FEFF 		bl	bno055_read_accel_y
 9898              	.LVL1182:
4294:Src/bno055.c  **** 				/* Convert the raw x to m/s2 */
 9899              		.loc 1 4294 0
 9900 002a 90B9     		cbnz	r0, .L1089
 9901              	.LVL1183:
4297:Src/bno055.c  **** 				*accel_y_d = data_f;
 9902              		.loc 1 4297 0
 9903 002c BDF90600 		ldrsh	r0, [sp, #6]
 9904              	.LVL1184:
 9905 0030 FFF7FEFF 		bl	__aeabi_i2d
 9906              	.LVL1185:
4296:Src/bno055.c  **** 				(double)(reg_accel_y_s16/BNO055_ACCEL_DIV_MSQ);
 9907              		.loc 1 4296 0
 9908 0034 0022     		movs	r2, #0
 9909 0036 094B     		ldr	r3, .L1095
 9910 0038 FFF7FEFF 		bl	__aeabi_ddiv
 9911              	.LVL1186:
4298:Src/bno055.c  **** 			} else {
 9912              		.loc 1 4298 0
ARM GAS  /tmp/ccVWLGiI.s 			page 318


 9913 003c C6E90001 		strd	r0, [r6]
4306:Src/bno055.c  **** /*!
 9914              		.loc 1 4306 0
 9915 0040 60B2     		sxtb	r0, r4
 9916 0042 02B0     		add	sp, sp, #8
 9917              	.LCFI422:
 9918              		.cfi_remember_state
 9919              		.cfi_def_cfa_offset 16
 9920              		@ sp needed
 9921 0044 70BD     		pop	{r4, r5, r6, pc}
 9922              	.LVL1187:
 9923              	.L1094:
 9924              	.LCFI423:
 9925              		.cfi_restore_state
4290:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 9926              		.loc 1 4290 0
 9927 0046 2846     		mov	r0, r5
 9928 0048 FFF7FEFF 		bl	bno055_set_accel_unit
 9929              	.LVL1188:
 9930 004c 2044     		add	r0, r0, r4
 9931 004e C4B2     		uxtb	r4, r0
 9932              	.LVL1189:
 9933 0050 E6E7     		b	.L1086
 9934              	.LVL1190:
 9935              	.L1089:
4303:Src/bno055.c  **** 		}
 9936              		.loc 1 4303 0
 9937 0052 FF24     		movs	r4, #255
 9938              	.LVL1191:
4306:Src/bno055.c  **** /*!
 9939              		.loc 1 4306 0
 9940 0054 60B2     		sxtb	r0, r4
 9941 0056 02B0     		add	sp, sp, #8
 9942              	.LCFI424:
 9943              		.cfi_def_cfa_offset 16
 9944              		@ sp needed
 9945 0058 70BD     		pop	{r4, r5, r6, pc}
 9946              	.LVL1192:
 9947              	.L1096:
 9948 005a 00BF     		.align	2
 9949              	.L1095:
 9950 005c 00005940 		.word	1079574528
 9951              		.cfi_endproc
 9952              	.LFE81:
 9954              		.section	.text.bno055_convert_double_accel_y_mg,"ax",%progbits
 9955              		.align	2
 9956              		.global	bno055_convert_double_accel_y_mg
 9957              		.thumb
 9958              		.thumb_func
 9960              	bno055_convert_double_accel_y_mg:
 9961              	.LFB82:
4323:Src/bno055.c  **** 	/* Variable used to return value of
 9962              		.loc 1 4323 0
 9963              		.cfi_startproc
 9964              		@ args = 0, pretend = 0, frame = 8
 9965              		@ frame_needed = 0, uses_anonymous_args = 0
 9966              	.LVL1193:
ARM GAS  /tmp/ccVWLGiI.s 			page 319


 9967 0000 30B5     		push	{r4, r5, lr}
 9968              	.LCFI425:
 9969              		.cfi_def_cfa_offset 12
 9970              		.cfi_offset 4, -12
 9971              		.cfi_offset 5, -8
 9972              		.cfi_offset 14, -4
 9973 0002 83B0     		sub	sp, sp, #12
 9974              	.LCFI426:
 9975              		.cfi_def_cfa_offset 24
4329:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9976              		.loc 1 4329 0
 9977 0004 02AB     		add	r3, sp, #8
4327:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 9978              		.loc 1 4327 0
 9979 0006 0022     		movs	r2, #0
4329:Src/bno055.c  **** 	/* Read the current accel unit and set the
 9980              		.loc 1 4329 0
 9981 0008 03F8032D 		strb	r2, [r3, #-3]!
4323:Src/bno055.c  **** 	/* Variable used to return value of
 9982              		.loc 1 4323 0
 9983 000c 0546     		mov	r5, r0
4332:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9984              		.loc 1 4332 0
 9985 000e 1846     		mov	r0, r3
 9986              	.LVL1194:
4327:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 9987              		.loc 1 4327 0
 9988 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 9989              	.LVL1195:
4332:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9990              		.loc 1 4332 0
 9991 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 9992              	.LVL1196:
4333:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9993              		.loc 1 4333 0
 9994 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4332:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 9995              		.loc 1 4332 0
 9996 001c 0446     		mov	r4, r0
 9997              	.LVL1197:
4333:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 9998              		.loc 1 4333 0
 9999 001e 012B     		cmp	r3, #1
 10000 0020 04D0     		beq	.L1098
4334:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10001              		.loc 1 4334 0
 10002 0022 0120     		movs	r0, #1
 10003 0024 FFF7FEFF 		bl	bno055_set_accel_unit
 10004              	.LVL1198:
 10005 0028 2044     		add	r0, r0, r4
 10006 002a C4B2     		uxtb	r4, r0
 10007              	.LVL1199:
 10008              	.L1098:
4335:Src/bno055.c  **** 			/* Read the accel raw y data*/
 10009              		.loc 1 4335 0
 10010 002c 6CB9     		cbnz	r4, .L1101
4337:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 320


 10011              		.loc 1 4337 0
 10012 002e 0DF10600 		add	r0, sp, #6
 10013 0032 FFF7FEFF 		bl	bno055_read_accel_y
 10014              	.LVL1200:
4338:Src/bno055.c  **** 				/* Convert the raw y to mg */
 10015              		.loc 1 4338 0
 10016 0036 40B9     		cbnz	r0, .L1101
 10017              	.LVL1201:
4340:Src/bno055.c  **** 				(double)(reg_accel_y_s16/BNO055_ACCEL_DIV_MG);
 10018              		.loc 1 4340 0
 10019 0038 BDF90600 		ldrsh	r0, [sp, #6]
 10020              	.LVL1202:
 10021 003c FFF7FEFF 		bl	__aeabi_i2d
 10022              	.LVL1203:
 10023 0040 C5E90001 		strd	r0, [r5]
4350:Src/bno055.c  **** /*!
 10024              		.loc 1 4350 0
 10025 0044 60B2     		sxtb	r0, r4
 10026 0046 03B0     		add	sp, sp, #12
 10027              	.LCFI427:
 10028              		.cfi_remember_state
 10029              		.cfi_def_cfa_offset 12
 10030              		@ sp needed
 10031 0048 30BD     		pop	{r4, r5, pc}
 10032              	.LVL1204:
 10033              	.L1101:
 10034              	.LCFI428:
 10035              		.cfi_restore_state
4347:Src/bno055.c  **** 		}
 10036              		.loc 1 4347 0
 10037 004a FF24     		movs	r4, #255
 10038              	.LVL1205:
4350:Src/bno055.c  **** /*!
 10039              		.loc 1 4350 0
 10040 004c 60B2     		sxtb	r0, r4
 10041 004e 03B0     		add	sp, sp, #12
 10042              	.LCFI429:
 10043              		.cfi_def_cfa_offset 12
 10044              		@ sp needed
 10045 0050 30BD     		pop	{r4, r5, pc}
 10046              		.cfi_endproc
 10047              	.LFE82:
 10049 0052 00BF     		.section	.text.bno055_convert_double_accel_z_msq,"ax",%progbits
 10050              		.align	2
 10051              		.global	bno055_convert_double_accel_z_msq
 10052              		.thumb
 10053              		.thumb_func
 10055              	bno055_convert_double_accel_z_msq:
 10056              	.LFB83:
4365:Src/bno055.c  **** 	/* Variable used to return value of
 10057              		.loc 1 4365 0
 10058              		.cfi_startproc
 10059              		@ args = 0, pretend = 0, frame = 8
 10060              		@ frame_needed = 0, uses_anonymous_args = 0
 10061              	.LVL1206:
 10062 0000 70B5     		push	{r4, r5, r6, lr}
 10063              	.LCFI430:
ARM GAS  /tmp/ccVWLGiI.s 			page 321


 10064              		.cfi_def_cfa_offset 16
 10065              		.cfi_offset 4, -16
 10066              		.cfi_offset 5, -12
 10067              		.cfi_offset 6, -8
 10068              		.cfi_offset 14, -4
 10069 0002 82B0     		sub	sp, sp, #8
 10070              	.LCFI431:
 10071              		.cfi_def_cfa_offset 24
4371:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10072              		.loc 1 4371 0
 10073 0004 02AB     		add	r3, sp, #8
4369:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 10074              		.loc 1 4369 0
 10075 0006 0025     		movs	r5, #0
4371:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10076              		.loc 1 4371 0
 10077 0008 03F8035D 		strb	r5, [r3, #-3]!
4365:Src/bno055.c  **** 	/* Variable used to return value of
 10078              		.loc 1 4365 0
 10079 000c 0646     		mov	r6, r0
4374:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 10080              		.loc 1 4374 0
 10081 000e 1846     		mov	r0, r3
 10082              	.LVL1207:
4369:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 10083              		.loc 1 4369 0
 10084 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 10085              	.LVL1208:
4374:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 10086              		.loc 1 4374 0
 10087 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 10088              	.LVL1209:
4375:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 10089              		.loc 1 4375 0
 10090 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4374:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 10091              		.loc 1 4374 0
 10092 001c 0446     		mov	r4, r0
 10093              	.LVL1210:
4375:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 10094              		.loc 1 4375 0
 10095 001e 93B9     		cbnz	r3, .L1115
 10096              	.L1107:
4377:Src/bno055.c  **** 			/* Read the accel raw z data*/
 10097              		.loc 1 4377 0
 10098 0020 BCB9     		cbnz	r4, .L1110
4379:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10099              		.loc 1 4379 0
 10100 0022 0DF10600 		add	r0, sp, #6
 10101 0026 FFF7FEFF 		bl	bno055_read_accel_z
 10102              	.LVL1211:
4380:Src/bno055.c  **** 				/* Convert the raw z to m/s2 */
 10103              		.loc 1 4380 0
 10104 002a 90B9     		cbnz	r0, .L1110
 10105              	.LVL1212:
4383:Src/bno055.c  **** 				*accel_z_d = data_d;
 10106              		.loc 1 4383 0
ARM GAS  /tmp/ccVWLGiI.s 			page 322


 10107 002c BDF90600 		ldrsh	r0, [sp, #6]
 10108              	.LVL1213:
 10109 0030 FFF7FEFF 		bl	__aeabi_i2d
 10110              	.LVL1214:
4382:Src/bno055.c  **** 				(double)(reg_accel_z_s16/BNO055_ACCEL_DIV_MSQ);
 10111              		.loc 1 4382 0
 10112 0034 0022     		movs	r2, #0
 10113 0036 094B     		ldr	r3, .L1116
 10114 0038 FFF7FEFF 		bl	__aeabi_ddiv
 10115              	.LVL1215:
4384:Src/bno055.c  **** 			} else {
 10116              		.loc 1 4384 0
 10117 003c C6E90001 		strd	r0, [r6]
4392:Src/bno055.c  **** /*!
 10118              		.loc 1 4392 0
 10119 0040 60B2     		sxtb	r0, r4
 10120 0042 02B0     		add	sp, sp, #8
 10121              	.LCFI432:
 10122              		.cfi_remember_state
 10123              		.cfi_def_cfa_offset 16
 10124              		@ sp needed
 10125 0044 70BD     		pop	{r4, r5, r6, pc}
 10126              	.LVL1216:
 10127              	.L1115:
 10128              	.LCFI433:
 10129              		.cfi_restore_state
4376:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10130              		.loc 1 4376 0
 10131 0046 2846     		mov	r0, r5
 10132 0048 FFF7FEFF 		bl	bno055_set_accel_unit
 10133              	.LVL1217:
 10134 004c 2044     		add	r0, r0, r4
 10135 004e C4B2     		uxtb	r4, r0
 10136              	.LVL1218:
 10137 0050 E6E7     		b	.L1107
 10138              	.LVL1219:
 10139              	.L1110:
4389:Src/bno055.c  **** 		}
 10140              		.loc 1 4389 0
 10141 0052 FF24     		movs	r4, #255
 10142              	.LVL1220:
4392:Src/bno055.c  **** /*!
 10143              		.loc 1 4392 0
 10144 0054 60B2     		sxtb	r0, r4
 10145 0056 02B0     		add	sp, sp, #8
 10146              	.LCFI434:
 10147              		.cfi_def_cfa_offset 16
 10148              		@ sp needed
 10149 0058 70BD     		pop	{r4, r5, r6, pc}
 10150              	.LVL1221:
 10151              	.L1117:
 10152 005a 00BF     		.align	2
 10153              	.L1116:
 10154 005c 00005940 		.word	1079574528
 10155              		.cfi_endproc
 10156              	.LFE83:
 10158              		.section	.text.bno055_convert_double_accel_z_mg,"ax",%progbits
ARM GAS  /tmp/ccVWLGiI.s 			page 323


 10159              		.align	2
 10160              		.global	bno055_convert_double_accel_z_mg
 10161              		.thumb
 10162              		.thumb_func
 10164              	bno055_convert_double_accel_z_mg:
 10165              	.LFB84:
4408:Src/bno055.c  **** 	/* Variable used to return value of
 10166              		.loc 1 4408 0
 10167              		.cfi_startproc
 10168              		@ args = 0, pretend = 0, frame = 8
 10169              		@ frame_needed = 0, uses_anonymous_args = 0
 10170              	.LVL1222:
 10171 0000 30B5     		push	{r4, r5, lr}
 10172              	.LCFI435:
 10173              		.cfi_def_cfa_offset 12
 10174              		.cfi_offset 4, -12
 10175              		.cfi_offset 5, -8
 10176              		.cfi_offset 14, -4
 10177 0002 83B0     		sub	sp, sp, #12
 10178              	.LCFI436:
 10179              		.cfi_def_cfa_offset 24
4414:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10180              		.loc 1 4414 0
 10181 0004 02AB     		add	r3, sp, #8
4412:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 10182              		.loc 1 4412 0
 10183 0006 0022     		movs	r2, #0
4414:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10184              		.loc 1 4414 0
 10185 0008 03F8032D 		strb	r2, [r3, #-3]!
4408:Src/bno055.c  **** 	/* Variable used to return value of
 10186              		.loc 1 4408 0
 10187 000c 0546     		mov	r5, r0
4417:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 10188              		.loc 1 4417 0
 10189 000e 1846     		mov	r0, r3
 10190              	.LVL1223:
4412:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 10191              		.loc 1 4412 0
 10192 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 10193              	.LVL1224:
4417:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 10194              		.loc 1 4417 0
 10195 0014 FFF7FEFF 		bl	bno055_get_accel_unit
 10196              	.LVL1225:
4418:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 10197              		.loc 1 4418 0
 10198 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4417:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 10199              		.loc 1 4417 0
 10200 001c 0446     		mov	r4, r0
 10201              	.LVL1226:
4418:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 10202              		.loc 1 4418 0
 10203 001e 012B     		cmp	r3, #1
 10204 0020 04D0     		beq	.L1119
4419:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 324


 10205              		.loc 1 4419 0
 10206 0022 0120     		movs	r0, #1
 10207 0024 FFF7FEFF 		bl	bno055_set_accel_unit
 10208              	.LVL1227:
 10209 0028 2044     		add	r0, r0, r4
 10210 002a C4B2     		uxtb	r4, r0
 10211              	.LVL1228:
 10212              	.L1119:
4420:Src/bno055.c  **** 			/* Read the accel raw z data*/
 10213              		.loc 1 4420 0
 10214 002c 6CB9     		cbnz	r4, .L1122
4422:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10215              		.loc 1 4422 0
 10216 002e 0DF10600 		add	r0, sp, #6
 10217 0032 FFF7FEFF 		bl	bno055_read_accel_z
 10218              	.LVL1229:
4423:Src/bno055.c  **** 				/* Convert the raw z to mg */
 10219              		.loc 1 4423 0
 10220 0036 40B9     		cbnz	r0, .L1122
 10221              	.LVL1230:
4425:Src/bno055.c  **** 				(double)(reg_accel_z_s16/BNO055_ACCEL_DIV_MG);
 10222              		.loc 1 4425 0
 10223 0038 BDF90600 		ldrsh	r0, [sp, #6]
 10224              	.LVL1231:
 10225 003c FFF7FEFF 		bl	__aeabi_i2d
 10226              	.LVL1232:
 10227 0040 C5E90001 		strd	r0, [r5]
4435:Src/bno055.c  **** /*!
 10228              		.loc 1 4435 0
 10229 0044 60B2     		sxtb	r0, r4
 10230 0046 03B0     		add	sp, sp, #12
 10231              	.LCFI437:
 10232              		.cfi_remember_state
 10233              		.cfi_def_cfa_offset 12
 10234              		@ sp needed
 10235 0048 30BD     		pop	{r4, r5, pc}
 10236              	.LVL1233:
 10237              	.L1122:
 10238              	.LCFI438:
 10239              		.cfi_restore_state
4432:Src/bno055.c  **** 		}
 10240              		.loc 1 4432 0
 10241 004a FF24     		movs	r4, #255
 10242              	.LVL1234:
4435:Src/bno055.c  **** /*!
 10243              		.loc 1 4435 0
 10244 004c 60B2     		sxtb	r0, r4
 10245 004e 03B0     		add	sp, sp, #12
 10246              	.LCFI439:
 10247              		.cfi_def_cfa_offset 12
 10248              		@ sp needed
 10249 0050 30BD     		pop	{r4, r5, pc}
 10250              		.cfi_endproc
 10251              	.LFE84:
 10253 0052 00BF     		.section	.text.bno055_convert_double_accel_xyz_msq,"ax",%progbits
 10254              		.align	2
 10255              		.global	bno055_convert_double_accel_xyz_msq
ARM GAS  /tmp/ccVWLGiI.s 			page 325


 10256              		.thumb
 10257              		.thumb_func
 10259              	bno055_convert_double_accel_xyz_msq:
 10260              	.LFB85:
4457:Src/bno055.c  **** 	/* Variable used to return value of
 10261              		.loc 1 4457 0
 10262              		.cfi_startproc
 10263              		@ args = 0, pretend = 0, frame = 16
 10264              		@ frame_needed = 0, uses_anonymous_args = 0
 10265              	.LVL1235:
 10266 0000 70B5     		push	{r4, r5, r6, lr}
 10267              	.LCFI440:
 10268              		.cfi_def_cfa_offset 16
 10269              		.cfi_offset 4, -16
 10270              		.cfi_offset 5, -12
 10271              		.cfi_offset 6, -8
 10272              		.cfi_offset 14, -4
 10273 0002 84B0     		sub	sp, sp, #16
 10274              	.LCFI441:
 10275              		.cfi_def_cfa_offset 32
4463:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10276              		.loc 1 4463 0
 10277 0004 04AB     		add	r3, sp, #16
4461:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 10278              		.loc 1 4461 0
 10279 0006 0024     		movs	r4, #0
4463:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10280              		.loc 1 4463 0
 10281 0008 03F8094D 		strb	r4, [r3, #-9]!
4457:Src/bno055.c  **** 	/* Variable used to return value of
 10282              		.loc 1 4457 0
 10283 000c 0646     		mov	r6, r0
4466:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 10284              		.loc 1 4466 0
 10285 000e 1846     		mov	r0, r3
 10286              	.LVL1236:
4461:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 10287              		.loc 1 4461 0
 10288 0010 ADF80840 		strh	r4, [sp, #8]	@ movhi
 10289 0014 ADF80A40 		strh	r4, [sp, #10]	@ movhi
 10290 0018 ADF80C40 		strh	r4, [sp, #12]	@ movhi
4466:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 10291              		.loc 1 4466 0
 10292 001c FFF7FEFF 		bl	bno055_get_accel_unit
 10293              	.LVL1237:
4467:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 10294              		.loc 1 4467 0
 10295 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
4466:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MSQ)
 10296              		.loc 1 4466 0
 10297 0024 0546     		mov	r5, r0
 10298              	.LVL1238:
4467:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MSQ);
 10299              		.loc 1 4467 0
 10300 0026 2BBB     		cbnz	r3, .L1136
 10301              	.L1128:
4469:Src/bno055.c  **** 			/* Read the accel raw xyz data*/
ARM GAS  /tmp/ccVWLGiI.s 			page 326


 10302              		.loc 1 4469 0
 10303 0028 55BB     		cbnz	r5, .L1131
4471:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10304              		.loc 1 4471 0
 10305 002a 02A8     		add	r0, sp, #8
 10306 002c FFF7FEFF 		bl	bno055_read_accel_xyz
 10307              	.LVL1239:
4472:Src/bno055.c  **** 				/* Convert raw xyz to m/s2*/
 10308              		.loc 1 4472 0
 10309 0030 30BB     		cbnz	r0, .L1131
4475:Src/bno055.c  **** 				accel_xyz->y =
 10310              		.loc 1 4475 0
 10311 0032 BDF90800 		ldrsh	r0, [sp, #8]
 10312              	.LVL1240:
 10313 0036 FFF7FEFF 		bl	__aeabi_i2d
 10314              	.LVL1241:
 10315 003a 0022     		movs	r2, #0
 10316 003c 124B     		ldr	r3, .L1137
 10317 003e FFF7FEFF 		bl	__aeabi_ddiv
 10318              	.LVL1242:
4474:Src/bno055.c  **** 				(double)(reg_accel_xyz.x/BNO055_ACCEL_DIV_MSQ);
 10319              		.loc 1 4474 0
 10320 0042 C6E90001 		strd	r0, [r6]
4477:Src/bno055.c  **** 				accel_xyz->z =
 10321              		.loc 1 4477 0
 10322 0046 BDF90A00 		ldrsh	r0, [sp, #10]
 10323 004a FFF7FEFF 		bl	__aeabi_i2d
 10324              	.LVL1243:
 10325 004e 0022     		movs	r2, #0
 10326 0050 0D4B     		ldr	r3, .L1137
 10327 0052 FFF7FEFF 		bl	__aeabi_ddiv
 10328              	.LVL1244:
4476:Src/bno055.c  **** 				(double)(reg_accel_xyz.y/BNO055_ACCEL_DIV_MSQ);
 10329              		.loc 1 4476 0
 10330 0056 C6E90201 		strd	r0, [r6, #8]
4479:Src/bno055.c  **** 			} else {
 10331              		.loc 1 4479 0
 10332 005a BDF90C00 		ldrsh	r0, [sp, #12]
 10333 005e FFF7FEFF 		bl	__aeabi_i2d
 10334              	.LVL1245:
 10335 0062 0022     		movs	r2, #0
 10336 0064 084B     		ldr	r3, .L1137
 10337 0066 FFF7FEFF 		bl	__aeabi_ddiv
 10338              	.LVL1246:
4478:Src/bno055.c  **** 				(double)(reg_accel_xyz.z/BNO055_ACCEL_DIV_MSQ);
 10339              		.loc 1 4478 0
 10340 006a C6E90401 		strd	r0, [r6, #16]
4487:Src/bno055.c  **** /*!
 10341              		.loc 1 4487 0
 10342 006e 68B2     		sxtb	r0, r5
 10343 0070 04B0     		add	sp, sp, #16
 10344              	.LCFI442:
 10345              		.cfi_remember_state
 10346              		.cfi_def_cfa_offset 16
 10347              		@ sp needed
 10348 0072 70BD     		pop	{r4, r5, r6, pc}
 10349              	.LVL1247:
ARM GAS  /tmp/ccVWLGiI.s 			page 327


 10350              	.L1136:
 10351              	.LCFI443:
 10352              		.cfi_restore_state
4468:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10353              		.loc 1 4468 0
 10354 0074 2046     		mov	r0, r4
 10355 0076 FFF7FEFF 		bl	bno055_set_accel_unit
 10356              	.LVL1248:
 10357 007a 2844     		add	r0, r0, r5
 10358 007c C5B2     		uxtb	r5, r0
 10359              	.LVL1249:
 10360 007e D3E7     		b	.L1128
 10361              	.LVL1250:
 10362              	.L1131:
4484:Src/bno055.c  **** 		}
 10363              		.loc 1 4484 0
 10364 0080 FF25     		movs	r5, #255
 10365              	.LVL1251:
4487:Src/bno055.c  **** /*!
 10366              		.loc 1 4487 0
 10367 0082 68B2     		sxtb	r0, r5
 10368 0084 04B0     		add	sp, sp, #16
 10369              	.LCFI444:
 10370              		.cfi_def_cfa_offset 16
 10371              		@ sp needed
 10372 0086 70BD     		pop	{r4, r5, r6, pc}
 10373              	.LVL1252:
 10374              	.L1138:
 10375              		.align	2
 10376              	.L1137:
 10377 0088 00005940 		.word	1079574528
 10378              		.cfi_endproc
 10379              	.LFE85:
 10381              		.section	.text.bno055_convert_double_accel_xyz_mg,"ax",%progbits
 10382              		.align	2
 10383              		.global	bno055_convert_double_accel_xyz_mg
 10384              		.thumb
 10385              		.thumb_func
 10387              	bno055_convert_double_accel_xyz_mg:
 10388              	.LFB86:
4508:Src/bno055.c  **** 	/* Variable used to return value of
 10389              		.loc 1 4508 0
 10390              		.cfi_startproc
 10391              		@ args = 0, pretend = 0, frame = 16
 10392              		@ frame_needed = 0, uses_anonymous_args = 0
 10393              	.LVL1253:
 10394 0000 30B5     		push	{r4, r5, lr}
 10395              	.LCFI445:
 10396              		.cfi_def_cfa_offset 12
 10397              		.cfi_offset 4, -12
 10398              		.cfi_offset 5, -8
 10399              		.cfi_offset 14, -4
 10400 0002 85B0     		sub	sp, sp, #20
 10401              	.LCFI446:
 10402              		.cfi_def_cfa_offset 32
4512:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 10403              		.loc 1 4512 0
ARM GAS  /tmp/ccVWLGiI.s 			page 328


 10404 0004 0023     		movs	r3, #0
4514:Src/bno055.c  **** 	/* Read the current accel unit and set the
 10405              		.loc 1 4514 0
 10406 0006 04AA     		add	r2, sp, #16
 10407 0008 02F8093D 		strb	r3, [r2, #-9]!
4508:Src/bno055.c  **** 	/* Variable used to return value of
 10408              		.loc 1 4508 0
 10409 000c 0546     		mov	r5, r0
4517:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 10410              		.loc 1 4517 0
 10411 000e 1046     		mov	r0, r2
 10412              	.LVL1254:
4512:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 10413              		.loc 1 4512 0
 10414 0010 ADF80830 		strh	r3, [sp, #8]	@ movhi
 10415 0014 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 10416 0018 ADF80C30 		strh	r3, [sp, #12]	@ movhi
4517:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 10417              		.loc 1 4517 0
 10418 001c FFF7FEFF 		bl	bno055_get_accel_unit
 10419              	.LVL1255:
4518:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 10420              		.loc 1 4518 0
 10421 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
4517:Src/bno055.c  **** 	if (accel_unit_u8 != BNO055_ACCEL_UNIT_MG)
 10422              		.loc 1 4517 0
 10423 0024 0446     		mov	r4, r0
 10424              	.LVL1256:
4518:Src/bno055.c  **** 		com_rslt += bno055_set_accel_unit(BNO055_ACCEL_UNIT_MG);
 10425              		.loc 1 4518 0
 10426 0026 012B     		cmp	r3, #1
 10427 0028 04D0     		beq	.L1140
4519:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10428              		.loc 1 4519 0
 10429 002a 0120     		movs	r0, #1
 10430 002c FFF7FEFF 		bl	bno055_set_accel_unit
 10431              	.LVL1257:
 10432 0030 2044     		add	r0, r0, r4
 10433 0032 C4B2     		uxtb	r4, r0
 10434              	.LVL1258:
 10435              	.L1140:
4520:Src/bno055.c  **** 			/* Read the accel raw xyz data*/
 10436              		.loc 1 4520 0
 10437 0034 C4B9     		cbnz	r4, .L1143
4522:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10438              		.loc 1 4522 0
 10439 0036 02A8     		add	r0, sp, #8
 10440 0038 FFF7FEFF 		bl	bno055_read_accel_xyz
 10441              	.LVL1259:
4523:Src/bno055.c  **** 				/* Convert raw xyz to mg*/
 10442              		.loc 1 4523 0
 10443 003c A0B9     		cbnz	r0, .L1143
4526:Src/bno055.c  **** 				accel_xyz->y =
 10444              		.loc 1 4526 0
 10445 003e BDF90800 		ldrsh	r0, [sp, #8]
 10446              	.LVL1260:
 10447 0042 FFF7FEFF 		bl	__aeabi_i2d
ARM GAS  /tmp/ccVWLGiI.s 			page 329


 10448              	.LVL1261:
 10449 0046 C5E90001 		strd	r0, [r5]
4528:Src/bno055.c  **** 				accel_xyz->z =
 10450              		.loc 1 4528 0
 10451 004a BDF90A00 		ldrsh	r0, [sp, #10]
 10452 004e FFF7FEFF 		bl	__aeabi_i2d
 10453              	.LVL1262:
 10454 0052 C5E90201 		strd	r0, [r5, #8]
4530:Src/bno055.c  **** 			} else {
 10455              		.loc 1 4530 0
 10456 0056 BDF90C00 		ldrsh	r0, [sp, #12]
 10457 005a FFF7FEFF 		bl	__aeabi_i2d
 10458              	.LVL1263:
 10459 005e C5E90401 		strd	r0, [r5, #16]
4538:Src/bno055.c  **** /*!
 10460              		.loc 1 4538 0
 10461 0062 60B2     		sxtb	r0, r4
 10462 0064 05B0     		add	sp, sp, #20
 10463              	.LCFI447:
 10464              		.cfi_remember_state
 10465              		.cfi_def_cfa_offset 12
 10466              		@ sp needed
 10467 0066 30BD     		pop	{r4, r5, pc}
 10468              	.LVL1264:
 10469              	.L1143:
 10470              	.LCFI448:
 10471              		.cfi_restore_state
4535:Src/bno055.c  **** 		}
 10472              		.loc 1 4535 0
 10473 0068 FF24     		movs	r4, #255
 10474              	.LVL1265:
4538:Src/bno055.c  **** /*!
 10475              		.loc 1 4538 0
 10476 006a 60B2     		sxtb	r0, r4
 10477 006c 05B0     		add	sp, sp, #20
 10478              	.LCFI449:
 10479              		.cfi_def_cfa_offset 12
 10480              		@ sp needed
 10481 006e 30BD     		pop	{r4, r5, pc}
 10482              		.cfi_endproc
 10483              	.LFE86:
 10485              		.section	.text.bno055_set_gyro_unit,"ax",%progbits
 10486              		.align	2
 10487              		.global	bno055_set_gyro_unit
 10488              		.thumb
 10489              		.thumb_func
 10491              	bno055_set_gyro_unit:
 10492              	.LFB136:
6711:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 10493              		.loc 1 6711 0
 10494              		.cfi_startproc
 10495              		@ args = 0, pretend = 0, frame = 8
 10496              		@ frame_needed = 0, uses_anonymous_args = 0
 10497              	.LVL1266:
 10498 0000 30B5     		push	{r4, r5, lr}
 10499              	.LCFI450:
 10500              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 330


 10501              		.cfi_offset 4, -12
 10502              		.cfi_offset 5, -8
 10503              		.cfi_offset 14, -4
6717:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 10504              		.loc 1 6717 0
 10505 0002 244C     		ldr	r4, .L1164
6711:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 10506              		.loc 1 6711 0
 10507 0004 83B0     		sub	sp, sp, #12
 10508              	.LCFI451:
 10509              		.cfi_def_cfa_offset 24
6717:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 10510              		.loc 1 6717 0
 10511 0006 2268     		ldr	r2, [r4]
6713:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 10512              		.loc 1 6713 0
 10513 0008 0023     		movs	r3, #0
 10514 000a 8DF80630 		strb	r3, [sp, #6]
6714:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 10515              		.loc 1 6714 0
 10516 000e 8DF80730 		strb	r3, [sp, #7]
 10517              	.LVL1267:
6717:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 10518              		.loc 1 6717 0
 10519 0012 002A     		cmp	r2, #0
 10520 0014 3CD0     		beq	.L1156
 10521 0016 0546     		mov	r5, r0
6723:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 10522              		.loc 1 6723 0
 10523 0018 0DF10700 		add	r0, sp, #7
 10524              	.LVL1268:
 10525 001c FFF7FEFF 		bl	bno055_get_operation_mode
 10526              	.LVL1269:
6724:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 10527              		.loc 1 6724 0
 10528 0020 38B1     		cbz	r0, .L1150
 10529              	.L1155:
6749:Src/bno055.c  **** 		}
 10530              		.loc 1 6749 0
 10531 0022 FF24     		movs	r4, #255
 10532              	.LVL1270:
 10533              	.L1151:
6752:Src/bno055.c  **** 		/* set the operation mode
 10534              		.loc 1 6752 0
 10535 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 10536 0028 30BB     		cbnz	r0, .L1163
 10537 002a 2046     		mov	r0, r4
 10538              	.LVL1271:
 10539              	.L1149:
6758:Src/bno055.c  **** /*!
 10540              		.loc 1 6758 0
 10541 002c 40B2     		sxtb	r0, r0
 10542 002e 03B0     		add	sp, sp, #12
 10543              	.LCFI452:
 10544              		.cfi_remember_state
 10545              		.cfi_def_cfa_offset 12
 10546              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 331


 10547 0030 30BD     		pop	{r4, r5, pc}
 10548              	.LVL1272:
 10549              	.L1150:
 10550              	.LCFI453:
 10551              		.cfi_restore_state
6725:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 10552              		.loc 1 6725 0
 10553 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 10554 0036 33BB     		cbnz	r3, .L1152
 10555              	.L1154:
 10556              	.LVL1273:
6730:Src/bno055.c  **** 				(p_bno055->dev_addr,
 10557              		.loc 1 6730 0
 10558 0038 2368     		ldr	r3, [r4]
 10559 003a 0DF10602 		add	r2, sp, #6
 10560 003e 1C69     		ldr	r4, [r3, #16]
 10561 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 10562 0042 3B21     		movs	r1, #59
 10563 0044 0123     		movs	r3, #1
 10564 0046 A047     		blx	r4
 10565              	.LVL1274:
 10566 0048 124B     		ldr	r3, .L1164
6734:Src/bno055.c  **** 					data_u8r =
 10567              		.loc 1 6734 0
 10568 004a 0446     		mov	r4, r0
 10569 004c 0028     		cmp	r0, #0
 10570 004e E9D1     		bne	.L1151
6735:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 10571              		.loc 1 6735 0
 10572 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
6736:Src/bno055.c  **** 					BNO055_GYRO_UNIT, gyro_unit_u8);
 10573              		.loc 1 6736 0
 10574 0054 6800     		lsls	r0, r5, #1
 10575              	.LVL1275:
6739:Src/bno055.c  **** 					(p_bno055->dev_addr,
 10576              		.loc 1 6739 0
 10577 0056 1968     		ldr	r1, [r3]
6735:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 10578              		.loc 1 6735 0
 10579 0058 00F00200 		and	r0, r0, #2
 10580 005c 22F00203 		bic	r3, r2, #2
 10581 0060 1843     		orrs	r0, r0, r3
6739:Src/bno055.c  **** 					(p_bno055->dev_addr,
 10582              		.loc 1 6739 0
 10583 0062 CC68     		ldr	r4, [r1, #12]
6735:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 10584              		.loc 1 6735 0
 10585 0064 8DF80600 		strb	r0, [sp, #6]
6739:Src/bno055.c  **** 					(p_bno055->dev_addr,
 10586              		.loc 1 6739 0
 10587 0068 0DF10602 		add	r2, sp, #6
 10588 006c 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 10589 006e 0123     		movs	r3, #1
 10590 0070 3B21     		movs	r1, #59
 10591 0072 A047     		blx	r4
 10592              	.LVL1276:
 10593 0074 0446     		mov	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 332


 10594              	.LVL1277:
 10595 0076 D5E7     		b	.L1151
 10596              	.L1163:
6755:Src/bno055.c  **** 		(prev_opmode_u8);
 10597              		.loc 1 6755 0
 10598 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 10599              	.LVL1278:
 10600 007c 2044     		add	r0, r0, r4
 10601 007e C0B2     		uxtb	r0, r0
 10602              	.LVL1279:
6758:Src/bno055.c  **** /*!
 10603              		.loc 1 6758 0
 10604 0080 40B2     		sxtb	r0, r0
 10605 0082 03B0     		add	sp, sp, #12
 10606              	.LCFI454:
 10607              		.cfi_remember_state
 10608              		.cfi_def_cfa_offset 12
 10609              		@ sp needed
 10610 0084 30BD     		pop	{r4, r5, pc}
 10611              	.LVL1280:
 10612              	.L1152:
 10613              	.LCFI455:
 10614              		.cfi_restore_state
6726:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 10615              		.loc 1 6726 0
 10616 0086 FFF7FEFF 		bl	bno055_set_operation_mode
 10617              	.LVL1281:
6728:Src/bno055.c  **** 				/* Write the gyro unit */
 10618              		.loc 1 6728 0
 10619 008a 0028     		cmp	r0, #0
 10620 008c C9D1     		bne	.L1155
 10621 008e D3E7     		b	.L1154
 10622              	.LVL1282:
 10623              	.L1156:
6718:Src/bno055.c  **** 	} else {
 10624              		.loc 1 6718 0
 10625 0090 8120     		movs	r0, #129
 10626              	.LVL1283:
 10627 0092 CBE7     		b	.L1149
 10628              	.L1165:
 10629              		.align	2
 10630              	.L1164:
 10631 0094 00000000 		.word	.LANCHOR0
 10632              		.cfi_endproc
 10633              	.LFE136:
 10635              		.section	.text.bno055_convert_float_gyro_x_dps,"ax",%progbits
 10636              		.align	2
 10637              		.global	bno055_convert_float_gyro_x_dps
 10638              		.thumb
 10639              		.thumb_func
 10641              	bno055_convert_float_gyro_x_dps:
 10642              	.LFB53:
3140:Src/bno055.c  **** 	/* Variable used to return value of
 10643              		.loc 1 3140 0
 10644              		.cfi_startproc
 10645              		@ args = 0, pretend = 0, frame = 8
 10646              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccVWLGiI.s 			page 333


 10647              	.LVL1284:
 10648 0000 70B5     		push	{r4, r5, r6, lr}
 10649              	.LCFI456:
 10650              		.cfi_def_cfa_offset 16
 10651              		.cfi_offset 4, -16
 10652              		.cfi_offset 5, -12
 10653              		.cfi_offset 6, -8
 10654              		.cfi_offset 14, -4
 10655 0002 82B0     		sub	sp, sp, #8
 10656              	.LCFI457:
 10657              		.cfi_def_cfa_offset 24
3146:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10658              		.loc 1 3146 0
 10659 0004 02AB     		add	r3, sp, #8
3144:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10660              		.loc 1 3144 0
 10661 0006 0025     		movs	r5, #0
3146:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10662              		.loc 1 3146 0
 10663 0008 03F8035D 		strb	r5, [r3, #-3]!
3140:Src/bno055.c  **** 	/* Variable used to return value of
 10664              		.loc 1 3140 0
 10665 000c 0646     		mov	r6, r0
3149:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 10666              		.loc 1 3149 0
 10667 000e 1846     		mov	r0, r3
 10668              	.LVL1285:
3144:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10669              		.loc 1 3144 0
 10670 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 10671              	.LVL1286:
3149:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 10672              		.loc 1 3149 0
 10673 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 10674              	.LVL1287:
3150:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 10675              		.loc 1 3150 0
 10676 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3149:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 10677              		.loc 1 3149 0
 10678 001c 0446     		mov	r4, r0
 10679              	.LVL1288:
3150:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 10680              		.loc 1 3150 0
 10681 001e 9BB9     		cbnz	r3, .L1175
 10682              	.L1167:
3152:Src/bno055.c  **** 			/* Read gyro raw x data */
 10683              		.loc 1 3152 0
 10684 0020 C4B9     		cbnz	r4, .L1170
3154:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10685              		.loc 1 3154 0
 10686 0022 0DF10600 		add	r0, sp, #6
 10687 0026 FFF7FEFF 		bl	bno055_read_gyro_x
 10688              	.LVL1289:
3155:Src/bno055.c  **** 				/* Convert the raw gyro x to dps*/
 10689              		.loc 1 3155 0
 10690 002a 98B9     		cbnz	r0, .L1170
ARM GAS  /tmp/ccVWLGiI.s 			page 334


 10691              	.LVL1290:
3158:Src/bno055.c  **** 				*gyro_x_f = data_f;
 10692              		.loc 1 3158 0
 10693 002c BDF90600 		ldrsh	r0, [sp, #6]
 10694              	.LVL1291:
 10695 0030 FFF7FEFF 		bl	__aeabi_i2d
 10696              	.LVL1292:
 10697 0034 0022     		movs	r2, #0
 10698 0036 094B     		ldr	r3, .L1176
 10699 0038 FFF7FEFF 		bl	__aeabi_dmul
 10700              	.LVL1293:
3157:Src/bno055.c  **** 				(float)(reg_gyro_x_s16/BNO055_GYRO_DIV_DPS);
 10701              		.loc 1 3157 0
 10702 003c FFF7FEFF 		bl	__aeabi_d2f
 10703              	.LVL1294:
 10704 0040 3060     		str	r0, [r6]	@ float
3167:Src/bno055.c  **** /*!
 10705              		.loc 1 3167 0
 10706 0042 60B2     		sxtb	r0, r4
 10707 0044 02B0     		add	sp, sp, #8
 10708              	.LCFI458:
 10709              		.cfi_remember_state
 10710              		.cfi_def_cfa_offset 16
 10711              		@ sp needed
 10712 0046 70BD     		pop	{r4, r5, r6, pc}
 10713              	.LVL1295:
 10714              	.L1175:
 10715              	.LCFI459:
 10716              		.cfi_restore_state
3151:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10717              		.loc 1 3151 0
 10718 0048 2846     		mov	r0, r5
 10719 004a FFF7FEFF 		bl	bno055_set_gyro_unit
 10720              	.LVL1296:
 10721 004e 2044     		add	r0, r0, r4
 10722 0050 C4B2     		uxtb	r4, r0
 10723              	.LVL1297:
 10724 0052 E5E7     		b	.L1167
 10725              	.LVL1298:
 10726              	.L1170:
3164:Src/bno055.c  **** 		}
 10727              		.loc 1 3164 0
 10728 0054 FF24     		movs	r4, #255
 10729              	.LVL1299:
3167:Src/bno055.c  **** /*!
 10730              		.loc 1 3167 0
 10731 0056 60B2     		sxtb	r0, r4
 10732 0058 02B0     		add	sp, sp, #8
 10733              	.LCFI460:
 10734              		.cfi_def_cfa_offset 16
 10735              		@ sp needed
 10736 005a 70BD     		pop	{r4, r5, r6, pc}
 10737              	.LVL1300:
 10738              	.L1177:
 10739              		.align	2
 10740              	.L1176:
 10741 005c 0000B03F 		.word	1068498944
ARM GAS  /tmp/ccVWLGiI.s 			page 335


 10742              		.cfi_endproc
 10743              	.LFE53:
 10745              		.section	.text.bno055_convert_float_gyro_x_rps,"ax",%progbits
 10746              		.align	2
 10747              		.global	bno055_convert_float_gyro_x_rps
 10748              		.thumb
 10749              		.thumb_func
 10751              	bno055_convert_float_gyro_x_rps:
 10752              	.LFB54:
3183:Src/bno055.c  **** 	/* Variable used to return value of
 10753              		.loc 1 3183 0
 10754              		.cfi_startproc
 10755              		@ args = 0, pretend = 0, frame = 8
 10756              		@ frame_needed = 0, uses_anonymous_args = 0
 10757              	.LVL1301:
 10758 0000 30B5     		push	{r4, r5, lr}
 10759              	.LCFI461:
 10760              		.cfi_def_cfa_offset 12
 10761              		.cfi_offset 4, -12
 10762              		.cfi_offset 5, -8
 10763              		.cfi_offset 14, -4
 10764 0002 83B0     		sub	sp, sp, #12
 10765              	.LCFI462:
 10766              		.cfi_def_cfa_offset 24
3189:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10767              		.loc 1 3189 0
 10768 0004 02AB     		add	r3, sp, #8
3187:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10769              		.loc 1 3187 0
 10770 0006 0022     		movs	r2, #0
3189:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10771              		.loc 1 3189 0
 10772 0008 03F8032D 		strb	r2, [r3, #-3]!
3183:Src/bno055.c  **** 	/* Variable used to return value of
 10773              		.loc 1 3183 0
 10774 000c 0546     		mov	r5, r0
3192:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 10775              		.loc 1 3192 0
 10776 000e 1846     		mov	r0, r3
 10777              	.LVL1302:
3187:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10778              		.loc 1 3187 0
 10779 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 10780              	.LVL1303:
3192:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 10781              		.loc 1 3192 0
 10782 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 10783              	.LVL1304:
3193:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 10784              		.loc 1 3193 0
 10785 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3192:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 10786              		.loc 1 3192 0
 10787 001c 0446     		mov	r4, r0
 10788              	.LVL1305:
3193:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 10789              		.loc 1 3193 0
ARM GAS  /tmp/ccVWLGiI.s 			page 336


 10790 001e 012B     		cmp	r3, #1
 10791 0020 04D0     		beq	.L1179
3194:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10792              		.loc 1 3194 0
 10793 0022 0120     		movs	r0, #1
 10794 0024 FFF7FEFF 		bl	bno055_set_gyro_unit
 10795              	.LVL1306:
 10796 0028 2044     		add	r0, r0, r4
 10797 002a C4B2     		uxtb	r4, r0
 10798              	.LVL1307:
 10799              	.L1179:
3195:Src/bno055.c  **** 			/* Read gyro raw x data */
 10800              		.loc 1 3195 0
 10801 002c 94B9     		cbnz	r4, .L1182
3197:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10802              		.loc 1 3197 0
 10803 002e 0DF10600 		add	r0, sp, #6
 10804 0032 FFF7FEFF 		bl	bno055_read_gyro_x
 10805              	.LVL1308:
3198:Src/bno055.c  **** 				/* Convert the raw gyro x to rps*/
 10806              		.loc 1 3198 0
 10807 0036 68B9     		cbnz	r0, .L1182
 10808              	.LVL1309:
3201:Src/bno055.c  **** 				*gyro_x_f = data_f;
 10809              		.loc 1 3201 0
 10810 0038 BDF90600 		ldrsh	r0, [sp, #6]
 10811              	.LVL1310:
 10812 003c FFF7FEFF 		bl	__aeabi_i2d
 10813              	.LVL1311:
 10814 0040 0022     		movs	r2, #0
 10815 0042 064B     		ldr	r3, .L1187
 10816 0044 FFF7FEFF 		bl	__aeabi_ddiv
 10817              	.LVL1312:
3200:Src/bno055.c  **** 				(float)(reg_gyro_x_s16/BNO055_GYRO_DIV_RPS);
 10818              		.loc 1 3200 0
 10819 0048 FFF7FEFF 		bl	__aeabi_d2f
 10820              	.LVL1313:
 10821 004c 2860     		str	r0, [r5]	@ float
3210:Src/bno055.c  **** /*!
 10822              		.loc 1 3210 0
 10823 004e 60B2     		sxtb	r0, r4
 10824 0050 03B0     		add	sp, sp, #12
 10825              	.LCFI463:
 10826              		.cfi_remember_state
 10827              		.cfi_def_cfa_offset 12
 10828              		@ sp needed
 10829 0052 30BD     		pop	{r4, r5, pc}
 10830              	.LVL1314:
 10831              	.L1182:
 10832              	.LCFI464:
 10833              		.cfi_restore_state
3207:Src/bno055.c  **** 		}
 10834              		.loc 1 3207 0
 10835 0054 FF24     		movs	r4, #255
 10836              	.LVL1315:
3210:Src/bno055.c  **** /*!
 10837              		.loc 1 3210 0
ARM GAS  /tmp/ccVWLGiI.s 			page 337


 10838 0056 60B2     		sxtb	r0, r4
 10839 0058 03B0     		add	sp, sp, #12
 10840              	.LCFI465:
 10841              		.cfi_def_cfa_offset 12
 10842              		@ sp needed
 10843 005a 30BD     		pop	{r4, r5, pc}
 10844              	.LVL1316:
 10845              	.L1188:
 10846              		.align	2
 10847              	.L1187:
 10848 005c 00208C40 		.word	1082925056
 10849              		.cfi_endproc
 10850              	.LFE54:
 10852              		.section	.text.bno055_convert_float_gyro_y_dps,"ax",%progbits
 10853              		.align	2
 10854              		.global	bno055_convert_float_gyro_y_dps
 10855              		.thumb
 10856              		.thumb_func
 10858              	bno055_convert_float_gyro_y_dps:
 10859              	.LFB55:
3226:Src/bno055.c  **** 	/* Variable used to return value of
 10860              		.loc 1 3226 0
 10861              		.cfi_startproc
 10862              		@ args = 0, pretend = 0, frame = 8
 10863              		@ frame_needed = 0, uses_anonymous_args = 0
 10864              	.LVL1317:
 10865 0000 70B5     		push	{r4, r5, r6, lr}
 10866              	.LCFI466:
 10867              		.cfi_def_cfa_offset 16
 10868              		.cfi_offset 4, -16
 10869              		.cfi_offset 5, -12
 10870              		.cfi_offset 6, -8
 10871              		.cfi_offset 14, -4
 10872 0002 82B0     		sub	sp, sp, #8
 10873              	.LCFI467:
 10874              		.cfi_def_cfa_offset 24
3232:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10875              		.loc 1 3232 0
 10876 0004 02AB     		add	r3, sp, #8
3230:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10877              		.loc 1 3230 0
 10878 0006 0025     		movs	r5, #0
3232:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10879              		.loc 1 3232 0
 10880 0008 03F8035D 		strb	r5, [r3, #-3]!
3226:Src/bno055.c  **** 	/* Variable used to return value of
 10881              		.loc 1 3226 0
 10882 000c 0646     		mov	r6, r0
3235:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 10883              		.loc 1 3235 0
 10884 000e 1846     		mov	r0, r3
 10885              	.LVL1318:
3230:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10886              		.loc 1 3230 0
 10887 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 10888              	.LVL1319:
3235:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
ARM GAS  /tmp/ccVWLGiI.s 			page 338


 10889              		.loc 1 3235 0
 10890 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 10891              	.LVL1320:
3236:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 10892              		.loc 1 3236 0
 10893 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3235:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 10894              		.loc 1 3235 0
 10895 001c 0446     		mov	r4, r0
 10896              	.LVL1321:
3236:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 10897              		.loc 1 3236 0
 10898 001e 9BB9     		cbnz	r3, .L1198
 10899              	.L1190:
3238:Src/bno055.c  **** 			/* Read gyro raw y data */
 10900              		.loc 1 3238 0
 10901 0020 C4B9     		cbnz	r4, .L1193
3240:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 10902              		.loc 1 3240 0
 10903 0022 0DF10600 		add	r0, sp, #6
 10904 0026 FFF7FEFF 		bl	bno055_read_gyro_y
 10905              	.LVL1322:
3241:Src/bno055.c  **** 				/* Convert the raw gyro x to dps*/
 10906              		.loc 1 3241 0
 10907 002a 98B9     		cbnz	r0, .L1193
 10908              	.LVL1323:
3244:Src/bno055.c  **** 				*gyro_y_f = data_f;
 10909              		.loc 1 3244 0
 10910 002c BDF90600 		ldrsh	r0, [sp, #6]
 10911              	.LVL1324:
 10912 0030 FFF7FEFF 		bl	__aeabi_i2d
 10913              	.LVL1325:
 10914 0034 0022     		movs	r2, #0
 10915 0036 094B     		ldr	r3, .L1199
 10916 0038 FFF7FEFF 		bl	__aeabi_dmul
 10917              	.LVL1326:
3243:Src/bno055.c  **** 				(float)(reg_gyro_y_s16/BNO055_GYRO_DIV_DPS);
 10918              		.loc 1 3243 0
 10919 003c FFF7FEFF 		bl	__aeabi_d2f
 10920              	.LVL1327:
 10921 0040 3060     		str	r0, [r6]	@ float
3253:Src/bno055.c  **** /*!
 10922              		.loc 1 3253 0
 10923 0042 60B2     		sxtb	r0, r4
 10924 0044 02B0     		add	sp, sp, #8
 10925              	.LCFI468:
 10926              		.cfi_remember_state
 10927              		.cfi_def_cfa_offset 16
 10928              		@ sp needed
 10929 0046 70BD     		pop	{r4, r5, r6, pc}
 10930              	.LVL1328:
 10931              	.L1198:
 10932              	.LCFI469:
 10933              		.cfi_restore_state
3237:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 10934              		.loc 1 3237 0
 10935 0048 2846     		mov	r0, r5
ARM GAS  /tmp/ccVWLGiI.s 			page 339


 10936 004a FFF7FEFF 		bl	bno055_set_gyro_unit
 10937              	.LVL1329:
 10938 004e 2044     		add	r0, r0, r4
 10939 0050 C4B2     		uxtb	r4, r0
 10940              	.LVL1330:
 10941 0052 E5E7     		b	.L1190
 10942              	.LVL1331:
 10943              	.L1193:
3250:Src/bno055.c  **** 		}
 10944              		.loc 1 3250 0
 10945 0054 FF24     		movs	r4, #255
 10946              	.LVL1332:
3253:Src/bno055.c  **** /*!
 10947              		.loc 1 3253 0
 10948 0056 60B2     		sxtb	r0, r4
 10949 0058 02B0     		add	sp, sp, #8
 10950              	.LCFI470:
 10951              		.cfi_def_cfa_offset 16
 10952              		@ sp needed
 10953 005a 70BD     		pop	{r4, r5, r6, pc}
 10954              	.LVL1333:
 10955              	.L1200:
 10956              		.align	2
 10957              	.L1199:
 10958 005c 0000B03F 		.word	1068498944
 10959              		.cfi_endproc
 10960              	.LFE55:
 10962              		.section	.text.bno055_convert_float_gyro_y_rps,"ax",%progbits
 10963              		.align	2
 10964              		.global	bno055_convert_float_gyro_y_rps
 10965              		.thumb
 10966              		.thumb_func
 10968              	bno055_convert_float_gyro_y_rps:
 10969              	.LFB56:
3270:Src/bno055.c  **** 	/* Variable used to return value of
 10970              		.loc 1 3270 0
 10971              		.cfi_startproc
 10972              		@ args = 0, pretend = 0, frame = 8
 10973              		@ frame_needed = 0, uses_anonymous_args = 0
 10974              	.LVL1334:
 10975 0000 30B5     		push	{r4, r5, lr}
 10976              	.LCFI471:
 10977              		.cfi_def_cfa_offset 12
 10978              		.cfi_offset 4, -12
 10979              		.cfi_offset 5, -8
 10980              		.cfi_offset 14, -4
 10981 0002 83B0     		sub	sp, sp, #12
 10982              	.LCFI472:
 10983              		.cfi_def_cfa_offset 24
3276:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10984              		.loc 1 3276 0
 10985 0004 02AB     		add	r3, sp, #8
3274:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10986              		.loc 1 3274 0
 10987 0006 0022     		movs	r2, #0
3276:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 10988              		.loc 1 3276 0
ARM GAS  /tmp/ccVWLGiI.s 			page 340


 10989 0008 03F8032D 		strb	r2, [r3, #-3]!
3270:Src/bno055.c  **** 	/* Variable used to return value of
 10990              		.loc 1 3270 0
 10991 000c 0546     		mov	r5, r0
3279:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 10992              		.loc 1 3279 0
 10993 000e 1846     		mov	r0, r3
 10994              	.LVL1335:
3274:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 10995              		.loc 1 3274 0
 10996 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 10997              	.LVL1336:
3279:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 10998              		.loc 1 3279 0
 10999 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11000              	.LVL1337:
3280:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11001              		.loc 1 3280 0
 11002 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3279:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11003              		.loc 1 3279 0
 11004 001c 0446     		mov	r4, r0
 11005              	.LVL1338:
3280:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11006              		.loc 1 3280 0
 11007 001e 012B     		cmp	r3, #1
 11008 0020 04D0     		beq	.L1202
3281:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11009              		.loc 1 3281 0
 11010 0022 0120     		movs	r0, #1
 11011 0024 FFF7FEFF 		bl	bno055_set_gyro_unit
 11012              	.LVL1339:
 11013 0028 2044     		add	r0, r0, r4
 11014 002a C4B2     		uxtb	r4, r0
 11015              	.LVL1340:
 11016              	.L1202:
3282:Src/bno055.c  **** 			/* Read gyro raw y data */
 11017              		.loc 1 3282 0
 11018 002c 94B9     		cbnz	r4, .L1205
3284:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11019              		.loc 1 3284 0
 11020 002e 0DF10600 		add	r0, sp, #6
 11021 0032 FFF7FEFF 		bl	bno055_read_gyro_y
 11022              	.LVL1341:
3285:Src/bno055.c  **** 				/* Convert the raw gyro x to rps*/
 11023              		.loc 1 3285 0
 11024 0036 68B9     		cbnz	r0, .L1205
 11025              	.LVL1342:
3288:Src/bno055.c  **** 				*gyro_y_f = data_f;
 11026              		.loc 1 3288 0
 11027 0038 BDF90600 		ldrsh	r0, [sp, #6]
 11028              	.LVL1343:
 11029 003c FFF7FEFF 		bl	__aeabi_i2d
 11030              	.LVL1344:
 11031 0040 0022     		movs	r2, #0
 11032 0042 064B     		ldr	r3, .L1210
 11033 0044 FFF7FEFF 		bl	__aeabi_ddiv
ARM GAS  /tmp/ccVWLGiI.s 			page 341


 11034              	.LVL1345:
3287:Src/bno055.c  **** 				(float)(reg_gyro_y_s16/BNO055_GYRO_DIV_RPS);
 11035              		.loc 1 3287 0
 11036 0048 FFF7FEFF 		bl	__aeabi_d2f
 11037              	.LVL1346:
 11038 004c 2860     		str	r0, [r5]	@ float
3297:Src/bno055.c  **** /*!
 11039              		.loc 1 3297 0
 11040 004e 60B2     		sxtb	r0, r4
 11041 0050 03B0     		add	sp, sp, #12
 11042              	.LCFI473:
 11043              		.cfi_remember_state
 11044              		.cfi_def_cfa_offset 12
 11045              		@ sp needed
 11046 0052 30BD     		pop	{r4, r5, pc}
 11047              	.LVL1347:
 11048              	.L1205:
 11049              	.LCFI474:
 11050              		.cfi_restore_state
3294:Src/bno055.c  **** 		}
 11051              		.loc 1 3294 0
 11052 0054 FF24     		movs	r4, #255
 11053              	.LVL1348:
3297:Src/bno055.c  **** /*!
 11054              		.loc 1 3297 0
 11055 0056 60B2     		sxtb	r0, r4
 11056 0058 03B0     		add	sp, sp, #12
 11057              	.LCFI475:
 11058              		.cfi_def_cfa_offset 12
 11059              		@ sp needed
 11060 005a 30BD     		pop	{r4, r5, pc}
 11061              	.LVL1349:
 11062              	.L1211:
 11063              		.align	2
 11064              	.L1210:
 11065 005c 00208C40 		.word	1082925056
 11066              		.cfi_endproc
 11067              	.LFE56:
 11069              		.section	.text.bno055_convert_float_gyro_z_dps,"ax",%progbits
 11070              		.align	2
 11071              		.global	bno055_convert_float_gyro_z_dps
 11072              		.thumb
 11073              		.thumb_func
 11075              	bno055_convert_float_gyro_z_dps:
 11076              	.LFB57:
3313:Src/bno055.c  **** 	/* Variable used to return value of
 11077              		.loc 1 3313 0
 11078              		.cfi_startproc
 11079              		@ args = 0, pretend = 0, frame = 8
 11080              		@ frame_needed = 0, uses_anonymous_args = 0
 11081              	.LVL1350:
 11082 0000 70B5     		push	{r4, r5, r6, lr}
 11083              	.LCFI476:
 11084              		.cfi_def_cfa_offset 16
 11085              		.cfi_offset 4, -16
 11086              		.cfi_offset 5, -12
 11087              		.cfi_offset 6, -8
ARM GAS  /tmp/ccVWLGiI.s 			page 342


 11088              		.cfi_offset 14, -4
 11089 0002 82B0     		sub	sp, sp, #8
 11090              	.LCFI477:
 11091              		.cfi_def_cfa_offset 24
3319:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11092              		.loc 1 3319 0
 11093 0004 02AB     		add	r3, sp, #8
3317:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 11094              		.loc 1 3317 0
 11095 0006 0025     		movs	r5, #0
3319:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11096              		.loc 1 3319 0
 11097 0008 03F8035D 		strb	r5, [r3, #-3]!
3313:Src/bno055.c  **** 	/* Variable used to return value of
 11098              		.loc 1 3313 0
 11099 000c 0646     		mov	r6, r0
3322:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11100              		.loc 1 3322 0
 11101 000e 1846     		mov	r0, r3
 11102              	.LVL1351:
3317:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 11103              		.loc 1 3317 0
 11104 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 11105              	.LVL1352:
3322:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11106              		.loc 1 3322 0
 11107 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11108              	.LVL1353:
3323:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11109              		.loc 1 3323 0
 11110 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3322:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11111              		.loc 1 3322 0
 11112 001c 0446     		mov	r4, r0
 11113              	.LVL1354:
3323:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11114              		.loc 1 3323 0
 11115 001e 9BB9     		cbnz	r3, .L1221
 11116              	.L1213:
3325:Src/bno055.c  **** 			/* Read gyro raw z data */
 11117              		.loc 1 3325 0
 11118 0020 C4B9     		cbnz	r4, .L1216
3327:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11119              		.loc 1 3327 0
 11120 0022 0DF10600 		add	r0, sp, #6
 11121 0026 FFF7FEFF 		bl	bno055_read_gyro_z
 11122              	.LVL1355:
3328:Src/bno055.c  **** 				/* Convert the raw gyro x to dps*/
 11123              		.loc 1 3328 0
 11124 002a 98B9     		cbnz	r0, .L1216
 11125              	.LVL1356:
3331:Src/bno055.c  **** 				*gyro_z_f = data_f;
 11126              		.loc 1 3331 0
 11127 002c BDF90600 		ldrsh	r0, [sp, #6]
 11128              	.LVL1357:
 11129 0030 FFF7FEFF 		bl	__aeabi_i2d
 11130              	.LVL1358:
ARM GAS  /tmp/ccVWLGiI.s 			page 343


 11131 0034 0022     		movs	r2, #0
 11132 0036 094B     		ldr	r3, .L1222
 11133 0038 FFF7FEFF 		bl	__aeabi_dmul
 11134              	.LVL1359:
3330:Src/bno055.c  **** 				(float)(reg_gyro_z_s16/BNO055_GYRO_DIV_DPS);
 11135              		.loc 1 3330 0
 11136 003c FFF7FEFF 		bl	__aeabi_d2f
 11137              	.LVL1360:
 11138 0040 3060     		str	r0, [r6]	@ float
3340:Src/bno055.c  **** /*!
 11139              		.loc 1 3340 0
 11140 0042 60B2     		sxtb	r0, r4
 11141 0044 02B0     		add	sp, sp, #8
 11142              	.LCFI478:
 11143              		.cfi_remember_state
 11144              		.cfi_def_cfa_offset 16
 11145              		@ sp needed
 11146 0046 70BD     		pop	{r4, r5, r6, pc}
 11147              	.LVL1361:
 11148              	.L1221:
 11149              	.LCFI479:
 11150              		.cfi_restore_state
3324:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11151              		.loc 1 3324 0
 11152 0048 2846     		mov	r0, r5
 11153 004a FFF7FEFF 		bl	bno055_set_gyro_unit
 11154              	.LVL1362:
 11155 004e 2044     		add	r0, r0, r4
 11156 0050 C4B2     		uxtb	r4, r0
 11157              	.LVL1363:
 11158 0052 E5E7     		b	.L1213
 11159              	.LVL1364:
 11160              	.L1216:
3337:Src/bno055.c  **** 		}
 11161              		.loc 1 3337 0
 11162 0054 FF24     		movs	r4, #255
 11163              	.LVL1365:
3340:Src/bno055.c  **** /*!
 11164              		.loc 1 3340 0
 11165 0056 60B2     		sxtb	r0, r4
 11166 0058 02B0     		add	sp, sp, #8
 11167              	.LCFI480:
 11168              		.cfi_def_cfa_offset 16
 11169              		@ sp needed
 11170 005a 70BD     		pop	{r4, r5, r6, pc}
 11171              	.LVL1366:
 11172              	.L1223:
 11173              		.align	2
 11174              	.L1222:
 11175 005c 0000B03F 		.word	1068498944
 11176              		.cfi_endproc
 11177              	.LFE57:
 11179              		.section	.text.bno055_convert_float_gyro_z_rps,"ax",%progbits
 11180              		.align	2
 11181              		.global	bno055_convert_float_gyro_z_rps
 11182              		.thumb
 11183              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 344


 11185              	bno055_convert_float_gyro_z_rps:
 11186              	.LFB58:
3356:Src/bno055.c  **** 	/* Variable used to return value of
 11187              		.loc 1 3356 0
 11188              		.cfi_startproc
 11189              		@ args = 0, pretend = 0, frame = 8
 11190              		@ frame_needed = 0, uses_anonymous_args = 0
 11191              	.LVL1367:
 11192 0000 30B5     		push	{r4, r5, lr}
 11193              	.LCFI481:
 11194              		.cfi_def_cfa_offset 12
 11195              		.cfi_offset 4, -12
 11196              		.cfi_offset 5, -8
 11197              		.cfi_offset 14, -4
 11198 0002 83B0     		sub	sp, sp, #12
 11199              	.LCFI482:
 11200              		.cfi_def_cfa_offset 24
3362:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11201              		.loc 1 3362 0
 11202 0004 02AB     		add	r3, sp, #8
3360:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 11203              		.loc 1 3360 0
 11204 0006 0022     		movs	r2, #0
3362:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11205              		.loc 1 3362 0
 11206 0008 03F8032D 		strb	r2, [r3, #-3]!
3356:Src/bno055.c  **** 	/* Variable used to return value of
 11207              		.loc 1 3356 0
 11208 000c 0546     		mov	r5, r0
3365:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11209              		.loc 1 3365 0
 11210 000e 1846     		mov	r0, r3
 11211              	.LVL1368:
3360:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 11212              		.loc 1 3360 0
 11213 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 11214              	.LVL1369:
3365:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11215              		.loc 1 3365 0
 11216 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11217              	.LVL1370:
3366:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11218              		.loc 1 3366 0
 11219 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3365:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11220              		.loc 1 3365 0
 11221 001c 0446     		mov	r4, r0
 11222              	.LVL1371:
3366:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11223              		.loc 1 3366 0
 11224 001e 012B     		cmp	r3, #1
 11225 0020 04D0     		beq	.L1225
3367:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11226              		.loc 1 3367 0
 11227 0022 0120     		movs	r0, #1
 11228 0024 FFF7FEFF 		bl	bno055_set_gyro_unit
 11229              	.LVL1372:
ARM GAS  /tmp/ccVWLGiI.s 			page 345


 11230 0028 2044     		add	r0, r0, r4
 11231 002a C4B2     		uxtb	r4, r0
 11232              	.LVL1373:
 11233              	.L1225:
3368:Src/bno055.c  **** 			/* Read gyro raw x data */
 11234              		.loc 1 3368 0
 11235 002c 94B9     		cbnz	r4, .L1228
3370:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11236              		.loc 1 3370 0
 11237 002e 0DF10600 		add	r0, sp, #6
 11238 0032 FFF7FEFF 		bl	bno055_read_gyro_z
 11239              	.LVL1374:
3371:Src/bno055.c  **** 				/* Convert the raw gyro x to rps*/
 11240              		.loc 1 3371 0
 11241 0036 68B9     		cbnz	r0, .L1228
 11242              	.LVL1375:
3374:Src/bno055.c  **** 				*gyro_z_f = data_f;
 11243              		.loc 1 3374 0
 11244 0038 BDF90600 		ldrsh	r0, [sp, #6]
 11245              	.LVL1376:
 11246 003c FFF7FEFF 		bl	__aeabi_i2d
 11247              	.LVL1377:
 11248 0040 0022     		movs	r2, #0
 11249 0042 064B     		ldr	r3, .L1233
 11250 0044 FFF7FEFF 		bl	__aeabi_ddiv
 11251              	.LVL1378:
3373:Src/bno055.c  **** 				(float)(reg_gyro_z_s16/BNO055_GYRO_DIV_RPS);
 11252              		.loc 1 3373 0
 11253 0048 FFF7FEFF 		bl	__aeabi_d2f
 11254              	.LVL1379:
 11255 004c 2860     		str	r0, [r5]	@ float
3383:Src/bno055.c  **** /*!
 11256              		.loc 1 3383 0
 11257 004e 60B2     		sxtb	r0, r4
 11258 0050 03B0     		add	sp, sp, #12
 11259              	.LCFI483:
 11260              		.cfi_remember_state
 11261              		.cfi_def_cfa_offset 12
 11262              		@ sp needed
 11263 0052 30BD     		pop	{r4, r5, pc}
 11264              	.LVL1380:
 11265              	.L1228:
 11266              	.LCFI484:
 11267              		.cfi_restore_state
3380:Src/bno055.c  **** 		}
 11268              		.loc 1 3380 0
 11269 0054 FF24     		movs	r4, #255
 11270              	.LVL1381:
3383:Src/bno055.c  **** /*!
 11271              		.loc 1 3383 0
 11272 0056 60B2     		sxtb	r0, r4
 11273 0058 03B0     		add	sp, sp, #12
 11274              	.LCFI485:
 11275              		.cfi_def_cfa_offset 12
 11276              		@ sp needed
 11277 005a 30BD     		pop	{r4, r5, pc}
 11278              	.LVL1382:
ARM GAS  /tmp/ccVWLGiI.s 			page 346


 11279              	.L1234:
 11280              		.align	2
 11281              	.L1233:
 11282 005c 00208C40 		.word	1082925056
 11283              		.cfi_endproc
 11284              	.LFE58:
 11286              		.section	.text.bno055_convert_float_gyro_xyz_dps,"ax",%progbits
 11287              		.align	2
 11288              		.global	bno055_convert_float_gyro_xyz_dps
 11289              		.thumb
 11290              		.thumb_func
 11292              	bno055_convert_float_gyro_xyz_dps:
 11293              	.LFB59:
3405:Src/bno055.c  **** 	/* Variable used to return value of
 11294              		.loc 1 3405 0
 11295              		.cfi_startproc
 11296              		@ args = 0, pretend = 0, frame = 16
 11297              		@ frame_needed = 0, uses_anonymous_args = 0
 11298              	.LVL1383:
 11299 0000 70B5     		push	{r4, r5, r6, lr}
 11300              	.LCFI486:
 11301              		.cfi_def_cfa_offset 16
 11302              		.cfi_offset 4, -16
 11303              		.cfi_offset 5, -12
 11304              		.cfi_offset 6, -8
 11305              		.cfi_offset 14, -4
 11306 0002 84B0     		sub	sp, sp, #16
 11307              	.LCFI487:
 11308              		.cfi_def_cfa_offset 32
3411:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11309              		.loc 1 3411 0
 11310 0004 04AB     		add	r3, sp, #16
3409:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 11311              		.loc 1 3409 0
 11312 0006 0024     		movs	r4, #0
3411:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11313              		.loc 1 3411 0
 11314 0008 03F8094D 		strb	r4, [r3, #-9]!
3405:Src/bno055.c  **** 	/* Variable used to return value of
 11315              		.loc 1 3405 0
 11316 000c 0646     		mov	r6, r0
3414:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11317              		.loc 1 3414 0
 11318 000e 1846     		mov	r0, r3
 11319              	.LVL1384:
3409:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 11320              		.loc 1 3409 0
 11321 0010 ADF80840 		strh	r4, [sp, #8]	@ movhi
 11322 0014 ADF80A40 		strh	r4, [sp, #10]	@ movhi
 11323 0018 ADF80C40 		strh	r4, [sp, #12]	@ movhi
3414:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11324              		.loc 1 3414 0
 11325 001c FFF7FEFF 		bl	bno055_get_gyro_unit
 11326              	.LVL1385:
3415:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11327              		.loc 1 3415 0
 11328 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 347


3414:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11329              		.loc 1 3414 0
 11330 0024 0546     		mov	r5, r0
 11331              	.LVL1386:
3415:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11332              		.loc 1 3415 0
 11333 0026 43BB     		cbnz	r3, .L1244
 11334              	.L1236:
3417:Src/bno055.c  **** 			/* Read gyro raw xyz data */
 11335              		.loc 1 3417 0
 11336 0028 6DBB     		cbnz	r5, .L1239
3419:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11337              		.loc 1 3419 0
 11338 002a 02A8     		add	r0, sp, #8
 11339 002c FFF7FEFF 		bl	bno055_read_gyro_xyz
 11340              	.LVL1387:
3420:Src/bno055.c  **** 				/* Convert gyro raw xyz to dps*/
 11341              		.loc 1 3420 0
 11342 0030 48BB     		cbnz	r0, .L1239
3423:Src/bno055.c  **** 				gyro_xyz_data->y =
 11343              		.loc 1 3423 0
 11344 0032 BDF90800 		ldrsh	r0, [sp, #8]
 11345              	.LVL1388:
 11346 0036 FFF7FEFF 		bl	__aeabi_i2d
 11347              	.LVL1389:
 11348 003a 0022     		movs	r2, #0
 11349 003c 144B     		ldr	r3, .L1245
 11350 003e FFF7FEFF 		bl	__aeabi_dmul
 11351              	.LVL1390:
 11352 0042 FFF7FEFF 		bl	__aeabi_d2f
 11353              	.LVL1391:
 11354 0046 3060     		str	r0, [r6]	@ float
3425:Src/bno055.c  **** 				gyro_xyz_data->z =
 11355              		.loc 1 3425 0
 11356 0048 BDF90A00 		ldrsh	r0, [sp, #10]
 11357 004c FFF7FEFF 		bl	__aeabi_i2d
 11358              	.LVL1392:
 11359 0050 0022     		movs	r2, #0
 11360 0052 0F4B     		ldr	r3, .L1245
 11361 0054 FFF7FEFF 		bl	__aeabi_dmul
 11362              	.LVL1393:
 11363 0058 FFF7FEFF 		bl	__aeabi_d2f
 11364              	.LVL1394:
 11365 005c 7060     		str	r0, [r6, #4]	@ float
3427:Src/bno055.c  **** 			} else {
 11366              		.loc 1 3427 0
 11367 005e BDF90C00 		ldrsh	r0, [sp, #12]
 11368 0062 FFF7FEFF 		bl	__aeabi_i2d
 11369              	.LVL1395:
 11370 0066 0022     		movs	r2, #0
 11371 0068 094B     		ldr	r3, .L1245
 11372 006a FFF7FEFF 		bl	__aeabi_dmul
 11373              	.LVL1396:
 11374 006e FFF7FEFF 		bl	__aeabi_d2f
 11375              	.LVL1397:
 11376 0072 B060     		str	r0, [r6, #8]	@ float
3435:Src/bno055.c  **** /*!
ARM GAS  /tmp/ccVWLGiI.s 			page 348


 11377              		.loc 1 3435 0
 11378 0074 68B2     		sxtb	r0, r5
 11379 0076 04B0     		add	sp, sp, #16
 11380              	.LCFI488:
 11381              		.cfi_remember_state
 11382              		.cfi_def_cfa_offset 16
 11383              		@ sp needed
 11384 0078 70BD     		pop	{r4, r5, r6, pc}
 11385              	.LVL1398:
 11386              	.L1244:
 11387              	.LCFI489:
 11388              		.cfi_restore_state
3416:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11389              		.loc 1 3416 0
 11390 007a 2046     		mov	r0, r4
 11391 007c FFF7FEFF 		bl	bno055_set_gyro_unit
 11392              	.LVL1399:
 11393 0080 2844     		add	r0, r0, r5
 11394 0082 C5B2     		uxtb	r5, r0
 11395              	.LVL1400:
 11396 0084 D0E7     		b	.L1236
 11397              	.LVL1401:
 11398              	.L1239:
3432:Src/bno055.c  **** 		}
 11399              		.loc 1 3432 0
 11400 0086 FF25     		movs	r5, #255
 11401              	.LVL1402:
3435:Src/bno055.c  **** /*!
 11402              		.loc 1 3435 0
 11403 0088 68B2     		sxtb	r0, r5
 11404 008a 04B0     		add	sp, sp, #16
 11405              	.LCFI490:
 11406              		.cfi_def_cfa_offset 16
 11407              		@ sp needed
 11408 008c 70BD     		pop	{r4, r5, r6, pc}
 11409              	.LVL1403:
 11410              	.L1246:
 11411 008e 00BF     		.align	2
 11412              	.L1245:
 11413 0090 0000B03F 		.word	1068498944
 11414              		.cfi_endproc
 11415              	.LFE59:
 11417              		.section	.text.bno055_convert_float_gyro_xyz_rps,"ax",%progbits
 11418              		.align	2
 11419              		.global	bno055_convert_float_gyro_xyz_rps
 11420              		.thumb
 11421              		.thumb_func
 11423              	bno055_convert_float_gyro_xyz_rps:
 11424              	.LFB60:
3457:Src/bno055.c  **** 	/* Variable used to return value of
 11425              		.loc 1 3457 0
 11426              		.cfi_startproc
 11427              		@ args = 0, pretend = 0, frame = 16
 11428              		@ frame_needed = 0, uses_anonymous_args = 0
 11429              	.LVL1404:
 11430 0000 30B5     		push	{r4, r5, lr}
 11431              	.LCFI491:
ARM GAS  /tmp/ccVWLGiI.s 			page 349


 11432              		.cfi_def_cfa_offset 12
 11433              		.cfi_offset 4, -12
 11434              		.cfi_offset 5, -8
 11435              		.cfi_offset 14, -4
 11436 0002 85B0     		sub	sp, sp, #20
 11437              	.LCFI492:
 11438              		.cfi_def_cfa_offset 32
3461:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 11439              		.loc 1 3461 0
 11440 0004 0023     		movs	r3, #0
3463:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11441              		.loc 1 3463 0
 11442 0006 04AA     		add	r2, sp, #16
 11443 0008 02F8093D 		strb	r3, [r2, #-9]!
3457:Src/bno055.c  **** 	/* Variable used to return value of
 11444              		.loc 1 3457 0
 11445 000c 0546     		mov	r5, r0
3466:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11446              		.loc 1 3466 0
 11447 000e 1046     		mov	r0, r2
 11448              	.LVL1405:
3461:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 11449              		.loc 1 3461 0
 11450 0010 ADF80830 		strh	r3, [sp, #8]	@ movhi
 11451 0014 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 11452 0018 ADF80C30 		strh	r3, [sp, #12]	@ movhi
3466:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11453              		.loc 1 3466 0
 11454 001c FFF7FEFF 		bl	bno055_get_gyro_unit
 11455              	.LVL1406:
3467:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11456              		.loc 1 3467 0
 11457 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
3466:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11458              		.loc 1 3466 0
 11459 0024 0446     		mov	r4, r0
 11460              	.LVL1407:
3467:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11461              		.loc 1 3467 0
 11462 0026 012B     		cmp	r3, #1
 11463 0028 04D0     		beq	.L1248
3468:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11464              		.loc 1 3468 0
 11465 002a 0120     		movs	r0, #1
 11466 002c FFF7FEFF 		bl	bno055_set_gyro_unit
 11467              	.LVL1408:
 11468 0030 2044     		add	r0, r0, r4
 11469 0032 C4B2     		uxtb	r4, r0
 11470              	.LVL1409:
 11471              	.L1248:
3469:Src/bno055.c  **** 			/* Read gyro raw xyz data */
 11472              		.loc 1 3469 0
 11473 0034 3CBB     		cbnz	r4, .L1251
3471:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11474              		.loc 1 3471 0
 11475 0036 02A8     		add	r0, sp, #8
 11476 0038 FFF7FEFF 		bl	bno055_read_gyro_xyz
ARM GAS  /tmp/ccVWLGiI.s 			page 350


 11477              	.LVL1410:
3472:Src/bno055.c  **** 				/* Convert gyro raw xyz to rps*/
 11478              		.loc 1 3472 0
 11479 003c 18BB     		cbnz	r0, .L1251
3475:Src/bno055.c  **** 				gyro_xyz_data->y =
 11480              		.loc 1 3475 0
 11481 003e BDF90800 		ldrsh	r0, [sp, #8]
 11482              	.LVL1411:
 11483 0042 FFF7FEFF 		bl	__aeabi_i2d
 11484              	.LVL1412:
 11485 0046 0022     		movs	r2, #0
 11486 0048 114B     		ldr	r3, .L1256
 11487 004a FFF7FEFF 		bl	__aeabi_ddiv
 11488              	.LVL1413:
 11489 004e FFF7FEFF 		bl	__aeabi_d2f
 11490              	.LVL1414:
 11491 0052 2860     		str	r0, [r5]	@ float
3477:Src/bno055.c  **** 				gyro_xyz_data->z =
 11492              		.loc 1 3477 0
 11493 0054 BDF90A00 		ldrsh	r0, [sp, #10]
 11494 0058 FFF7FEFF 		bl	__aeabi_i2d
 11495              	.LVL1415:
 11496 005c 0022     		movs	r2, #0
 11497 005e 0C4B     		ldr	r3, .L1256
 11498 0060 FFF7FEFF 		bl	__aeabi_ddiv
 11499              	.LVL1416:
 11500 0064 FFF7FEFF 		bl	__aeabi_d2f
 11501              	.LVL1417:
 11502 0068 6860     		str	r0, [r5, #4]	@ float
3479:Src/bno055.c  **** 			} else {
 11503              		.loc 1 3479 0
 11504 006a BDF90C00 		ldrsh	r0, [sp, #12]
 11505 006e FFF7FEFF 		bl	__aeabi_i2d
 11506              	.LVL1418:
 11507 0072 0022     		movs	r2, #0
 11508 0074 064B     		ldr	r3, .L1256
 11509 0076 FFF7FEFF 		bl	__aeabi_ddiv
 11510              	.LVL1419:
 11511 007a FFF7FEFF 		bl	__aeabi_d2f
 11512              	.LVL1420:
 11513 007e A860     		str	r0, [r5, #8]	@ float
3487:Src/bno055.c  **** /*!
 11514              		.loc 1 3487 0
 11515 0080 60B2     		sxtb	r0, r4
 11516 0082 05B0     		add	sp, sp, #20
 11517              	.LCFI493:
 11518              		.cfi_remember_state
 11519              		.cfi_def_cfa_offset 12
 11520              		@ sp needed
 11521 0084 30BD     		pop	{r4, r5, pc}
 11522              	.LVL1421:
 11523              	.L1251:
 11524              	.LCFI494:
 11525              		.cfi_restore_state
3484:Src/bno055.c  **** 		}
 11526              		.loc 1 3484 0
 11527 0086 FF24     		movs	r4, #255
ARM GAS  /tmp/ccVWLGiI.s 			page 351


 11528              	.LVL1422:
3487:Src/bno055.c  **** /*!
 11529              		.loc 1 3487 0
 11530 0088 60B2     		sxtb	r0, r4
 11531 008a 05B0     		add	sp, sp, #20
 11532              	.LCFI495:
 11533              		.cfi_def_cfa_offset 12
 11534              		@ sp needed
 11535 008c 30BD     		pop	{r4, r5, pc}
 11536              	.LVL1423:
 11537              	.L1257:
 11538 008e 00BF     		.align	2
 11539              	.L1256:
 11540 0090 00208C40 		.word	1082925056
 11541              		.cfi_endproc
 11542              	.LFE60:
 11544              		.section	.text.bno055_convert_double_gyro_x_dps,"ax",%progbits
 11545              		.align	2
 11546              		.global	bno055_convert_double_gyro_x_dps
 11547              		.thumb
 11548              		.thumb_func
 11550              	bno055_convert_double_gyro_x_dps:
 11551              	.LFB91:
4697:Src/bno055.c  **** 	/* Variable used to return value of
 11552              		.loc 1 4697 0
 11553              		.cfi_startproc
 11554              		@ args = 0, pretend = 0, frame = 8
 11555              		@ frame_needed = 0, uses_anonymous_args = 0
 11556              	.LVL1424:
 11557 0000 70B5     		push	{r4, r5, r6, lr}
 11558              	.LCFI496:
 11559              		.cfi_def_cfa_offset 16
 11560              		.cfi_offset 4, -16
 11561              		.cfi_offset 5, -12
 11562              		.cfi_offset 6, -8
 11563              		.cfi_offset 14, -4
 11564 0002 82B0     		sub	sp, sp, #8
 11565              	.LCFI497:
 11566              		.cfi_def_cfa_offset 24
4703:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11567              		.loc 1 4703 0
 11568 0004 02AB     		add	r3, sp, #8
4701:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11569              		.loc 1 4701 0
 11570 0006 0025     		movs	r5, #0
4703:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11571              		.loc 1 4703 0
 11572 0008 03F8035D 		strb	r5, [r3, #-3]!
4697:Src/bno055.c  **** 	/* Variable used to return value of
 11573              		.loc 1 4697 0
 11574 000c 0646     		mov	r6, r0
4706:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11575              		.loc 1 4706 0
 11576 000e 1846     		mov	r0, r3
 11577              	.LVL1425:
4701:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11578              		.loc 1 4701 0
ARM GAS  /tmp/ccVWLGiI.s 			page 352


 11579 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 11580              	.LVL1426:
4706:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11581              		.loc 1 4706 0
 11582 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11583              	.LVL1427:
4707:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11584              		.loc 1 4707 0
 11585 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4706:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11586              		.loc 1 4706 0
 11587 001c 0446     		mov	r4, r0
 11588              	.LVL1428:
4707:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11589              		.loc 1 4707 0
 11590 001e 93B9     		cbnz	r3, .L1267
 11591              	.L1259:
4709:Src/bno055.c  **** 			/* Read gyro raw x data */
 11592              		.loc 1 4709 0
 11593 0020 BCB9     		cbnz	r4, .L1262
4711:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11594              		.loc 1 4711 0
 11595 0022 0DF10600 		add	r0, sp, #6
 11596 0026 FFF7FEFF 		bl	bno055_read_gyro_x
 11597              	.LVL1429:
4712:Src/bno055.c  **** 				/* Convert raw gyro x to dps */
 11598              		.loc 1 4712 0
 11599 002a 90B9     		cbnz	r0, .L1262
 11600              	.LVL1430:
4715:Src/bno055.c  **** 				*gyro_x_d = data_d;
 11601              		.loc 1 4715 0
 11602 002c BDF90600 		ldrsh	r0, [sp, #6]
 11603              	.LVL1431:
 11604 0030 FFF7FEFF 		bl	__aeabi_i2d
 11605              	.LVL1432:
4714:Src/bno055.c  **** 				(double)(reg_gyro_x_s16/BNO055_GYRO_DIV_DPS);
 11606              		.loc 1 4714 0
 11607 0034 0022     		movs	r2, #0
 11608 0036 094B     		ldr	r3, .L1268
 11609 0038 FFF7FEFF 		bl	__aeabi_dmul
 11610              	.LVL1433:
4716:Src/bno055.c  **** 			} else {
 11611              		.loc 1 4716 0
 11612 003c C6E90001 		strd	r0, [r6]
4724:Src/bno055.c  **** /*!
 11613              		.loc 1 4724 0
 11614 0040 60B2     		sxtb	r0, r4
 11615 0042 02B0     		add	sp, sp, #8
 11616              	.LCFI498:
 11617              		.cfi_remember_state
 11618              		.cfi_def_cfa_offset 16
 11619              		@ sp needed
 11620 0044 70BD     		pop	{r4, r5, r6, pc}
 11621              	.LVL1434:
 11622              	.L1267:
 11623              	.LCFI499:
 11624              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 353


4708:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11625              		.loc 1 4708 0
 11626 0046 2846     		mov	r0, r5
 11627 0048 FFF7FEFF 		bl	bno055_set_gyro_unit
 11628              	.LVL1435:
 11629 004c 2044     		add	r0, r0, r4
 11630 004e C4B2     		uxtb	r4, r0
 11631              	.LVL1436:
 11632 0050 E6E7     		b	.L1259
 11633              	.LVL1437:
 11634              	.L1262:
4721:Src/bno055.c  **** 		}
 11635              		.loc 1 4721 0
 11636 0052 FF24     		movs	r4, #255
 11637              	.LVL1438:
4724:Src/bno055.c  **** /*!
 11638              		.loc 1 4724 0
 11639 0054 60B2     		sxtb	r0, r4
 11640 0056 02B0     		add	sp, sp, #8
 11641              	.LCFI500:
 11642              		.cfi_def_cfa_offset 16
 11643              		@ sp needed
 11644 0058 70BD     		pop	{r4, r5, r6, pc}
 11645              	.LVL1439:
 11646              	.L1269:
 11647 005a 00BF     		.align	2
 11648              	.L1268:
 11649 005c 0000B03F 		.word	1068498944
 11650              		.cfi_endproc
 11651              	.LFE91:
 11653              		.section	.text.bno055_convert_double_gyro_x_rps,"ax",%progbits
 11654              		.align	2
 11655              		.global	bno055_convert_double_gyro_x_rps
 11656              		.thumb
 11657              		.thumb_func
 11659              	bno055_convert_double_gyro_x_rps:
 11660              	.LFB92:
4741:Src/bno055.c  **** 	/* Variable used to return value of
 11661              		.loc 1 4741 0
 11662              		.cfi_startproc
 11663              		@ args = 0, pretend = 0, frame = 8
 11664              		@ frame_needed = 0, uses_anonymous_args = 0
 11665              	.LVL1440:
 11666 0000 30B5     		push	{r4, r5, lr}
 11667              	.LCFI501:
 11668              		.cfi_def_cfa_offset 12
 11669              		.cfi_offset 4, -12
 11670              		.cfi_offset 5, -8
 11671              		.cfi_offset 14, -4
 11672 0002 83B0     		sub	sp, sp, #12
 11673              	.LCFI502:
 11674              		.cfi_def_cfa_offset 24
4747:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11675              		.loc 1 4747 0
 11676 0004 02AB     		add	r3, sp, #8
4745:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11677              		.loc 1 4745 0
ARM GAS  /tmp/ccVWLGiI.s 			page 354


 11678 0006 0022     		movs	r2, #0
4747:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11679              		.loc 1 4747 0
 11680 0008 03F8032D 		strb	r2, [r3, #-3]!
4741:Src/bno055.c  **** 	/* Variable used to return value of
 11681              		.loc 1 4741 0
 11682 000c 0546     		mov	r5, r0
4750:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11683              		.loc 1 4750 0
 11684 000e 1846     		mov	r0, r3
 11685              	.LVL1441:
4745:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11686              		.loc 1 4745 0
 11687 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 11688              	.LVL1442:
4750:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11689              		.loc 1 4750 0
 11690 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11691              	.LVL1443:
4751:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11692              		.loc 1 4751 0
 11693 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4750:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11694              		.loc 1 4750 0
 11695 001c 0446     		mov	r4, r0
 11696              	.LVL1444:
4751:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11697              		.loc 1 4751 0
 11698 001e 012B     		cmp	r3, #1
 11699 0020 04D0     		beq	.L1271
4752:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11700              		.loc 1 4752 0
 11701 0022 0120     		movs	r0, #1
 11702 0024 FFF7FEFF 		bl	bno055_set_gyro_unit
 11703              	.LVL1445:
 11704 0028 2044     		add	r0, r0, r4
 11705 002a C4B2     		uxtb	r4, r0
 11706              	.LVL1446:
 11707              	.L1271:
4753:Src/bno055.c  **** 			/* Read gyro raw x data */
 11708              		.loc 1 4753 0
 11709 002c 8CB9     		cbnz	r4, .L1274
4755:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11710              		.loc 1 4755 0
 11711 002e 0DF10600 		add	r0, sp, #6
 11712 0032 FFF7FEFF 		bl	bno055_read_gyro_x
 11713              	.LVL1447:
4756:Src/bno055.c  **** 				/* Convert raw gyro x to rps */
 11714              		.loc 1 4756 0
 11715 0036 60B9     		cbnz	r0, .L1274
 11716              	.LVL1448:
4759:Src/bno055.c  **** 				*gyro_x_d = data_d;
 11717              		.loc 1 4759 0
 11718 0038 BDF90600 		ldrsh	r0, [sp, #6]
 11719              	.LVL1449:
 11720 003c FFF7FEFF 		bl	__aeabi_i2d
 11721              	.LVL1450:
ARM GAS  /tmp/ccVWLGiI.s 			page 355


4758:Src/bno055.c  **** 				(double)(reg_gyro_x_s16/BNO055_GYRO_DIV_RPS);
 11722              		.loc 1 4758 0
 11723 0040 0022     		movs	r2, #0
 11724 0042 064B     		ldr	r3, .L1279
 11725 0044 FFF7FEFF 		bl	__aeabi_ddiv
 11726              	.LVL1451:
4760:Src/bno055.c  **** 			} else {
 11727              		.loc 1 4760 0
 11728 0048 C5E90001 		strd	r0, [r5]
4768:Src/bno055.c  **** /*!
 11729              		.loc 1 4768 0
 11730 004c 60B2     		sxtb	r0, r4
 11731 004e 03B0     		add	sp, sp, #12
 11732              	.LCFI503:
 11733              		.cfi_remember_state
 11734              		.cfi_def_cfa_offset 12
 11735              		@ sp needed
 11736 0050 30BD     		pop	{r4, r5, pc}
 11737              	.LVL1452:
 11738              	.L1274:
 11739              	.LCFI504:
 11740              		.cfi_restore_state
4765:Src/bno055.c  **** 		}
 11741              		.loc 1 4765 0
 11742 0052 FF24     		movs	r4, #255
 11743              	.LVL1453:
4768:Src/bno055.c  **** /*!
 11744              		.loc 1 4768 0
 11745 0054 60B2     		sxtb	r0, r4
 11746 0056 03B0     		add	sp, sp, #12
 11747              	.LCFI505:
 11748              		.cfi_def_cfa_offset 12
 11749              		@ sp needed
 11750 0058 30BD     		pop	{r4, r5, pc}
 11751              	.LVL1454:
 11752              	.L1280:
 11753 005a 00BF     		.align	2
 11754              	.L1279:
 11755 005c 00208C40 		.word	1082925056
 11756              		.cfi_endproc
 11757              	.LFE92:
 11759              		.section	.text.bno055_convert_double_gyro_y_dps,"ax",%progbits
 11760              		.align	2
 11761              		.global	bno055_convert_double_gyro_y_dps
 11762              		.thumb
 11763              		.thumb_func
 11765              	bno055_convert_double_gyro_y_dps:
 11766              	.LFB93:
4785:Src/bno055.c  **** 	/* Variable used to return value of
 11767              		.loc 1 4785 0
 11768              		.cfi_startproc
 11769              		@ args = 0, pretend = 0, frame = 8
 11770              		@ frame_needed = 0, uses_anonymous_args = 0
 11771              	.LVL1455:
 11772 0000 70B5     		push	{r4, r5, r6, lr}
 11773              	.LCFI506:
 11774              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccVWLGiI.s 			page 356


 11775              		.cfi_offset 4, -16
 11776              		.cfi_offset 5, -12
 11777              		.cfi_offset 6, -8
 11778              		.cfi_offset 14, -4
 11779 0002 82B0     		sub	sp, sp, #8
 11780              	.LCFI507:
 11781              		.cfi_def_cfa_offset 24
4791:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11782              		.loc 1 4791 0
 11783 0004 02AB     		add	r3, sp, #8
4789:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11784              		.loc 1 4789 0
 11785 0006 0025     		movs	r5, #0
4791:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11786              		.loc 1 4791 0
 11787 0008 03F8035D 		strb	r5, [r3, #-3]!
4785:Src/bno055.c  **** 	/* Variable used to return value of
 11788              		.loc 1 4785 0
 11789 000c 0646     		mov	r6, r0
4794:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11790              		.loc 1 4794 0
 11791 000e 1846     		mov	r0, r3
 11792              	.LVL1456:
4789:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11793              		.loc 1 4789 0
 11794 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 11795              	.LVL1457:
4794:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11796              		.loc 1 4794 0
 11797 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11798              	.LVL1458:
4795:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11799              		.loc 1 4795 0
 11800 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4794:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 11801              		.loc 1 4794 0
 11802 001c 0446     		mov	r4, r0
 11803              	.LVL1459:
4795:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 11804              		.loc 1 4795 0
 11805 001e 93B9     		cbnz	r3, .L1290
 11806              	.L1282:
4797:Src/bno055.c  **** 			/* Read gyro raw y data */
 11807              		.loc 1 4797 0
 11808 0020 BCB9     		cbnz	r4, .L1285
4799:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11809              		.loc 1 4799 0
 11810 0022 0DF10600 		add	r0, sp, #6
 11811 0026 FFF7FEFF 		bl	bno055_read_gyro_y
 11812              	.LVL1460:
4800:Src/bno055.c  **** 				/* Convert raw gyro y to dps */
 11813              		.loc 1 4800 0
 11814 002a 90B9     		cbnz	r0, .L1285
 11815              	.LVL1461:
4803:Src/bno055.c  **** 				*gyro_y_d = data_d;
 11816              		.loc 1 4803 0
 11817 002c BDF90600 		ldrsh	r0, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 357


 11818              	.LVL1462:
 11819 0030 FFF7FEFF 		bl	__aeabi_i2d
 11820              	.LVL1463:
4802:Src/bno055.c  **** 				(double)(reg_gyro_y_s16/BNO055_GYRO_DIV_DPS);
 11821              		.loc 1 4802 0
 11822 0034 0022     		movs	r2, #0
 11823 0036 094B     		ldr	r3, .L1291
 11824 0038 FFF7FEFF 		bl	__aeabi_dmul
 11825              	.LVL1464:
4804:Src/bno055.c  **** 			} else {
 11826              		.loc 1 4804 0
 11827 003c C6E90001 		strd	r0, [r6]
4812:Src/bno055.c  **** /*!
 11828              		.loc 1 4812 0
 11829 0040 60B2     		sxtb	r0, r4
 11830 0042 02B0     		add	sp, sp, #8
 11831              	.LCFI508:
 11832              		.cfi_remember_state
 11833              		.cfi_def_cfa_offset 16
 11834              		@ sp needed
 11835 0044 70BD     		pop	{r4, r5, r6, pc}
 11836              	.LVL1465:
 11837              	.L1290:
 11838              	.LCFI509:
 11839              		.cfi_restore_state
4796:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11840              		.loc 1 4796 0
 11841 0046 2846     		mov	r0, r5
 11842 0048 FFF7FEFF 		bl	bno055_set_gyro_unit
 11843              	.LVL1466:
 11844 004c 2044     		add	r0, r0, r4
 11845 004e C4B2     		uxtb	r4, r0
 11846              	.LVL1467:
 11847 0050 E6E7     		b	.L1282
 11848              	.LVL1468:
 11849              	.L1285:
4809:Src/bno055.c  **** 		}
 11850              		.loc 1 4809 0
 11851 0052 FF24     		movs	r4, #255
 11852              	.LVL1469:
4812:Src/bno055.c  **** /*!
 11853              		.loc 1 4812 0
 11854 0054 60B2     		sxtb	r0, r4
 11855 0056 02B0     		add	sp, sp, #8
 11856              	.LCFI510:
 11857              		.cfi_def_cfa_offset 16
 11858              		@ sp needed
 11859 0058 70BD     		pop	{r4, r5, r6, pc}
 11860              	.LVL1470:
 11861              	.L1292:
 11862 005a 00BF     		.align	2
 11863              	.L1291:
 11864 005c 0000B03F 		.word	1068498944
 11865              		.cfi_endproc
 11866              	.LFE93:
 11868              		.section	.text.bno055_convert_double_gyro_y_rps,"ax",%progbits
 11869              		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 358


 11870              		.global	bno055_convert_double_gyro_y_rps
 11871              		.thumb
 11872              		.thumb_func
 11874              	bno055_convert_double_gyro_y_rps:
 11875              	.LFB94:
4829:Src/bno055.c  **** 	/* Variable used to return value of
 11876              		.loc 1 4829 0
 11877              		.cfi_startproc
 11878              		@ args = 0, pretend = 0, frame = 8
 11879              		@ frame_needed = 0, uses_anonymous_args = 0
 11880              	.LVL1471:
 11881 0000 30B5     		push	{r4, r5, lr}
 11882              	.LCFI511:
 11883              		.cfi_def_cfa_offset 12
 11884              		.cfi_offset 4, -12
 11885              		.cfi_offset 5, -8
 11886              		.cfi_offset 14, -4
 11887 0002 83B0     		sub	sp, sp, #12
 11888              	.LCFI512:
 11889              		.cfi_def_cfa_offset 24
4835:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11890              		.loc 1 4835 0
 11891 0004 02AB     		add	r3, sp, #8
4833:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11892              		.loc 1 4833 0
 11893 0006 0022     		movs	r2, #0
4835:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11894              		.loc 1 4835 0
 11895 0008 03F8032D 		strb	r2, [r3, #-3]!
4829:Src/bno055.c  **** 	/* Variable used to return value of
 11896              		.loc 1 4829 0
 11897 000c 0546     		mov	r5, r0
4838:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11898              		.loc 1 4838 0
 11899 000e 1846     		mov	r0, r3
 11900              	.LVL1472:
4833:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11901              		.loc 1 4833 0
 11902 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 11903              	.LVL1473:
4838:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11904              		.loc 1 4838 0
 11905 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 11906              	.LVL1474:
4839:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11907              		.loc 1 4839 0
 11908 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4838:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 11909              		.loc 1 4838 0
 11910 001c 0446     		mov	r4, r0
 11911              	.LVL1475:
4839:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 11912              		.loc 1 4839 0
 11913 001e 012B     		cmp	r3, #1
 11914 0020 04D0     		beq	.L1294
4840:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 11915              		.loc 1 4840 0
ARM GAS  /tmp/ccVWLGiI.s 			page 359


 11916 0022 0120     		movs	r0, #1
 11917 0024 FFF7FEFF 		bl	bno055_set_gyro_unit
 11918              	.LVL1476:
 11919 0028 2044     		add	r0, r0, r4
 11920 002a C4B2     		uxtb	r4, r0
 11921              	.LVL1477:
 11922              	.L1294:
4841:Src/bno055.c  **** 			/* Read gyro raw y data */
 11923              		.loc 1 4841 0
 11924 002c 8CB9     		cbnz	r4, .L1297
4843:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 11925              		.loc 1 4843 0
 11926 002e 0DF10600 		add	r0, sp, #6
 11927 0032 FFF7FEFF 		bl	bno055_read_gyro_y
 11928              	.LVL1478:
4844:Src/bno055.c  **** 				/* Convert raw gyro y to rps */
 11929              		.loc 1 4844 0
 11930 0036 60B9     		cbnz	r0, .L1297
 11931              	.LVL1479:
4847:Src/bno055.c  **** 				*gyro_y_d = data_d;
 11932              		.loc 1 4847 0
 11933 0038 BDF90600 		ldrsh	r0, [sp, #6]
 11934              	.LVL1480:
 11935 003c FFF7FEFF 		bl	__aeabi_i2d
 11936              	.LVL1481:
4846:Src/bno055.c  **** 				(double)(reg_gyro_y_s16/BNO055_GYRO_DIV_RPS);
 11937              		.loc 1 4846 0
 11938 0040 0022     		movs	r2, #0
 11939 0042 064B     		ldr	r3, .L1302
 11940 0044 FFF7FEFF 		bl	__aeabi_ddiv
 11941              	.LVL1482:
4848:Src/bno055.c  **** 			} else {
 11942              		.loc 1 4848 0
 11943 0048 C5E90001 		strd	r0, [r5]
4856:Src/bno055.c  **** /*!
 11944              		.loc 1 4856 0
 11945 004c 60B2     		sxtb	r0, r4
 11946 004e 03B0     		add	sp, sp, #12
 11947              	.LCFI513:
 11948              		.cfi_remember_state
 11949              		.cfi_def_cfa_offset 12
 11950              		@ sp needed
 11951 0050 30BD     		pop	{r4, r5, pc}
 11952              	.LVL1483:
 11953              	.L1297:
 11954              	.LCFI514:
 11955              		.cfi_restore_state
4853:Src/bno055.c  **** 		}
 11956              		.loc 1 4853 0
 11957 0052 FF24     		movs	r4, #255
 11958              	.LVL1484:
4856:Src/bno055.c  **** /*!
 11959              		.loc 1 4856 0
 11960 0054 60B2     		sxtb	r0, r4
 11961 0056 03B0     		add	sp, sp, #12
 11962              	.LCFI515:
 11963              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 360


 11964              		@ sp needed
 11965 0058 30BD     		pop	{r4, r5, pc}
 11966              	.LVL1485:
 11967              	.L1303:
 11968 005a 00BF     		.align	2
 11969              	.L1302:
 11970 005c 00208C40 		.word	1082925056
 11971              		.cfi_endproc
 11972              	.LFE94:
 11974              		.section	.text.bno055_convert_double_gyro_z_dps,"ax",%progbits
 11975              		.align	2
 11976              		.global	bno055_convert_double_gyro_z_dps
 11977              		.thumb
 11978              		.thumb_func
 11980              	bno055_convert_double_gyro_z_dps:
 11981              	.LFB95:
4873:Src/bno055.c  **** 	/* Variable used to return value of
 11982              		.loc 1 4873 0
 11983              		.cfi_startproc
 11984              		@ args = 0, pretend = 0, frame = 8
 11985              		@ frame_needed = 0, uses_anonymous_args = 0
 11986              	.LVL1486:
 11987 0000 70B5     		push	{r4, r5, r6, lr}
 11988              	.LCFI516:
 11989              		.cfi_def_cfa_offset 16
 11990              		.cfi_offset 4, -16
 11991              		.cfi_offset 5, -12
 11992              		.cfi_offset 6, -8
 11993              		.cfi_offset 14, -4
 11994 0002 82B0     		sub	sp, sp, #8
 11995              	.LCFI517:
 11996              		.cfi_def_cfa_offset 24
4879:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 11997              		.loc 1 4879 0
 11998 0004 02AB     		add	r3, sp, #8
4877:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 11999              		.loc 1 4877 0
 12000 0006 0025     		movs	r5, #0
4879:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 12001              		.loc 1 4879 0
 12002 0008 03F8035D 		strb	r5, [r3, #-3]!
4873:Src/bno055.c  **** 	/* Variable used to return value of
 12003              		.loc 1 4873 0
 12004 000c 0646     		mov	r6, r0
4882:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 12005              		.loc 1 4882 0
 12006 000e 1846     		mov	r0, r3
 12007              	.LVL1487:
4877:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 12008              		.loc 1 4877 0
 12009 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 12010              	.LVL1488:
4882:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 12011              		.loc 1 4882 0
 12012 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 12013              	.LVL1489:
4883:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
ARM GAS  /tmp/ccVWLGiI.s 			page 361


 12014              		.loc 1 4883 0
 12015 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4882:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 12016              		.loc 1 4882 0
 12017 001c 0446     		mov	r4, r0
 12018              	.LVL1490:
4883:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 12019              		.loc 1 4883 0
 12020 001e 93B9     		cbnz	r3, .L1313
 12021              	.L1305:
4885:Src/bno055.c  **** 			/* Read gyro raw z data */
 12022              		.loc 1 4885 0
 12023 0020 BCB9     		cbnz	r4, .L1308
4887:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12024              		.loc 1 4887 0
 12025 0022 0DF10600 		add	r0, sp, #6
 12026 0026 FFF7FEFF 		bl	bno055_read_gyro_z
 12027              	.LVL1491:
4888:Src/bno055.c  **** 				/* Convert raw gyro z to dps */
 12028              		.loc 1 4888 0
 12029 002a 90B9     		cbnz	r0, .L1308
 12030              	.LVL1492:
4891:Src/bno055.c  **** 				*gyro_z_d = data_d;
 12031              		.loc 1 4891 0
 12032 002c BDF90600 		ldrsh	r0, [sp, #6]
 12033              	.LVL1493:
 12034 0030 FFF7FEFF 		bl	__aeabi_i2d
 12035              	.LVL1494:
4890:Src/bno055.c  **** 				(double)(reg_gyro_z_s16/BNO055_GYRO_DIV_DPS);
 12036              		.loc 1 4890 0
 12037 0034 0022     		movs	r2, #0
 12038 0036 094B     		ldr	r3, .L1314
 12039 0038 FFF7FEFF 		bl	__aeabi_dmul
 12040              	.LVL1495:
4892:Src/bno055.c  **** 			} else {
 12041              		.loc 1 4892 0
 12042 003c C6E90001 		strd	r0, [r6]
4900:Src/bno055.c  **** /*!
 12043              		.loc 1 4900 0
 12044 0040 60B2     		sxtb	r0, r4
 12045 0042 02B0     		add	sp, sp, #8
 12046              	.LCFI518:
 12047              		.cfi_remember_state
 12048              		.cfi_def_cfa_offset 16
 12049              		@ sp needed
 12050 0044 70BD     		pop	{r4, r5, r6, pc}
 12051              	.LVL1496:
 12052              	.L1313:
 12053              	.LCFI519:
 12054              		.cfi_restore_state
4884:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 12055              		.loc 1 4884 0
 12056 0046 2846     		mov	r0, r5
 12057 0048 FFF7FEFF 		bl	bno055_set_gyro_unit
 12058              	.LVL1497:
 12059 004c 2044     		add	r0, r0, r4
 12060 004e C4B2     		uxtb	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 362


 12061              	.LVL1498:
 12062 0050 E6E7     		b	.L1305
 12063              	.LVL1499:
 12064              	.L1308:
4897:Src/bno055.c  **** 		}
 12065              		.loc 1 4897 0
 12066 0052 FF24     		movs	r4, #255
 12067              	.LVL1500:
4900:Src/bno055.c  **** /*!
 12068              		.loc 1 4900 0
 12069 0054 60B2     		sxtb	r0, r4
 12070 0056 02B0     		add	sp, sp, #8
 12071              	.LCFI520:
 12072              		.cfi_def_cfa_offset 16
 12073              		@ sp needed
 12074 0058 70BD     		pop	{r4, r5, r6, pc}
 12075              	.LVL1501:
 12076              	.L1315:
 12077 005a 00BF     		.align	2
 12078              	.L1314:
 12079 005c 0000B03F 		.word	1068498944
 12080              		.cfi_endproc
 12081              	.LFE95:
 12083              		.section	.text.bno055_convert_double_gyro_z_rps,"ax",%progbits
 12084              		.align	2
 12085              		.global	bno055_convert_double_gyro_z_rps
 12086              		.thumb
 12087              		.thumb_func
 12089              	bno055_convert_double_gyro_z_rps:
 12090              	.LFB96:
4917:Src/bno055.c  **** 	/* Variable used to return value of
 12091              		.loc 1 4917 0
 12092              		.cfi_startproc
 12093              		@ args = 0, pretend = 0, frame = 8
 12094              		@ frame_needed = 0, uses_anonymous_args = 0
 12095              	.LVL1502:
 12096 0000 30B5     		push	{r4, r5, lr}
 12097              	.LCFI521:
 12098              		.cfi_def_cfa_offset 12
 12099              		.cfi_offset 4, -12
 12100              		.cfi_offset 5, -8
 12101              		.cfi_offset 14, -4
 12102 0002 83B0     		sub	sp, sp, #12
 12103              	.LCFI522:
 12104              		.cfi_def_cfa_offset 24
4923:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 12105              		.loc 1 4923 0
 12106 0004 02AB     		add	r3, sp, #8
4921:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 12107              		.loc 1 4921 0
 12108 0006 0022     		movs	r2, #0
4923:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 12109              		.loc 1 4923 0
 12110 0008 03F8032D 		strb	r2, [r3, #-3]!
4917:Src/bno055.c  **** 	/* Variable used to return value of
 12111              		.loc 1 4917 0
 12112 000c 0546     		mov	r5, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 363


4926:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 12113              		.loc 1 4926 0
 12114 000e 1846     		mov	r0, r3
 12115              	.LVL1503:
4921:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 12116              		.loc 1 4921 0
 12117 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 12118              	.LVL1504:
4926:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 12119              		.loc 1 4926 0
 12120 0014 FFF7FEFF 		bl	bno055_get_gyro_unit
 12121              	.LVL1505:
4927:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 12122              		.loc 1 4927 0
 12123 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
4926:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 12124              		.loc 1 4926 0
 12125 001c 0446     		mov	r4, r0
 12126              	.LVL1506:
4927:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 12127              		.loc 1 4927 0
 12128 001e 012B     		cmp	r3, #1
 12129 0020 04D0     		beq	.L1317
4928:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 12130              		.loc 1 4928 0
 12131 0022 0120     		movs	r0, #1
 12132 0024 FFF7FEFF 		bl	bno055_set_gyro_unit
 12133              	.LVL1507:
 12134 0028 2044     		add	r0, r0, r4
 12135 002a C4B2     		uxtb	r4, r0
 12136              	.LVL1508:
 12137              	.L1317:
4929:Src/bno055.c  **** 			/* Read gyro raw x data */
 12138              		.loc 1 4929 0
 12139 002c 8CB9     		cbnz	r4, .L1320
4931:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12140              		.loc 1 4931 0
 12141 002e 0DF10600 		add	r0, sp, #6
 12142 0032 FFF7FEFF 		bl	bno055_read_gyro_z
 12143              	.LVL1509:
4932:Src/bno055.c  **** 				/* Convert raw gyro x to rps */
 12144              		.loc 1 4932 0
 12145 0036 60B9     		cbnz	r0, .L1320
 12146              	.LVL1510:
4935:Src/bno055.c  **** 				*gyro_z_d = data_d;
 12147              		.loc 1 4935 0
 12148 0038 BDF90600 		ldrsh	r0, [sp, #6]
 12149              	.LVL1511:
 12150 003c FFF7FEFF 		bl	__aeabi_i2d
 12151              	.LVL1512:
4934:Src/bno055.c  **** 				(double)(reg_gyro_z_s16/BNO055_GYRO_DIV_RPS);
 12152              		.loc 1 4934 0
 12153 0040 0022     		movs	r2, #0
 12154 0042 064B     		ldr	r3, .L1325
 12155 0044 FFF7FEFF 		bl	__aeabi_ddiv
 12156              	.LVL1513:
4936:Src/bno055.c  **** 			} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 364


 12157              		.loc 1 4936 0
 12158 0048 C5E90001 		strd	r0, [r5]
4944:Src/bno055.c  **** /*!
 12159              		.loc 1 4944 0
 12160 004c 60B2     		sxtb	r0, r4
 12161 004e 03B0     		add	sp, sp, #12
 12162              	.LCFI523:
 12163              		.cfi_remember_state
 12164              		.cfi_def_cfa_offset 12
 12165              		@ sp needed
 12166 0050 30BD     		pop	{r4, r5, pc}
 12167              	.LVL1514:
 12168              	.L1320:
 12169              	.LCFI524:
 12170              		.cfi_restore_state
4941:Src/bno055.c  **** 		}
 12171              		.loc 1 4941 0
 12172 0052 FF24     		movs	r4, #255
 12173              	.LVL1515:
4944:Src/bno055.c  **** /*!
 12174              		.loc 1 4944 0
 12175 0054 60B2     		sxtb	r0, r4
 12176 0056 03B0     		add	sp, sp, #12
 12177              	.LCFI525:
 12178              		.cfi_def_cfa_offset 12
 12179              		@ sp needed
 12180 0058 30BD     		pop	{r4, r5, pc}
 12181              	.LVL1516:
 12182              	.L1326:
 12183 005a 00BF     		.align	2
 12184              	.L1325:
 12185 005c 00208C40 		.word	1082925056
 12186              		.cfi_endproc
 12187              	.LFE96:
 12189              		.section	.text.bno055_convert_double_gyro_xyz_dps,"ax",%progbits
 12190              		.align	2
 12191              		.global	bno055_convert_double_gyro_xyz_dps
 12192              		.thumb
 12193              		.thumb_func
 12195              	bno055_convert_double_gyro_xyz_dps:
 12196              	.LFB97:
4965:Src/bno055.c  **** 	/* Variable used to return value of
 12197              		.loc 1 4965 0
 12198              		.cfi_startproc
 12199              		@ args = 0, pretend = 0, frame = 16
 12200              		@ frame_needed = 0, uses_anonymous_args = 0
 12201              	.LVL1517:
 12202 0000 70B5     		push	{r4, r5, r6, lr}
 12203              	.LCFI526:
 12204              		.cfi_def_cfa_offset 16
 12205              		.cfi_offset 4, -16
 12206              		.cfi_offset 5, -12
 12207              		.cfi_offset 6, -8
 12208              		.cfi_offset 14, -4
 12209 0002 84B0     		sub	sp, sp, #16
 12210              	.LCFI527:
 12211              		.cfi_def_cfa_offset 32
ARM GAS  /tmp/ccVWLGiI.s 			page 365


4971:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 12212              		.loc 1 4971 0
 12213 0004 04AB     		add	r3, sp, #16
4969:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 12214              		.loc 1 4969 0
 12215 0006 0024     		movs	r4, #0
4971:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 12216              		.loc 1 4971 0
 12217 0008 03F8094D 		strb	r4, [r3, #-9]!
4965:Src/bno055.c  **** 	/* Variable used to return value of
 12218              		.loc 1 4965 0
 12219 000c 0646     		mov	r6, r0
4974:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 12220              		.loc 1 4974 0
 12221 000e 1846     		mov	r0, r3
 12222              	.LVL1518:
4969:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 12223              		.loc 1 4969 0
 12224 0010 ADF80840 		strh	r4, [sp, #8]	@ movhi
 12225 0014 ADF80A40 		strh	r4, [sp, #10]	@ movhi
 12226 0018 ADF80C40 		strh	r4, [sp, #12]	@ movhi
4974:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 12227              		.loc 1 4974 0
 12228 001c FFF7FEFF 		bl	bno055_get_gyro_unit
 12229              	.LVL1519:
4975:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 12230              		.loc 1 4975 0
 12231 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
4974:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_DPS)
 12232              		.loc 1 4974 0
 12233 0024 0546     		mov	r5, r0
 12234              	.LVL1520:
4975:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_DPS);
 12235              		.loc 1 4975 0
 12236 0026 2BBB     		cbnz	r3, .L1336
 12237              	.L1328:
4977:Src/bno055.c  **** 			/* Read gyro raw xyz data */
 12238              		.loc 1 4977 0
 12239 0028 55BB     		cbnz	r5, .L1331
4979:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12240              		.loc 1 4979 0
 12241 002a 02A8     		add	r0, sp, #8
 12242 002c FFF7FEFF 		bl	bno055_read_gyro_xyz
 12243              	.LVL1521:
4980:Src/bno055.c  **** 				/* Convert gyro raw xyz to dps*/
 12244              		.loc 1 4980 0
 12245 0030 30BB     		cbnz	r0, .L1331
4983:Src/bno055.c  **** 				gyro_xyz->y =
 12246              		.loc 1 4983 0
 12247 0032 BDF90800 		ldrsh	r0, [sp, #8]
 12248              	.LVL1522:
 12249 0036 FFF7FEFF 		bl	__aeabi_i2d
 12250              	.LVL1523:
 12251 003a 0022     		movs	r2, #0
 12252 003c 124B     		ldr	r3, .L1337
 12253 003e FFF7FEFF 		bl	__aeabi_dmul
 12254              	.LVL1524:
ARM GAS  /tmp/ccVWLGiI.s 			page 366


4982:Src/bno055.c  **** 				(double)(reg_gyro_xyz.x/BNO055_GYRO_DIV_DPS);
 12255              		.loc 1 4982 0
 12256 0042 C6E90001 		strd	r0, [r6]
4985:Src/bno055.c  **** 				gyro_xyz->z =
 12257              		.loc 1 4985 0
 12258 0046 BDF90A00 		ldrsh	r0, [sp, #10]
 12259 004a FFF7FEFF 		bl	__aeabi_i2d
 12260              	.LVL1525:
 12261 004e 0022     		movs	r2, #0
 12262 0050 0D4B     		ldr	r3, .L1337
 12263 0052 FFF7FEFF 		bl	__aeabi_dmul
 12264              	.LVL1526:
4984:Src/bno055.c  **** 				(double)(reg_gyro_xyz.y/BNO055_GYRO_DIV_DPS);
 12265              		.loc 1 4984 0
 12266 0056 C6E90201 		strd	r0, [r6, #8]
4987:Src/bno055.c  **** 			} else {
 12267              		.loc 1 4987 0
 12268 005a BDF90C00 		ldrsh	r0, [sp, #12]
 12269 005e FFF7FEFF 		bl	__aeabi_i2d
 12270              	.LVL1527:
 12271 0062 0022     		movs	r2, #0
 12272 0064 084B     		ldr	r3, .L1337
 12273 0066 FFF7FEFF 		bl	__aeabi_dmul
 12274              	.LVL1528:
4986:Src/bno055.c  **** 				(double)(reg_gyro_xyz.z/BNO055_GYRO_DIV_DPS);
 12275              		.loc 1 4986 0
 12276 006a C6E90401 		strd	r0, [r6, #16]
4995:Src/bno055.c  **** /*!
 12277              		.loc 1 4995 0
 12278 006e 68B2     		sxtb	r0, r5
 12279 0070 04B0     		add	sp, sp, #16
 12280              	.LCFI528:
 12281              		.cfi_remember_state
 12282              		.cfi_def_cfa_offset 16
 12283              		@ sp needed
 12284 0072 70BD     		pop	{r4, r5, r6, pc}
 12285              	.LVL1529:
 12286              	.L1336:
 12287              	.LCFI529:
 12288              		.cfi_restore_state
4976:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 12289              		.loc 1 4976 0
 12290 0074 2046     		mov	r0, r4
 12291 0076 FFF7FEFF 		bl	bno055_set_gyro_unit
 12292              	.LVL1530:
 12293 007a 2844     		add	r0, r0, r5
 12294 007c C5B2     		uxtb	r5, r0
 12295              	.LVL1531:
 12296 007e D3E7     		b	.L1328
 12297              	.LVL1532:
 12298              	.L1331:
4992:Src/bno055.c  **** 		}
 12299              		.loc 1 4992 0
 12300 0080 FF25     		movs	r5, #255
 12301              	.LVL1533:
4995:Src/bno055.c  **** /*!
 12302              		.loc 1 4995 0
ARM GAS  /tmp/ccVWLGiI.s 			page 367


 12303 0082 68B2     		sxtb	r0, r5
 12304 0084 04B0     		add	sp, sp, #16
 12305              	.LCFI530:
 12306              		.cfi_def_cfa_offset 16
 12307              		@ sp needed
 12308 0086 70BD     		pop	{r4, r5, r6, pc}
 12309              	.LVL1534:
 12310              	.L1338:
 12311              		.align	2
 12312              	.L1337:
 12313 0088 0000B03F 		.word	1068498944
 12314              		.cfi_endproc
 12315              	.LFE97:
 12317              		.section	.text.bno055_convert_double_gyro_xyz_rps,"ax",%progbits
 12318              		.align	2
 12319              		.global	bno055_convert_double_gyro_xyz_rps
 12320              		.thumb
 12321              		.thumb_func
 12323              	bno055_convert_double_gyro_xyz_rps:
 12324              	.LFB98:
5016:Src/bno055.c  **** 	/* Variable used to return value of
 12325              		.loc 1 5016 0
 12326              		.cfi_startproc
 12327              		@ args = 0, pretend = 0, frame = 16
 12328              		@ frame_needed = 0, uses_anonymous_args = 0
 12329              	.LVL1535:
 12330 0000 30B5     		push	{r4, r5, lr}
 12331              	.LCFI531:
 12332              		.cfi_def_cfa_offset 12
 12333              		.cfi_offset 4, -12
 12334              		.cfi_offset 5, -8
 12335              		.cfi_offset 14, -4
 12336 0002 85B0     		sub	sp, sp, #20
 12337              	.LCFI532:
 12338              		.cfi_def_cfa_offset 32
5020:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 12339              		.loc 1 5020 0
 12340 0004 0023     		movs	r3, #0
5022:Src/bno055.c  **** 	/* Read the current gyro unit and set the
 12341              		.loc 1 5022 0
 12342 0006 04AA     		add	r2, sp, #16
 12343 0008 02F8093D 		strb	r3, [r2, #-9]!
5016:Src/bno055.c  **** 	/* Variable used to return value of
 12344              		.loc 1 5016 0
 12345 000c 0546     		mov	r5, r0
5025:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 12346              		.loc 1 5025 0
 12347 000e 1046     		mov	r0, r2
 12348              	.LVL1536:
5020:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 12349              		.loc 1 5020 0
 12350 0010 ADF80830 		strh	r3, [sp, #8]	@ movhi
 12351 0014 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 12352 0018 ADF80C30 		strh	r3, [sp, #12]	@ movhi
5025:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 12353              		.loc 1 5025 0
 12354 001c FFF7FEFF 		bl	bno055_get_gyro_unit
ARM GAS  /tmp/ccVWLGiI.s 			page 368


 12355              	.LVL1537:
5026:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 12356              		.loc 1 5026 0
 12357 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
5025:Src/bno055.c  **** 	if (gyro_unit_u8 != BNO055_GYRO_UNIT_RPS)
 12358              		.loc 1 5025 0
 12359 0024 0446     		mov	r4, r0
 12360              	.LVL1538:
5026:Src/bno055.c  **** 		com_rslt += bno055_set_gyro_unit(BNO055_GYRO_UNIT_RPS);
 12361              		.loc 1 5026 0
 12362 0026 012B     		cmp	r3, #1
 12363 0028 04D0     		beq	.L1340
5027:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 12364              		.loc 1 5027 0
 12365 002a 0120     		movs	r0, #1
 12366 002c FFF7FEFF 		bl	bno055_set_gyro_unit
 12367              	.LVL1539:
 12368 0030 2044     		add	r0, r0, r4
 12369 0032 C4B2     		uxtb	r4, r0
 12370              	.LVL1540:
 12371              	.L1340:
5028:Src/bno055.c  **** 			/* Read gyro raw x data */
 12372              		.loc 1 5028 0
 12373 0034 24BB     		cbnz	r4, .L1343
5030:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12374              		.loc 1 5030 0
 12375 0036 02A8     		add	r0, sp, #8
 12376 0038 FFF7FEFF 		bl	bno055_read_gyro_xyz
 12377              	.LVL1541:
5031:Src/bno055.c  **** 				/* Convert the raw gyro xyz to rps*/
 12378              		.loc 1 5031 0
 12379 003c 00BB     		cbnz	r0, .L1343
5034:Src/bno055.c  **** 				gyro_xyz->y =
 12380              		.loc 1 5034 0
 12381 003e BDF90800 		ldrsh	r0, [sp, #8]
 12382              	.LVL1542:
 12383 0042 FFF7FEFF 		bl	__aeabi_i2d
 12384              	.LVL1543:
 12385 0046 0022     		movs	r2, #0
 12386 0048 0F4B     		ldr	r3, .L1348
 12387 004a FFF7FEFF 		bl	__aeabi_ddiv
 12388              	.LVL1544:
5033:Src/bno055.c  **** 				(double)(reg_gyro_xyz.x/BNO055_GYRO_DIV_RPS);
 12389              		.loc 1 5033 0
 12390 004e C5E90001 		strd	r0, [r5]
5036:Src/bno055.c  **** 				gyro_xyz->z =
 12391              		.loc 1 5036 0
 12392 0052 BDF90A00 		ldrsh	r0, [sp, #10]
 12393 0056 FFF7FEFF 		bl	__aeabi_i2d
 12394              	.LVL1545:
 12395 005a 0022     		movs	r2, #0
 12396 005c 0A4B     		ldr	r3, .L1348
 12397 005e FFF7FEFF 		bl	__aeabi_ddiv
 12398              	.LVL1546:
5035:Src/bno055.c  **** 				(double)(reg_gyro_xyz.y/BNO055_GYRO_DIV_RPS);
 12399              		.loc 1 5035 0
 12400 0062 C5E90201 		strd	r0, [r5, #8]
ARM GAS  /tmp/ccVWLGiI.s 			page 369


5038:Src/bno055.c  **** 			} else {
 12401              		.loc 1 5038 0
 12402 0066 BDF90C00 		ldrsh	r0, [sp, #12]
 12403 006a FFF7FEFF 		bl	__aeabi_i2d
 12404              	.LVL1547:
 12405 006e 0022     		movs	r2, #0
 12406 0070 054B     		ldr	r3, .L1348
 12407 0072 FFF7FEFF 		bl	__aeabi_ddiv
 12408              	.LVL1548:
5037:Src/bno055.c  **** 				(double)(reg_gyro_xyz.z/BNO055_GYRO_DIV_RPS);
 12409              		.loc 1 5037 0
 12410 0076 C5E90401 		strd	r0, [r5, #16]
5046:Src/bno055.c  **** /*!
 12411              		.loc 1 5046 0
 12412 007a 60B2     		sxtb	r0, r4
 12413 007c 05B0     		add	sp, sp, #20
 12414              	.LCFI533:
 12415              		.cfi_remember_state
 12416              		.cfi_def_cfa_offset 12
 12417              		@ sp needed
 12418 007e 30BD     		pop	{r4, r5, pc}
 12419              	.LVL1549:
 12420              	.L1343:
 12421              	.LCFI534:
 12422              		.cfi_restore_state
5043:Src/bno055.c  **** 		}
 12423              		.loc 1 5043 0
 12424 0080 FF24     		movs	r4, #255
 12425              	.LVL1550:
5046:Src/bno055.c  **** /*!
 12426              		.loc 1 5046 0
 12427 0082 60B2     		sxtb	r0, r4
 12428 0084 05B0     		add	sp, sp, #20
 12429              	.LCFI535:
 12430              		.cfi_def_cfa_offset 12
 12431              		@ sp needed
 12432 0086 30BD     		pop	{r4, r5, pc}
 12433              	.LVL1551:
 12434              	.L1349:
 12435              		.align	2
 12436              	.L1348:
 12437 0088 00208C40 		.word	1082925056
 12438              		.cfi_endproc
 12439              	.LFE98:
 12441              		.section	.text.bno055_set_euler_unit,"ax",%progbits
 12442              		.align	2
 12443              		.global	bno055_set_euler_unit
 12444              		.thumb
 12445              		.thumb_func
 12447              	bno055_set_euler_unit:
 12448              	.LFB138:
6827:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12449              		.loc 1 6827 0
 12450              		.cfi_startproc
 12451              		@ args = 0, pretend = 0, frame = 8
 12452              		@ frame_needed = 0, uses_anonymous_args = 0
 12453              	.LVL1552:
ARM GAS  /tmp/ccVWLGiI.s 			page 370


 12454 0000 30B5     		push	{r4, r5, lr}
 12455              	.LCFI536:
 12456              		.cfi_def_cfa_offset 12
 12457              		.cfi_offset 4, -12
 12458              		.cfi_offset 5, -8
 12459              		.cfi_offset 14, -4
6833:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 12460              		.loc 1 6833 0
 12461 0002 244C     		ldr	r4, .L1366
6827:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12462              		.loc 1 6827 0
 12463 0004 83B0     		sub	sp, sp, #12
 12464              	.LCFI537:
 12465              		.cfi_def_cfa_offset 24
6833:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 12466              		.loc 1 6833 0
 12467 0006 2268     		ldr	r2, [r4]
6829:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 12468              		.loc 1 6829 0
 12469 0008 0023     		movs	r3, #0
 12470 000a 8DF80630 		strb	r3, [sp, #6]
6830:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 12471              		.loc 1 6830 0
 12472 000e 8DF80730 		strb	r3, [sp, #7]
 12473              	.LVL1553:
6833:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 12474              		.loc 1 6833 0
 12475 0012 002A     		cmp	r2, #0
 12476 0014 3CD0     		beq	.L1358
 12477 0016 0546     		mov	r5, r0
6839:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 12478              		.loc 1 6839 0
 12479 0018 0DF10700 		add	r0, sp, #7
 12480              	.LVL1554:
 12481 001c FFF7FEFF 		bl	bno055_get_operation_mode
 12482              	.LVL1555:
6840:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 12483              		.loc 1 6840 0
 12484 0020 38B1     		cbz	r0, .L1352
 12485              	.L1357:
6865:Src/bno055.c  **** 		}
 12486              		.loc 1 6865 0
 12487 0022 FF24     		movs	r4, #255
 12488              	.LVL1556:
 12489              	.L1353:
6868:Src/bno055.c  **** 		/* set the operation mode
 12490              		.loc 1 6868 0
 12491 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 12492 0028 30BB     		cbnz	r0, .L1365
 12493 002a 2046     		mov	r0, r4
 12494              	.LVL1557:
 12495              	.L1351:
6874:Src/bno055.c  **** /*!
 12496              		.loc 1 6874 0
 12497 002c 40B2     		sxtb	r0, r0
 12498 002e 03B0     		add	sp, sp, #12
 12499              	.LCFI538:
ARM GAS  /tmp/ccVWLGiI.s 			page 371


 12500              		.cfi_remember_state
 12501              		.cfi_def_cfa_offset 12
 12502              		@ sp needed
 12503 0030 30BD     		pop	{r4, r5, pc}
 12504              	.LVL1558:
 12505              	.L1352:
 12506              	.LCFI539:
 12507              		.cfi_restore_state
6841:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 12508              		.loc 1 6841 0
 12509 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 12510 0036 33BB     		cbnz	r3, .L1354
 12511              	.L1356:
 12512              	.LVL1559:
6846:Src/bno055.c  **** 				(p_bno055->dev_addr,
 12513              		.loc 1 6846 0
 12514 0038 2368     		ldr	r3, [r4]
 12515 003a 0DF10602 		add	r2, sp, #6
 12516 003e 1C69     		ldr	r4, [r3, #16]
 12517 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 12518 0042 3B21     		movs	r1, #59
 12519 0044 0123     		movs	r3, #1
 12520 0046 A047     		blx	r4
 12521              	.LVL1560:
 12522 0048 124B     		ldr	r3, .L1366
6850:Src/bno055.c  **** 					data_u8r =
 12523              		.loc 1 6850 0
 12524 004a 0446     		mov	r4, r0
 12525 004c 0028     		cmp	r0, #0
 12526 004e E9D1     		bne	.L1353
6851:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 12527              		.loc 1 6851 0
 12528 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
6852:Src/bno055.c  **** 					BNO055_EULER_UNIT, euler_unit_u8);
 12529              		.loc 1 6852 0
 12530 0054 A800     		lsls	r0, r5, #2
 12531              	.LVL1561:
6855:Src/bno055.c  **** 					(p_bno055->dev_addr,
 12532              		.loc 1 6855 0
 12533 0056 1968     		ldr	r1, [r3]
6851:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 12534              		.loc 1 6851 0
 12535 0058 00F00400 		and	r0, r0, #4
 12536 005c 22F00403 		bic	r3, r2, #4
 12537 0060 1843     		orrs	r0, r0, r3
6855:Src/bno055.c  **** 					(p_bno055->dev_addr,
 12538              		.loc 1 6855 0
 12539 0062 CC68     		ldr	r4, [r1, #12]
6851:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 12540              		.loc 1 6851 0
 12541 0064 8DF80600 		strb	r0, [sp, #6]
6855:Src/bno055.c  **** 					(p_bno055->dev_addr,
 12542              		.loc 1 6855 0
 12543 0068 0DF10602 		add	r2, sp, #6
 12544 006c 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 12545 006e 0123     		movs	r3, #1
 12546 0070 3B21     		movs	r1, #59
ARM GAS  /tmp/ccVWLGiI.s 			page 372


 12547 0072 A047     		blx	r4
 12548              	.LVL1562:
 12549 0074 0446     		mov	r4, r0
 12550              	.LVL1563:
 12551 0076 D5E7     		b	.L1353
 12552              	.L1365:
6871:Src/bno055.c  **** 		(prev_opmode_u8);
 12553              		.loc 1 6871 0
 12554 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 12555              	.LVL1564:
 12556 007c 2044     		add	r0, r0, r4
 12557 007e C0B2     		uxtb	r0, r0
 12558              	.LVL1565:
6874:Src/bno055.c  **** /*!
 12559              		.loc 1 6874 0
 12560 0080 40B2     		sxtb	r0, r0
 12561 0082 03B0     		add	sp, sp, #12
 12562              	.LCFI540:
 12563              		.cfi_remember_state
 12564              		.cfi_def_cfa_offset 12
 12565              		@ sp needed
 12566 0084 30BD     		pop	{r4, r5, pc}
 12567              	.LVL1566:
 12568              	.L1354:
 12569              	.LCFI541:
 12570              		.cfi_restore_state
6842:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 12571              		.loc 1 6842 0
 12572 0086 FFF7FEFF 		bl	bno055_set_operation_mode
 12573              	.LVL1567:
6844:Src/bno055.c  **** 				/* Write the Euler unit*/
 12574              		.loc 1 6844 0
 12575 008a 0028     		cmp	r0, #0
 12576 008c C9D1     		bne	.L1357
 12577 008e D3E7     		b	.L1356
 12578              	.LVL1568:
 12579              	.L1358:
6834:Src/bno055.c  **** 	} else {
 12580              		.loc 1 6834 0
 12581 0090 8120     		movs	r0, #129
 12582              	.LVL1569:
 12583 0092 CBE7     		b	.L1351
 12584              	.L1367:
 12585              		.align	2
 12586              	.L1366:
 12587 0094 00000000 		.word	.LANCHOR0
 12588              		.cfi_endproc
 12589              	.LFE138:
 12591              		.section	.text.bno055_convert_float_euler_h_deg,"ax",%progbits
 12592              		.align	2
 12593              		.global	bno055_convert_float_euler_h_deg
 12594              		.thumb
 12595              		.thumb_func
 12597              	bno055_convert_float_euler_h_deg:
 12598              	.LFB61:
3502:Src/bno055.c  **** 	/* Variable used to return value of
 12599              		.loc 1 3502 0
ARM GAS  /tmp/ccVWLGiI.s 			page 373


 12600              		.cfi_startproc
 12601              		@ args = 0, pretend = 0, frame = 8
 12602              		@ frame_needed = 0, uses_anonymous_args = 0
 12603              	.LVL1570:
 12604 0000 70B5     		push	{r4, r5, r6, lr}
 12605              	.LCFI542:
 12606              		.cfi_def_cfa_offset 16
 12607              		.cfi_offset 4, -16
 12608              		.cfi_offset 5, -12
 12609              		.cfi_offset 6, -8
 12610              		.cfi_offset 14, -4
 12611 0002 82B0     		sub	sp, sp, #8
 12612              	.LCFI543:
 12613              		.cfi_def_cfa_offset 24
3508:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 12614              		.loc 1 3508 0
 12615 0004 02AB     		add	r3, sp, #8
3506:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12616              		.loc 1 3506 0
 12617 0006 0025     		movs	r5, #0
3508:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 12618              		.loc 1 3508 0
 12619 0008 03F8035D 		strb	r5, [r3, #-3]!
3502:Src/bno055.c  **** 	/* Variable used to return value of
 12620              		.loc 1 3502 0
 12621 000c 0646     		mov	r6, r0
3511:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 12622              		.loc 1 3511 0
 12623 000e 1846     		mov	r0, r3
 12624              	.LVL1571:
3506:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12625              		.loc 1 3506 0
 12626 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 12627              	.LVL1572:
3511:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 12628              		.loc 1 3511 0
 12629 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 12630              	.LVL1573:
3512:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 12631              		.loc 1 3512 0
 12632 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3511:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 12633              		.loc 1 3511 0
 12634 001c 0446     		mov	r4, r0
 12635              	.LVL1574:
3512:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 12636              		.loc 1 3512 0
 12637 001e 9BB9     		cbnz	r3, .L1377
 12638              	.L1369:
3514:Src/bno055.c  **** 			/* Read Euler raw h data*/
 12639              		.loc 1 3514 0
 12640 0020 C4B9     		cbnz	r4, .L1372
3516:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12641              		.loc 1 3516 0
 12642 0022 0DF10600 		add	r0, sp, #6
 12643 0026 FFF7FEFF 		bl	bno055_read_euler_h
 12644              	.LVL1575:
ARM GAS  /tmp/ccVWLGiI.s 			page 374


3517:Src/bno055.c  **** 				/* Convert raw Euler h data to degree*/
 12645              		.loc 1 3517 0
 12646 002a 98B9     		cbnz	r0, .L1372
 12647              	.LVL1576:
3520:Src/bno055.c  **** 				*euler_h_f = data_f;
 12648              		.loc 1 3520 0
 12649 002c BDF90600 		ldrsh	r0, [sp, #6]
 12650              	.LVL1577:
 12651 0030 FFF7FEFF 		bl	__aeabi_i2d
 12652              	.LVL1578:
 12653 0034 0022     		movs	r2, #0
 12654 0036 094B     		ldr	r3, .L1378
 12655 0038 FFF7FEFF 		bl	__aeabi_dmul
 12656              	.LVL1579:
3519:Src/bno055.c  **** 				(float)(reg_euler_h_s16/BNO055_EULER_DIV_DEG);
 12657              		.loc 1 3519 0
 12658 003c FFF7FEFF 		bl	__aeabi_d2f
 12659              	.LVL1580:
 12660 0040 3060     		str	r0, [r6]	@ float
3529:Src/bno055.c  **** /*!
 12661              		.loc 1 3529 0
 12662 0042 60B2     		sxtb	r0, r4
 12663 0044 02B0     		add	sp, sp, #8
 12664              	.LCFI544:
 12665              		.cfi_remember_state
 12666              		.cfi_def_cfa_offset 16
 12667              		@ sp needed
 12668 0046 70BD     		pop	{r4, r5, r6, pc}
 12669              	.LVL1581:
 12670              	.L1377:
 12671              	.LCFI545:
 12672              		.cfi_restore_state
3513:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 12673              		.loc 1 3513 0
 12674 0048 2846     		mov	r0, r5
 12675 004a FFF7FEFF 		bl	bno055_set_euler_unit
 12676              	.LVL1582:
 12677 004e 2044     		add	r0, r0, r4
 12678 0050 C4B2     		uxtb	r4, r0
 12679              	.LVL1583:
 12680 0052 E5E7     		b	.L1369
 12681              	.LVL1584:
 12682              	.L1372:
3526:Src/bno055.c  **** 		}
 12683              		.loc 1 3526 0
 12684 0054 FF24     		movs	r4, #255
 12685              	.LVL1585:
3529:Src/bno055.c  **** /*!
 12686              		.loc 1 3529 0
 12687 0056 60B2     		sxtb	r0, r4
 12688 0058 02B0     		add	sp, sp, #8
 12689              	.LCFI546:
 12690              		.cfi_def_cfa_offset 16
 12691              		@ sp needed
 12692 005a 70BD     		pop	{r4, r5, r6, pc}
 12693              	.LVL1586:
 12694              	.L1379:
ARM GAS  /tmp/ccVWLGiI.s 			page 375


 12695              		.align	2
 12696              	.L1378:
 12697 005c 0000B03F 		.word	1068498944
 12698              		.cfi_endproc
 12699              	.LFE61:
 12701              		.section	.text.bno055_convert_float_euler_h_rad,"ax",%progbits
 12702              		.align	2
 12703              		.global	bno055_convert_float_euler_h_rad
 12704              		.thumb
 12705              		.thumb_func
 12707              	bno055_convert_float_euler_h_rad:
 12708              	.LFB62:
3544:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12709              		.loc 1 3544 0
 12710              		.cfi_startproc
 12711              		@ args = 0, pretend = 0, frame = 8
 12712              		@ frame_needed = 0, uses_anonymous_args = 0
 12713              	.LVL1587:
 12714 0000 30B5     		push	{r4, r5, lr}
 12715              	.LCFI547:
 12716              		.cfi_def_cfa_offset 12
 12717              		.cfi_offset 4, -12
 12718              		.cfi_offset 5, -8
 12719              		.cfi_offset 14, -4
 12720 0002 83B0     		sub	sp, sp, #12
 12721              	.LCFI548:
 12722              		.cfi_def_cfa_offset 24
3548:Src/bno055.c  **** 
 12723              		.loc 1 3548 0
 12724 0004 02AB     		add	r3, sp, #8
3546:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12725              		.loc 1 3546 0
 12726 0006 0022     		movs	r2, #0
3548:Src/bno055.c  **** 
 12727              		.loc 1 3548 0
 12728 0008 03F8032D 		strb	r2, [r3, #-3]!
3544:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12729              		.loc 1 3544 0
 12730 000c 0546     		mov	r5, r0
3550:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 12731              		.loc 1 3550 0
 12732 000e 1846     		mov	r0, r3
 12733              	.LVL1588:
3546:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12734              		.loc 1 3546 0
 12735 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 12736              	.LVL1589:
3550:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 12737              		.loc 1 3550 0
 12738 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 12739              	.LVL1590:
3551:Src/bno055.c  **** 		/* Read the current Euler unit and set the
 12740              		.loc 1 3551 0
 12741 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3550:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 12742              		.loc 1 3550 0
 12743 001c 0446     		mov	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 376


 12744              	.LVL1591:
3551:Src/bno055.c  **** 		/* Read the current Euler unit and set the
 12745              		.loc 1 3551 0
 12746 001e 012B     		cmp	r3, #1
 12747 0020 04D0     		beq	.L1381
3554:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 12748              		.loc 1 3554 0
 12749 0022 0120     		movs	r0, #1
 12750 0024 FFF7FEFF 		bl	bno055_set_euler_unit
 12751              	.LVL1592:
 12752 0028 2044     		add	r0, r0, r4
 12753 002a C4B2     		uxtb	r4, r0
 12754              	.LVL1593:
 12755              	.L1381:
3555:Src/bno055.c  **** 			/* Read Euler raw h data*/
 12756              		.loc 1 3555 0
 12757 002c 94B9     		cbnz	r4, .L1384
3557:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12758              		.loc 1 3557 0
 12759 002e 0DF10600 		add	r0, sp, #6
 12760 0032 FFF7FEFF 		bl	bno055_read_euler_h
 12761              	.LVL1594:
3558:Src/bno055.c  **** 				/* Convert raw Euler h data to degree*/
 12762              		.loc 1 3558 0
 12763 0036 68B9     		cbnz	r0, .L1384
 12764              	.LVL1595:
3561:Src/bno055.c  **** 				*euler_h_f = data_f;
 12765              		.loc 1 3561 0
 12766 0038 BDF90600 		ldrsh	r0, [sp, #6]
 12767              	.LVL1596:
 12768 003c FFF7FEFF 		bl	__aeabi_i2d
 12769              	.LVL1597:
 12770 0040 0022     		movs	r2, #0
 12771 0042 064B     		ldr	r3, .L1389
 12772 0044 FFF7FEFF 		bl	__aeabi_ddiv
 12773              	.LVL1598:
3560:Src/bno055.c  **** 				(float)(reg_euler_h_s16/BNO055_EULER_DIV_RAD);
 12774              		.loc 1 3560 0
 12775 0048 FFF7FEFF 		bl	__aeabi_d2f
 12776              	.LVL1599:
 12777 004c 2860     		str	r0, [r5]	@ float
3570:Src/bno055.c  **** /*!
 12778              		.loc 1 3570 0
 12779 004e 60B2     		sxtb	r0, r4
 12780 0050 03B0     		add	sp, sp, #12
 12781              	.LCFI549:
 12782              		.cfi_remember_state
 12783              		.cfi_def_cfa_offset 12
 12784              		@ sp needed
 12785 0052 30BD     		pop	{r4, r5, pc}
 12786              	.LVL1600:
 12787              	.L1384:
 12788              	.LCFI550:
 12789              		.cfi_restore_state
3567:Src/bno055.c  **** 		}
 12790              		.loc 1 3567 0
 12791 0054 FF24     		movs	r4, #255
ARM GAS  /tmp/ccVWLGiI.s 			page 377


 12792              	.LVL1601:
3570:Src/bno055.c  **** /*!
 12793              		.loc 1 3570 0
 12794 0056 60B2     		sxtb	r0, r4
 12795 0058 03B0     		add	sp, sp, #12
 12796              	.LCFI551:
 12797              		.cfi_def_cfa_offset 12
 12798              		@ sp needed
 12799 005a 30BD     		pop	{r4, r5, pc}
 12800              	.LVL1602:
 12801              	.L1390:
 12802              		.align	2
 12803              	.L1389:
 12804 005c 00208C40 		.word	1082925056
 12805              		.cfi_endproc
 12806              	.LFE62:
 12808              		.section	.text.bno055_convert_float_euler_r_deg,"ax",%progbits
 12809              		.align	2
 12810              		.global	bno055_convert_float_euler_r_deg
 12811              		.thumb
 12812              		.thumb_func
 12814              	bno055_convert_float_euler_r_deg:
 12815              	.LFB63:
3584:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12816              		.loc 1 3584 0
 12817              		.cfi_startproc
 12818              		@ args = 0, pretend = 0, frame = 8
 12819              		@ frame_needed = 0, uses_anonymous_args = 0
 12820              	.LVL1603:
 12821 0000 70B5     		push	{r4, r5, r6, lr}
 12822              	.LCFI552:
 12823              		.cfi_def_cfa_offset 16
 12824              		.cfi_offset 4, -16
 12825              		.cfi_offset 5, -12
 12826              		.cfi_offset 6, -8
 12827              		.cfi_offset 14, -4
 12828 0002 82B0     		sub	sp, sp, #8
 12829              	.LCFI553:
 12830              		.cfi_def_cfa_offset 24
3588:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 12831              		.loc 1 3588 0
 12832 0004 02AB     		add	r3, sp, #8
3586:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12833              		.loc 1 3586 0
 12834 0006 0025     		movs	r5, #0
3588:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 12835              		.loc 1 3588 0
 12836 0008 03F8035D 		strb	r5, [r3, #-3]!
3584:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12837              		.loc 1 3584 0
 12838 000c 0646     		mov	r6, r0
3591:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 12839              		.loc 1 3591 0
 12840 000e 1846     		mov	r0, r3
 12841              	.LVL1604:
3586:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12842              		.loc 1 3586 0
ARM GAS  /tmp/ccVWLGiI.s 			page 378


 12843 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 12844              	.LVL1605:
3591:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 12845              		.loc 1 3591 0
 12846 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 12847              	.LVL1606:
3592:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 12848              		.loc 1 3592 0
 12849 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3591:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 12850              		.loc 1 3591 0
 12851 001c 0446     		mov	r4, r0
 12852              	.LVL1607:
3592:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 12853              		.loc 1 3592 0
 12854 001e 9BB9     		cbnz	r3, .L1400
 12855              	.L1392:
3594:Src/bno055.c  **** 			/* Read Euler raw r data*/
 12856              		.loc 1 3594 0
 12857 0020 C4B9     		cbnz	r4, .L1395
3596:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12858              		.loc 1 3596 0
 12859 0022 0DF10600 		add	r0, sp, #6
 12860 0026 FFF7FEFF 		bl	bno055_read_euler_r
 12861              	.LVL1608:
3597:Src/bno055.c  **** 				/* Convert raw Euler r data to degree*/
 12862              		.loc 1 3597 0
 12863 002a 98B9     		cbnz	r0, .L1395
 12864              	.LVL1609:
3600:Src/bno055.c  **** 				*euler_r_f = data_f;
 12865              		.loc 1 3600 0
 12866 002c BDF90600 		ldrsh	r0, [sp, #6]
 12867              	.LVL1610:
 12868 0030 FFF7FEFF 		bl	__aeabi_i2d
 12869              	.LVL1611:
 12870 0034 0022     		movs	r2, #0
 12871 0036 094B     		ldr	r3, .L1401
 12872 0038 FFF7FEFF 		bl	__aeabi_dmul
 12873              	.LVL1612:
3599:Src/bno055.c  **** 				reg_euler_r/BNO055_EULER_DIV_DEG);
 12874              		.loc 1 3599 0
 12875 003c FFF7FEFF 		bl	__aeabi_d2f
 12876              	.LVL1613:
 12877 0040 3060     		str	r0, [r6]	@ float
3609:Src/bno055.c  **** /*!
 12878              		.loc 1 3609 0
 12879 0042 60B2     		sxtb	r0, r4
 12880 0044 02B0     		add	sp, sp, #8
 12881              	.LCFI554:
 12882              		.cfi_remember_state
 12883              		.cfi_def_cfa_offset 16
 12884              		@ sp needed
 12885 0046 70BD     		pop	{r4, r5, r6, pc}
 12886              	.LVL1614:
 12887              	.L1400:
 12888              	.LCFI555:
 12889              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 379


3593:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 12890              		.loc 1 3593 0
 12891 0048 2846     		mov	r0, r5
 12892 004a FFF7FEFF 		bl	bno055_set_euler_unit
 12893              	.LVL1615:
 12894 004e 2044     		add	r0, r0, r4
 12895 0050 C4B2     		uxtb	r4, r0
 12896              	.LVL1616:
 12897 0052 E5E7     		b	.L1392
 12898              	.LVL1617:
 12899              	.L1395:
3606:Src/bno055.c  **** 		}
 12900              		.loc 1 3606 0
 12901 0054 FF24     		movs	r4, #255
 12902              	.LVL1618:
3609:Src/bno055.c  **** /*!
 12903              		.loc 1 3609 0
 12904 0056 60B2     		sxtb	r0, r4
 12905 0058 02B0     		add	sp, sp, #8
 12906              	.LCFI556:
 12907              		.cfi_def_cfa_offset 16
 12908              		@ sp needed
 12909 005a 70BD     		pop	{r4, r5, r6, pc}
 12910              	.LVL1619:
 12911              	.L1402:
 12912              		.align	2
 12913              	.L1401:
 12914 005c 0000B03F 		.word	1068498944
 12915              		.cfi_endproc
 12916              	.LFE63:
 12918              		.section	.text.bno055_convert_float_euler_r_rad,"ax",%progbits
 12919              		.align	2
 12920              		.global	bno055_convert_float_euler_r_rad
 12921              		.thumb
 12922              		.thumb_func
 12924              	bno055_convert_float_euler_r_rad:
 12925              	.LFB64:
3623:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12926              		.loc 1 3623 0
 12927              		.cfi_startproc
 12928              		@ args = 0, pretend = 0, frame = 8
 12929              		@ frame_needed = 0, uses_anonymous_args = 0
 12930              	.LVL1620:
 12931 0000 30B5     		push	{r4, r5, lr}
 12932              	.LCFI557:
 12933              		.cfi_def_cfa_offset 12
 12934              		.cfi_offset 4, -12
 12935              		.cfi_offset 5, -8
 12936              		.cfi_offset 14, -4
 12937 0002 83B0     		sub	sp, sp, #12
 12938              	.LCFI558:
 12939              		.cfi_def_cfa_offset 24
3627:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 12940              		.loc 1 3627 0
 12941 0004 02AB     		add	r3, sp, #8
3625:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12942              		.loc 1 3625 0
ARM GAS  /tmp/ccVWLGiI.s 			page 380


 12943 0006 0022     		movs	r2, #0
3627:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 12944              		.loc 1 3627 0
 12945 0008 03F8032D 		strb	r2, [r3, #-3]!
3623:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 12946              		.loc 1 3623 0
 12947 000c 0546     		mov	r5, r0
3630:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 12948              		.loc 1 3630 0
 12949 000e 1846     		mov	r0, r3
 12950              	.LVL1621:
3625:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 12951              		.loc 1 3625 0
 12952 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 12953              	.LVL1622:
3630:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 12954              		.loc 1 3630 0
 12955 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 12956              	.LVL1623:
3631:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 12957              		.loc 1 3631 0
 12958 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3630:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 12959              		.loc 1 3630 0
 12960 001c 0446     		mov	r4, r0
 12961              	.LVL1624:
3631:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 12962              		.loc 1 3631 0
 12963 001e 012B     		cmp	r3, #1
 12964 0020 04D0     		beq	.L1404
3632:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 12965              		.loc 1 3632 0
 12966 0022 0120     		movs	r0, #1
 12967 0024 FFF7FEFF 		bl	bno055_set_euler_unit
 12968              	.LVL1625:
 12969 0028 2044     		add	r0, r0, r4
 12970 002a C4B2     		uxtb	r4, r0
 12971              	.LVL1626:
 12972              	.L1404:
3633:Src/bno055.c  **** 			/* Read Euler raw r data*/
 12973              		.loc 1 3633 0
 12974 002c 94B9     		cbnz	r4, .L1407
3635:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 12975              		.loc 1 3635 0
 12976 002e 0DF10600 		add	r0, sp, #6
 12977 0032 FFF7FEFF 		bl	bno055_read_euler_r
 12978              	.LVL1627:
3636:Src/bno055.c  **** 				/* Convert raw Euler r data to radians*/
 12979              		.loc 1 3636 0
 12980 0036 68B9     		cbnz	r0, .L1407
 12981              	.LVL1628:
3639:Src/bno055.c  **** 				*euler_r_f = data_f;
 12982              		.loc 1 3639 0
 12983 0038 BDF90600 		ldrsh	r0, [sp, #6]
 12984              	.LVL1629:
 12985 003c FFF7FEFF 		bl	__aeabi_i2d
 12986              	.LVL1630:
ARM GAS  /tmp/ccVWLGiI.s 			page 381


 12987 0040 0022     		movs	r2, #0
 12988 0042 064B     		ldr	r3, .L1412
 12989 0044 FFF7FEFF 		bl	__aeabi_ddiv
 12990              	.LVL1631:
3638:Src/bno055.c  **** 				(float)(reg_euler_r_f/BNO055_EULER_DIV_RAD);
 12991              		.loc 1 3638 0
 12992 0048 FFF7FEFF 		bl	__aeabi_d2f
 12993              	.LVL1632:
 12994 004c 2860     		str	r0, [r5]	@ float
3648:Src/bno055.c  **** /*!
 12995              		.loc 1 3648 0
 12996 004e 60B2     		sxtb	r0, r4
 12997 0050 03B0     		add	sp, sp, #12
 12998              	.LCFI559:
 12999              		.cfi_remember_state
 13000              		.cfi_def_cfa_offset 12
 13001              		@ sp needed
 13002 0052 30BD     		pop	{r4, r5, pc}
 13003              	.LVL1633:
 13004              	.L1407:
 13005              	.LCFI560:
 13006              		.cfi_restore_state
3645:Src/bno055.c  **** 		}
 13007              		.loc 1 3645 0
 13008 0054 FF24     		movs	r4, #255
 13009              	.LVL1634:
3648:Src/bno055.c  **** /*!
 13010              		.loc 1 3648 0
 13011 0056 60B2     		sxtb	r0, r4
 13012 0058 03B0     		add	sp, sp, #12
 13013              	.LCFI561:
 13014              		.cfi_def_cfa_offset 12
 13015              		@ sp needed
 13016 005a 30BD     		pop	{r4, r5, pc}
 13017              	.LVL1635:
 13018              	.L1413:
 13019              		.align	2
 13020              	.L1412:
 13021 005c 00208C40 		.word	1082925056
 13022              		.cfi_endproc
 13023              	.LFE64:
 13025              		.section	.text.bno055_convert_float_euler_p_deg,"ax",%progbits
 13026              		.align	2
 13027              		.global	bno055_convert_float_euler_p_deg
 13028              		.thumb
 13029              		.thumb_func
 13031              	bno055_convert_float_euler_p_deg:
 13032              	.LFB65:
3662:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13033              		.loc 1 3662 0
 13034              		.cfi_startproc
 13035              		@ args = 0, pretend = 0, frame = 8
 13036              		@ frame_needed = 0, uses_anonymous_args = 0
 13037              	.LVL1636:
 13038 0000 70B5     		push	{r4, r5, r6, lr}
 13039              	.LCFI562:
 13040              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccVWLGiI.s 			page 382


 13041              		.cfi_offset 4, -16
 13042              		.cfi_offset 5, -12
 13043              		.cfi_offset 6, -8
 13044              		.cfi_offset 14, -4
 13045 0002 82B0     		sub	sp, sp, #8
 13046              	.LCFI563:
 13047              		.cfi_def_cfa_offset 24
3666:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13048              		.loc 1 3666 0
 13049 0004 02AB     		add	r3, sp, #8
3664:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 13050              		.loc 1 3664 0
 13051 0006 0025     		movs	r5, #0
3666:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13052              		.loc 1 3666 0
 13053 0008 03F8035D 		strb	r5, [r3, #-3]!
3662:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13054              		.loc 1 3662 0
 13055 000c 0646     		mov	r6, r0
3669:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13056              		.loc 1 3669 0
 13057 000e 1846     		mov	r0, r3
 13058              	.LVL1637:
3664:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 13059              		.loc 1 3664 0
 13060 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 13061              	.LVL1638:
3669:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13062              		.loc 1 3669 0
 13063 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13064              	.LVL1639:
3670:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13065              		.loc 1 3670 0
 13066 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3669:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13067              		.loc 1 3669 0
 13068 001c 0446     		mov	r4, r0
 13069              	.LVL1640:
3670:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13070              		.loc 1 3670 0
 13071 001e 9BB9     		cbnz	r3, .L1423
 13072              	.L1415:
3672:Src/bno055.c  **** 			/* Read Euler raw p data*/
 13073              		.loc 1 3672 0
 13074 0020 C4B9     		cbnz	r4, .L1418
3674:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13075              		.loc 1 3674 0
 13076 0022 0DF10600 		add	r0, sp, #6
 13077 0026 FFF7FEFF 		bl	bno055_read_euler_p
 13078              	.LVL1641:
3675:Src/bno055.c  **** 				/* Convert raw Euler p data to degree*/
 13079              		.loc 1 3675 0
 13080 002a 98B9     		cbnz	r0, .L1418
 13081              	.LVL1642:
3678:Src/bno055.c  **** 				*euler_p_f = data_f;
 13082              		.loc 1 3678 0
 13083 002c BDF90600 		ldrsh	r0, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 383


 13084              	.LVL1643:
 13085 0030 FFF7FEFF 		bl	__aeabi_i2d
 13086              	.LVL1644:
 13087 0034 0022     		movs	r2, #0
 13088 0036 094B     		ldr	r3, .L1424
 13089 0038 FFF7FEFF 		bl	__aeabi_dmul
 13090              	.LVL1645:
3677:Src/bno055.c  **** 				(float)(reg_euler_p_f/BNO055_EULER_DIV_DEG);
 13091              		.loc 1 3677 0
 13092 003c FFF7FEFF 		bl	__aeabi_d2f
 13093              	.LVL1646:
 13094 0040 3060     		str	r0, [r6]	@ float
3687:Src/bno055.c  **** /*!
 13095              		.loc 1 3687 0
 13096 0042 60B2     		sxtb	r0, r4
 13097 0044 02B0     		add	sp, sp, #8
 13098              	.LCFI564:
 13099              		.cfi_remember_state
 13100              		.cfi_def_cfa_offset 16
 13101              		@ sp needed
 13102 0046 70BD     		pop	{r4, r5, r6, pc}
 13103              	.LVL1647:
 13104              	.L1423:
 13105              	.LCFI565:
 13106              		.cfi_restore_state
3671:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 13107              		.loc 1 3671 0
 13108 0048 2846     		mov	r0, r5
 13109 004a FFF7FEFF 		bl	bno055_set_euler_unit
 13110              	.LVL1648:
 13111 004e 2044     		add	r0, r0, r4
 13112 0050 C4B2     		uxtb	r4, r0
 13113              	.LVL1649:
 13114 0052 E5E7     		b	.L1415
 13115              	.LVL1650:
 13116              	.L1418:
3684:Src/bno055.c  **** 		}
 13117              		.loc 1 3684 0
 13118 0054 FF24     		movs	r4, #255
 13119              	.LVL1651:
3687:Src/bno055.c  **** /*!
 13120              		.loc 1 3687 0
 13121 0056 60B2     		sxtb	r0, r4
 13122 0058 02B0     		add	sp, sp, #8
 13123              	.LCFI566:
 13124              		.cfi_def_cfa_offset 16
 13125              		@ sp needed
 13126 005a 70BD     		pop	{r4, r5, r6, pc}
 13127              	.LVL1652:
 13128              	.L1425:
 13129              		.align	2
 13130              	.L1424:
 13131 005c 0000B03F 		.word	1068498944
 13132              		.cfi_endproc
 13133              	.LFE65:
 13135              		.section	.text.bno055_convert_float_euler_p_rad,"ax",%progbits
 13136              		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 384


 13137              		.global	bno055_convert_float_euler_p_rad
 13138              		.thumb
 13139              		.thumb_func
 13141              	bno055_convert_float_euler_p_rad:
 13142              	.LFB66:
3702:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13143              		.loc 1 3702 0
 13144              		.cfi_startproc
 13145              		@ args = 0, pretend = 0, frame = 8
 13146              		@ frame_needed = 0, uses_anonymous_args = 0
 13147              	.LVL1653:
 13148 0000 30B5     		push	{r4, r5, lr}
 13149              	.LCFI567:
 13150              		.cfi_def_cfa_offset 12
 13151              		.cfi_offset 4, -12
 13152              		.cfi_offset 5, -8
 13153              		.cfi_offset 14, -4
 13154 0002 83B0     		sub	sp, sp, #12
 13155              	.LCFI568:
 13156              		.cfi_def_cfa_offset 24
3706:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13157              		.loc 1 3706 0
 13158 0004 02AB     		add	r3, sp, #8
3704:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 13159              		.loc 1 3704 0
 13160 0006 0022     		movs	r2, #0
3706:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13161              		.loc 1 3706 0
 13162 0008 03F8032D 		strb	r2, [r3, #-3]!
3702:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13163              		.loc 1 3702 0
 13164 000c 0546     		mov	r5, r0
3709:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13165              		.loc 1 3709 0
 13166 000e 1846     		mov	r0, r3
 13167              	.LVL1654:
3704:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 13168              		.loc 1 3704 0
 13169 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 13170              	.LVL1655:
3709:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13171              		.loc 1 3709 0
 13172 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13173              	.LVL1656:
3710:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13174              		.loc 1 3710 0
 13175 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
3709:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13176              		.loc 1 3709 0
 13177 001c 0446     		mov	r4, r0
 13178              	.LVL1657:
3710:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13179              		.loc 1 3710 0
 13180 001e 012B     		cmp	r3, #1
 13181 0020 04D0     		beq	.L1427
3711:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 13182              		.loc 1 3711 0
ARM GAS  /tmp/ccVWLGiI.s 			page 385


 13183 0022 0120     		movs	r0, #1
 13184 0024 FFF7FEFF 		bl	bno055_set_euler_unit
 13185              	.LVL1658:
 13186 0028 2044     		add	r0, r0, r4
 13187 002a C4B2     		uxtb	r4, r0
 13188              	.LVL1659:
 13189              	.L1427:
3712:Src/bno055.c  **** 			/* Read Euler raw r data*/
 13190              		.loc 1 3712 0
 13191 002c 94B9     		cbnz	r4, .L1430
3714:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13192              		.loc 1 3714 0
 13193 002e 0DF10600 		add	r0, sp, #6
 13194 0032 FFF7FEFF 		bl	bno055_read_euler_p
 13195              	.LVL1660:
3715:Src/bno055.c  **** 				/* Convert raw Euler r data to radians*/
 13196              		.loc 1 3715 0
 13197 0036 68B9     		cbnz	r0, .L1430
 13198              	.LVL1661:
3718:Src/bno055.c  **** 				*euler_p_f = data_f;
 13199              		.loc 1 3718 0
 13200 0038 BDF90600 		ldrsh	r0, [sp, #6]
 13201              	.LVL1662:
 13202 003c FFF7FEFF 		bl	__aeabi_i2d
 13203              	.LVL1663:
 13204 0040 0022     		movs	r2, #0
 13205 0042 064B     		ldr	r3, .L1435
 13206 0044 FFF7FEFF 		bl	__aeabi_ddiv
 13207              	.LVL1664:
3717:Src/bno055.c  **** 				(float)(reg_euler_p_f/BNO055_EULER_DIV_RAD);
 13208              		.loc 1 3717 0
 13209 0048 FFF7FEFF 		bl	__aeabi_d2f
 13210              	.LVL1665:
 13211 004c 2860     		str	r0, [r5]	@ float
3727:Src/bno055.c  **** /*!
 13212              		.loc 1 3727 0
 13213 004e 60B2     		sxtb	r0, r4
 13214 0050 03B0     		add	sp, sp, #12
 13215              	.LCFI569:
 13216              		.cfi_remember_state
 13217              		.cfi_def_cfa_offset 12
 13218              		@ sp needed
 13219 0052 30BD     		pop	{r4, r5, pc}
 13220              	.LVL1666:
 13221              	.L1430:
 13222              	.LCFI570:
 13223              		.cfi_restore_state
3724:Src/bno055.c  **** 		}
 13224              		.loc 1 3724 0
 13225 0054 FF24     		movs	r4, #255
 13226              	.LVL1667:
3727:Src/bno055.c  **** /*!
 13227              		.loc 1 3727 0
 13228 0056 60B2     		sxtb	r0, r4
 13229 0058 03B0     		add	sp, sp, #12
 13230              	.LCFI571:
 13231              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 386


 13232              		@ sp needed
 13233 005a 30BD     		pop	{r4, r5, pc}
 13234              	.LVL1668:
 13235              	.L1436:
 13236              		.align	2
 13237              	.L1435:
 13238 005c 00208C40 		.word	1082925056
 13239              		.cfi_endproc
 13240              	.LFE66:
 13242              		.section	.text.bno055_convert_float_euler_hpr_deg,"ax",%progbits
 13243              		.align	2
 13244              		.global	bno055_convert_float_euler_hpr_deg
 13245              		.thumb
 13246              		.thumb_func
 13248              	bno055_convert_float_euler_hpr_deg:
 13249              	.LFB67:
3748:Src/bno055.c  **** 	/* Variable used to return value of
 13250              		.loc 1 3748 0
 13251              		.cfi_startproc
 13252              		@ args = 0, pretend = 0, frame = 16
 13253              		@ frame_needed = 0, uses_anonymous_args = 0
 13254              	.LVL1669:
 13255 0000 70B5     		push	{r4, r5, r6, lr}
 13256              	.LCFI572:
 13257              		.cfi_def_cfa_offset 16
 13258              		.cfi_offset 4, -16
 13259              		.cfi_offset 5, -12
 13260              		.cfi_offset 6, -8
 13261              		.cfi_offset 14, -4
 13262 0002 84B0     		sub	sp, sp, #16
 13263              	.LCFI573:
 13264              		.cfi_def_cfa_offset 32
3754:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13265              		.loc 1 3754 0
 13266 0004 04AB     		add	r3, sp, #16
3752:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 13267              		.loc 1 3752 0
 13268 0006 0024     		movs	r4, #0
3754:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13269              		.loc 1 3754 0
 13270 0008 03F8094D 		strb	r4, [r3, #-9]!
3748:Src/bno055.c  **** 	/* Variable used to return value of
 13271              		.loc 1 3748 0
 13272 000c 0646     		mov	r6, r0
3757:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13273              		.loc 1 3757 0
 13274 000e 1846     		mov	r0, r3
 13275              	.LVL1670:
3752:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 13276              		.loc 1 3752 0
 13277 0010 ADF80840 		strh	r4, [sp, #8]	@ movhi
 13278 0014 ADF80A40 		strh	r4, [sp, #10]	@ movhi
 13279 0018 ADF80C40 		strh	r4, [sp, #12]	@ movhi
3757:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13280              		.loc 1 3757 0
 13281 001c FFF7FEFF 		bl	bno055_get_euler_unit
 13282              	.LVL1671:
ARM GAS  /tmp/ccVWLGiI.s 			page 387


3758:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13283              		.loc 1 3758 0
 13284 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
3757:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13285              		.loc 1 3757 0
 13286 0024 0546     		mov	r5, r0
 13287              	.LVL1672:
3758:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13288              		.loc 1 3758 0
 13289 0026 43BB     		cbnz	r3, .L1446
 13290              	.L1438:
3760:Src/bno055.c  **** 			/* Read Euler raw hrp data*/
 13291              		.loc 1 3760 0
 13292 0028 6DBB     		cbnz	r5, .L1441
3762:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13293              		.loc 1 3762 0
 13294 002a 02A8     		add	r0, sp, #8
 13295 002c FFF7FEFF 		bl	bno055_read_euler_hrp
 13296              	.LVL1673:
3763:Src/bno055.c  **** 				/* Convert raw Euler hrp to degree*/
 13297              		.loc 1 3763 0
 13298 0030 48BB     		cbnz	r0, .L1441
3766:Src/bno055.c  **** 				euler_hpr->p =
 13299              		.loc 1 3766 0
 13300 0032 BDF90800 		ldrsh	r0, [sp, #8]
 13301              	.LVL1674:
 13302 0036 FFF7FEFF 		bl	__aeabi_i2d
 13303              	.LVL1675:
 13304 003a 0022     		movs	r2, #0
 13305 003c 144B     		ldr	r3, .L1447
 13306 003e FFF7FEFF 		bl	__aeabi_dmul
 13307              	.LVL1676:
 13308 0042 FFF7FEFF 		bl	__aeabi_d2f
 13309              	.LVL1677:
 13310 0046 3060     		str	r0, [r6]	@ float
3768:Src/bno055.c  **** 				euler_hpr->r =
 13311              		.loc 1 3768 0
 13312 0048 BDF90C00 		ldrsh	r0, [sp, #12]
 13313 004c FFF7FEFF 		bl	__aeabi_i2d
 13314              	.LVL1678:
 13315 0050 0022     		movs	r2, #0
 13316 0052 0F4B     		ldr	r3, .L1447
 13317 0054 FFF7FEFF 		bl	__aeabi_dmul
 13318              	.LVL1679:
 13319 0058 FFF7FEFF 		bl	__aeabi_d2f
 13320              	.LVL1680:
 13321 005c B060     		str	r0, [r6, #8]	@ float
3770:Src/bno055.c  **** 			} else {
 13322              		.loc 1 3770 0
 13323 005e BDF90A00 		ldrsh	r0, [sp, #10]
 13324 0062 FFF7FEFF 		bl	__aeabi_i2d
 13325              	.LVL1681:
 13326 0066 0022     		movs	r2, #0
 13327 0068 094B     		ldr	r3, .L1447
 13328 006a FFF7FEFF 		bl	__aeabi_dmul
 13329              	.LVL1682:
 13330 006e FFF7FEFF 		bl	__aeabi_d2f
ARM GAS  /tmp/ccVWLGiI.s 			page 388


 13331              	.LVL1683:
 13332 0072 7060     		str	r0, [r6, #4]	@ float
3778:Src/bno055.c  **** /*!
 13333              		.loc 1 3778 0
 13334 0074 68B2     		sxtb	r0, r5
 13335 0076 04B0     		add	sp, sp, #16
 13336              	.LCFI574:
 13337              		.cfi_remember_state
 13338              		.cfi_def_cfa_offset 16
 13339              		@ sp needed
 13340 0078 70BD     		pop	{r4, r5, r6, pc}
 13341              	.LVL1684:
 13342              	.L1446:
 13343              	.LCFI575:
 13344              		.cfi_restore_state
3759:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 13345              		.loc 1 3759 0
 13346 007a 2046     		mov	r0, r4
 13347 007c FFF7FEFF 		bl	bno055_set_euler_unit
 13348              	.LVL1685:
 13349 0080 2844     		add	r0, r0, r5
 13350 0082 C5B2     		uxtb	r5, r0
 13351              	.LVL1686:
 13352 0084 D0E7     		b	.L1438
 13353              	.LVL1687:
 13354              	.L1441:
3775:Src/bno055.c  **** 		}
 13355              		.loc 1 3775 0
 13356 0086 FF25     		movs	r5, #255
 13357              	.LVL1688:
3778:Src/bno055.c  **** /*!
 13358              		.loc 1 3778 0
 13359 0088 68B2     		sxtb	r0, r5
 13360 008a 04B0     		add	sp, sp, #16
 13361              	.LCFI576:
 13362              		.cfi_def_cfa_offset 16
 13363              		@ sp needed
 13364 008c 70BD     		pop	{r4, r5, r6, pc}
 13365              	.LVL1689:
 13366              	.L1448:
 13367 008e 00BF     		.align	2
 13368              	.L1447:
 13369 0090 0000B03F 		.word	1068498944
 13370              		.cfi_endproc
 13371              	.LFE67:
 13373              		.section	.text.bno055_convert_float_euler_hpr_rad,"ax",%progbits
 13374              		.align	2
 13375              		.global	bno055_convert_float_euler_hpr_rad
 13376              		.thumb
 13377              		.thumb_func
 13379              	bno055_convert_float_euler_hpr_rad:
 13380              	.LFB68:
3799:Src/bno055.c  **** 	/* Variable used to return value of
 13381              		.loc 1 3799 0
 13382              		.cfi_startproc
 13383              		@ args = 0, pretend = 0, frame = 16
 13384              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccVWLGiI.s 			page 389


 13385              	.LVL1690:
 13386 0000 30B5     		push	{r4, r5, lr}
 13387              	.LCFI577:
 13388              		.cfi_def_cfa_offset 12
 13389              		.cfi_offset 4, -12
 13390              		.cfi_offset 5, -8
 13391              		.cfi_offset 14, -4
 13392 0002 85B0     		sub	sp, sp, #20
 13393              	.LCFI578:
 13394              		.cfi_def_cfa_offset 32
3803:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 13395              		.loc 1 3803 0
 13396 0004 0023     		movs	r3, #0
3805:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13397              		.loc 1 3805 0
 13398 0006 04AA     		add	r2, sp, #16
 13399 0008 02F8093D 		strb	r3, [r2, #-9]!
3799:Src/bno055.c  **** 	/* Variable used to return value of
 13400              		.loc 1 3799 0
 13401 000c 0546     		mov	r5, r0
3808:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13402              		.loc 1 3808 0
 13403 000e 1046     		mov	r0, r2
 13404              	.LVL1691:
3803:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 13405              		.loc 1 3803 0
 13406 0010 ADF80830 		strh	r3, [sp, #8]	@ movhi
 13407 0014 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 13408 0018 ADF80C30 		strh	r3, [sp, #12]	@ movhi
3808:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13409              		.loc 1 3808 0
 13410 001c FFF7FEFF 		bl	bno055_get_euler_unit
 13411              	.LVL1692:
3809:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13412              		.loc 1 3809 0
 13413 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
3808:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13414              		.loc 1 3808 0
 13415 0024 0446     		mov	r4, r0
 13416              	.LVL1693:
3809:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13417              		.loc 1 3809 0
 13418 0026 012B     		cmp	r3, #1
 13419 0028 04D0     		beq	.L1450
3810:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 13420              		.loc 1 3810 0
 13421 002a 0120     		movs	r0, #1
 13422 002c FFF7FEFF 		bl	bno055_set_euler_unit
 13423              	.LVL1694:
 13424 0030 2044     		add	r0, r0, r4
 13425 0032 C4B2     		uxtb	r4, r0
 13426              	.LVL1695:
 13427              	.L1450:
3811:Src/bno055.c  **** 			/* Read Euler raw hrp data*/
 13428              		.loc 1 3811 0
 13429 0034 3CBB     		cbnz	r4, .L1453
3813:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 390


 13430              		.loc 1 3813 0
 13431 0036 02A8     		add	r0, sp, #8
 13432 0038 FFF7FEFF 		bl	bno055_read_euler_hrp
 13433              	.LVL1696:
3814:Src/bno055.c  **** 				/* Convert raw hrp to radians */
 13434              		.loc 1 3814 0
 13435 003c 18BB     		cbnz	r0, .L1453
3817:Src/bno055.c  **** 				euler_hpr->p =
 13436              		.loc 1 3817 0
 13437 003e BDF90800 		ldrsh	r0, [sp, #8]
 13438              	.LVL1697:
 13439 0042 FFF7FEFF 		bl	__aeabi_i2d
 13440              	.LVL1698:
 13441 0046 0022     		movs	r2, #0
 13442 0048 114B     		ldr	r3, .L1458
 13443 004a FFF7FEFF 		bl	__aeabi_ddiv
 13444              	.LVL1699:
 13445 004e FFF7FEFF 		bl	__aeabi_d2f
 13446              	.LVL1700:
 13447 0052 2860     		str	r0, [r5]	@ float
3819:Src/bno055.c  **** 				euler_hpr->r =
 13448              		.loc 1 3819 0
 13449 0054 BDF90C00 		ldrsh	r0, [sp, #12]
 13450 0058 FFF7FEFF 		bl	__aeabi_i2d
 13451              	.LVL1701:
 13452 005c 0022     		movs	r2, #0
 13453 005e 0C4B     		ldr	r3, .L1458
 13454 0060 FFF7FEFF 		bl	__aeabi_ddiv
 13455              	.LVL1702:
 13456 0064 FFF7FEFF 		bl	__aeabi_d2f
 13457              	.LVL1703:
 13458 0068 A860     		str	r0, [r5, #8]	@ float
3821:Src/bno055.c  **** 			} else {
 13459              		.loc 1 3821 0
 13460 006a BDF90A00 		ldrsh	r0, [sp, #10]
 13461 006e FFF7FEFF 		bl	__aeabi_i2d
 13462              	.LVL1704:
 13463 0072 0022     		movs	r2, #0
 13464 0074 064B     		ldr	r3, .L1458
 13465 0076 FFF7FEFF 		bl	__aeabi_ddiv
 13466              	.LVL1705:
 13467 007a FFF7FEFF 		bl	__aeabi_d2f
 13468              	.LVL1706:
 13469 007e 6860     		str	r0, [r5, #4]	@ float
3829:Src/bno055.c  **** /*!
 13470              		.loc 1 3829 0
 13471 0080 60B2     		sxtb	r0, r4
 13472 0082 05B0     		add	sp, sp, #20
 13473              	.LCFI579:
 13474              		.cfi_remember_state
 13475              		.cfi_def_cfa_offset 12
 13476              		@ sp needed
 13477 0084 30BD     		pop	{r4, r5, pc}
 13478              	.LVL1707:
 13479              	.L1453:
 13480              	.LCFI580:
 13481              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 391


3826:Src/bno055.c  **** 		}
 13482              		.loc 1 3826 0
 13483 0086 FF24     		movs	r4, #255
 13484              	.LVL1708:
3829:Src/bno055.c  **** /*!
 13485              		.loc 1 3829 0
 13486 0088 60B2     		sxtb	r0, r4
 13487 008a 05B0     		add	sp, sp, #20
 13488              	.LCFI581:
 13489              		.cfi_def_cfa_offset 12
 13490              		@ sp needed
 13491 008c 30BD     		pop	{r4, r5, pc}
 13492              	.LVL1709:
 13493              	.L1459:
 13494 008e 00BF     		.align	2
 13495              	.L1458:
 13496 0090 00208C40 		.word	1082925056
 13497              		.cfi_endproc
 13498              	.LFE68:
 13500              		.section	.text.bno055_convert_double_euler_h_deg,"ax",%progbits
 13501              		.align	2
 13502              		.global	bno055_convert_double_euler_h_deg
 13503              		.thumb
 13504              		.thumb_func
 13506              	bno055_convert_double_euler_h_deg:
 13507              	.LFB99:
5061:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13508              		.loc 1 5061 0
 13509              		.cfi_startproc
 13510              		@ args = 0, pretend = 0, frame = 8
 13511              		@ frame_needed = 0, uses_anonymous_args = 0
 13512              	.LVL1710:
 13513 0000 70B5     		push	{r4, r5, r6, lr}
 13514              	.LCFI582:
 13515              		.cfi_def_cfa_offset 16
 13516              		.cfi_offset 4, -16
 13517              		.cfi_offset 5, -12
 13518              		.cfi_offset 6, -8
 13519              		.cfi_offset 14, -4
 13520 0002 82B0     		sub	sp, sp, #8
 13521              	.LCFI583:
 13522              		.cfi_def_cfa_offset 24
5065:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13523              		.loc 1 5065 0
 13524 0004 02AB     		add	r3, sp, #8
5063:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13525              		.loc 1 5063 0
 13526 0006 0025     		movs	r5, #0
5065:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13527              		.loc 1 5065 0
 13528 0008 03F8035D 		strb	r5, [r3, #-3]!
5061:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13529              		.loc 1 5061 0
 13530 000c 0646     		mov	r6, r0
5068:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13531              		.loc 1 5068 0
 13532 000e 1846     		mov	r0, r3
ARM GAS  /tmp/ccVWLGiI.s 			page 392


 13533              	.LVL1711:
5063:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13534              		.loc 1 5063 0
 13535 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 13536              	.LVL1712:
5068:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13537              		.loc 1 5068 0
 13538 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13539              	.LVL1713:
5069:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13540              		.loc 1 5069 0
 13541 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
5068:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13542              		.loc 1 5068 0
 13543 001c 0446     		mov	r4, r0
 13544              	.LVL1714:
5069:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13545              		.loc 1 5069 0
 13546 001e 93B9     		cbnz	r3, .L1469
 13547              	.L1461:
5071:Src/bno055.c  **** 			/* Read Euler raw h data*/
 13548              		.loc 1 5071 0
 13549 0020 BCB9     		cbnz	r4, .L1464
5073:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13550              		.loc 1 5073 0
 13551 0022 0DF10600 		add	r0, sp, #6
 13552 0026 FFF7FEFF 		bl	bno055_read_euler_h
 13553              	.LVL1715:
5074:Src/bno055.c  **** 				/* Convert raw Euler h to degree */
 13554              		.loc 1 5074 0
 13555 002a 90B9     		cbnz	r0, .L1464
 13556              	.LVL1716:
5077:Src/bno055.c  **** 				*euler_h_d = data_d;
 13557              		.loc 1 5077 0
 13558 002c BDF90600 		ldrsh	r0, [sp, #6]
 13559              	.LVL1717:
 13560 0030 FFF7FEFF 		bl	__aeabi_i2d
 13561              	.LVL1718:
5076:Src/bno055.c  **** 				(double)(reg_euler_h_s16/BNO055_EULER_DIV_DEG);
 13562              		.loc 1 5076 0
 13563 0034 0022     		movs	r2, #0
 13564 0036 094B     		ldr	r3, .L1470
 13565 0038 FFF7FEFF 		bl	__aeabi_dmul
 13566              	.LVL1719:
5078:Src/bno055.c  **** 			} else {
 13567              		.loc 1 5078 0
 13568 003c C6E90001 		strd	r0, [r6]
5086:Src/bno055.c  **** /*!
 13569              		.loc 1 5086 0
 13570 0040 60B2     		sxtb	r0, r4
 13571 0042 02B0     		add	sp, sp, #8
 13572              	.LCFI584:
 13573              		.cfi_remember_state
 13574              		.cfi_def_cfa_offset 16
 13575              		@ sp needed
 13576 0044 70BD     		pop	{r4, r5, r6, pc}
 13577              	.LVL1720:
ARM GAS  /tmp/ccVWLGiI.s 			page 393


 13578              	.L1469:
 13579              	.LCFI585:
 13580              		.cfi_restore_state
5070:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 13581              		.loc 1 5070 0
 13582 0046 2846     		mov	r0, r5
 13583 0048 FFF7FEFF 		bl	bno055_set_euler_unit
 13584              	.LVL1721:
 13585 004c 2044     		add	r0, r0, r4
 13586 004e C4B2     		uxtb	r4, r0
 13587              	.LVL1722:
 13588 0050 E6E7     		b	.L1461
 13589              	.LVL1723:
 13590              	.L1464:
5083:Src/bno055.c  **** 		}
 13591              		.loc 1 5083 0
 13592 0052 FF24     		movs	r4, #255
 13593              	.LVL1724:
5086:Src/bno055.c  **** /*!
 13594              		.loc 1 5086 0
 13595 0054 60B2     		sxtb	r0, r4
 13596 0056 02B0     		add	sp, sp, #8
 13597              	.LCFI586:
 13598              		.cfi_def_cfa_offset 16
 13599              		@ sp needed
 13600 0058 70BD     		pop	{r4, r5, r6, pc}
 13601              	.LVL1725:
 13602              	.L1471:
 13603 005a 00BF     		.align	2
 13604              	.L1470:
 13605 005c 0000B03F 		.word	1068498944
 13606              		.cfi_endproc
 13607              	.LFE99:
 13609              		.section	.text.bno055_convert_double_euler_h_rad,"ax",%progbits
 13610              		.align	2
 13611              		.global	bno055_convert_double_euler_h_rad
 13612              		.thumb
 13613              		.thumb_func
 13615              	bno055_convert_double_euler_h_rad:
 13616              	.LFB100:
5101:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13617              		.loc 1 5101 0
 13618              		.cfi_startproc
 13619              		@ args = 0, pretend = 0, frame = 8
 13620              		@ frame_needed = 0, uses_anonymous_args = 0
 13621              	.LVL1726:
 13622 0000 30B5     		push	{r4, r5, lr}
 13623              	.LCFI587:
 13624              		.cfi_def_cfa_offset 12
 13625              		.cfi_offset 4, -12
 13626              		.cfi_offset 5, -8
 13627              		.cfi_offset 14, -4
 13628 0002 83B0     		sub	sp, sp, #12
 13629              	.LCFI588:
 13630              		.cfi_def_cfa_offset 24
5105:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13631              		.loc 1 5105 0
ARM GAS  /tmp/ccVWLGiI.s 			page 394


 13632 0004 02AB     		add	r3, sp, #8
5103:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13633              		.loc 1 5103 0
 13634 0006 0022     		movs	r2, #0
5105:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13635              		.loc 1 5105 0
 13636 0008 03F8032D 		strb	r2, [r3, #-3]!
5101:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13637              		.loc 1 5101 0
 13638 000c 0546     		mov	r5, r0
5108:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13639              		.loc 1 5108 0
 13640 000e 1846     		mov	r0, r3
 13641              	.LVL1727:
5103:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13642              		.loc 1 5103 0
 13643 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 13644              	.LVL1728:
5108:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13645              		.loc 1 5108 0
 13646 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13647              	.LVL1729:
5109:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13648              		.loc 1 5109 0
 13649 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
5108:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13650              		.loc 1 5108 0
 13651 001c 0446     		mov	r4, r0
 13652              	.LVL1730:
5109:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13653              		.loc 1 5109 0
 13654 001e 012B     		cmp	r3, #1
 13655 0020 04D0     		beq	.L1473
5110:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 13656              		.loc 1 5110 0
 13657 0022 0120     		movs	r0, #1
 13658 0024 FFF7FEFF 		bl	bno055_set_euler_unit
 13659              	.LVL1731:
 13660 0028 2044     		add	r0, r0, r4
 13661 002a C4B2     		uxtb	r4, r0
 13662              	.LVL1732:
 13663              	.L1473:
5111:Src/bno055.c  **** 			/* Read Euler raw h data*/
 13664              		.loc 1 5111 0
 13665 002c 8CB9     		cbnz	r4, .L1476
5113:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13666              		.loc 1 5113 0
 13667 002e 0DF10600 		add	r0, sp, #6
 13668 0032 FFF7FEFF 		bl	bno055_read_euler_h
 13669              	.LVL1733:
5114:Src/bno055.c  **** 				/* Convert raw Euler h to radians */
 13670              		.loc 1 5114 0
 13671 0036 60B9     		cbnz	r0, .L1476
 13672              	.LVL1734:
5117:Src/bno055.c  **** 				*euler_h_d = data_d;
 13673              		.loc 1 5117 0
 13674 0038 BDF90600 		ldrsh	r0, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 395


 13675              	.LVL1735:
 13676 003c FFF7FEFF 		bl	__aeabi_i2d
 13677              	.LVL1736:
5116:Src/bno055.c  **** 				(double)(reg_euler_h_s16/BNO055_EULER_DIV_RAD);
 13678              		.loc 1 5116 0
 13679 0040 0022     		movs	r2, #0
 13680 0042 064B     		ldr	r3, .L1481
 13681 0044 FFF7FEFF 		bl	__aeabi_ddiv
 13682              	.LVL1737:
5118:Src/bno055.c  **** 			} else {
 13683              		.loc 1 5118 0
 13684 0048 C5E90001 		strd	r0, [r5]
5126:Src/bno055.c  **** /*!
 13685              		.loc 1 5126 0
 13686 004c 60B2     		sxtb	r0, r4
 13687 004e 03B0     		add	sp, sp, #12
 13688              	.LCFI589:
 13689              		.cfi_remember_state
 13690              		.cfi_def_cfa_offset 12
 13691              		@ sp needed
 13692 0050 30BD     		pop	{r4, r5, pc}
 13693              	.LVL1738:
 13694              	.L1476:
 13695              	.LCFI590:
 13696              		.cfi_restore_state
5123:Src/bno055.c  **** 		}
 13697              		.loc 1 5123 0
 13698 0052 FF24     		movs	r4, #255
 13699              	.LVL1739:
5126:Src/bno055.c  **** /*!
 13700              		.loc 1 5126 0
 13701 0054 60B2     		sxtb	r0, r4
 13702 0056 03B0     		add	sp, sp, #12
 13703              	.LCFI591:
 13704              		.cfi_def_cfa_offset 12
 13705              		@ sp needed
 13706 0058 30BD     		pop	{r4, r5, pc}
 13707              	.LVL1740:
 13708              	.L1482:
 13709 005a 00BF     		.align	2
 13710              	.L1481:
 13711 005c 00208C40 		.word	1082925056
 13712              		.cfi_endproc
 13713              	.LFE100:
 13715              		.section	.text.bno055_convert_double_euler_r_deg,"ax",%progbits
 13716              		.align	2
 13717              		.global	bno055_convert_double_euler_r_deg
 13718              		.thumb
 13719              		.thumb_func
 13721              	bno055_convert_double_euler_r_deg:
 13722              	.LFB101:
5141:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13723              		.loc 1 5141 0
 13724              		.cfi_startproc
 13725              		@ args = 0, pretend = 0, frame = 8
 13726              		@ frame_needed = 0, uses_anonymous_args = 0
 13727              	.LVL1741:
ARM GAS  /tmp/ccVWLGiI.s 			page 396


 13728 0000 70B5     		push	{r4, r5, r6, lr}
 13729              	.LCFI592:
 13730              		.cfi_def_cfa_offset 16
 13731              		.cfi_offset 4, -16
 13732              		.cfi_offset 5, -12
 13733              		.cfi_offset 6, -8
 13734              		.cfi_offset 14, -4
 13735 0002 82B0     		sub	sp, sp, #8
 13736              	.LCFI593:
 13737              		.cfi_def_cfa_offset 24
5145:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13738              		.loc 1 5145 0
 13739 0004 02AB     		add	r3, sp, #8
5143:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13740              		.loc 1 5143 0
 13741 0006 0025     		movs	r5, #0
5145:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13742              		.loc 1 5145 0
 13743 0008 03F8035D 		strb	r5, [r3, #-3]!
5141:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13744              		.loc 1 5141 0
 13745 000c 0646     		mov	r6, r0
5148:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13746              		.loc 1 5148 0
 13747 000e 1846     		mov	r0, r3
 13748              	.LVL1742:
5143:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13749              		.loc 1 5143 0
 13750 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 13751              	.LVL1743:
5148:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13752              		.loc 1 5148 0
 13753 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13754              	.LVL1744:
5149:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13755              		.loc 1 5149 0
 13756 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
5148:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13757              		.loc 1 5148 0
 13758 001c 0446     		mov	r4, r0
 13759              	.LVL1745:
5149:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13760              		.loc 1 5149 0
 13761 001e 93B9     		cbnz	r3, .L1492
 13762              	.L1484:
5151:Src/bno055.c  **** 			/* Read Euler raw r data*/
 13763              		.loc 1 5151 0
 13764 0020 BCB9     		cbnz	r4, .L1487
5153:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13765              		.loc 1 5153 0
 13766 0022 0DF10600 		add	r0, sp, #6
 13767 0026 FFF7FEFF 		bl	bno055_read_euler_r
 13768              	.LVL1746:
5154:Src/bno055.c  **** 				/* Convert raw Euler r to degree */
 13769              		.loc 1 5154 0
 13770 002a 90B9     		cbnz	r0, .L1487
 13771              	.LVL1747:
ARM GAS  /tmp/ccVWLGiI.s 			page 397


5157:Src/bno055.c  **** 				*euler_r_d = data_d;
 13772              		.loc 1 5157 0
 13773 002c BDF90600 		ldrsh	r0, [sp, #6]
 13774              	.LVL1748:
 13775 0030 FFF7FEFF 		bl	__aeabi_i2d
 13776              	.LVL1749:
5156:Src/bno055.c  **** 				(double)(reg_euler_r_s16/BNO055_EULER_DIV_DEG);
 13777              		.loc 1 5156 0
 13778 0034 0022     		movs	r2, #0
 13779 0036 094B     		ldr	r3, .L1493
 13780 0038 FFF7FEFF 		bl	__aeabi_dmul
 13781              	.LVL1750:
5158:Src/bno055.c  **** 			} else {
 13782              		.loc 1 5158 0
 13783 003c C6E90001 		strd	r0, [r6]
5166:Src/bno055.c  **** /*!
 13784              		.loc 1 5166 0
 13785 0040 60B2     		sxtb	r0, r4
 13786 0042 02B0     		add	sp, sp, #8
 13787              	.LCFI594:
 13788              		.cfi_remember_state
 13789              		.cfi_def_cfa_offset 16
 13790              		@ sp needed
 13791 0044 70BD     		pop	{r4, r5, r6, pc}
 13792              	.LVL1751:
 13793              	.L1492:
 13794              	.LCFI595:
 13795              		.cfi_restore_state
5150:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 13796              		.loc 1 5150 0
 13797 0046 2846     		mov	r0, r5
 13798 0048 FFF7FEFF 		bl	bno055_set_euler_unit
 13799              	.LVL1752:
 13800 004c 2044     		add	r0, r0, r4
 13801 004e C4B2     		uxtb	r4, r0
 13802              	.LVL1753:
 13803 0050 E6E7     		b	.L1484
 13804              	.LVL1754:
 13805              	.L1487:
5163:Src/bno055.c  **** 		}
 13806              		.loc 1 5163 0
 13807 0052 FF24     		movs	r4, #255
 13808              	.LVL1755:
5166:Src/bno055.c  **** /*!
 13809              		.loc 1 5166 0
 13810 0054 60B2     		sxtb	r0, r4
 13811 0056 02B0     		add	sp, sp, #8
 13812              	.LCFI596:
 13813              		.cfi_def_cfa_offset 16
 13814              		@ sp needed
 13815 0058 70BD     		pop	{r4, r5, r6, pc}
 13816              	.LVL1756:
 13817              	.L1494:
 13818 005a 00BF     		.align	2
 13819              	.L1493:
 13820 005c 0000B03F 		.word	1068498944
 13821              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 398


 13822              	.LFE101:
 13824              		.section	.text.bno055_convert_double_euler_r_rad,"ax",%progbits
 13825              		.align	2
 13826              		.global	bno055_convert_double_euler_r_rad
 13827              		.thumb
 13828              		.thumb_func
 13830              	bno055_convert_double_euler_r_rad:
 13831              	.LFB102:
5181:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13832              		.loc 1 5181 0
 13833              		.cfi_startproc
 13834              		@ args = 0, pretend = 0, frame = 8
 13835              		@ frame_needed = 0, uses_anonymous_args = 0
 13836              	.LVL1757:
 13837 0000 30B5     		push	{r4, r5, lr}
 13838              	.LCFI597:
 13839              		.cfi_def_cfa_offset 12
 13840              		.cfi_offset 4, -12
 13841              		.cfi_offset 5, -8
 13842              		.cfi_offset 14, -4
 13843 0002 83B0     		sub	sp, sp, #12
 13844              	.LCFI598:
 13845              		.cfi_def_cfa_offset 24
5185:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13846              		.loc 1 5185 0
 13847 0004 02AB     		add	r3, sp, #8
5183:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13848              		.loc 1 5183 0
 13849 0006 0022     		movs	r2, #0
5185:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13850              		.loc 1 5185 0
 13851 0008 03F8032D 		strb	r2, [r3, #-3]!
5181:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13852              		.loc 1 5181 0
 13853 000c 0546     		mov	r5, r0
5188:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13854              		.loc 1 5188 0
 13855 000e 1846     		mov	r0, r3
 13856              	.LVL1758:
5183:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13857              		.loc 1 5183 0
 13858 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 13859              	.LVL1759:
5188:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13860              		.loc 1 5188 0
 13861 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13862              	.LVL1760:
5189:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13863              		.loc 1 5189 0
 13864 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
5188:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 13865              		.loc 1 5188 0
 13866 001c 0446     		mov	r4, r0
 13867              	.LVL1761:
5189:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 13868              		.loc 1 5189 0
 13869 001e 012B     		cmp	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 399


 13870 0020 04D0     		beq	.L1496
5190:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 13871              		.loc 1 5190 0
 13872 0022 0120     		movs	r0, #1
 13873 0024 FFF7FEFF 		bl	bno055_set_euler_unit
 13874              	.LVL1762:
 13875 0028 2044     		add	r0, r0, r4
 13876 002a C4B2     		uxtb	r4, r0
 13877              	.LVL1763:
 13878              	.L1496:
5191:Src/bno055.c  **** 			/* Read Euler raw r data*/
 13879              		.loc 1 5191 0
 13880 002c 8CB9     		cbnz	r4, .L1499
5193:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13881              		.loc 1 5193 0
 13882 002e 0DF10600 		add	r0, sp, #6
 13883 0032 FFF7FEFF 		bl	bno055_read_euler_r
 13884              	.LVL1764:
5194:Src/bno055.c  **** 				/* Convert raw Euler r to radians */
 13885              		.loc 1 5194 0
 13886 0036 60B9     		cbnz	r0, .L1499
 13887              	.LVL1765:
5197:Src/bno055.c  **** 				*euler_r_d = data_d;
 13888              		.loc 1 5197 0
 13889 0038 BDF90600 		ldrsh	r0, [sp, #6]
 13890              	.LVL1766:
 13891 003c FFF7FEFF 		bl	__aeabi_i2d
 13892              	.LVL1767:
5196:Src/bno055.c  **** 				(double)(reg_euler_r_s16/BNO055_EULER_DIV_RAD);
 13893              		.loc 1 5196 0
 13894 0040 0022     		movs	r2, #0
 13895 0042 064B     		ldr	r3, .L1504
 13896 0044 FFF7FEFF 		bl	__aeabi_ddiv
 13897              	.LVL1768:
5198:Src/bno055.c  **** 			} else {
 13898              		.loc 1 5198 0
 13899 0048 C5E90001 		strd	r0, [r5]
5206:Src/bno055.c  **** /*!
 13900              		.loc 1 5206 0
 13901 004c 60B2     		sxtb	r0, r4
 13902 004e 03B0     		add	sp, sp, #12
 13903              	.LCFI599:
 13904              		.cfi_remember_state
 13905              		.cfi_def_cfa_offset 12
 13906              		@ sp needed
 13907 0050 30BD     		pop	{r4, r5, pc}
 13908              	.LVL1769:
 13909              	.L1499:
 13910              	.LCFI600:
 13911              		.cfi_restore_state
5203:Src/bno055.c  **** 		}
 13912              		.loc 1 5203 0
 13913 0052 FF24     		movs	r4, #255
 13914              	.LVL1770:
5206:Src/bno055.c  **** /*!
 13915              		.loc 1 5206 0
 13916 0054 60B2     		sxtb	r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 400


 13917 0056 03B0     		add	sp, sp, #12
 13918              	.LCFI601:
 13919              		.cfi_def_cfa_offset 12
 13920              		@ sp needed
 13921 0058 30BD     		pop	{r4, r5, pc}
 13922              	.LVL1771:
 13923              	.L1505:
 13924 005a 00BF     		.align	2
 13925              	.L1504:
 13926 005c 00208C40 		.word	1082925056
 13927              		.cfi_endproc
 13928              	.LFE102:
 13930              		.section	.text.bno055_convert_double_euler_p_deg,"ax",%progbits
 13931              		.align	2
 13932              		.global	bno055_convert_double_euler_p_deg
 13933              		.thumb
 13934              		.thumb_func
 13936              	bno055_convert_double_euler_p_deg:
 13937              	.LFB103:
5221:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13938              		.loc 1 5221 0
 13939              		.cfi_startproc
 13940              		@ args = 0, pretend = 0, frame = 8
 13941              		@ frame_needed = 0, uses_anonymous_args = 0
 13942              	.LVL1772:
 13943 0000 70B5     		push	{r4, r5, r6, lr}
 13944              	.LCFI602:
 13945              		.cfi_def_cfa_offset 16
 13946              		.cfi_offset 4, -16
 13947              		.cfi_offset 5, -12
 13948              		.cfi_offset 6, -8
 13949              		.cfi_offset 14, -4
 13950 0002 82B0     		sub	sp, sp, #8
 13951              	.LCFI603:
 13952              		.cfi_def_cfa_offset 24
5225:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13953              		.loc 1 5225 0
 13954 0004 02AB     		add	r3, sp, #8
5223:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13955              		.loc 1 5223 0
 13956 0006 0025     		movs	r5, #0
5225:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 13957              		.loc 1 5225 0
 13958 0008 03F8035D 		strb	r5, [r3, #-3]!
5221:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 13959              		.loc 1 5221 0
 13960 000c 0646     		mov	r6, r0
5228:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13961              		.loc 1 5228 0
 13962 000e 1846     		mov	r0, r3
 13963              	.LVL1773:
5223:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 13964              		.loc 1 5223 0
 13965 0010 ADF80650 		strh	r5, [sp, #6]	@ movhi
 13966              	.LVL1774:
5228:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13967              		.loc 1 5228 0
ARM GAS  /tmp/ccVWLGiI.s 			page 401


 13968 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 13969              	.LVL1775:
5229:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13970              		.loc 1 5229 0
 13971 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
5228:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 13972              		.loc 1 5228 0
 13973 001c 0446     		mov	r4, r0
 13974              	.LVL1776:
5229:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 13975              		.loc 1 5229 0
 13976 001e 93B9     		cbnz	r3, .L1515
 13977              	.L1507:
5231:Src/bno055.c  **** 			/* Read Euler raw p data*/
 13978              		.loc 1 5231 0
 13979 0020 BCB9     		cbnz	r4, .L1510
5233:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 13980              		.loc 1 5233 0
 13981 0022 0DF10600 		add	r0, sp, #6
 13982 0026 FFF7FEFF 		bl	bno055_read_euler_p
 13983              	.LVL1777:
5234:Src/bno055.c  **** 				/* Convert raw Euler p to degree*/
 13984              		.loc 1 5234 0
 13985 002a 90B9     		cbnz	r0, .L1510
 13986              	.LVL1778:
5237:Src/bno055.c  **** 				*euler_p_d = data_d;
 13987              		.loc 1 5237 0
 13988 002c BDF90600 		ldrsh	r0, [sp, #6]
 13989              	.LVL1779:
 13990 0030 FFF7FEFF 		bl	__aeabi_i2d
 13991              	.LVL1780:
5236:Src/bno055.c  **** 				(double)(reg_euler_p_s16/BNO055_EULER_DIV_DEG);
 13992              		.loc 1 5236 0
 13993 0034 0022     		movs	r2, #0
 13994 0036 094B     		ldr	r3, .L1516
 13995 0038 FFF7FEFF 		bl	__aeabi_dmul
 13996              	.LVL1781:
5238:Src/bno055.c  **** 			} else {
 13997              		.loc 1 5238 0
 13998 003c C6E90001 		strd	r0, [r6]
5246:Src/bno055.c  **** /*!
 13999              		.loc 1 5246 0
 14000 0040 60B2     		sxtb	r0, r4
 14001 0042 02B0     		add	sp, sp, #8
 14002              	.LCFI604:
 14003              		.cfi_remember_state
 14004              		.cfi_def_cfa_offset 16
 14005              		@ sp needed
 14006 0044 70BD     		pop	{r4, r5, r6, pc}
 14007              	.LVL1782:
 14008              	.L1515:
 14009              	.LCFI605:
 14010              		.cfi_restore_state
5230:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 14011              		.loc 1 5230 0
 14012 0046 2846     		mov	r0, r5
 14013 0048 FFF7FEFF 		bl	bno055_set_euler_unit
ARM GAS  /tmp/ccVWLGiI.s 			page 402


 14014              	.LVL1783:
 14015 004c 2044     		add	r0, r0, r4
 14016 004e C4B2     		uxtb	r4, r0
 14017              	.LVL1784:
 14018 0050 E6E7     		b	.L1507
 14019              	.LVL1785:
 14020              	.L1510:
5243:Src/bno055.c  **** 		}
 14021              		.loc 1 5243 0
 14022 0052 FF24     		movs	r4, #255
 14023              	.LVL1786:
5246:Src/bno055.c  **** /*!
 14024              		.loc 1 5246 0
 14025 0054 60B2     		sxtb	r0, r4
 14026 0056 02B0     		add	sp, sp, #8
 14027              	.LCFI606:
 14028              		.cfi_def_cfa_offset 16
 14029              		@ sp needed
 14030 0058 70BD     		pop	{r4, r5, r6, pc}
 14031              	.LVL1787:
 14032              	.L1517:
 14033 005a 00BF     		.align	2
 14034              	.L1516:
 14035 005c 0000B03F 		.word	1068498944
 14036              		.cfi_endproc
 14037              	.LFE103:
 14039              		.section	.text.bno055_convert_double_euler_p_rad,"ax",%progbits
 14040              		.align	2
 14041              		.global	bno055_convert_double_euler_p_rad
 14042              		.thumb
 14043              		.thumb_func
 14045              	bno055_convert_double_euler_p_rad:
 14046              	.LFB104:
5262:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14047              		.loc 1 5262 0
 14048              		.cfi_startproc
 14049              		@ args = 0, pretend = 0, frame = 8
 14050              		@ frame_needed = 0, uses_anonymous_args = 0
 14051              	.LVL1788:
 14052 0000 30B5     		push	{r4, r5, lr}
 14053              	.LCFI607:
 14054              		.cfi_def_cfa_offset 12
 14055              		.cfi_offset 4, -12
 14056              		.cfi_offset 5, -8
 14057              		.cfi_offset 14, -4
 14058 0002 83B0     		sub	sp, sp, #12
 14059              	.LCFI608:
 14060              		.cfi_def_cfa_offset 24
5266:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 14061              		.loc 1 5266 0
 14062 0004 02AB     		add	r3, sp, #8
5264:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 14063              		.loc 1 5264 0
 14064 0006 0022     		movs	r2, #0
5266:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 14065              		.loc 1 5266 0
 14066 0008 03F8032D 		strb	r2, [r3, #-3]!
ARM GAS  /tmp/ccVWLGiI.s 			page 403


5262:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14067              		.loc 1 5262 0
 14068 000c 0546     		mov	r5, r0
5269:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 14069              		.loc 1 5269 0
 14070 000e 1846     		mov	r0, r3
 14071              	.LVL1789:
5264:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 14072              		.loc 1 5264 0
 14073 0010 ADF80620 		strh	r2, [sp, #6]	@ movhi
 14074              	.LVL1790:
5269:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 14075              		.loc 1 5269 0
 14076 0014 FFF7FEFF 		bl	bno055_get_euler_unit
 14077              	.LVL1791:
5270:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 14078              		.loc 1 5270 0
 14079 0018 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
5269:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 14080              		.loc 1 5269 0
 14081 001c 0446     		mov	r4, r0
 14082              	.LVL1792:
5270:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 14083              		.loc 1 5270 0
 14084 001e 012B     		cmp	r3, #1
 14085 0020 04D0     		beq	.L1519
5271:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 14086              		.loc 1 5271 0
 14087 0022 0120     		movs	r0, #1
 14088 0024 FFF7FEFF 		bl	bno055_set_euler_unit
 14089              	.LVL1793:
 14090 0028 2044     		add	r0, r0, r4
 14091 002a C4B2     		uxtb	r4, r0
 14092              	.LVL1794:
 14093              	.L1519:
5272:Src/bno055.c  **** 			/* Read Euler raw p data*/
 14094              		.loc 1 5272 0
 14095 002c 8CB9     		cbnz	r4, .L1522
5274:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 14096              		.loc 1 5274 0
 14097 002e 0DF10600 		add	r0, sp, #6
 14098 0032 FFF7FEFF 		bl	bno055_read_euler_p
 14099              	.LVL1795:
5275:Src/bno055.c  **** 				/* Convert raw p to radians*/
 14100              		.loc 1 5275 0
 14101 0036 60B9     		cbnz	r0, .L1522
 14102              	.LVL1796:
5278:Src/bno055.c  **** 				*euler_p_d = data_d;
 14103              		.loc 1 5278 0
 14104 0038 BDF90600 		ldrsh	r0, [sp, #6]
 14105              	.LVL1797:
 14106 003c FFF7FEFF 		bl	__aeabi_i2d
 14107              	.LVL1798:
5277:Src/bno055.c  **** 				(double)(reg_euler_p_s16/BNO055_EULER_DIV_RAD);
 14108              		.loc 1 5277 0
 14109 0040 0022     		movs	r2, #0
 14110 0042 064B     		ldr	r3, .L1527
ARM GAS  /tmp/ccVWLGiI.s 			page 404


 14111 0044 FFF7FEFF 		bl	__aeabi_ddiv
 14112              	.LVL1799:
5279:Src/bno055.c  **** 			} else {
 14113              		.loc 1 5279 0
 14114 0048 C5E90001 		strd	r0, [r5]
5287:Src/bno055.c  **** /*!
 14115              		.loc 1 5287 0
 14116 004c 60B2     		sxtb	r0, r4
 14117 004e 03B0     		add	sp, sp, #12
 14118              	.LCFI609:
 14119              		.cfi_remember_state
 14120              		.cfi_def_cfa_offset 12
 14121              		@ sp needed
 14122 0050 30BD     		pop	{r4, r5, pc}
 14123              	.LVL1800:
 14124              	.L1522:
 14125              	.LCFI610:
 14126              		.cfi_restore_state
5284:Src/bno055.c  **** 		}
 14127              		.loc 1 5284 0
 14128 0052 FF24     		movs	r4, #255
 14129              	.LVL1801:
5287:Src/bno055.c  **** /*!
 14130              		.loc 1 5287 0
 14131 0054 60B2     		sxtb	r0, r4
 14132 0056 03B0     		add	sp, sp, #12
 14133              	.LCFI611:
 14134              		.cfi_def_cfa_offset 12
 14135              		@ sp needed
 14136 0058 30BD     		pop	{r4, r5, pc}
 14137              	.LVL1802:
 14138              	.L1528:
 14139 005a 00BF     		.align	2
 14140              	.L1527:
 14141 005c 00208C40 		.word	1082925056
 14142              		.cfi_endproc
 14143              	.LFE104:
 14145              		.section	.text.bno055_convert_double_euler_hpr_deg,"ax",%progbits
 14146              		.align	2
 14147              		.global	bno055_convert_double_euler_hpr_deg
 14148              		.thumb
 14149              		.thumb_func
 14151              	bno055_convert_double_euler_hpr_deg:
 14152              	.LFB105:
5309:Src/bno055.c  **** 	/* Variable used to return value of
 14153              		.loc 1 5309 0
 14154              		.cfi_startproc
 14155              		@ args = 0, pretend = 0, frame = 16
 14156              		@ frame_needed = 0, uses_anonymous_args = 0
 14157              	.LVL1803:
 14158 0000 70B5     		push	{r4, r5, r6, lr}
 14159              	.LCFI612:
 14160              		.cfi_def_cfa_offset 16
 14161              		.cfi_offset 4, -16
 14162              		.cfi_offset 5, -12
 14163              		.cfi_offset 6, -8
 14164              		.cfi_offset 14, -4
ARM GAS  /tmp/ccVWLGiI.s 			page 405


 14165 0002 84B0     		sub	sp, sp, #16
 14166              	.LCFI613:
 14167              		.cfi_def_cfa_offset 32
5315:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 14168              		.loc 1 5315 0
 14169 0004 04AB     		add	r3, sp, #16
5313:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 14170              		.loc 1 5313 0
 14171 0006 0024     		movs	r4, #0
5315:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 14172              		.loc 1 5315 0
 14173 0008 03F8094D 		strb	r4, [r3, #-9]!
5309:Src/bno055.c  **** 	/* Variable used to return value of
 14174              		.loc 1 5309 0
 14175 000c 0646     		mov	r6, r0
5318:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 14176              		.loc 1 5318 0
 14177 000e 1846     		mov	r0, r3
 14178              	.LVL1804:
5313:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 14179              		.loc 1 5313 0
 14180 0010 ADF80840 		strh	r4, [sp, #8]	@ movhi
 14181 0014 ADF80A40 		strh	r4, [sp, #10]	@ movhi
 14182 0018 ADF80C40 		strh	r4, [sp, #12]	@ movhi
5318:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 14183              		.loc 1 5318 0
 14184 001c FFF7FEFF 		bl	bno055_get_euler_unit
 14185              	.LVL1805:
5319:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 14186              		.loc 1 5319 0
 14187 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
5318:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_DEG)
 14188              		.loc 1 5318 0
 14189 0024 0546     		mov	r5, r0
 14190              	.LVL1806:
5319:Src/bno055.c  **** 		com_rslt += bno055_set_euler_unit(BNO055_EULER_UNIT_DEG);
 14191              		.loc 1 5319 0
 14192 0026 2BBB     		cbnz	r3, .L1538
 14193              	.L1530:
5321:Src/bno055.c  **** 		/* Read Euler raw h data*/
 14194              		.loc 1 5321 0
 14195 0028 55BB     		cbnz	r5, .L1533
5323:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 14196              		.loc 1 5323 0
 14197 002a 02A8     		add	r0, sp, #8
 14198 002c FFF7FEFF 		bl	bno055_read_euler_hrp
 14199              	.LVL1807:
5324:Src/bno055.c  **** 			/* Convert raw Euler hrp to degree*/
 14200              		.loc 1 5324 0
 14201 0030 30BB     		cbnz	r0, .L1533
5327:Src/bno055.c  **** 			euler_hpr->p =
 14202              		.loc 1 5327 0
 14203 0032 BDF90800 		ldrsh	r0, [sp, #8]
 14204              	.LVL1808:
 14205 0036 FFF7FEFF 		bl	__aeabi_i2d
 14206              	.LVL1809:
 14207 003a 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 406


 14208 003c 124B     		ldr	r3, .L1539
 14209 003e FFF7FEFF 		bl	__aeabi_dmul
 14210              	.LVL1810:
5326:Src/bno055.c  **** 			(double)(reg_euler.h/BNO055_EULER_DIV_DEG);
 14211              		.loc 1 5326 0
 14212 0042 C6E90001 		strd	r0, [r6]
5329:Src/bno055.c  **** 			euler_hpr->r =
 14213              		.loc 1 5329 0
 14214 0046 BDF90C00 		ldrsh	r0, [sp, #12]
 14215 004a FFF7FEFF 		bl	__aeabi_i2d
 14216              	.LVL1811:
 14217 004e 0022     		movs	r2, #0
 14218 0050 0D4B     		ldr	r3, .L1539
 14219 0052 FFF7FEFF 		bl	__aeabi_dmul
 14220              	.LVL1812:
5328:Src/bno055.c  **** 			(double)(reg_euler.p/BNO055_EULER_DIV_DEG);
 14221              		.loc 1 5328 0
 14222 0056 C6E90401 		strd	r0, [r6, #16]
5331:Src/bno055.c  **** 		} else {
 14223              		.loc 1 5331 0
 14224 005a BDF90A00 		ldrsh	r0, [sp, #10]
 14225 005e FFF7FEFF 		bl	__aeabi_i2d
 14226              	.LVL1813:
 14227 0062 0022     		movs	r2, #0
 14228 0064 084B     		ldr	r3, .L1539
 14229 0066 FFF7FEFF 		bl	__aeabi_dmul
 14230              	.LVL1814:
5330:Src/bno055.c  **** 			(double)(reg_euler.r/BNO055_EULER_DIV_DEG);
 14231              		.loc 1 5330 0
 14232 006a C6E90201 		strd	r0, [r6, #8]
5339:Src/bno055.c  **** /*!
 14233              		.loc 1 5339 0
 14234 006e 68B2     		sxtb	r0, r5
 14235 0070 04B0     		add	sp, sp, #16
 14236              	.LCFI614:
 14237              		.cfi_remember_state
 14238              		.cfi_def_cfa_offset 16
 14239              		@ sp needed
 14240 0072 70BD     		pop	{r4, r5, r6, pc}
 14241              	.LVL1815:
 14242              	.L1538:
 14243              	.LCFI615:
 14244              		.cfi_restore_state
5320:Src/bno055.c  **** 	if (com_rslt == BNO055_SUCCESS) {
 14245              		.loc 1 5320 0
 14246 0074 2046     		mov	r0, r4
 14247 0076 FFF7FEFF 		bl	bno055_set_euler_unit
 14248              	.LVL1816:
 14249 007a 2844     		add	r0, r0, r5
 14250 007c C5B2     		uxtb	r5, r0
 14251              	.LVL1817:
 14252 007e D3E7     		b	.L1530
 14253              	.LVL1818:
 14254              	.L1533:
5336:Src/bno055.c  **** 	}
 14255              		.loc 1 5336 0
 14256 0080 FF25     		movs	r5, #255
ARM GAS  /tmp/ccVWLGiI.s 			page 407


 14257              	.LVL1819:
5339:Src/bno055.c  **** /*!
 14258              		.loc 1 5339 0
 14259 0082 68B2     		sxtb	r0, r5
 14260 0084 04B0     		add	sp, sp, #16
 14261              	.LCFI616:
 14262              		.cfi_def_cfa_offset 16
 14263              		@ sp needed
 14264 0086 70BD     		pop	{r4, r5, r6, pc}
 14265              	.LVL1820:
 14266              	.L1540:
 14267              		.align	2
 14268              	.L1539:
 14269 0088 0000B03F 		.word	1068498944
 14270              		.cfi_endproc
 14271              	.LFE105:
 14273              		.section	.text.bno055_convert_double_euler_hpr_rad,"ax",%progbits
 14274              		.align	2
 14275              		.global	bno055_convert_double_euler_hpr_rad
 14276              		.thumb
 14277              		.thumb_func
 14279              	bno055_convert_double_euler_hpr_rad:
 14280              	.LFB106:
5361:Src/bno055.c  **** 	/* Variable used to return value of
 14281              		.loc 1 5361 0
 14282              		.cfi_startproc
 14283              		@ args = 0, pretend = 0, frame = 16
 14284              		@ frame_needed = 0, uses_anonymous_args = 0
 14285              	.LVL1821:
 14286 0000 30B5     		push	{r4, r5, lr}
 14287              	.LCFI617:
 14288              		.cfi_def_cfa_offset 12
 14289              		.cfi_offset 4, -12
 14290              		.cfi_offset 5, -8
 14291              		.cfi_offset 14, -4
 14292 0002 85B0     		sub	sp, sp, #20
 14293              	.LCFI618:
 14294              		.cfi_def_cfa_offset 32
5365:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 14295              		.loc 1 5365 0
 14296 0004 0023     		movs	r3, #0
5367:Src/bno055.c  **** 	/* Read the current Euler unit and set the
 14297              		.loc 1 5367 0
 14298 0006 04AA     		add	r2, sp, #16
 14299 0008 02F8093D 		strb	r3, [r2, #-9]!
5361:Src/bno055.c  **** 	/* Variable used to return value of
 14300              		.loc 1 5361 0
 14301 000c 0446     		mov	r4, r0
5370:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 14302              		.loc 1 5370 0
 14303 000e 1046     		mov	r0, r2
 14304              	.LVL1822:
5365:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
 14305              		.loc 1 5365 0
 14306 0010 ADF80830 		strh	r3, [sp, #8]	@ movhi
 14307 0014 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 14308 0018 ADF80C30 		strh	r3, [sp, #12]	@ movhi
ARM GAS  /tmp/ccVWLGiI.s 			page 408


5370:Src/bno055.c  **** 	if (euler_unit_u8 != BNO055_EULER_UNIT_RAD)
 14309              		.loc 1 5370 0
 14310 001c FFF7FEFF 		bl	bno055_get_euler_unit
 14311              	.LVL1823:
5371:Src/bno055.c  **** 		com_rslt = bno055_set_euler_unit(BNO055_EULER_UNIT_RAD);
 14312              		.loc 1 5371 0
 14313 0020 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 14314 0024 012B     		cmp	r3, #1
 14315 0026 02D0     		beq	.L1542
5372:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 14316              		.loc 1 5372 0
 14317 0028 0120     		movs	r0, #1
 14318              	.LVL1824:
 14319 002a FFF7FEFF 		bl	bno055_set_euler_unit
 14320              	.LVL1825:
 14321              	.L1542:
5373:Src/bno055.c  **** 			/* Read the raw hrp */
 14322              		.loc 1 5373 0
 14323 002e 28BB     		cbnz	r0, .L1545
5375:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 14324              		.loc 1 5375 0
 14325 0030 02A8     		add	r0, sp, #8
 14326              	.LVL1826:
 14327 0032 FFF7FEFF 		bl	bno055_read_euler_hrp
 14328              	.LVL1827:
5376:Src/bno055.c  **** 				/* Convert raw Euler hrp to radians*/
 14329              		.loc 1 5376 0
 14330 0036 0546     		mov	r5, r0
 14331 0038 00BB     		cbnz	r0, .L1545
5379:Src/bno055.c  **** 				euler_hpr->p =
 14332              		.loc 1 5379 0
 14333 003a BDF90800 		ldrsh	r0, [sp, #8]
 14334              	.LVL1828:
 14335 003e FFF7FEFF 		bl	__aeabi_i2d
 14336              	.LVL1829:
 14337 0042 0022     		movs	r2, #0
 14338 0044 0F4B     		ldr	r3, .L1550
 14339 0046 FFF7FEFF 		bl	__aeabi_ddiv
 14340              	.LVL1830:
5378:Src/bno055.c  **** 				(double)(reg_euler.h/BNO055_EULER_DIV_RAD);
 14341              		.loc 1 5378 0
 14342 004a C4E90001 		strd	r0, [r4]
5381:Src/bno055.c  **** 				euler_hpr->r =
 14343              		.loc 1 5381 0
 14344 004e BDF90C00 		ldrsh	r0, [sp, #12]
 14345 0052 FFF7FEFF 		bl	__aeabi_i2d
 14346              	.LVL1831:
 14347 0056 0022     		movs	r2, #0
 14348 0058 0A4B     		ldr	r3, .L1550
 14349 005a FFF7FEFF 		bl	__aeabi_ddiv
 14350              	.LVL1832:
5380:Src/bno055.c  **** 				(double)(reg_euler.p/BNO055_EULER_DIV_RAD);
 14351              		.loc 1 5380 0
 14352 005e C4E90401 		strd	r0, [r4, #16]
5383:Src/bno055.c  **** 			} else {
 14353              		.loc 1 5383 0
 14354 0062 BDF90A00 		ldrsh	r0, [sp, #10]
ARM GAS  /tmp/ccVWLGiI.s 			page 409


 14355 0066 FFF7FEFF 		bl	__aeabi_i2d
 14356              	.LVL1833:
 14357 006a 0022     		movs	r2, #0
 14358 006c 054B     		ldr	r3, .L1550
 14359 006e FFF7FEFF 		bl	__aeabi_ddiv
 14360              	.LVL1834:
5382:Src/bno055.c  **** 				(double)(reg_euler.r/BNO055_EULER_DIV_RAD);
 14361              		.loc 1 5382 0
 14362 0072 C4E90201 		strd	r0, [r4, #8]
5391:Src/bno055.c  **** /*!
 14363              		.loc 1 5391 0
 14364 0076 68B2     		sxtb	r0, r5
 14365 0078 05B0     		add	sp, sp, #20
 14366              	.LCFI619:
 14367              		.cfi_remember_state
 14368              		.cfi_def_cfa_offset 12
 14369              		@ sp needed
 14370 007a 30BD     		pop	{r4, r5, pc}
 14371              	.LVL1835:
 14372              	.L1545:
 14373              	.LCFI620:
 14374              		.cfi_restore_state
5388:Src/bno055.c  **** 		}
 14375              		.loc 1 5388 0
 14376 007c FF25     		movs	r5, #255
 14377              	.LVL1836:
5391:Src/bno055.c  **** /*!
 14378              		.loc 1 5391 0
 14379 007e 68B2     		sxtb	r0, r5
 14380 0080 05B0     		add	sp, sp, #20
 14381              	.LCFI621:
 14382              		.cfi_def_cfa_offset 12
 14383              		@ sp needed
 14384 0082 30BD     		pop	{r4, r5, pc}
 14385              	.LVL1837:
 14386              	.L1551:
 14387              		.align	2
 14388              	.L1550:
 14389 0084 00208C40 		.word	1082925056
 14390              		.cfi_endproc
 14391              	.LFE106:
 14393              		.section	.text.bno055_set_tilt_unit,"ax",%progbits
 14394              		.align	2
 14395              		.global	bno055_set_tilt_unit
 14396              		.thumb
 14397              		.thumb_func
 14399              	bno055_set_tilt_unit:
 14400              	.LFB140:
6945:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14401              		.loc 1 6945 0
 14402              		.cfi_startproc
 14403              		@ args = 0, pretend = 0, frame = 8
 14404              		@ frame_needed = 0, uses_anonymous_args = 0
 14405              	.LVL1838:
 14406 0000 30B5     		push	{r4, r5, lr}
 14407              	.LCFI622:
 14408              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 410


 14409              		.cfi_offset 4, -12
 14410              		.cfi_offset 5, -8
 14411              		.cfi_offset 14, -4
6951:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 14412              		.loc 1 6951 0
 14413 0002 244C     		ldr	r4, .L1568
6945:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14414              		.loc 1 6945 0
 14415 0004 83B0     		sub	sp, sp, #12
 14416              	.LCFI623:
 14417              		.cfi_def_cfa_offset 24
6951:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 14418              		.loc 1 6951 0
 14419 0006 2268     		ldr	r2, [r4]
6947:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 14420              		.loc 1 6947 0
 14421 0008 0023     		movs	r3, #0
 14422 000a 8DF80630 		strb	r3, [sp, #6]
6948:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 14423              		.loc 1 6948 0
 14424 000e 8DF80730 		strb	r3, [sp, #7]
 14425              	.LVL1839:
6951:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 14426              		.loc 1 6951 0
 14427 0012 002A     		cmp	r2, #0
 14428 0014 3CD0     		beq	.L1560
 14429 0016 0546     		mov	r5, r0
6957:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 14430              		.loc 1 6957 0
 14431 0018 0DF10700 		add	r0, sp, #7
 14432              	.LVL1840:
 14433 001c FFF7FEFF 		bl	bno055_get_operation_mode
 14434              	.LVL1841:
6958:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 14435              		.loc 1 6958 0
 14436 0020 38B1     		cbz	r0, .L1554
 14437              	.L1559:
6982:Src/bno055.c  **** 		}
 14438              		.loc 1 6982 0
 14439 0022 FF24     		movs	r4, #255
 14440              	.LVL1842:
 14441              	.L1555:
6985:Src/bno055.c  **** 		/* set the operation mode
 14442              		.loc 1 6985 0
 14443 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 14444 0028 30BB     		cbnz	r0, .L1567
 14445 002a 2046     		mov	r0, r4
 14446              	.LVL1843:
 14447              	.L1553:
6991:Src/bno055.c  **** /*!
 14448              		.loc 1 6991 0
 14449 002c 40B2     		sxtb	r0, r0
 14450 002e 03B0     		add	sp, sp, #12
 14451              	.LCFI624:
 14452              		.cfi_remember_state
 14453              		.cfi_def_cfa_offset 12
 14454              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 411


 14455 0030 30BD     		pop	{r4, r5, pc}
 14456              	.LVL1844:
 14457              	.L1554:
 14458              	.LCFI625:
 14459              		.cfi_restore_state
6959:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 14460              		.loc 1 6959 0
 14461 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 14462 0036 33BB     		cbnz	r3, .L1556
 14463              	.L1558:
 14464              	.LVL1845:
6963:Src/bno055.c  **** 				(p_bno055->dev_addr,
 14465              		.loc 1 6963 0
 14466 0038 2368     		ldr	r3, [r4]
 14467 003a 0DF10602 		add	r2, sp, #6
 14468 003e 1C69     		ldr	r4, [r3, #16]
 14469 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 14470 0042 3B21     		movs	r1, #59
 14471 0044 0123     		movs	r3, #1
 14472 0046 A047     		blx	r4
 14473              	.LVL1846:
 14474 0048 124B     		ldr	r3, .L1568
6967:Src/bno055.c  **** 					data_u8r =
 14475              		.loc 1 6967 0
 14476 004a 0446     		mov	r4, r0
 14477 004c 0028     		cmp	r0, #0
 14478 004e E9D1     		bne	.L1555
6968:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 14479              		.loc 1 6968 0
 14480 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
6969:Src/bno055.c  **** 					BNO055_TILT_UNIT, tilt_unit_u8);
 14481              		.loc 1 6969 0
 14482 0054 E800     		lsls	r0, r5, #3
 14483              	.LVL1847:
6972:Src/bno055.c  **** 					(p_bno055->dev_addr,
 14484              		.loc 1 6972 0
 14485 0056 1968     		ldr	r1, [r3]
6968:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 14486              		.loc 1 6968 0
 14487 0058 00F00800 		and	r0, r0, #8
 14488 005c 22F00803 		bic	r3, r2, #8
 14489 0060 1843     		orrs	r0, r0, r3
6972:Src/bno055.c  **** 					(p_bno055->dev_addr,
 14490              		.loc 1 6972 0
 14491 0062 CC68     		ldr	r4, [r1, #12]
6968:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 14492              		.loc 1 6968 0
 14493 0064 8DF80600 		strb	r0, [sp, #6]
6972:Src/bno055.c  **** 					(p_bno055->dev_addr,
 14494              		.loc 1 6972 0
 14495 0068 0DF10602 		add	r2, sp, #6
 14496 006c 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 14497 006e 0123     		movs	r3, #1
 14498 0070 3B21     		movs	r1, #59
 14499 0072 A047     		blx	r4
 14500              	.LVL1848:
 14501 0074 0446     		mov	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 412


 14502              	.LVL1849:
 14503 0076 D5E7     		b	.L1555
 14504              	.L1567:
6988:Src/bno055.c  **** 		(prev_opmode_u8);
 14505              		.loc 1 6988 0
 14506 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 14507              	.LVL1850:
 14508 007c 2044     		add	r0, r0, r4
 14509 007e C0B2     		uxtb	r0, r0
 14510              	.LVL1851:
6991:Src/bno055.c  **** /*!
 14511              		.loc 1 6991 0
 14512 0080 40B2     		sxtb	r0, r0
 14513 0082 03B0     		add	sp, sp, #12
 14514              	.LCFI626:
 14515              		.cfi_remember_state
 14516              		.cfi_def_cfa_offset 12
 14517              		@ sp needed
 14518 0084 30BD     		pop	{r4, r5, pc}
 14519              	.LVL1852:
 14520              	.L1556:
 14521              	.LCFI627:
 14522              		.cfi_restore_state
6960:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 14523              		.loc 1 6960 0
 14524 0086 FFF7FEFF 		bl	bno055_set_operation_mode
 14525              	.LVL1853:
6962:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 14526              		.loc 1 6962 0
 14527 008a 0028     		cmp	r0, #0
 14528 008c C9D1     		bne	.L1559
 14529 008e D3E7     		b	.L1558
 14530              	.LVL1854:
 14531              	.L1560:
6952:Src/bno055.c  **** 	} else {
 14532              		.loc 1 6952 0
 14533 0090 8120     		movs	r0, #129
 14534              	.LVL1855:
 14535 0092 CBE7     		b	.L1553
 14536              	.L1569:
 14537              		.align	2
 14538              	.L1568:
 14539 0094 00000000 		.word	.LANCHOR0
 14540              		.cfi_endproc
 14541              	.LFE140:
 14543              		.section	.text.bno055_set_temp_unit,"ax",%progbits
 14544              		.align	2
 14545              		.global	bno055_set_temp_unit
 14546              		.thumb
 14547              		.thumb_func
 14549              	bno055_set_temp_unit:
 14550              	.LFB142:
7060:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14551              		.loc 1 7060 0
 14552              		.cfi_startproc
 14553              		@ args = 0, pretend = 0, frame = 8
 14554              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccVWLGiI.s 			page 413


 14555              	.LVL1856:
 14556 0000 30B5     		push	{r4, r5, lr}
 14557              	.LCFI628:
 14558              		.cfi_def_cfa_offset 12
 14559              		.cfi_offset 4, -12
 14560              		.cfi_offset 5, -8
 14561              		.cfi_offset 14, -4
7066:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 14562              		.loc 1 7066 0
 14563 0002 244C     		ldr	r4, .L1586
7060:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14564              		.loc 1 7060 0
 14565 0004 83B0     		sub	sp, sp, #12
 14566              	.LCFI629:
 14567              		.cfi_def_cfa_offset 24
7066:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 14568              		.loc 1 7066 0
 14569 0006 2268     		ldr	r2, [r4]
7062:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 14570              		.loc 1 7062 0
 14571 0008 0023     		movs	r3, #0
 14572 000a 8DF80630 		strb	r3, [sp, #6]
7063:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 14573              		.loc 1 7063 0
 14574 000e 8DF80730 		strb	r3, [sp, #7]
 14575              	.LVL1857:
7066:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 14576              		.loc 1 7066 0
 14577 0012 002A     		cmp	r2, #0
 14578 0014 3CD0     		beq	.L1578
 14579 0016 0546     		mov	r5, r0
7072:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 14580              		.loc 1 7072 0
 14581 0018 0DF10700 		add	r0, sp, #7
 14582              	.LVL1858:
 14583 001c FFF7FEFF 		bl	bno055_get_operation_mode
 14584              	.LVL1859:
7073:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 14585              		.loc 1 7073 0
 14586 0020 38B1     		cbz	r0, .L1572
 14587              	.L1577:
7099:Src/bno055.c  **** 		}
 14588              		.loc 1 7099 0
 14589 0022 FF24     		movs	r4, #255
 14590              	.LVL1860:
 14591              	.L1573:
7102:Src/bno055.c  **** 		/* set the operation mode
 14592              		.loc 1 7102 0
 14593 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 14594 0028 30BB     		cbnz	r0, .L1585
 14595 002a 2046     		mov	r0, r4
 14596              	.LVL1861:
 14597              	.L1571:
7108:Src/bno055.c  **** /*!
 14598              		.loc 1 7108 0
 14599 002c 40B2     		sxtb	r0, r0
 14600 002e 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 414


 14601              	.LCFI630:
 14602              		.cfi_remember_state
 14603              		.cfi_def_cfa_offset 12
 14604              		@ sp needed
 14605 0030 30BD     		pop	{r4, r5, pc}
 14606              	.LVL1862:
 14607              	.L1572:
 14608              	.LCFI631:
 14609              		.cfi_restore_state
7074:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 14610              		.loc 1 7074 0
 14611 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 14612 0036 33BB     		cbnz	r3, .L1574
 14613              	.L1576:
 14614              	.LVL1863:
7079:Src/bno055.c  **** 				(p_bno055->dev_addr,
 14615              		.loc 1 7079 0
 14616 0038 2368     		ldr	r3, [r4]
 14617 003a 0DF10602 		add	r2, sp, #6
 14618 003e 1C69     		ldr	r4, [r3, #16]
 14619 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 14620 0042 3B21     		movs	r1, #59
 14621 0044 0123     		movs	r3, #1
 14622 0046 A047     		blx	r4
 14623              	.LVL1864:
 14624 0048 124B     		ldr	r3, .L1586
7083:Src/bno055.c  **** 					data_u8r =
 14625              		.loc 1 7083 0
 14626 004a 0446     		mov	r4, r0
 14627 004c 0028     		cmp	r0, #0
 14628 004e E9D1     		bne	.L1573
7084:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 14629              		.loc 1 7084 0
 14630 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
7085:Src/bno055.c  **** 					BNO055_TEMP_UNIT,
 14631              		.loc 1 7085 0
 14632 0054 2801     		lsls	r0, r5, #4
 14633              	.LVL1865:
7089:Src/bno055.c  **** 					(p_bno055->dev_addr,
 14634              		.loc 1 7089 0
 14635 0056 1968     		ldr	r1, [r3]
7084:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 14636              		.loc 1 7084 0
 14637 0058 00F01000 		and	r0, r0, #16
 14638 005c 22F01003 		bic	r3, r2, #16
 14639 0060 1843     		orrs	r0, r0, r3
7089:Src/bno055.c  **** 					(p_bno055->dev_addr,
 14640              		.loc 1 7089 0
 14641 0062 CC68     		ldr	r4, [r1, #12]
7084:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 14642              		.loc 1 7084 0
 14643 0064 8DF80600 		strb	r0, [sp, #6]
7089:Src/bno055.c  **** 					(p_bno055->dev_addr,
 14644              		.loc 1 7089 0
 14645 0068 0DF10602 		add	r2, sp, #6
 14646 006c 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 14647 006e 0123     		movs	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 415


 14648 0070 3B21     		movs	r1, #59
 14649 0072 A047     		blx	r4
 14650              	.LVL1866:
 14651 0074 0446     		mov	r4, r0
 14652              	.LVL1867:
 14653 0076 D5E7     		b	.L1573
 14654              	.L1585:
7105:Src/bno055.c  **** 		(prev_opmode_u8);
 14655              		.loc 1 7105 0
 14656 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 14657              	.LVL1868:
 14658 007c 2044     		add	r0, r0, r4
 14659 007e C0B2     		uxtb	r0, r0
 14660              	.LVL1869:
7108:Src/bno055.c  **** /*!
 14661              		.loc 1 7108 0
 14662 0080 40B2     		sxtb	r0, r0
 14663 0082 03B0     		add	sp, sp, #12
 14664              	.LCFI632:
 14665              		.cfi_remember_state
 14666              		.cfi_def_cfa_offset 12
 14667              		@ sp needed
 14668 0084 30BD     		pop	{r4, r5, pc}
 14669              	.LVL1870:
 14670              	.L1574:
 14671              	.LCFI633:
 14672              		.cfi_restore_state
7075:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 14673              		.loc 1 7075 0
 14674 0086 FFF7FEFF 		bl	bno055_set_operation_mode
 14675              	.LVL1871:
7077:Src/bno055.c  **** 				/* Write the temperature unit */
 14676              		.loc 1 7077 0
 14677 008a 0028     		cmp	r0, #0
 14678 008c C9D1     		bne	.L1577
 14679 008e D3E7     		b	.L1576
 14680              	.LVL1872:
 14681              	.L1578:
7067:Src/bno055.c  **** 	} else {
 14682              		.loc 1 7067 0
 14683 0090 8120     		movs	r0, #129
 14684              	.LVL1873:
 14685 0092 CBE7     		b	.L1571
 14686              	.L1587:
 14687              		.align	2
 14688              	.L1586:
 14689 0094 00000000 		.word	.LANCHOR0
 14690              		.cfi_endproc
 14691              	.LFE142:
 14693              		.global	__aeabi_dadd
 14694              		.section	.text.bno055_convert_float_temp_fahrenheit,"ax",%progbits
 14695              		.align	2
 14696              		.global	bno055_convert_float_temp_fahrenheit
 14697              		.thumb
 14698              		.thumb_func
 14700              	bno055_convert_float_temp_fahrenheit:
 14701              	.LFB77:
ARM GAS  /tmp/ccVWLGiI.s 			page 416


4100:Src/bno055.c  **** 	/* Variable used to return value of
 14702              		.loc 1 4100 0
 14703              		.cfi_startproc
 14704              		@ args = 0, pretend = 0, frame = 8
 14705              		@ frame_needed = 0, uses_anonymous_args = 0
 14706              	.LVL1874:
 14707 0000 30B5     		push	{r4, r5, lr}
 14708              	.LCFI634:
 14709              		.cfi_def_cfa_offset 12
 14710              		.cfi_offset 4, -12
 14711              		.cfi_offset 5, -8
 14712              		.cfi_offset 14, -4
 14713 0002 83B0     		sub	sp, sp, #12
 14714              	.LCFI635:
 14715              		.cfi_def_cfa_offset 24
4106:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 14716              		.loc 1 4106 0
 14717 0004 02AB     		add	r3, sp, #8
4104:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 14718              		.loc 1 4104 0
 14719 0006 0022     		movs	r2, #0
4106:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 14720              		.loc 1 4106 0
 14721 0008 03F8012D 		strb	r2, [r3, #-1]!
4100:Src/bno055.c  **** 	/* Variable used to return value of
 14722              		.loc 1 4100 0
 14723 000c 0546     		mov	r5, r0
4109:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
 14724              		.loc 1 4109 0
 14725 000e 1846     		mov	r0, r3
 14726              	.LVL1875:
4104:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 14727              		.loc 1 4104 0
 14728 0010 8DF80620 		strb	r2, [sp, #6]
 14729              	.LVL1876:
4109:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
 14730              		.loc 1 4109 0
 14731 0014 FFF7FEFF 		bl	bno055_get_temp_unit
 14732              	.LVL1877:
4110:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_FAHRENHEIT);
 14733              		.loc 1 4110 0
 14734 0018 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
4109:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
 14735              		.loc 1 4109 0
 14736 001c 0446     		mov	r4, r0
 14737              	.LVL1878:
4110:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_FAHRENHEIT);
 14738              		.loc 1 4110 0
 14739 001e 012B     		cmp	r3, #1
 14740 0020 04D0     		beq	.L1589
4111:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 14741              		.loc 1 4111 0
 14742 0022 0120     		movs	r0, #1
 14743 0024 FFF7FEFF 		bl	bno055_set_temp_unit
 14744              	.LVL1879:
 14745 0028 2044     		add	r0, r0, r4
 14746 002a C4B2     		uxtb	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 417


 14747              	.LVL1880:
 14748              	.L1589:
4112:Src/bno055.c  **** 			/* Read the raw temperature data */
 14749              		.loc 1 4112 0
 14750 002c 94B9     		cbnz	r4, .L1592
4114:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 14751              		.loc 1 4114 0
 14752 002e 0DF10600 		add	r0, sp, #6
 14753 0032 FFF7FEFF 		bl	bno055_read_temp_data
 14754              	.LVL1881:
4115:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
 14755              		.loc 1 4115 0
 14756 0036 68B9     		cbnz	r0, .L1592
 14757              	.LVL1882:
4118:Src/bno055.c  **** 				*temp_f = data_f;
 14758              		.loc 1 4118 0
 14759 0038 9DF90600 		ldrsb	r0, [sp, #6]
 14760              	.LVL1883:
 14761 003c FFF7FEFF 		bl	__aeabi_i2d
 14762              	.LVL1884:
 14763 0040 0246     		mov	r2, r0
 14764 0042 0B46     		mov	r3, r1
 14765 0044 FFF7FEFF 		bl	__aeabi_dadd
 14766              	.LVL1885:
4117:Src/bno055.c  **** 				(reg_temp_s8/BNO055_TEMP_DIV_FAHRENHEIT);
 14767              		.loc 1 4117 0
 14768 0048 FFF7FEFF 		bl	__aeabi_d2f
 14769              	.LVL1886:
 14770 004c 2860     		str	r0, [r5]	@ float
4127:Src/bno055.c  **** /*!
 14771              		.loc 1 4127 0
 14772 004e 60B2     		sxtb	r0, r4
 14773 0050 03B0     		add	sp, sp, #12
 14774              	.LCFI636:
 14775              		.cfi_remember_state
 14776              		.cfi_def_cfa_offset 12
 14777              		@ sp needed
 14778 0052 30BD     		pop	{r4, r5, pc}
 14779              	.LVL1887:
 14780              	.L1592:
 14781              	.LCFI637:
 14782              		.cfi_restore_state
4124:Src/bno055.c  **** 		}
 14783              		.loc 1 4124 0
 14784 0054 FF24     		movs	r4, #255
 14785              	.LVL1888:
4127:Src/bno055.c  **** /*!
 14786              		.loc 1 4127 0
 14787 0056 60B2     		sxtb	r0, r4
 14788 0058 03B0     		add	sp, sp, #12
 14789              	.LCFI638:
 14790              		.cfi_def_cfa_offset 12
 14791              		@ sp needed
 14792 005a 30BD     		pop	{r4, r5, pc}
 14793              		.cfi_endproc
 14794              	.LFE77:
 14796              		.section	.text.bno055_convert_float_temp_celsius,"ax",%progbits
ARM GAS  /tmp/ccVWLGiI.s 			page 418


 14797              		.align	2
 14798              		.global	bno055_convert_float_temp_celsius
 14799              		.thumb
 14800              		.thumb_func
 14802              	bno055_convert_float_temp_celsius:
 14803              	.LFB78:
4143:Src/bno055.c  **** 	/* Variable used to return value of
 14804              		.loc 1 4143 0
 14805              		.cfi_startproc
 14806              		@ args = 0, pretend = 0, frame = 8
 14807              		@ frame_needed = 0, uses_anonymous_args = 0
 14808              	.LVL1889:
 14809 0000 70B5     		push	{r4, r5, r6, lr}
 14810              	.LCFI639:
 14811              		.cfi_def_cfa_offset 16
 14812              		.cfi_offset 4, -16
 14813              		.cfi_offset 5, -12
 14814              		.cfi_offset 6, -8
 14815              		.cfi_offset 14, -4
 14816 0002 82B0     		sub	sp, sp, #8
 14817              	.LCFI640:
 14818              		.cfi_def_cfa_offset 24
4149:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 14819              		.loc 1 4149 0
 14820 0004 02AB     		add	r3, sp, #8
4147:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 14821              		.loc 1 4147 0
 14822 0006 0025     		movs	r5, #0
4149:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 14823              		.loc 1 4149 0
 14824 0008 03F8015D 		strb	r5, [r3, #-1]!
4143:Src/bno055.c  **** 	/* Variable used to return value of
 14825              		.loc 1 4143 0
 14826 000c 0646     		mov	r6, r0
4152:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
 14827              		.loc 1 4152 0
 14828 000e 1846     		mov	r0, r3
 14829              	.LVL1890:
4147:Src/bno055.c  **** 	float data_f = BNO055_INIT_VALUE;
 14830              		.loc 1 4147 0
 14831 0010 8DF80650 		strb	r5, [sp, #6]
 14832              	.LVL1891:
4152:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
 14833              		.loc 1 4152 0
 14834 0014 FFF7FEFF 		bl	bno055_get_temp_unit
 14835              	.LVL1892:
4153:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_CELSIUS);
 14836              		.loc 1 4153 0
 14837 0018 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
4152:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
 14838              		.loc 1 4152 0
 14839 001c 0446     		mov	r4, r0
 14840              	.LVL1893:
4153:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_CELSIUS);
 14841              		.loc 1 4153 0
 14842 001e 6BB9     		cbnz	r3, .L1606
 14843              	.L1598:
ARM GAS  /tmp/ccVWLGiI.s 			page 419


4155:Src/bno055.c  **** 			/* Read the raw temperature data */
 14844              		.loc 1 4155 0
 14845 0020 94B9     		cbnz	r4, .L1601
4157:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 14846              		.loc 1 4157 0
 14847 0022 0DF10600 		add	r0, sp, #6
 14848 0026 FFF7FEFF 		bl	bno055_read_temp_data
 14849              	.LVL1894:
4158:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
 14850              		.loc 1 4158 0
 14851 002a 68B9     		cbnz	r0, .L1601
 14852              	.LVL1895:
4160:Src/bno055.c  **** 				(float)(reg_temp_s8/BNO055_TEMP_DIV_CELSIUS);
 14853              		.loc 1 4160 0
 14854 002c 9DF90600 		ldrsb	r0, [sp, #6]
 14855              	.LVL1896:
 14856 0030 FFF7FEFF 		bl	__aeabi_i2f
 14857              	.LVL1897:
 14858 0034 3060     		str	r0, [r6]	@ float
4170:Src/bno055.c  **** #endif
 14859              		.loc 1 4170 0
 14860 0036 60B2     		sxtb	r0, r4
 14861 0038 02B0     		add	sp, sp, #8
 14862              	.LCFI641:
 14863              		.cfi_remember_state
 14864              		.cfi_def_cfa_offset 16
 14865              		@ sp needed
 14866 003a 70BD     		pop	{r4, r5, r6, pc}
 14867              	.LVL1898:
 14868              	.L1606:
 14869              	.LCFI642:
 14870              		.cfi_restore_state
4154:Src/bno055.c  **** 		if (com_rslt ==  BNO055_SUCCESS) {
 14871              		.loc 1 4154 0
 14872 003c 2846     		mov	r0, r5
 14873 003e FFF7FEFF 		bl	bno055_set_temp_unit
 14874              	.LVL1899:
 14875 0042 2044     		add	r0, r0, r4
 14876 0044 C4B2     		uxtb	r4, r0
 14877              	.LVL1900:
 14878 0046 EBE7     		b	.L1598
 14879              	.LVL1901:
 14880              	.L1601:
4167:Src/bno055.c  **** 		}
 14881              		.loc 1 4167 0
 14882 0048 FF24     		movs	r4, #255
 14883              	.LVL1902:
4170:Src/bno055.c  **** #endif
 14884              		.loc 1 4170 0
 14885 004a 60B2     		sxtb	r0, r4
 14886 004c 02B0     		add	sp, sp, #8
 14887              	.LCFI643:
 14888              		.cfi_def_cfa_offset 16
 14889              		@ sp needed
 14890 004e 70BD     		pop	{r4, r5, r6, pc}
 14891              		.cfi_endproc
 14892              	.LFE78:
ARM GAS  /tmp/ccVWLGiI.s 			page 420


 14894              		.section	.text.bno055_convert_double_temp_fahrenheit,"ax",%progbits
 14895              		.align	2
 14896              		.global	bno055_convert_double_temp_fahrenheit
 14897              		.thumb
 14898              		.thumb_func
 14900              	bno055_convert_double_temp_fahrenheit:
 14901              	.LFB115:
5675:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14902              		.loc 1 5675 0
 14903              		.cfi_startproc
 14904              		@ args = 0, pretend = 0, frame = 8
 14905              		@ frame_needed = 0, uses_anonymous_args = 0
 14906              	.LVL1903:
 14907 0000 30B5     		push	{r4, r5, lr}
 14908              	.LCFI644:
 14909              		.cfi_def_cfa_offset 12
 14910              		.cfi_offset 4, -12
 14911              		.cfi_offset 5, -8
 14912              		.cfi_offset 14, -4
 14913 0002 83B0     		sub	sp, sp, #12
 14914              	.LCFI645:
 14915              		.cfi_def_cfa_offset 24
5679:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 14916              		.loc 1 5679 0
 14917 0004 02AB     		add	r3, sp, #8
5677:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 14918              		.loc 1 5677 0
 14919 0006 0022     		movs	r2, #0
5679:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 14920              		.loc 1 5679 0
 14921 0008 03F8012D 		strb	r2, [r3, #-1]!
5675:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 14922              		.loc 1 5675 0
 14923 000c 0546     		mov	r5, r0
5682:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
 14924              		.loc 1 5682 0
 14925 000e 1846     		mov	r0, r3
 14926              	.LVL1904:
5677:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 14927              		.loc 1 5677 0
 14928 0010 8DF80620 		strb	r2, [sp, #6]
 14929              	.LVL1905:
5682:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
 14930              		.loc 1 5682 0
 14931 0014 FFF7FEFF 		bl	bno055_get_temp_unit
 14932              	.LVL1906:
5683:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_FAHRENHEIT);
 14933              		.loc 1 5683 0
 14934 0018 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
5682:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_FAHRENHEIT)
 14935              		.loc 1 5682 0
 14936 001c 0446     		mov	r4, r0
 14937              	.LVL1907:
5683:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_FAHRENHEIT);
 14938              		.loc 1 5683 0
 14939 001e 012B     		cmp	r3, #1
 14940 0020 04D0     		beq	.L1608
ARM GAS  /tmp/ccVWLGiI.s 			page 421


5684:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 14941              		.loc 1 5684 0
 14942 0022 0120     		movs	r0, #1
 14943 0024 FFF7FEFF 		bl	bno055_set_temp_unit
 14944              	.LVL1908:
 14945 0028 2044     		add	r0, r0, r4
 14946 002a C4B2     		uxtb	r4, r0
 14947              	.LVL1909:
 14948              	.L1608:
5685:Src/bno055.c  **** 			/* Read the raw temperature data */
 14949              		.loc 1 5685 0
 14950 002c 24B1     		cbz	r4, .L1616
5697:Src/bno055.c  **** 		}
 14951              		.loc 1 5697 0
 14952 002e 013C     		subs	r4, r4, #1
 14953              	.LVL1910:
 14954 0030 E4B2     		uxtb	r4, r4
 14955              	.LVL1911:
5700:Src/bno055.c  **** /*!
 14956              		.loc 1 5700 0
 14957 0032 60B2     		sxtb	r0, r4
 14958 0034 03B0     		add	sp, sp, #12
 14959              	.LCFI646:
 14960              		.cfi_remember_state
 14961              		.cfi_def_cfa_offset 12
 14962              		@ sp needed
 14963 0036 30BD     		pop	{r4, r5, pc}
 14964              	.LVL1912:
 14965              	.L1616:
 14966              	.LCFI647:
 14967              		.cfi_restore_state
5687:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 14968              		.loc 1 5687 0
 14969 0038 0DF10600 		add	r0, sp, #6
 14970 003c FFF7FEFF 		bl	bno055_read_temp_data
 14971              	.LVL1913:
5688:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
 14972              		.loc 1 5688 0
 14973 0040 60B9     		cbnz	r0, .L1610
 14974              	.LVL1914:
5690:Src/bno055.c  **** 				BNO055_TEMP_DIV_FAHRENHEIT);
 14975              		.loc 1 5690 0
 14976 0042 9DF90600 		ldrsb	r0, [sp, #6]
 14977              	.LVL1915:
 14978 0046 FFF7FEFF 		bl	__aeabi_i2d
 14979              	.LVL1916:
 14980 004a 0246     		mov	r2, r0
 14981 004c 0B46     		mov	r3, r1
 14982 004e FFF7FEFF 		bl	__aeabi_dadd
 14983              	.LVL1917:
5692:Src/bno055.c  **** 			} else {
 14984              		.loc 1 5692 0
 14985 0052 C5E90001 		strd	r0, [r5]
 14986              	.LVL1918:
5700:Src/bno055.c  **** /*!
 14987              		.loc 1 5700 0
 14988 0056 60B2     		sxtb	r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 422


 14989 0058 03B0     		add	sp, sp, #12
 14990              	.LCFI648:
 14991              		.cfi_remember_state
 14992              		.cfi_def_cfa_offset 12
 14993              		@ sp needed
 14994 005a 30BD     		pop	{r4, r5, pc}
 14995              	.LVL1919:
 14996              	.L1610:
 14997              	.LCFI649:
 14998              		.cfi_restore_state
5694:Src/bno055.c  **** 			}
 14999              		.loc 1 5694 0
 15000 005c 0138     		subs	r0, r0, #1
 15001              	.LVL1920:
 15002 005e C4B2     		uxtb	r4, r0
 15003              	.LVL1921:
5700:Src/bno055.c  **** /*!
 15004              		.loc 1 5700 0
 15005 0060 60B2     		sxtb	r0, r4
 15006 0062 03B0     		add	sp, sp, #12
 15007              	.LCFI650:
 15008              		.cfi_def_cfa_offset 12
 15009              		@ sp needed
 15010 0064 30BD     		pop	{r4, r5, pc}
 15011              		.cfi_endproc
 15012              	.LFE115:
 15014 0066 00BF     		.section	.text.bno055_convert_double_temp_celsius,"ax",%progbits
 15015              		.align	2
 15016              		.global	bno055_convert_double_temp_celsius
 15017              		.thumb
 15018              		.thumb_func
 15020              	bno055_convert_double_temp_celsius:
 15021              	.LFB116:
5715:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15022              		.loc 1 5715 0
 15023              		.cfi_startproc
 15024              		@ args = 0, pretend = 0, frame = 8
 15025              		@ frame_needed = 0, uses_anonymous_args = 0
 15026              	.LVL1922:
 15027 0000 70B5     		push	{r4, r5, r6, lr}
 15028              	.LCFI651:
 15029              		.cfi_def_cfa_offset 16
 15030              		.cfi_offset 4, -16
 15031              		.cfi_offset 5, -12
 15032              		.cfi_offset 6, -8
 15033              		.cfi_offset 14, -4
 15034 0002 82B0     		sub	sp, sp, #8
 15035              	.LCFI652:
 15036              		.cfi_def_cfa_offset 24
5719:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 15037              		.loc 1 5719 0
 15038 0004 02AB     		add	r3, sp, #8
5717:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 15039              		.loc 1 5717 0
 15040 0006 0025     		movs	r5, #0
5719:Src/bno055.c  **** 	/* Read the current temperature unit and set the
 15041              		.loc 1 5719 0
ARM GAS  /tmp/ccVWLGiI.s 			page 423


 15042 0008 03F8015D 		strb	r5, [r3, #-1]!
5715:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15043              		.loc 1 5715 0
 15044 000c 0646     		mov	r6, r0
5722:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
 15045              		.loc 1 5722 0
 15046 000e 1846     		mov	r0, r3
 15047              	.LVL1923:
5717:Src/bno055.c  **** 	double data_d = BNO055_INIT_VALUE;
 15048              		.loc 1 5717 0
 15049 0010 8DF80650 		strb	r5, [sp, #6]
 15050              	.LVL1924:
5722:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
 15051              		.loc 1 5722 0
 15052 0014 FFF7FEFF 		bl	bno055_get_temp_unit
 15053              	.LVL1925:
5723:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_CELSIUS);
 15054              		.loc 1 5723 0
 15055 0018 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
5722:Src/bno055.c  **** 	if (temp_unit_u8 != BNO055_TEMP_UNIT_CELSIUS)
 15056              		.loc 1 5722 0
 15057 001c 0446     		mov	r4, r0
 15058              	.LVL1926:
5723:Src/bno055.c  **** 		com_rslt += bno055_set_temp_unit(BNO055_TEMP_UNIT_CELSIUS);
 15059              		.loc 1 5723 0
 15060 001e 2BB9     		cbnz	r3, .L1626
5725:Src/bno055.c  **** 			/* Read the raw temperature data */
 15061              		.loc 1 5725 0
 15062 0020 5CB1     		cbz	r4, .L1627
 15063              	.L1619:
5737:Src/bno055.c  **** 		}
 15064              		.loc 1 5737 0
 15065 0022 013C     		subs	r4, r4, #1
 15066              	.LVL1927:
 15067 0024 E4B2     		uxtb	r4, r4
 15068              	.LVL1928:
5740:Src/bno055.c  **** #endif
 15069              		.loc 1 5740 0
 15070 0026 60B2     		sxtb	r0, r4
 15071 0028 02B0     		add	sp, sp, #8
 15072              	.LCFI653:
 15073              		.cfi_remember_state
 15074              		.cfi_def_cfa_offset 16
 15075              		@ sp needed
 15076 002a 70BD     		pop	{r4, r5, r6, pc}
 15077              	.LVL1929:
 15078              	.L1626:
 15079              	.LCFI654:
 15080              		.cfi_restore_state
5724:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 15081              		.loc 1 5724 0
 15082 002c 2846     		mov	r0, r5
 15083 002e FFF7FEFF 		bl	bno055_set_temp_unit
 15084              	.LVL1930:
 15085 0032 2044     		add	r0, r0, r4
 15086 0034 C4B2     		uxtb	r4, r0
 15087              	.LVL1931:
ARM GAS  /tmp/ccVWLGiI.s 			page 424


5725:Src/bno055.c  **** 			/* Read the raw temperature data */
 15088              		.loc 1 5725 0
 15089 0036 002C     		cmp	r4, #0
 15090 0038 F3D1     		bne	.L1619
 15091              	.L1627:
5727:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 15092              		.loc 1 5727 0
 15093 003a 0DF10600 		add	r0, sp, #6
 15094 003e FFF7FEFF 		bl	bno055_read_temp_data
 15095              	.LVL1932:
5728:Src/bno055.c  **** 				/* Convert raw temperature data to Fahrenheit*/
 15096              		.loc 1 5728 0
 15097 0042 40B9     		cbnz	r0, .L1620
 15098              	.LVL1933:
5730:Src/bno055.c  **** 				(double)(reg_temp_s8/BNO055_TEMP_DIV_CELSIUS);
 15099              		.loc 1 5730 0
 15100 0044 9DF90600 		ldrsb	r0, [sp, #6]
 15101              	.LVL1934:
 15102 0048 FFF7FEFF 		bl	__aeabi_i2d
 15103              	.LVL1935:
 15104 004c C6E90001 		strd	r0, [r6]
 15105              	.LVL1936:
5740:Src/bno055.c  **** #endif
 15106              		.loc 1 5740 0
 15107 0050 60B2     		sxtb	r0, r4
 15108 0052 02B0     		add	sp, sp, #8
 15109              	.LCFI655:
 15110              		.cfi_remember_state
 15111              		.cfi_def_cfa_offset 16
 15112              		@ sp needed
 15113 0054 70BD     		pop	{r4, r5, r6, pc}
 15114              	.LVL1937:
 15115              	.L1620:
 15116              	.LCFI656:
 15117              		.cfi_restore_state
5734:Src/bno055.c  **** 			}
 15118              		.loc 1 5734 0
 15119 0056 0138     		subs	r0, r0, #1
 15120              	.LVL1938:
 15121 0058 C4B2     		uxtb	r4, r0
 15122              	.LVL1939:
5740:Src/bno055.c  **** #endif
 15123              		.loc 1 5740 0
 15124 005a 60B2     		sxtb	r0, r4
 15125 005c 02B0     		add	sp, sp, #8
 15126              	.LCFI657:
 15127              		.cfi_def_cfa_offset 16
 15128              		@ sp needed
 15129 005e 70BD     		pop	{r4, r5, r6, pc}
 15130              		.cfi_endproc
 15131              	.LFE116:
 15133              		.section	.text.bno055_set_data_output_format,"ax",%progbits
 15134              		.align	2
 15135              		.global	bno055_set_data_output_format
 15136              		.thumb
 15137              		.thumb_func
 15139              	bno055_set_data_output_format:
ARM GAS  /tmp/ccVWLGiI.s 			page 425


 15140              	.LFB144:
7177:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15141              		.loc 1 7177 0
 15142              		.cfi_startproc
 15143              		@ args = 0, pretend = 0, frame = 8
 15144              		@ frame_needed = 0, uses_anonymous_args = 0
 15145              	.LVL1940:
 15146 0000 30B5     		push	{r4, r5, lr}
 15147              	.LCFI658:
 15148              		.cfi_def_cfa_offset 12
 15149              		.cfi_offset 4, -12
 15150              		.cfi_offset 5, -8
 15151              		.cfi_offset 14, -4
7183:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 15152              		.loc 1 7183 0
 15153 0002 234C     		ldr	r4, .L1644
7177:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15154              		.loc 1 7177 0
 15155 0004 83B0     		sub	sp, sp, #12
 15156              	.LCFI659:
 15157              		.cfi_def_cfa_offset 24
7183:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 15158              		.loc 1 7183 0
 15159 0006 2268     		ldr	r2, [r4]
7179:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 15160              		.loc 1 7179 0
 15161 0008 0023     		movs	r3, #0
 15162 000a 8DF80630 		strb	r3, [sp, #6]
7180:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 15163              		.loc 1 7180 0
 15164 000e 8DF80730 		strb	r3, [sp, #7]
 15165              	.LVL1941:
7183:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 15166              		.loc 1 7183 0
 15167 0012 002A     		cmp	r2, #0
 15168 0014 3AD0     		beq	.L1636
 15169 0016 0546     		mov	r5, r0
7189:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 15170              		.loc 1 7189 0
 15171 0018 0DF10700 		add	r0, sp, #7
 15172              	.LVL1942:
 15173 001c FFF7FEFF 		bl	bno055_get_operation_mode
 15174              	.LVL1943:
7190:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 15175              		.loc 1 7190 0
 15176 0020 38B1     		cbz	r0, .L1630
 15177              	.L1635:
7216:Src/bno055.c  **** 		}
 15178              		.loc 1 7216 0
 15179 0022 FF24     		movs	r4, #255
 15180              	.LVL1944:
 15181              	.L1631:
7219:Src/bno055.c  **** 		/* set the operation mode
 15182              		.loc 1 7219 0
 15183 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 15184 0028 20BB     		cbnz	r0, .L1643
 15185 002a 2046     		mov	r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 426


 15186              	.LVL1945:
 15187              	.L1629:
7225:Src/bno055.c  **** /*!	@brief This API used to read the operation mode
 15188              		.loc 1 7225 0
 15189 002c 40B2     		sxtb	r0, r0
 15190 002e 03B0     		add	sp, sp, #12
 15191              	.LCFI660:
 15192              		.cfi_remember_state
 15193              		.cfi_def_cfa_offset 12
 15194              		@ sp needed
 15195 0030 30BD     		pop	{r4, r5, pc}
 15196              	.LVL1946:
 15197              	.L1630:
 15198              	.LCFI661:
 15199              		.cfi_restore_state
7191:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 15200              		.loc 1 7191 0
 15201 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 15202 0036 23BB     		cbnz	r3, .L1632
 15203              	.L1634:
 15204              	.LVL1947:
7196:Src/bno055.c  **** 				(p_bno055->dev_addr,
 15205              		.loc 1 7196 0
 15206 0038 2368     		ldr	r3, [r4]
 15207 003a 0DF10602 		add	r2, sp, #6
 15208 003e 1C69     		ldr	r4, [r3, #16]
 15209 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15210 0042 3B21     		movs	r1, #59
 15211 0044 0123     		movs	r3, #1
 15212 0046 A047     		blx	r4
 15213              	.LVL1948:
 15214 0048 114B     		ldr	r3, .L1644
7200:Src/bno055.c  **** 					data_u8r =
 15215              		.loc 1 7200 0
 15216 004a 0446     		mov	r4, r0
 15217 004c 0028     		cmp	r0, #0
 15218 004e E9D1     		bne	.L1631
7201:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 15219              		.loc 1 7201 0
 15220 0050 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 15221              	.LVL1949:
7206:Src/bno055.c  **** 					(p_bno055->dev_addr,
 15222              		.loc 1 7206 0
 15223 0054 1B68     		ldr	r3, [r3]
7201:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 15224              		.loc 1 7201 0
 15225 0056 00F07F00 		and	r0, r0, #127
 15226 005a 40EAC510 		orr	r0, r0, r5, lsl #7
7206:Src/bno055.c  **** 					(p_bno055->dev_addr,
 15227              		.loc 1 7206 0
 15228 005e DC68     		ldr	r4, [r3, #12]
7201:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 15229              		.loc 1 7201 0
 15230 0060 8DF80600 		strb	r0, [sp, #6]
7206:Src/bno055.c  **** 					(p_bno055->dev_addr,
 15231              		.loc 1 7206 0
 15232 0064 0DF10602 		add	r2, sp, #6
ARM GAS  /tmp/ccVWLGiI.s 			page 427


 15233 0068 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15234 006a 3B21     		movs	r1, #59
 15235 006c 0123     		movs	r3, #1
 15236 006e A047     		blx	r4
 15237              	.LVL1950:
 15238 0070 0446     		mov	r4, r0
 15239              	.LVL1951:
 15240 0072 D7E7     		b	.L1631
 15241              	.L1643:
7222:Src/bno055.c  **** 		(prev_opmode_u8);
 15242              		.loc 1 7222 0
 15243 0074 FFF7FEFF 		bl	bno055_set_operation_mode
 15244              	.LVL1952:
 15245 0078 2044     		add	r0, r0, r4
 15246 007a C0B2     		uxtb	r0, r0
 15247              	.LVL1953:
7225:Src/bno055.c  **** /*!	@brief This API used to read the operation mode
 15248              		.loc 1 7225 0
 15249 007c 40B2     		sxtb	r0, r0
 15250 007e 03B0     		add	sp, sp, #12
 15251              	.LCFI662:
 15252              		.cfi_remember_state
 15253              		.cfi_def_cfa_offset 12
 15254              		@ sp needed
 15255 0080 30BD     		pop	{r4, r5, pc}
 15256              	.LVL1954:
 15257              	.L1632:
 15258              	.LCFI663:
 15259              		.cfi_restore_state
7192:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 15260              		.loc 1 7192 0
 15261 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 15262              	.LVL1955:
7194:Src/bno055.c  **** 				/* Write the data output format */
 15263              		.loc 1 7194 0
 15264 0086 0028     		cmp	r0, #0
 15265 0088 CBD1     		bne	.L1635
 15266 008a D5E7     		b	.L1634
 15267              	.LVL1956:
 15268              	.L1636:
7184:Src/bno055.c  **** 	} else {
 15269              		.loc 1 7184 0
 15270 008c 8120     		movs	r0, #129
 15271              	.LVL1957:
 15272 008e CDE7     		b	.L1629
 15273              	.L1645:
 15274              		.align	2
 15275              	.L1644:
 15276 0090 00000000 		.word	.LANCHOR0
 15277              		.cfi_endproc
 15278              	.LFE144:
 15280              		.section	.text.bno055_get_power_mode,"ax",%progbits
 15281              		.align	2
 15282              		.global	bno055_get_power_mode
 15283              		.thumb
 15284              		.thumb_func
 15286              	bno055_get_power_mode:
ARM GAS  /tmp/ccVWLGiI.s 			page 428


 15287              	.LFB147:
7432:Src/bno055.c  **** /*!	@brief This API used to read the power mode
7433:Src/bno055.c  ****  *	from register from 0x3E bit 0 to 1
7434:Src/bno055.c  ****  *
7435:Src/bno055.c  ****  *	@param power_mode_u8 : The value of power mode
7436:Src/bno055.c  ****  *
7437:Src/bno055.c  ****  * power_mode_u8|      result           | comments
7438:Src/bno055.c  ****  * ---------|---------------------------|-------------------------------------
7439:Src/bno055.c  ****  *  0x00    |BNO055_POWER_MODE_NORMAL   | In the NORMAL mode the register
7440:Src/bno055.c  ****  *    -     |       -                   | map and the internal peripherals
7441:Src/bno055.c  ****  *    -     |       -                   | of the MCU are always
7442:Src/bno055.c  ****  *    -     |       -                   | operative in this mode
7443:Src/bno055.c  ****  *  0x01    |BNO055_POWER_MODE_LOWPOWER | This is first level of power
7444:Src/bno055.c  ****  *          |       -                   | saving mode
7445:Src/bno055.c  ****  *  0x02    |BNO055_POWER_MODE_SUSPEND  | In suspend mode the system is
7446:Src/bno055.c  ****  *   -      |      -                    | paused and all the sensors and
7447:Src/bno055.c  ****  *   -      |      -                    | the micro controller are
7448:Src/bno055.c  ****  *   -      |      -                    | put into sleep mode.
7449:Src/bno055.c  ****  *
7450:Src/bno055.c  ****  *	@return results of bus communication function
7451:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7452:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7453:Src/bno055.c  ****  *
7454:Src/bno055.c  ****  *	@note For detailed about LOWPOWER mode
7455:Src/bno055.c  ****  *	refer data sheet 3.4.2
7456:Src/bno055.c  ****  *
7457:Src/bno055.c  ****  */
7458:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_power_mode(
7459:Src/bno055.c  **** u8 *power_mode_u8)
7460:Src/bno055.c  **** {
 15288              		.loc 1 7460 0
 15289              		.cfi_startproc
 15290              		@ args = 0, pretend = 0, frame = 8
 15291              		@ frame_needed = 0, uses_anonymous_args = 0
 15292              	.LVL1958:
 15293 0000 30B5     		push	{r4, r5, lr}
 15294              	.LCFI664:
 15295              		.cfi_def_cfa_offset 12
 15296              		.cfi_offset 4, -12
 15297              		.cfi_offset 5, -8
 15298              		.cfi_offset 14, -4
7461:Src/bno055.c  **** 	/* Variable used to return value of
7462:Src/bno055.c  **** 	communication routine*/
7463:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7464:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7465:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7466:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7467:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 15299              		.loc 1 7467 0
 15300 0002 134C     		ldr	r4, .L1657
7460:Src/bno055.c  **** 	/* Variable used to return value of
 15301              		.loc 1 7460 0
 15302 0004 83B0     		sub	sp, sp, #12
 15303              	.LCFI665:
 15304              		.cfi_def_cfa_offset 24
 15305              		.loc 1 7467 0
 15306 0006 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 429


7464:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 15307              		.loc 1 7464 0
 15308 0008 0022     		movs	r2, #0
 15309 000a 8DF80720 		strb	r2, [sp, #7]
 15310              	.LVL1959:
 15311              		.loc 1 7467 0
 15312 000e E3B1     		cbz	r3, .L1650
7468:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7469:Src/bno055.c  **** 		} else {
7470:Src/bno055.c  **** 		/*condition check for page, power mode is
7471:Src/bno055.c  **** 		available in the page zero*/
7472:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 15313              		.loc 1 7472 0
 15314 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 15315 0012 0546     		mov	r5, r0
 15316 0014 71B9     		cbnz	r1, .L1656
 15317              	.LVL1960:
 15318              	.L1648:
7473:Src/bno055.c  **** 			/* Write the page zero*/
7474:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7475:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7476:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7477:Src/bno055.c  **** 			/* Read the value of power mode */
7478:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 15319              		.loc 1 7478 0
 15320 0016 1C69     		ldr	r4, [r3, #16]
 15321 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15322 001a 3E21     		movs	r1, #62
 15323 001c 0123     		movs	r3, #1
 15324 001e 0DF10702 		add	r2, sp, #7
 15325 0022 A047     		blx	r4
 15326              	.LVL1961:
7479:Src/bno055.c  **** 			(p_bno055->dev_addr,
7480:Src/bno055.c  **** 			BNO055_POWER_MODE_REG,
7481:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7482:Src/bno055.c  **** 			*power_mode_u8 =
 15327              		.loc 1 7482 0
 15328 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 15329 0028 03F00303 		and	r3, r3, #3
 15330 002c 2B70     		strb	r3, [r5]
 15331              	.LVL1962:
 15332              	.L1647:
7483:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
7484:Src/bno055.c  **** 			BNO055_POWER_MODE);
7485:Src/bno055.c  **** 		} else {
7486:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7487:Src/bno055.c  **** 		}
7488:Src/bno055.c  **** 	}
7489:Src/bno055.c  **** 	return com_rslt;
7490:Src/bno055.c  **** }
 15333              		.loc 1 7490 0
 15334 002e 40B2     		sxtb	r0, r0
 15335 0030 03B0     		add	sp, sp, #12
 15336              	.LCFI666:
 15337              		.cfi_remember_state
 15338              		.cfi_def_cfa_offset 12
 15339              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 430


 15340 0032 30BD     		pop	{r4, r5, pc}
 15341              	.LVL1963:
 15342              	.L1656:
 15343              	.LCFI667:
 15344              		.cfi_restore_state
7474:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 15345              		.loc 1 7474 0
 15346 0034 1046     		mov	r0, r2
 15347              	.LVL1964:
 15348 0036 FFF7FEFF 		bl	bno055_write_page_id
 15349              	.LVL1965:
 15350 003a 2368     		ldr	r3, [r4]
7475:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15351              		.loc 1 7475 0
 15352 003c 0028     		cmp	r0, #0
 15353 003e EAD0     		beq	.L1648
 15354              	.LVL1966:
7475:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15355              		.loc 1 7475 0 is_stmt 0 discriminator 1
 15356 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7486:Src/bno055.c  **** 		}
 15357              		.loc 1 7486 0 is_stmt 1 discriminator 1
 15358 0042 FF20     		movs	r0, #255
7475:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15359              		.loc 1 7475 0 discriminator 1
 15360 0044 002A     		cmp	r2, #0
 15361 0046 F2D1     		bne	.L1647
 15362 0048 E5E7     		b	.L1648
 15363              	.LVL1967:
 15364              	.L1650:
7468:Src/bno055.c  **** 		} else {
 15365              		.loc 1 7468 0
 15366 004a 8120     		movs	r0, #129
 15367              	.LVL1968:
 15368 004c EFE7     		b	.L1647
 15369              	.L1658:
 15370 004e 00BF     		.align	2
 15371              	.L1657:
 15372 0050 00000000 		.word	.LANCHOR0
 15373              		.cfi_endproc
 15374              	.LFE147:
 15376              		.section	.text.bno055_set_power_mode,"ax",%progbits
 15377              		.align	2
 15378              		.global	bno055_set_power_mode
 15379              		.thumb
 15380              		.thumb_func
 15382              	bno055_set_power_mode:
 15383              	.LFB148:
7491:Src/bno055.c  **** /*!	@brief This API used to write the power mode
7492:Src/bno055.c  ****  *	from register from 0x3E bit 0 to 1
7493:Src/bno055.c  ****  *
7494:Src/bno055.c  ****  *	@param power_mode_u8 : The value of power mode
7495:Src/bno055.c  ****  *
7496:Src/bno055.c  ****  *
7497:Src/bno055.c  ****  * power_mode_u8|      result          | comments
7498:Src/bno055.c  ****  * -------|----------------------------|---------------------------------
7499:Src/bno055.c  ****  *  0x00  | BNO055_POWER_MODE_NORMAL   | In the NORMAL mode the register
ARM GAS  /tmp/ccVWLGiI.s 			page 431


7500:Src/bno055.c  ****  *    -   |       -                    | map and the internal peripherals
7501:Src/bno055.c  ****  *    -   |       -                    | of the MCU are always
7502:Src/bno055.c  ****  *    -   |       -                    | operative in this mode
7503:Src/bno055.c  ****  *  0x01  | BNO055_POWER_MODE_LOWPOWER | This is first level of power
7504:Src/bno055.c  ****  *        |		-                      | saving mode
7505:Src/bno055.c  ****  *  0x02  | BNO055_POWER_MODE_SUSPEND  | In suspend mode the system is
7506:Src/bno055.c  ****  *   -    |      -                     | paused and all the sensors and
7507:Src/bno055.c  ****  *   -    |      -                     | the micro controller are
7508:Src/bno055.c  ****  *   -    |      -                     | put into sleep mode.
7509:Src/bno055.c  ****  *
7510:Src/bno055.c  ****  *	@return results of bus communication function
7511:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7512:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7513:Src/bno055.c  ****  *
7514:Src/bno055.c  ****  *	@note For detailed about LOWPOWER mode
7515:Src/bno055.c  ****  *	refer data sheet 3.4.2
7516:Src/bno055.c  ****  *
7517:Src/bno055.c  ****  */
7518:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_power_mode(u8 power_mode_u8)
7519:Src/bno055.c  **** {
 15384              		.loc 1 7519 0
 15385              		.cfi_startproc
 15386              		@ args = 0, pretend = 0, frame = 8
 15387              		@ frame_needed = 0, uses_anonymous_args = 0
 15388              	.LVL1969:
 15389 0000 30B5     		push	{r4, r5, lr}
 15390              	.LCFI668:
 15391              		.cfi_def_cfa_offset 12
 15392              		.cfi_offset 4, -12
 15393              		.cfi_offset 5, -8
 15394              		.cfi_offset 14, -4
7520:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7521:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
7522:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
7523:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
7524:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
7525:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 15395              		.loc 1 7525 0
 15396 0002 244C     		ldr	r4, .L1675
7519:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15397              		.loc 1 7519 0
 15398 0004 83B0     		sub	sp, sp, #12
 15399              	.LCFI669:
 15400              		.cfi_def_cfa_offset 24
 15401              		.loc 1 7525 0
 15402 0006 2268     		ldr	r2, [r4]
7521:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 15403              		.loc 1 7521 0
 15404 0008 0023     		movs	r3, #0
 15405 000a 8DF80630 		strb	r3, [sp, #6]
7522:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 15406              		.loc 1 7522 0
 15407 000e 8DF80730 		strb	r3, [sp, #7]
 15408              	.LVL1970:
 15409              		.loc 1 7525 0
 15410 0012 002A     		cmp	r2, #0
 15411 0014 3BD0     		beq	.L1667
ARM GAS  /tmp/ccVWLGiI.s 			page 432


 15412 0016 0546     		mov	r5, r0
7526:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
7527:Src/bno055.c  **** 	} else {
7528:Src/bno055.c  **** 		/* The write operation effective only if the operation
7529:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
7530:Src/bno055.c  **** 		current operation mode and set the config mode */
7531:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 15413              		.loc 1 7531 0
 15414 0018 0DF10700 		add	r0, sp, #7
 15415              	.LVL1971:
 15416 001c FFF7FEFF 		bl	bno055_get_operation_mode
 15417              	.LVL1972:
7532:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 15418              		.loc 1 7532 0
 15419 0020 38B1     		cbz	r0, .L1661
 15420              	.L1666:
7533:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
7534:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
7535:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
7536:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
7537:Src/bno055.c  **** 				/* Write the value of power mode */
7538:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
7539:Src/bno055.c  **** 				(p_bno055->dev_addr,
7540:Src/bno055.c  **** 				BNO055_POWER_MODE_REG,
7541:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7542:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
7543:Src/bno055.c  **** 					data_u8r =
7544:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
7545:Src/bno055.c  **** 					BNO055_POWER_MODE, power_mode_u8);
7546:Src/bno055.c  **** 					com_rslt +=
7547:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
7548:Src/bno055.c  **** 					(p_bno055->dev_addr,
7549:Src/bno055.c  **** 					BNO055_POWER_MODE_REG,
7550:Src/bno055.c  **** 					&data_u8r,
7551:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7552:Src/bno055.c  **** 				}
7553:Src/bno055.c  **** 			} else {
7554:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
7555:Src/bno055.c  **** 			}
7556:Src/bno055.c  **** 		} else {
7557:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 15421              		.loc 1 7557 0
 15422 0022 FF24     		movs	r4, #255
 15423              	.LVL1973:
 15424              	.L1662:
7558:Src/bno055.c  **** 		}
7559:Src/bno055.c  **** 	}
7560:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 15425              		.loc 1 7560 0
 15426 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 15427 0028 28BB     		cbnz	r0, .L1674
 15428 002a 2046     		mov	r0, r4
 15429              	.LVL1974:
 15430              	.L1660:
7561:Src/bno055.c  **** 		/* set the operation mode
7562:Src/bno055.c  **** 		of previous operation mode*/
7563:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
ARM GAS  /tmp/ccVWLGiI.s 			page 433


7564:Src/bno055.c  **** 		(prev_opmode_u8);
7565:Src/bno055.c  **** 	return com_rslt;
7566:Src/bno055.c  **** }
 15431              		.loc 1 7566 0
 15432 002c 40B2     		sxtb	r0, r0
 15433 002e 03B0     		add	sp, sp, #12
 15434              	.LCFI670:
 15435              		.cfi_remember_state
 15436              		.cfi_def_cfa_offset 12
 15437              		@ sp needed
 15438 0030 30BD     		pop	{r4, r5, pc}
 15439              	.LVL1975:
 15440              	.L1661:
 15441              	.LCFI671:
 15442              		.cfi_restore_state
7533:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 15443              		.loc 1 7533 0
 15444 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 15445 0036 2BBB     		cbnz	r3, .L1663
 15446              	.L1665:
 15447              	.LVL1976:
7538:Src/bno055.c  **** 				(p_bno055->dev_addr,
 15448              		.loc 1 7538 0
 15449 0038 2368     		ldr	r3, [r4]
 15450 003a 0DF10602 		add	r2, sp, #6
 15451 003e 1C69     		ldr	r4, [r3, #16]
 15452 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15453 0042 3E21     		movs	r1, #62
 15454 0044 0123     		movs	r3, #1
 15455 0046 A047     		blx	r4
 15456              	.LVL1977:
 15457 0048 124B     		ldr	r3, .L1675
7542:Src/bno055.c  **** 					data_u8r =
 15458              		.loc 1 7542 0
 15459 004a 0446     		mov	r4, r0
 15460 004c 0028     		cmp	r0, #0
 15461 004e E9D1     		bne	.L1662
7543:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 15462              		.loc 1 7543 0
 15463 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
7547:Src/bno055.c  **** 					(p_bno055->dev_addr,
 15464              		.loc 1 7547 0
 15465 0054 1B68     		ldr	r3, [r3]
7543:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 15466              		.loc 1 7543 0
 15467 0056 05F00300 		and	r0, r5, #3
 15468              	.LVL1978:
 15469 005a 22F00305 		bic	r5, r2, #3
 15470 005e 2843     		orrs	r0, r0, r5
7547:Src/bno055.c  **** 					(p_bno055->dev_addr,
 15471              		.loc 1 7547 0
 15472 0060 DC68     		ldr	r4, [r3, #12]
7543:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 15473              		.loc 1 7543 0
 15474 0062 8DF80600 		strb	r0, [sp, #6]
7547:Src/bno055.c  **** 					(p_bno055->dev_addr,
 15475              		.loc 1 7547 0
ARM GAS  /tmp/ccVWLGiI.s 			page 434


 15476 0066 0DF10602 		add	r2, sp, #6
 15477 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15478 006c 3E21     		movs	r1, #62
 15479 006e 0123     		movs	r3, #1
 15480 0070 A047     		blx	r4
 15481              	.LVL1979:
 15482 0072 0446     		mov	r4, r0
 15483              	.LVL1980:
 15484 0074 D6E7     		b	.L1662
 15485              	.L1674:
7563:Src/bno055.c  **** 		(prev_opmode_u8);
 15486              		.loc 1 7563 0
 15487 0076 FFF7FEFF 		bl	bno055_set_operation_mode
 15488              	.LVL1981:
 15489 007a 2044     		add	r0, r0, r4
 15490 007c C0B2     		uxtb	r0, r0
 15491              	.LVL1982:
 15492              		.loc 1 7566 0
 15493 007e 40B2     		sxtb	r0, r0
 15494 0080 03B0     		add	sp, sp, #12
 15495              	.LCFI672:
 15496              		.cfi_remember_state
 15497              		.cfi_def_cfa_offset 12
 15498              		@ sp needed
 15499 0082 30BD     		pop	{r4, r5, pc}
 15500              	.LVL1983:
 15501              	.L1663:
 15502              	.LCFI673:
 15503              		.cfi_restore_state
7534:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 15504              		.loc 1 7534 0
 15505 0084 FFF7FEFF 		bl	bno055_set_operation_mode
 15506              	.LVL1984:
7536:Src/bno055.c  **** 				/* Write the value of power mode */
 15507              		.loc 1 7536 0
 15508 0088 0028     		cmp	r0, #0
 15509 008a CAD1     		bne	.L1666
 15510 008c D4E7     		b	.L1665
 15511              	.LVL1985:
 15512              	.L1667:
7526:Src/bno055.c  **** 	} else {
 15513              		.loc 1 7526 0
 15514 008e 8120     		movs	r0, #129
 15515              	.LVL1986:
 15516 0090 CCE7     		b	.L1660
 15517              	.L1676:
 15518 0092 00BF     		.align	2
 15519              	.L1675:
 15520 0094 00000000 		.word	.LANCHOR0
 15521              		.cfi_endproc
 15522              	.LFE148:
 15524              		.section	.text.bno055_get_intr_rst,"ax",%progbits
 15525              		.align	2
 15526              		.global	bno055_get_intr_rst
 15527              		.thumb
 15528              		.thumb_func
 15530              	bno055_get_intr_rst:
ARM GAS  /tmp/ccVWLGiI.s 			page 435


 15531              	.LFB149:
7567:Src/bno055.c  **** /*!
7568:Src/bno055.c  ****  *	@brief This API used to read the reset interrupt
7569:Src/bno055.c  ****  *	from register from 0x3F bit 6
7570:Src/bno055.c  ****  *	It resets all the interrupt bit and interrupt output
7571:Src/bno055.c  ****  *
7572:Src/bno055.c  ****  *	@param intr_rst_u8 : The value of reset interrupt
7573:Src/bno055.c  ****  *
7574:Src/bno055.c  ****  *    intr_rst_u8 | result
7575:Src/bno055.c  ****  *   ------------ |----------
7576:Src/bno055.c  ****  *     0x01       | BNO055_BIT_ENABLE
7577:Src/bno055.c  ****  *     0x00       | BNO055_BIT_DISABLE
7578:Src/bno055.c  ****  *
7579:Src/bno055.c  ****  *	@return results of bus communication function
7580:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7581:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7582:Src/bno055.c  ****  *
7583:Src/bno055.c  ****  */
7584:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_rst(
7585:Src/bno055.c  **** u8 *intr_rst_u8)
7586:Src/bno055.c  **** {
 15532              		.loc 1 7586 0
 15533              		.cfi_startproc
 15534              		@ args = 0, pretend = 0, frame = 8
 15535              		@ frame_needed = 0, uses_anonymous_args = 0
 15536              	.LVL1987:
 15537 0000 30B5     		push	{r4, r5, lr}
 15538              	.LCFI674:
 15539              		.cfi_def_cfa_offset 12
 15540              		.cfi_offset 4, -12
 15541              		.cfi_offset 5, -8
 15542              		.cfi_offset 14, -4
7587:Src/bno055.c  **** 	/* Variable used to return value of
7588:Src/bno055.c  **** 	communication routine*/
7589:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7590:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7591:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7592:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7593:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 15543              		.loc 1 7593 0
 15544 0002 134C     		ldr	r4, .L1688
7586:Src/bno055.c  **** 	/* Variable used to return value of
 15545              		.loc 1 7586 0
 15546 0004 83B0     		sub	sp, sp, #12
 15547              	.LCFI675:
 15548              		.cfi_def_cfa_offset 24
 15549              		.loc 1 7593 0
 15550 0006 2368     		ldr	r3, [r4]
7590:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 15551              		.loc 1 7590 0
 15552 0008 0022     		movs	r2, #0
 15553 000a 8DF80720 		strb	r2, [sp, #7]
 15554              	.LVL1988:
 15555              		.loc 1 7593 0
 15556 000e E3B1     		cbz	r3, .L1681
7594:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7595:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 436


7596:Src/bno055.c  **** 		/*condition check for page,  reset interrupt is
7597:Src/bno055.c  **** 		available in the page zero*/
7598:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 15557              		.loc 1 7598 0
 15558 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 15559 0012 0546     		mov	r5, r0
 15560 0014 71B9     		cbnz	r1, .L1687
 15561              	.LVL1989:
 15562              	.L1679:
7599:Src/bno055.c  **** 			/* Write the page zero*/
7600:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7601:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7602:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7603:Src/bno055.c  **** 			/* Read the value of reset interrupt*/
7604:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 15563              		.loc 1 7604 0
 15564 0016 1C69     		ldr	r4, [r3, #16]
 15565 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15566 001a 3F21     		movs	r1, #63
 15567 001c 0123     		movs	r3, #1
 15568 001e 0DF10702 		add	r2, sp, #7
 15569 0022 A047     		blx	r4
 15570              	.LVL1990:
7605:Src/bno055.c  **** 			(p_bno055->dev_addr,
7606:Src/bno055.c  **** 			BNO055_INTR_RST_REG,
7607:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7608:Src/bno055.c  **** 			*intr_rst_u8 =
7609:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_INTR_RST);
 15571              		.loc 1 7609 0
 15572 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 15573 0028 C3F38013 		ubfx	r3, r3, #6, #1
7608:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_INTR_RST);
 15574              		.loc 1 7608 0
 15575 002c 2B70     		strb	r3, [r5]
 15576              	.LVL1991:
 15577              	.L1678:
7610:Src/bno055.c  **** 		} else {
7611:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7612:Src/bno055.c  **** 		}
7613:Src/bno055.c  **** 	}
7614:Src/bno055.c  **** 	return com_rslt;
7615:Src/bno055.c  **** }
 15578              		.loc 1 7615 0
 15579 002e 40B2     		sxtb	r0, r0
 15580 0030 03B0     		add	sp, sp, #12
 15581              	.LCFI676:
 15582              		.cfi_remember_state
 15583              		.cfi_def_cfa_offset 12
 15584              		@ sp needed
 15585 0032 30BD     		pop	{r4, r5, pc}
 15586              	.LVL1992:
 15587              	.L1687:
 15588              	.LCFI677:
 15589              		.cfi_restore_state
7600:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 15590              		.loc 1 7600 0
 15591 0034 1046     		mov	r0, r2
ARM GAS  /tmp/ccVWLGiI.s 			page 437


 15592              	.LVL1993:
 15593 0036 FFF7FEFF 		bl	bno055_write_page_id
 15594              	.LVL1994:
 15595 003a 2368     		ldr	r3, [r4]
7601:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15596              		.loc 1 7601 0
 15597 003c 0028     		cmp	r0, #0
 15598 003e EAD0     		beq	.L1679
 15599              	.LVL1995:
7601:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15600              		.loc 1 7601 0 is_stmt 0 discriminator 1
 15601 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7611:Src/bno055.c  **** 		}
 15602              		.loc 1 7611 0 is_stmt 1 discriminator 1
 15603 0042 FF20     		movs	r0, #255
7601:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15604              		.loc 1 7601 0 discriminator 1
 15605 0044 002A     		cmp	r2, #0
 15606 0046 F2D1     		bne	.L1678
 15607 0048 E5E7     		b	.L1679
 15608              	.LVL1996:
 15609              	.L1681:
7594:Src/bno055.c  **** 		} else {
 15610              		.loc 1 7594 0
 15611 004a 8120     		movs	r0, #129
 15612              	.LVL1997:
 15613 004c EFE7     		b	.L1678
 15614              	.L1689:
 15615 004e 00BF     		.align	2
 15616              	.L1688:
 15617 0050 00000000 		.word	.LANCHOR0
 15618              		.cfi_endproc
 15619              	.LFE149:
 15621              		.section	.text.bno055_set_intr_rst,"ax",%progbits
 15622              		.align	2
 15623              		.global	bno055_set_intr_rst
 15624              		.thumb
 15625              		.thumb_func
 15627              	bno055_set_intr_rst:
 15628              	.LFB150:
7616:Src/bno055.c  **** /*!
7617:Src/bno055.c  ****  *	@brief This API used to write the reset interrupt
7618:Src/bno055.c  ****  *	from register from 0x3F bit 6
7619:Src/bno055.c  ****  *	It resets all the interrupt bit and interrupt output
7620:Src/bno055.c  ****  *
7621:Src/bno055.c  ****  *	@param intr_rst_u8 : The value of reset interrupt
7622:Src/bno055.c  ****  *
7623:Src/bno055.c  ****  *    intr_rst_u8 | result
7624:Src/bno055.c  ****  *   -------------- |----------
7625:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7626:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7627:Src/bno055.c  ****  *
7628:Src/bno055.c  ****  *	@return results of bus communication function
7629:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7630:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7631:Src/bno055.c  ****  *
7632:Src/bno055.c  ****  */
ARM GAS  /tmp/ccVWLGiI.s 			page 438


7633:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_rst(u8 intr_rst_u8)
7634:Src/bno055.c  **** {
 15629              		.loc 1 7634 0
 15630              		.cfi_startproc
 15631              		@ args = 0, pretend = 0, frame = 8
 15632              		@ frame_needed = 0, uses_anonymous_args = 0
 15633              	.LVL1998:
 15634 0000 70B5     		push	{r4, r5, r6, lr}
 15635              	.LCFI678:
 15636              		.cfi_def_cfa_offset 16
 15637              		.cfi_offset 4, -16
 15638              		.cfi_offset 5, -12
 15639              		.cfi_offset 6, -8
 15640              		.cfi_offset 14, -4
7635:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7636:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7637:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7638:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7639:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 15641              		.loc 1 7639 0
 15642 0002 1C4D     		ldr	r5, .L1703
7634:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15643              		.loc 1 7634 0
 15644 0004 82B0     		sub	sp, sp, #8
 15645              	.LCFI679:
 15646              		.cfi_def_cfa_offset 24
 15647              		.loc 1 7639 0
 15648 0006 2B68     		ldr	r3, [r5]
7636:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 15649              		.loc 1 7636 0
 15650 0008 0022     		movs	r2, #0
 15651 000a 8DF80720 		strb	r2, [sp, #7]
 15652              	.LVL1999:
 15653              		.loc 1 7639 0
 15654 000e 002B     		cmp	r3, #0
 15655 0010 2DD0     		beq	.L1694
7640:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7641:Src/bno055.c  **** 		} else {
7642:Src/bno055.c  **** 		/*condition check for page, reset interrupt
7643:Src/bno055.c  **** 		available in the page zero*/
7644:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 15656              		.loc 1 7644 0
 15657 0012 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 15658 0014 0446     		mov	r4, r0
 15659 0016 51B9     		cbnz	r1, .L1701
 15660              	.LVL2000:
 15661              	.L1692:
7645:Src/bno055.c  **** 			/* Write the page zero*/
7646:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7647:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7648:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7649:Src/bno055.c  **** 			/* Write the value of reset interrupt */
7650:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 15662              		.loc 1 7650 0
 15663 0018 1E69     		ldr	r6, [r3, #16]
 15664 001a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15665 001c 0DF10702 		add	r2, sp, #7
ARM GAS  /tmp/ccVWLGiI.s 			page 439


 15666 0020 3F21     		movs	r1, #63
 15667 0022 0123     		movs	r3, #1
 15668 0024 B047     		blx	r6
 15669              	.LVL2001:
7651:Src/bno055.c  **** 			(p_bno055->dev_addr,
7652:Src/bno055.c  **** 			BNO055_INTR_RST_REG,
7653:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7654:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 15670              		.loc 1 7654 0
 15671 0026 68B1     		cbz	r0, .L1702
 15672              	.LVL2002:
 15673              	.L1691:
7655:Src/bno055.c  **** 				data_u8r =
7656:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
7657:Src/bno055.c  **** 				BNO055_INTR_RST, intr_rst_u8);
7658:Src/bno055.c  **** 				com_rslt +=
7659:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
7660:Src/bno055.c  **** 				(p_bno055->dev_addr,
7661:Src/bno055.c  **** 				BNO055_INTR_RST_REG,
7662:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7663:Src/bno055.c  **** 			}
7664:Src/bno055.c  **** 		} else {
7665:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7666:Src/bno055.c  **** 		}
7667:Src/bno055.c  **** 	}
7668:Src/bno055.c  **** 	return com_rslt;
7669:Src/bno055.c  **** }
 15674              		.loc 1 7669 0
 15675 0028 40B2     		sxtb	r0, r0
 15676 002a 02B0     		add	sp, sp, #8
 15677              	.LCFI680:
 15678              		.cfi_remember_state
 15679              		.cfi_def_cfa_offset 16
 15680              		@ sp needed
 15681 002c 70BD     		pop	{r4, r5, r6, pc}
 15682              	.LVL2003:
 15683              	.L1701:
 15684              	.LCFI681:
 15685              		.cfi_restore_state
7646:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 15686              		.loc 1 7646 0
 15687 002e 1046     		mov	r0, r2
 15688              	.LVL2004:
 15689 0030 FFF7FEFF 		bl	bno055_write_page_id
 15690              	.LVL2005:
 15691 0034 2B68     		ldr	r3, [r5]
7647:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15692              		.loc 1 7647 0
 15693 0036 0028     		cmp	r0, #0
 15694 0038 EED0     		beq	.L1692
 15695              	.LVL2006:
7647:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15696              		.loc 1 7647 0 is_stmt 0 discriminator 1
 15697 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7665:Src/bno055.c  **** 		}
 15698              		.loc 1 7665 0 is_stmt 1 discriminator 1
 15699 003c FF20     		movs	r0, #255
ARM GAS  /tmp/ccVWLGiI.s 			page 440


7647:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15700              		.loc 1 7647 0 discriminator 1
 15701 003e 002A     		cmp	r2, #0
 15702 0040 F2D1     		bne	.L1691
 15703 0042 E9E7     		b	.L1692
 15704              	.LVL2007:
 15705              	.L1702:
7655:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 15706              		.loc 1 7655 0
 15707 0044 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
7656:Src/bno055.c  **** 				BNO055_INTR_RST, intr_rst_u8);
 15708              		.loc 1 7656 0
 15709 0048 A001     		lsls	r0, r4, #6
 15710              	.LVL2008:
7659:Src/bno055.c  **** 				(p_bno055->dev_addr,
 15711              		.loc 1 7659 0
 15712 004a 2968     		ldr	r1, [r5]
7655:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 15713              		.loc 1 7655 0
 15714 004c 23F04004 		bic	r4, r3, #64
 15715 0050 00F04000 		and	r0, r0, #64
 15716 0054 2043     		orrs	r0, r0, r4
 15717 0056 8DF80700 		strb	r0, [sp, #7]
7659:Src/bno055.c  **** 				(p_bno055->dev_addr,
 15718              		.loc 1 7659 0
 15719 005a CC68     		ldr	r4, [r1, #12]
 15720 005c 0DF10702 		add	r2, sp, #7
 15721 0060 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 15722 0062 0123     		movs	r3, #1
 15723 0064 3F21     		movs	r1, #63
 15724 0066 A047     		blx	r4
 15725              	.LVL2009:
 15726              		.loc 1 7669 0
 15727 0068 40B2     		sxtb	r0, r0
 15728 006a 02B0     		add	sp, sp, #8
 15729              	.LCFI682:
 15730              		.cfi_remember_state
 15731              		.cfi_def_cfa_offset 16
 15732              		@ sp needed
 15733 006c 70BD     		pop	{r4, r5, r6, pc}
 15734              	.LVL2010:
 15735              	.L1694:
 15736              	.LCFI683:
 15737              		.cfi_restore_state
7640:Src/bno055.c  **** 		} else {
 15738              		.loc 1 7640 0
 15739 006e 8120     		movs	r0, #129
 15740              	.LVL2011:
 15741 0070 DAE7     		b	.L1691
 15742              	.L1704:
 15743 0072 00BF     		.align	2
 15744              	.L1703:
 15745 0074 00000000 		.word	.LANCHOR0
 15746              		.cfi_endproc
 15747              	.LFE150:
 15749              		.section	.text.bno055_get_clk_src,"ax",%progbits
 15750              		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 441


 15751              		.global	bno055_get_clk_src
 15752              		.thumb
 15753              		.thumb_func
 15755              	bno055_get_clk_src:
 15756              	.LFB151:
7670:Src/bno055.c  **** /*!
7671:Src/bno055.c  ****  *	@brief This API used to read the clk source
7672:Src/bno055.c  ****  *	from register from 0x3F bit 7
7673:Src/bno055.c  ****  *
7674:Src/bno055.c  ****  *	@param clk_src_u8 : The value of clk source
7675:Src/bno055.c  ****  *
7676:Src/bno055.c  ****  *	 clk_src_u8   | result
7677:Src/bno055.c  ****  *   -------------- |----------
7678:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7679:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7680:Src/bno055.c  ****  *
7681:Src/bno055.c  ****  *	@return results of bus communication function
7682:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7683:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7684:Src/bno055.c  ****  *
7685:Src/bno055.c  ****  */
7686:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_clk_src(
7687:Src/bno055.c  **** u8 *clk_src_u8)
7688:Src/bno055.c  **** {
 15757              		.loc 1 7688 0
 15758              		.cfi_startproc
 15759              		@ args = 0, pretend = 0, frame = 8
 15760              		@ frame_needed = 0, uses_anonymous_args = 0
 15761              	.LVL2012:
 15762 0000 30B5     		push	{r4, r5, lr}
 15763              	.LCFI684:
 15764              		.cfi_def_cfa_offset 12
 15765              		.cfi_offset 4, -12
 15766              		.cfi_offset 5, -8
 15767              		.cfi_offset 14, -4
7689:Src/bno055.c  **** 	/* Variable used to return value of
7690:Src/bno055.c  **** 	communication routine*/
7691:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7692:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7693:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7694:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7695:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 15768              		.loc 1 7695 0
 15769 0002 124C     		ldr	r4, .L1716
7688:Src/bno055.c  **** 	/* Variable used to return value of
 15770              		.loc 1 7688 0
 15771 0004 83B0     		sub	sp, sp, #12
 15772              	.LCFI685:
 15773              		.cfi_def_cfa_offset 24
 15774              		.loc 1 7695 0
 15775 0006 2368     		ldr	r3, [r4]
7692:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 15776              		.loc 1 7692 0
 15777 0008 0022     		movs	r2, #0
 15778 000a 8DF80720 		strb	r2, [sp, #7]
 15779              	.LVL2013:
 15780              		.loc 1 7695 0
ARM GAS  /tmp/ccVWLGiI.s 			page 442


 15781 000e DBB1     		cbz	r3, .L1709
7696:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7697:Src/bno055.c  **** 		} else {
7698:Src/bno055.c  **** 		/*condition check for page, clk source is
7699:Src/bno055.c  **** 		available in the page zero*/
7700:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 15782              		.loc 1 7700 0
 15783 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 15784 0012 0546     		mov	r5, r0
 15785 0014 69B9     		cbnz	r1, .L1715
 15786              	.LVL2014:
 15787              	.L1707:
7701:Src/bno055.c  **** 			/* Write the page zero*/
7702:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7703:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7704:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7705:Src/bno055.c  **** 			/* Read the value of clk source */
7706:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 15788              		.loc 1 7706 0
 15789 0016 1C69     		ldr	r4, [r3, #16]
 15790 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15791 001a 3F21     		movs	r1, #63
 15792 001c 0123     		movs	r3, #1
 15793 001e 0DF10702 		add	r2, sp, #7
 15794 0022 A047     		blx	r4
 15795              	.LVL2015:
7707:Src/bno055.c  **** 			(p_bno055->dev_addr,
7708:Src/bno055.c  **** 			BNO055_CLK_SRC_REG,
7709:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7710:Src/bno055.c  **** 			*clk_src_u8 =
7711:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_CLK_SRC);
 15796              		.loc 1 7711 0
 15797 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 15798 0028 DB09     		lsrs	r3, r3, #7
7710:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r, BNO055_CLK_SRC);
 15799              		.loc 1 7710 0
 15800 002a 2B70     		strb	r3, [r5]
 15801              	.LVL2016:
 15802              	.L1706:
7712:Src/bno055.c  **** 		} else {
7713:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7714:Src/bno055.c  **** 		}
7715:Src/bno055.c  **** 	}
7716:Src/bno055.c  **** 	return com_rslt;
7717:Src/bno055.c  **** }
 15803              		.loc 1 7717 0
 15804 002c 40B2     		sxtb	r0, r0
 15805 002e 03B0     		add	sp, sp, #12
 15806              	.LCFI686:
 15807              		.cfi_remember_state
 15808              		.cfi_def_cfa_offset 12
 15809              		@ sp needed
 15810 0030 30BD     		pop	{r4, r5, pc}
 15811              	.LVL2017:
 15812              	.L1715:
 15813              	.LCFI687:
 15814              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 443


7702:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 15815              		.loc 1 7702 0
 15816 0032 1046     		mov	r0, r2
 15817              	.LVL2018:
 15818 0034 FFF7FEFF 		bl	bno055_write_page_id
 15819              	.LVL2019:
 15820 0038 2368     		ldr	r3, [r4]
7703:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15821              		.loc 1 7703 0
 15822 003a 0028     		cmp	r0, #0
 15823 003c EBD0     		beq	.L1707
 15824              	.LVL2020:
7703:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15825              		.loc 1 7703 0 is_stmt 0 discriminator 1
 15826 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7713:Src/bno055.c  **** 		}
 15827              		.loc 1 7713 0 is_stmt 1 discriminator 1
 15828 0040 FF20     		movs	r0, #255
7703:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15829              		.loc 1 7703 0 discriminator 1
 15830 0042 002A     		cmp	r2, #0
 15831 0044 F2D1     		bne	.L1706
 15832 0046 E6E7     		b	.L1707
 15833              	.LVL2021:
 15834              	.L1709:
7696:Src/bno055.c  **** 		} else {
 15835              		.loc 1 7696 0
 15836 0048 8120     		movs	r0, #129
 15837              	.LVL2022:
 15838 004a EFE7     		b	.L1706
 15839              	.L1717:
 15840              		.align	2
 15841              	.L1716:
 15842 004c 00000000 		.word	.LANCHOR0
 15843              		.cfi_endproc
 15844              	.LFE151:
 15846              		.section	.text.bno055_set_clk_src,"ax",%progbits
 15847              		.align	2
 15848              		.global	bno055_set_clk_src
 15849              		.thumb
 15850              		.thumb_func
 15852              	bno055_set_clk_src:
 15853              	.LFB152:
7718:Src/bno055.c  **** /*!
7719:Src/bno055.c  ****  *	@brief This API used to write the clk source
7720:Src/bno055.c  ****  *	from register from 0x3F bit 7
7721:Src/bno055.c  ****  *
7722:Src/bno055.c  ****  *	@param clk_src_u8 : The value of clk source
7723:Src/bno055.c  ****  *
7724:Src/bno055.c  ****  *	 clk_src_u8   | result
7725:Src/bno055.c  ****  *   -------------- |----------
7726:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7727:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7728:Src/bno055.c  ****  *
7729:Src/bno055.c  ****  *	@return results of bus communication function
7730:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7731:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
ARM GAS  /tmp/ccVWLGiI.s 			page 444


7732:Src/bno055.c  ****  *
7733:Src/bno055.c  ****  */
7734:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_clk_src(u8 clk_src_u8)
7735:Src/bno055.c  **** {
 15854              		.loc 1 7735 0
 15855              		.cfi_startproc
 15856              		@ args = 0, pretend = 0, frame = 8
 15857              		@ frame_needed = 0, uses_anonymous_args = 0
 15858              	.LVL2023:
 15859 0000 70B5     		push	{r4, r5, r6, lr}
 15860              	.LCFI688:
 15861              		.cfi_def_cfa_offset 16
 15862              		.cfi_offset 4, -16
 15863              		.cfi_offset 5, -12
 15864              		.cfi_offset 6, -8
 15865              		.cfi_offset 14, -4
7736:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7737:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7738:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7739:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7740:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 15866              		.loc 1 7740 0
 15867 0002 1A4C     		ldr	r4, .L1731
7735:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 15868              		.loc 1 7735 0
 15869 0004 82B0     		sub	sp, sp, #8
 15870              	.LCFI689:
 15871              		.cfi_def_cfa_offset 24
 15872              		.loc 1 7740 0
 15873 0006 2368     		ldr	r3, [r4]
7737:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 15874              		.loc 1 7737 0
 15875 0008 0022     		movs	r2, #0
 15876 000a 8DF80720 		strb	r2, [sp, #7]
 15877              	.LVL2024:
 15878              		.loc 1 7740 0
 15879 000e 5BB3     		cbz	r3, .L1722
7741:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7742:Src/bno055.c  **** 		} else {
7743:Src/bno055.c  **** 		/*condition check for page, clk source is
7744:Src/bno055.c  **** 		available in the page zero*/
7745:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 15880              		.loc 1 7745 0
 15881 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 15882 0012 0546     		mov	r5, r0
 15883 0014 51B9     		cbnz	r1, .L1729
 15884              	.LVL2025:
 15885              	.L1720:
7746:Src/bno055.c  **** 			/* Write the page zero*/
7747:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7748:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7749:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7750:Src/bno055.c  **** 			/* Write the value of clk source */
7751:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 15886              		.loc 1 7751 0
 15887 0016 1E69     		ldr	r6, [r3, #16]
 15888 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 445


 15889 001a 0DF10702 		add	r2, sp, #7
 15890 001e 3F21     		movs	r1, #63
 15891 0020 0123     		movs	r3, #1
 15892 0022 B047     		blx	r6
 15893              	.LVL2026:
7752:Src/bno055.c  **** 			(p_bno055->dev_addr,
7753:Src/bno055.c  **** 			BNO055_CLK_SRC_REG,
7754:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7755:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 15894              		.loc 1 7755 0
 15895 0024 68B1     		cbz	r0, .L1730
 15896              	.LVL2027:
 15897              	.L1719:
7756:Src/bno055.c  **** 				data_u8r =
7757:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
7758:Src/bno055.c  **** 				BNO055_CLK_SRC, clk_src_u8);
7759:Src/bno055.c  **** 				com_rslt +=
7760:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
7761:Src/bno055.c  **** 				(p_bno055->dev_addr,
7762:Src/bno055.c  **** 				BNO055_CLK_SRC_REG,
7763:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7764:Src/bno055.c  **** 			}
7765:Src/bno055.c  **** 		} else {
7766:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7767:Src/bno055.c  **** 		}
7768:Src/bno055.c  **** 	}
7769:Src/bno055.c  **** 	return com_rslt;
7770:Src/bno055.c  **** }
 15898              		.loc 1 7770 0
 15899 0026 40B2     		sxtb	r0, r0
 15900 0028 02B0     		add	sp, sp, #8
 15901              	.LCFI690:
 15902              		.cfi_remember_state
 15903              		.cfi_def_cfa_offset 16
 15904              		@ sp needed
 15905 002a 70BD     		pop	{r4, r5, r6, pc}
 15906              	.LVL2028:
 15907              	.L1729:
 15908              	.LCFI691:
 15909              		.cfi_restore_state
7747:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 15910              		.loc 1 7747 0
 15911 002c 1046     		mov	r0, r2
 15912              	.LVL2029:
 15913 002e FFF7FEFF 		bl	bno055_write_page_id
 15914              	.LVL2030:
 15915 0032 2368     		ldr	r3, [r4]
7748:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15916              		.loc 1 7748 0
 15917 0034 0028     		cmp	r0, #0
 15918 0036 EED0     		beq	.L1720
 15919              	.LVL2031:
7748:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15920              		.loc 1 7748 0 is_stmt 0 discriminator 1
 15921 0038 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7766:Src/bno055.c  **** 		}
 15922              		.loc 1 7766 0 is_stmt 1 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 446


 15923 003a FF20     		movs	r0, #255
7748:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 15924              		.loc 1 7748 0 discriminator 1
 15925 003c 002A     		cmp	r2, #0
 15926 003e F2D1     		bne	.L1719
 15927 0040 E9E7     		b	.L1720
 15928              	.LVL2032:
 15929              	.L1730:
7756:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 15930              		.loc 1 7756 0
 15931 0042 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 15932              	.LVL2033:
7760:Src/bno055.c  **** 				(p_bno055->dev_addr,
 15933              		.loc 1 7760 0
 15934 0046 2368     		ldr	r3, [r4]
7756:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 15935              		.loc 1 7756 0
 15936 0048 00F07F00 		and	r0, r0, #127
 15937 004c 40EAC510 		orr	r0, r0, r5, lsl #7
 15938 0050 8DF80700 		strb	r0, [sp, #7]
7760:Src/bno055.c  **** 				(p_bno055->dev_addr,
 15939              		.loc 1 7760 0
 15940 0054 DC68     		ldr	r4, [r3, #12]
 15941 0056 0DF10702 		add	r2, sp, #7
 15942 005a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 15943 005c 3F21     		movs	r1, #63
 15944 005e 0123     		movs	r3, #1
 15945 0060 A047     		blx	r4
 15946              	.LVL2034:
 15947              		.loc 1 7770 0
 15948 0062 40B2     		sxtb	r0, r0
 15949 0064 02B0     		add	sp, sp, #8
 15950              	.LCFI692:
 15951              		.cfi_remember_state
 15952              		.cfi_def_cfa_offset 16
 15953              		@ sp needed
 15954 0066 70BD     		pop	{r4, r5, r6, pc}
 15955              	.LVL2035:
 15956              	.L1722:
 15957              	.LCFI693:
 15958              		.cfi_restore_state
7741:Src/bno055.c  **** 		} else {
 15959              		.loc 1 7741 0
 15960 0068 8120     		movs	r0, #129
 15961              	.LVL2036:
 15962 006a DCE7     		b	.L1719
 15963              	.L1732:
 15964              		.align	2
 15965              	.L1731:
 15966 006c 00000000 		.word	.LANCHOR0
 15967              		.cfi_endproc
 15968              	.LFE152:
 15970              		.section	.text.bno055_get_sys_rst,"ax",%progbits
 15971              		.align	2
 15972              		.global	bno055_get_sys_rst
 15973              		.thumb
 15974              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 447


 15976              	bno055_get_sys_rst:
 15977              	.LFB153:
7771:Src/bno055.c  **** /*!
7772:Src/bno055.c  ****  *	@brief This API used to read the reset system
7773:Src/bno055.c  ****  *	from register from 0x3F bit 5
7774:Src/bno055.c  ****  *
7775:Src/bno055.c  ****  *	@param sys_rst_u8 : The value of reset system
7776:Src/bno055.c  ****  *
7777:Src/bno055.c  ****  *	 sys_rst_u8   | result
7778:Src/bno055.c  ****  *   -------------- |----------
7779:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7780:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7781:Src/bno055.c  ****  *
7782:Src/bno055.c  ****  *	@return results of bus communication function
7783:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7784:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7785:Src/bno055.c  ****  *
7786:Src/bno055.c  ****  *	@note It resets the whole system
7787:Src/bno055.c  ****  */
7788:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_sys_rst(
7789:Src/bno055.c  **** u8 *sys_rst_u8)
7790:Src/bno055.c  **** {
 15978              		.loc 1 7790 0
 15979              		.cfi_startproc
 15980              		@ args = 0, pretend = 0, frame = 8
 15981              		@ frame_needed = 0, uses_anonymous_args = 0
 15982              	.LVL2037:
 15983 0000 30B5     		push	{r4, r5, lr}
 15984              	.LCFI694:
 15985              		.cfi_def_cfa_offset 12
 15986              		.cfi_offset 4, -12
 15987              		.cfi_offset 5, -8
 15988              		.cfi_offset 14, -4
7791:Src/bno055.c  **** 	/* Variable used to return value of
7792:Src/bno055.c  **** 	communication routine*/
7793:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7794:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7795:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7796:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7797:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 15989              		.loc 1 7797 0
 15990 0002 134C     		ldr	r4, .L1744
7790:Src/bno055.c  **** 	/* Variable used to return value of
 15991              		.loc 1 7790 0
 15992 0004 83B0     		sub	sp, sp, #12
 15993              	.LCFI695:
 15994              		.cfi_def_cfa_offset 24
 15995              		.loc 1 7797 0
 15996 0006 2368     		ldr	r3, [r4]
7794:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 15997              		.loc 1 7794 0
 15998 0008 0022     		movs	r2, #0
 15999 000a 8DF80720 		strb	r2, [sp, #7]
 16000              	.LVL2038:
 16001              		.loc 1 7797 0
 16002 000e E3B1     		cbz	r3, .L1737
7798:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
ARM GAS  /tmp/ccVWLGiI.s 			page 448


7799:Src/bno055.c  **** 		} else {
7800:Src/bno055.c  **** 		/*condition check for page, reset system is
7801:Src/bno055.c  **** 		available in the page zero*/
7802:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 16003              		.loc 1 7802 0
 16004 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 16005 0012 0546     		mov	r5, r0
 16006 0014 71B9     		cbnz	r1, .L1743
 16007              	.LVL2039:
 16008              	.L1735:
7803:Src/bno055.c  **** 			/* Write the page zero*/
7804:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7805:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7806:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7807:Src/bno055.c  **** 			/* Read the value of reset system */
7808:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 16009              		.loc 1 7808 0
 16010 0016 1C69     		ldr	r4, [r3, #16]
 16011 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16012 001a 3F21     		movs	r1, #63
 16013 001c 0123     		movs	r3, #1
 16014 001e 0DF10702 		add	r2, sp, #7
 16015 0022 A047     		blx	r4
 16016              	.LVL2040:
7809:Src/bno055.c  **** 			(p_bno055->dev_addr,
7810:Src/bno055.c  **** 			BNO055_SYS_RST_REG,
7811:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7812:Src/bno055.c  **** 			*sys_rst_u8 =
7813:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 16017              		.loc 1 7813 0
 16018 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16019 0028 C3F34013 		ubfx	r3, r3, #5, #1
7812:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 16020              		.loc 1 7812 0
 16021 002c 2B70     		strb	r3, [r5]
 16022              	.LVL2041:
 16023              	.L1734:
7814:Src/bno055.c  **** 			BNO055_SYS_RST);
7815:Src/bno055.c  **** 		} else {
7816:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7817:Src/bno055.c  **** 		}
7818:Src/bno055.c  **** 	}
7819:Src/bno055.c  **** 	return com_rslt;
7820:Src/bno055.c  **** }
 16024              		.loc 1 7820 0
 16025 002e 40B2     		sxtb	r0, r0
 16026 0030 03B0     		add	sp, sp, #12
 16027              	.LCFI696:
 16028              		.cfi_remember_state
 16029              		.cfi_def_cfa_offset 12
 16030              		@ sp needed
 16031 0032 30BD     		pop	{r4, r5, pc}
 16032              	.LVL2042:
 16033              	.L1743:
 16034              	.LCFI697:
 16035              		.cfi_restore_state
7804:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
ARM GAS  /tmp/ccVWLGiI.s 			page 449


 16036              		.loc 1 7804 0
 16037 0034 1046     		mov	r0, r2
 16038              	.LVL2043:
 16039 0036 FFF7FEFF 		bl	bno055_write_page_id
 16040              	.LVL2044:
 16041 003a 2368     		ldr	r3, [r4]
7805:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16042              		.loc 1 7805 0
 16043 003c 0028     		cmp	r0, #0
 16044 003e EAD0     		beq	.L1735
 16045              	.LVL2045:
7805:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16046              		.loc 1 7805 0 is_stmt 0 discriminator 1
 16047 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7816:Src/bno055.c  **** 		}
 16048              		.loc 1 7816 0 is_stmt 1 discriminator 1
 16049 0042 FF20     		movs	r0, #255
7805:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16050              		.loc 1 7805 0 discriminator 1
 16051 0044 002A     		cmp	r2, #0
 16052 0046 F2D1     		bne	.L1734
 16053 0048 E5E7     		b	.L1735
 16054              	.LVL2046:
 16055              	.L1737:
7798:Src/bno055.c  **** 		} else {
 16056              		.loc 1 7798 0
 16057 004a 8120     		movs	r0, #129
 16058              	.LVL2047:
 16059 004c EFE7     		b	.L1734
 16060              	.L1745:
 16061 004e 00BF     		.align	2
 16062              	.L1744:
 16063 0050 00000000 		.word	.LANCHOR0
 16064              		.cfi_endproc
 16065              	.LFE153:
 16067              		.section	.text.bno055_set_sys_rst,"ax",%progbits
 16068              		.align	2
 16069              		.global	bno055_set_sys_rst
 16070              		.thumb
 16071              		.thumb_func
 16073              	bno055_set_sys_rst:
 16074              	.LFB154:
7821:Src/bno055.c  **** /*!
7822:Src/bno055.c  ****  *	@brief This API used to write the reset system
7823:Src/bno055.c  ****  *	from register from 0x3F bit 5
7824:Src/bno055.c  ****  *
7825:Src/bno055.c  ****  *	@param sys_rst_u8 : The value of reset system
7826:Src/bno055.c  ****  *
7827:Src/bno055.c  ****  *	 sys_rst_u8   | result
7828:Src/bno055.c  ****  *   -------------- |----------
7829:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7830:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7831:Src/bno055.c  ****  *
7832:Src/bno055.c  ****  *	@return results of bus communication function
7833:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7834:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7835:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 450


7836:Src/bno055.c  ****  *	@note It resets the whole system
7837:Src/bno055.c  ****  */
7838:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_sys_rst(u8 sys_rst_u8)
7839:Src/bno055.c  **** {
 16075              		.loc 1 7839 0
 16076              		.cfi_startproc
 16077              		@ args = 0, pretend = 0, frame = 8
 16078              		@ frame_needed = 0, uses_anonymous_args = 0
 16079              	.LVL2048:
 16080 0000 70B5     		push	{r4, r5, r6, lr}
 16081              	.LCFI698:
 16082              		.cfi_def_cfa_offset 16
 16083              		.cfi_offset 4, -16
 16084              		.cfi_offset 5, -12
 16085              		.cfi_offset 6, -8
 16086              		.cfi_offset 14, -4
7840:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7841:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7842:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7843:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7844:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 16087              		.loc 1 7844 0
 16088 0002 1C4D     		ldr	r5, .L1759
7839:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 16089              		.loc 1 7839 0
 16090 0004 82B0     		sub	sp, sp, #8
 16091              	.LCFI699:
 16092              		.cfi_def_cfa_offset 24
 16093              		.loc 1 7844 0
 16094 0006 2B68     		ldr	r3, [r5]
7841:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 16095              		.loc 1 7841 0
 16096 0008 0022     		movs	r2, #0
 16097 000a 8DF80720 		strb	r2, [sp, #7]
 16098              	.LVL2049:
 16099              		.loc 1 7844 0
 16100 000e 002B     		cmp	r3, #0
 16101 0010 2DD0     		beq	.L1750
7845:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7846:Src/bno055.c  **** 		} else {
7847:Src/bno055.c  **** 		/*condition check for page, reset system is
7848:Src/bno055.c  **** 		available in the page zero*/
7849:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 16102              		.loc 1 7849 0
 16103 0012 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 16104 0014 0446     		mov	r4, r0
 16105 0016 51B9     		cbnz	r1, .L1757
 16106              	.LVL2050:
 16107              	.L1748:
7850:Src/bno055.c  **** 			/* Write the page zero*/
7851:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7852:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7853:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7854:Src/bno055.c  **** 			/* Write the value of reset system */
7855:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 16108              		.loc 1 7855 0
 16109 0018 1E69     		ldr	r6, [r3, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 451


 16110 001a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16111 001c 0DF10702 		add	r2, sp, #7
 16112 0020 3F21     		movs	r1, #63
 16113 0022 0123     		movs	r3, #1
 16114 0024 B047     		blx	r6
 16115              	.LVL2051:
7856:Src/bno055.c  **** 			(p_bno055->dev_addr,
7857:Src/bno055.c  **** 			BNO055_SYS_RST_REG,
7858:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7859:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 16116              		.loc 1 7859 0
 16117 0026 68B1     		cbz	r0, .L1758
 16118              	.LVL2052:
 16119              	.L1747:
7860:Src/bno055.c  **** 				data_u8r =
7861:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
7862:Src/bno055.c  **** 				BNO055_SYS_RST, sys_rst_u8);
7863:Src/bno055.c  **** 				com_rslt =
7864:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
7865:Src/bno055.c  **** 				(p_bno055->dev_addr,
7866:Src/bno055.c  **** 				BNO055_SYS_RST_REG,
7867:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7868:Src/bno055.c  **** 			}
7869:Src/bno055.c  **** 		} else {
7870:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7871:Src/bno055.c  **** 		}
7872:Src/bno055.c  **** 	}
7873:Src/bno055.c  **** 	return com_rslt;
7874:Src/bno055.c  **** }
 16120              		.loc 1 7874 0
 16121 0028 40B2     		sxtb	r0, r0
 16122 002a 02B0     		add	sp, sp, #8
 16123              	.LCFI700:
 16124              		.cfi_remember_state
 16125              		.cfi_def_cfa_offset 16
 16126              		@ sp needed
 16127 002c 70BD     		pop	{r4, r5, r6, pc}
 16128              	.LVL2053:
 16129              	.L1757:
 16130              	.LCFI701:
 16131              		.cfi_restore_state
7851:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 16132              		.loc 1 7851 0
 16133 002e 1046     		mov	r0, r2
 16134              	.LVL2054:
 16135 0030 FFF7FEFF 		bl	bno055_write_page_id
 16136              	.LVL2055:
 16137 0034 2B68     		ldr	r3, [r5]
7852:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16138              		.loc 1 7852 0
 16139 0036 0028     		cmp	r0, #0
 16140 0038 EED0     		beq	.L1748
 16141              	.LVL2056:
7852:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16142              		.loc 1 7852 0 is_stmt 0 discriminator 1
 16143 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7870:Src/bno055.c  **** 		}
ARM GAS  /tmp/ccVWLGiI.s 			page 452


 16144              		.loc 1 7870 0 is_stmt 1 discriminator 1
 16145 003c FF20     		movs	r0, #255
7852:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16146              		.loc 1 7852 0 discriminator 1
 16147 003e 002A     		cmp	r2, #0
 16148 0040 F2D1     		bne	.L1747
 16149 0042 E9E7     		b	.L1748
 16150              	.LVL2057:
 16151              	.L1758:
7860:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 16152              		.loc 1 7860 0
 16153 0044 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
7861:Src/bno055.c  **** 				BNO055_SYS_RST, sys_rst_u8);
 16154              		.loc 1 7861 0
 16155 0048 6001     		lsls	r0, r4, #5
 16156              	.LVL2058:
7864:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16157              		.loc 1 7864 0
 16158 004a 2968     		ldr	r1, [r5]
7860:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 16159              		.loc 1 7860 0
 16160 004c 23F02004 		bic	r4, r3, #32
 16161 0050 00F02000 		and	r0, r0, #32
 16162 0054 2043     		orrs	r0, r0, r4
 16163 0056 8DF80700 		strb	r0, [sp, #7]
7863:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
 16164              		.loc 1 7863 0
 16165 005a CC68     		ldr	r4, [r1, #12]
 16166 005c 0DF10702 		add	r2, sp, #7
 16167 0060 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 16168 0062 0123     		movs	r3, #1
 16169 0064 3F21     		movs	r1, #63
 16170 0066 A047     		blx	r4
 16171              	.LVL2059:
 16172              		.loc 1 7874 0
 16173 0068 40B2     		sxtb	r0, r0
 16174              	.LVL2060:
 16175 006a 02B0     		add	sp, sp, #8
 16176              	.LCFI702:
 16177              		.cfi_remember_state
 16178              		.cfi_def_cfa_offset 16
 16179              		@ sp needed
 16180 006c 70BD     		pop	{r4, r5, r6, pc}
 16181              	.LVL2061:
 16182              	.L1750:
 16183              	.LCFI703:
 16184              		.cfi_restore_state
7845:Src/bno055.c  **** 		} else {
 16185              		.loc 1 7845 0
 16186 006e 8120     		movs	r0, #129
 16187              	.LVL2062:
 16188 0070 DAE7     		b	.L1747
 16189              	.L1760:
 16190 0072 00BF     		.align	2
 16191              	.L1759:
 16192 0074 00000000 		.word	.LANCHOR0
 16193              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 453


 16194              	.LFE154:
 16196              		.section	.text.bno055_get_selftest,"ax",%progbits
 16197              		.align	2
 16198              		.global	bno055_get_selftest
 16199              		.thumb
 16200              		.thumb_func
 16202              	bno055_get_selftest:
 16203              	.LFB155:
7875:Src/bno055.c  **** /*!
7876:Src/bno055.c  ****  *	@brief This API used to read the self test
7877:Src/bno055.c  ****  *	from register from 0x3F bit 0
7878:Src/bno055.c  ****  *
7879:Src/bno055.c  ****  *	@param selftest_u8 : The value of self test
7880:Src/bno055.c  ****  *
7881:Src/bno055.c  ****  *	 selftest_u8  | result
7882:Src/bno055.c  ****  *   -------------- |----------
7883:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7884:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7885:Src/bno055.c  ****  *
7886:Src/bno055.c  ****  *	@return results of bus communication function
7887:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7888:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7889:Src/bno055.c  ****  *
7890:Src/bno055.c  ****  *	@note It triggers the self test
7891:Src/bno055.c  ****  */
7892:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_selftest(
7893:Src/bno055.c  **** u8 *selftest_u8)
7894:Src/bno055.c  **** {
 16204              		.loc 1 7894 0
 16205              		.cfi_startproc
 16206              		@ args = 0, pretend = 0, frame = 8
 16207              		@ frame_needed = 0, uses_anonymous_args = 0
 16208              	.LVL2063:
 16209 0000 30B5     		push	{r4, r5, lr}
 16210              	.LCFI704:
 16211              		.cfi_def_cfa_offset 12
 16212              		.cfi_offset 4, -12
 16213              		.cfi_offset 5, -8
 16214              		.cfi_offset 14, -4
7895:Src/bno055.c  **** 	/* Variable used to return value of
7896:Src/bno055.c  **** 	communication routine*/
7897:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7898:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
7899:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
7900:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
7901:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 16215              		.loc 1 7901 0
 16216 0002 134C     		ldr	r4, .L1772
7894:Src/bno055.c  **** 	/* Variable used to return value of
 16217              		.loc 1 7894 0
 16218 0004 83B0     		sub	sp, sp, #12
 16219              	.LCFI705:
 16220              		.cfi_def_cfa_offset 24
 16221              		.loc 1 7901 0
 16222 0006 2368     		ldr	r3, [r4]
7898:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 16223              		.loc 1 7898 0
ARM GAS  /tmp/ccVWLGiI.s 			page 454


 16224 0008 0022     		movs	r2, #0
 16225 000a 8DF80720 		strb	r2, [sp, #7]
 16226              	.LVL2064:
 16227              		.loc 1 7901 0
 16228 000e E3B1     		cbz	r3, .L1765
7902:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
7903:Src/bno055.c  **** 		} else {
7904:Src/bno055.c  **** 		/*condition check for page, self test is
7905:Src/bno055.c  **** 		available in the page zero*/
7906:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 16229              		.loc 1 7906 0
 16230 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 16231 0012 0546     		mov	r5, r0
 16232 0014 71B9     		cbnz	r1, .L1771
 16233              	.LVL2065:
 16234              	.L1763:
7907:Src/bno055.c  **** 			/* Write the page zero*/
7908:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
7909:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
7910:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
7911:Src/bno055.c  **** 			/* Read the value of self test */
7912:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 16235              		.loc 1 7912 0
 16236 0016 1C69     		ldr	r4, [r3, #16]
 16237 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16238 001a 3F21     		movs	r1, #63
 16239 001c 0123     		movs	r3, #1
 16240 001e 0DF10702 		add	r2, sp, #7
 16241 0022 A047     		blx	r4
 16242              	.LVL2066:
7913:Src/bno055.c  **** 			(p_bno055->dev_addr,
7914:Src/bno055.c  **** 			BNO055_SELFTEST_REG,
7915:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7916:Src/bno055.c  **** 			*selftest_u8 =
 16243              		.loc 1 7916 0
 16244 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16245 0028 03F00103 		and	r3, r3, #1
 16246 002c 2B70     		strb	r3, [r5]
 16247              	.LVL2067:
 16248              	.L1762:
7917:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
7918:Src/bno055.c  **** 			BNO055_SELFTEST);
7919:Src/bno055.c  **** 		} else {
7920:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
7921:Src/bno055.c  **** 		}
7922:Src/bno055.c  **** 	}
7923:Src/bno055.c  **** 	return com_rslt;
7924:Src/bno055.c  **** }
 16249              		.loc 1 7924 0
 16250 002e 40B2     		sxtb	r0, r0
 16251 0030 03B0     		add	sp, sp, #12
 16252              	.LCFI706:
 16253              		.cfi_remember_state
 16254              		.cfi_def_cfa_offset 12
 16255              		@ sp needed
 16256 0032 30BD     		pop	{r4, r5, pc}
 16257              	.LVL2068:
ARM GAS  /tmp/ccVWLGiI.s 			page 455


 16258              	.L1771:
 16259              	.LCFI707:
 16260              		.cfi_restore_state
7908:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 16261              		.loc 1 7908 0
 16262 0034 1046     		mov	r0, r2
 16263              	.LVL2069:
 16264 0036 FFF7FEFF 		bl	bno055_write_page_id
 16265              	.LVL2070:
 16266 003a 2368     		ldr	r3, [r4]
7909:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16267              		.loc 1 7909 0
 16268 003c 0028     		cmp	r0, #0
 16269 003e EAD0     		beq	.L1763
 16270              	.LVL2071:
7909:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16271              		.loc 1 7909 0 is_stmt 0 discriminator 1
 16272 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
7920:Src/bno055.c  **** 		}
 16273              		.loc 1 7920 0 is_stmt 1 discriminator 1
 16274 0042 FF20     		movs	r0, #255
7909:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16275              		.loc 1 7909 0 discriminator 1
 16276 0044 002A     		cmp	r2, #0
 16277 0046 F2D1     		bne	.L1762
 16278 0048 E5E7     		b	.L1763
 16279              	.LVL2072:
 16280              	.L1765:
7902:Src/bno055.c  **** 		} else {
 16281              		.loc 1 7902 0
 16282 004a 8120     		movs	r0, #129
 16283              	.LVL2073:
 16284 004c EFE7     		b	.L1762
 16285              	.L1773:
 16286 004e 00BF     		.align	2
 16287              	.L1772:
 16288 0050 00000000 		.word	.LANCHOR0
 16289              		.cfi_endproc
 16290              	.LFE155:
 16292              		.section	.text.bno055_set_selftest,"ax",%progbits
 16293              		.align	2
 16294              		.global	bno055_set_selftest
 16295              		.thumb
 16296              		.thumb_func
 16298              	bno055_set_selftest:
 16299              	.LFB156:
7925:Src/bno055.c  **** /*!
7926:Src/bno055.c  ****  *	@brief This API used to write the self test
7927:Src/bno055.c  ****  *	from register from 0x3F bit 0
7928:Src/bno055.c  ****  *
7929:Src/bno055.c  ****  *	@param selftest_u8 : The value of self test
7930:Src/bno055.c  ****  *
7931:Src/bno055.c  ****  *	 selftest_u8  | result
7932:Src/bno055.c  ****  *   -------------- |----------
7933:Src/bno055.c  ****  *     0x01         | BNO055_BIT_ENABLE
7934:Src/bno055.c  ****  *     0x00         | BNO055_BIT_DISABLE
7935:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 456


7936:Src/bno055.c  ****  *	@return results of bus communication function
7937:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
7938:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
7939:Src/bno055.c  ****  *
7940:Src/bno055.c  ****  *	@note It triggers the self test
7941:Src/bno055.c  ****  *
7942:Src/bno055.c  ****  *
7943:Src/bno055.c  ****  */
7944:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_selftest(u8 selftest_u8)
7945:Src/bno055.c  **** {
 16300              		.loc 1 7945 0
 16301              		.cfi_startproc
 16302              		@ args = 0, pretend = 0, frame = 8
 16303              		@ frame_needed = 0, uses_anonymous_args = 0
 16304              	.LVL2074:
 16305 0000 30B5     		push	{r4, r5, lr}
 16306              	.LCFI708:
 16307              		.cfi_def_cfa_offset 12
 16308              		.cfi_offset 4, -12
 16309              		.cfi_offset 5, -8
 16310              		.cfi_offset 14, -4
7946:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
7947:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
7948:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
7949:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
7950:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
7951:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 16311              		.loc 1 7951 0
 16312 0002 244C     		ldr	r4, .L1790
7945:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 16313              		.loc 1 7945 0
 16314 0004 83B0     		sub	sp, sp, #12
 16315              	.LCFI709:
 16316              		.cfi_def_cfa_offset 24
 16317              		.loc 1 7951 0
 16318 0006 2268     		ldr	r2, [r4]
7947:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 16319              		.loc 1 7947 0
 16320 0008 0023     		movs	r3, #0
 16321 000a 8DF80630 		strb	r3, [sp, #6]
7948:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 16322              		.loc 1 7948 0
 16323 000e 8DF80730 		strb	r3, [sp, #7]
 16324              	.LVL2075:
 16325              		.loc 1 7951 0
 16326 0012 002A     		cmp	r2, #0
 16327 0014 3BD0     		beq	.L1782
 16328 0016 0546     		mov	r5, r0
7952:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
7953:Src/bno055.c  **** 	} else {
7954:Src/bno055.c  **** 		/* The write operation effective only if the operation
7955:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
7956:Src/bno055.c  **** 		current operation mode and set the config mode */
7957:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 16329              		.loc 1 7957 0
 16330 0018 0DF10700 		add	r0, sp, #7
 16331              	.LVL2076:
ARM GAS  /tmp/ccVWLGiI.s 			page 457


 16332 001c FFF7FEFF 		bl	bno055_get_operation_mode
 16333              	.LVL2077:
7958:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 16334              		.loc 1 7958 0
 16335 0020 38B1     		cbz	r0, .L1776
 16336              	.L1781:
7959:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
7960:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
7961:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
7962:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
7963:Src/bno055.c  **** 				/* Write the value of self test */
7964:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
7965:Src/bno055.c  **** 				(p_bno055->dev_addr,
7966:Src/bno055.c  **** 				BNO055_SELFTEST_REG,
7967:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
7968:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
7969:Src/bno055.c  **** 					data_u8r =
7970:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
7971:Src/bno055.c  **** 					BNO055_SELFTEST,
7972:Src/bno055.c  **** 					selftest_u8);
7973:Src/bno055.c  **** 					com_rslt +=
7974:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
7975:Src/bno055.c  **** 					(p_bno055->dev_addr,
7976:Src/bno055.c  **** 					BNO055_SELFTEST_REG,
7977:Src/bno055.c  **** 					&data_u8r,
7978:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
7979:Src/bno055.c  **** 				}
7980:Src/bno055.c  **** 			} else {
7981:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
7982:Src/bno055.c  **** 			}
7983:Src/bno055.c  **** 		} else {
7984:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 16337              		.loc 1 7984 0
 16338 0022 FF24     		movs	r4, #255
 16339              	.LVL2078:
 16340              	.L1777:
7985:Src/bno055.c  **** 		}
7986:Src/bno055.c  **** 	}
7987:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 16341              		.loc 1 7987 0
 16342 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 16343 0028 28BB     		cbnz	r0, .L1789
 16344 002a 2046     		mov	r0, r4
 16345              	.LVL2079:
 16346              	.L1775:
7988:Src/bno055.c  **** 		/* set the operation mode
7989:Src/bno055.c  **** 		of previous operation mode*/
7990:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
7991:Src/bno055.c  **** 		(prev_opmode_u8);
7992:Src/bno055.c  **** 	return com_rslt;
7993:Src/bno055.c  **** }
 16347              		.loc 1 7993 0
 16348 002c 40B2     		sxtb	r0, r0
 16349 002e 03B0     		add	sp, sp, #12
 16350              	.LCFI710:
 16351              		.cfi_remember_state
 16352              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 458


 16353              		@ sp needed
 16354 0030 30BD     		pop	{r4, r5, pc}
 16355              	.LVL2080:
 16356              	.L1776:
 16357              	.LCFI711:
 16358              		.cfi_restore_state
7959:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 16359              		.loc 1 7959 0
 16360 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16361 0036 2BBB     		cbnz	r3, .L1778
 16362              	.L1780:
 16363              	.LVL2081:
7964:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16364              		.loc 1 7964 0
 16365 0038 2368     		ldr	r3, [r4]
 16366 003a 0DF10602 		add	r2, sp, #6
 16367 003e 1C69     		ldr	r4, [r3, #16]
 16368 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16369 0042 3F21     		movs	r1, #63
 16370 0044 0123     		movs	r3, #1
 16371 0046 A047     		blx	r4
 16372              	.LVL2082:
 16373 0048 124B     		ldr	r3, .L1790
7968:Src/bno055.c  **** 					data_u8r =
 16374              		.loc 1 7968 0
 16375 004a 0446     		mov	r4, r0
 16376 004c 0028     		cmp	r0, #0
 16377 004e E9D1     		bne	.L1777
7969:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 16378              		.loc 1 7969 0
 16379 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
7974:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16380              		.loc 1 7974 0
 16381 0054 1B68     		ldr	r3, [r3]
7969:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 16382              		.loc 1 7969 0
 16383 0056 05F00100 		and	r0, r5, #1
 16384              	.LVL2083:
 16385 005a 22F00105 		bic	r5, r2, #1
 16386 005e 2843     		orrs	r0, r0, r5
7974:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16387              		.loc 1 7974 0
 16388 0060 DC68     		ldr	r4, [r3, #12]
7969:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 16389              		.loc 1 7969 0
 16390 0062 8DF80600 		strb	r0, [sp, #6]
7974:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16391              		.loc 1 7974 0
 16392 0066 0DF10602 		add	r2, sp, #6
 16393 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16394 006c 3F21     		movs	r1, #63
 16395 006e 0123     		movs	r3, #1
 16396 0070 A047     		blx	r4
 16397              	.LVL2084:
 16398 0072 0446     		mov	r4, r0
 16399              	.LVL2085:
 16400 0074 D6E7     		b	.L1777
ARM GAS  /tmp/ccVWLGiI.s 			page 459


 16401              	.L1789:
7990:Src/bno055.c  **** 		(prev_opmode_u8);
 16402              		.loc 1 7990 0
 16403 0076 FFF7FEFF 		bl	bno055_set_operation_mode
 16404              	.LVL2086:
 16405 007a 2044     		add	r0, r0, r4
 16406 007c C0B2     		uxtb	r0, r0
 16407              	.LVL2087:
 16408              		.loc 1 7993 0
 16409 007e 40B2     		sxtb	r0, r0
 16410 0080 03B0     		add	sp, sp, #12
 16411              	.LCFI712:
 16412              		.cfi_remember_state
 16413              		.cfi_def_cfa_offset 12
 16414              		@ sp needed
 16415 0082 30BD     		pop	{r4, r5, pc}
 16416              	.LVL2088:
 16417              	.L1778:
 16418              	.LCFI713:
 16419              		.cfi_restore_state
7960:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 16420              		.loc 1 7960 0
 16421 0084 FFF7FEFF 		bl	bno055_set_operation_mode
 16422              	.LVL2089:
7962:Src/bno055.c  **** 				/* Write the value of self test */
 16423              		.loc 1 7962 0
 16424 0088 0028     		cmp	r0, #0
 16425 008a CAD1     		bne	.L1781
 16426 008c D4E7     		b	.L1780
 16427              	.LVL2090:
 16428              	.L1782:
7952:Src/bno055.c  **** 	} else {
 16429              		.loc 1 7952 0
 16430 008e 8120     		movs	r0, #129
 16431              	.LVL2091:
 16432 0090 CCE7     		b	.L1775
 16433              	.L1791:
 16434 0092 00BF     		.align	2
 16435              	.L1790:
 16436 0094 00000000 		.word	.LANCHOR0
 16437              		.cfi_endproc
 16438              	.LFE156:
 16440              		.section	.text.bno055_get_temp_source,"ax",%progbits
 16441              		.align	2
 16442              		.global	bno055_get_temp_source
 16443              		.thumb
 16444              		.thumb_func
 16446              	bno055_get_temp_source:
 16447              	.LFB157:
7994:Src/bno055.c  **** /*!
7995:Src/bno055.c  ****  *	@brief This API used to read the temperature source
7996:Src/bno055.c  ****  *	from register from 0x40 bit 0 and 1
7997:Src/bno055.c  ****  *
7998:Src/bno055.c  ****  *	@param temp_source_u8 : The value of selected temperature source
7999:Src/bno055.c  ****  *
8000:Src/bno055.c  ****  *     temp_source_u8 | result
8001:Src/bno055.c  ****  *    ----------------  |---------------
ARM GAS  /tmp/ccVWLGiI.s 			page 460


8002:Src/bno055.c  ****  *      0x00            | BNO055_ACCEL_TEMP_EN
8003:Src/bno055.c  ****  *      0X01            | BNO055_GYRO_TEMP_EN
8004:Src/bno055.c  ****  *      0X03            | BNO055_MCU_TEMP_EN
8005:Src/bno055.c  ****  *
8006:Src/bno055.c  ****  *	@return results of bus communication function
8007:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8008:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8009:Src/bno055.c  ****  *
8010:Src/bno055.c  ****  */
8011:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_temp_source(
8012:Src/bno055.c  **** u8 *temp_source_u8)
8013:Src/bno055.c  **** {
 16448              		.loc 1 8013 0
 16449              		.cfi_startproc
 16450              		@ args = 0, pretend = 0, frame = 8
 16451              		@ frame_needed = 0, uses_anonymous_args = 0
 16452              	.LVL2092:
 16453 0000 30B5     		push	{r4, r5, lr}
 16454              	.LCFI714:
 16455              		.cfi_def_cfa_offset 12
 16456              		.cfi_offset 4, -12
 16457              		.cfi_offset 5, -8
 16458              		.cfi_offset 14, -4
8014:Src/bno055.c  **** 	/* Variable used to return value of
8015:Src/bno055.c  **** 	communication routine*/
8016:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8017:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
8018:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
8019:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
8020:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 16459              		.loc 1 8020 0
 16460 0002 134C     		ldr	r4, .L1803
8013:Src/bno055.c  **** 	/* Variable used to return value of
 16461              		.loc 1 8013 0
 16462 0004 83B0     		sub	sp, sp, #12
 16463              	.LCFI715:
 16464              		.cfi_def_cfa_offset 24
 16465              		.loc 1 8020 0
 16466 0006 2368     		ldr	r3, [r4]
8017:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 16467              		.loc 1 8017 0
 16468 0008 0022     		movs	r2, #0
 16469 000a 8DF80720 		strb	r2, [sp, #7]
 16470              	.LVL2093:
 16471              		.loc 1 8020 0
 16472 000e E3B1     		cbz	r3, .L1796
8021:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
8022:Src/bno055.c  **** 		} else {
8023:Src/bno055.c  **** 		/*condition check for page, temperature source is
8024:Src/bno055.c  **** 		available in the page zero*/
8025:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 16473              		.loc 1 8025 0
 16474 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 16475 0012 0546     		mov	r5, r0
 16476 0014 71B9     		cbnz	r1, .L1802
 16477              	.LVL2094:
 16478              	.L1794:
ARM GAS  /tmp/ccVWLGiI.s 			page 461


8026:Src/bno055.c  **** 			/* Write the page zero*/
8027:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
8028:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
8029:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
8030:Src/bno055.c  **** 			/* Read the value of temperature source */
8031:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 16479              		.loc 1 8031 0
 16480 0016 1C69     		ldr	r4, [r3, #16]
 16481 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16482 001a 4021     		movs	r1, #64
 16483 001c 0123     		movs	r3, #1
 16484 001e 0DF10702 		add	r2, sp, #7
 16485 0022 A047     		blx	r4
 16486              	.LVL2095:
8032:Src/bno055.c  **** 			(p_bno055->dev_addr,
8033:Src/bno055.c  **** 			BNO055_TEMP_SOURCE_REG,
8034:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8035:Src/bno055.c  **** 			*temp_source_u8 =
 16487              		.loc 1 8035 0
 16488 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16489 0028 03F00303 		and	r3, r3, #3
 16490 002c 2B70     		strb	r3, [r5]
 16491              	.LVL2096:
 16492              	.L1793:
8036:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
8037:Src/bno055.c  **** 			BNO055_TEMP_SOURCE);
8038:Src/bno055.c  **** 		} else {
8039:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
8040:Src/bno055.c  **** 		}
8041:Src/bno055.c  **** 	}
8042:Src/bno055.c  **** 	return com_rslt;
8043:Src/bno055.c  **** }
 16493              		.loc 1 8043 0
 16494 002e 40B2     		sxtb	r0, r0
 16495 0030 03B0     		add	sp, sp, #12
 16496              	.LCFI716:
 16497              		.cfi_remember_state
 16498              		.cfi_def_cfa_offset 12
 16499              		@ sp needed
 16500 0032 30BD     		pop	{r4, r5, pc}
 16501              	.LVL2097:
 16502              	.L1802:
 16503              	.LCFI717:
 16504              		.cfi_restore_state
8027:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 16505              		.loc 1 8027 0
 16506 0034 1046     		mov	r0, r2
 16507              	.LVL2098:
 16508 0036 FFF7FEFF 		bl	bno055_write_page_id
 16509              	.LVL2099:
 16510 003a 2368     		ldr	r3, [r4]
8028:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16511              		.loc 1 8028 0
 16512 003c 0028     		cmp	r0, #0
 16513 003e EAD0     		beq	.L1794
 16514              	.LVL2100:
8028:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 462


 16515              		.loc 1 8028 0 is_stmt 0 discriminator 1
 16516 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
8039:Src/bno055.c  **** 		}
 16517              		.loc 1 8039 0 is_stmt 1 discriminator 1
 16518 0042 FF20     		movs	r0, #255
8028:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16519              		.loc 1 8028 0 discriminator 1
 16520 0044 002A     		cmp	r2, #0
 16521 0046 F2D1     		bne	.L1793
 16522 0048 E5E7     		b	.L1794
 16523              	.LVL2101:
 16524              	.L1796:
8021:Src/bno055.c  **** 		} else {
 16525              		.loc 1 8021 0
 16526 004a 8120     		movs	r0, #129
 16527              	.LVL2102:
 16528 004c EFE7     		b	.L1793
 16529              	.L1804:
 16530 004e 00BF     		.align	2
 16531              	.L1803:
 16532 0050 00000000 		.word	.LANCHOR0
 16533              		.cfi_endproc
 16534              	.LFE157:
 16536              		.section	.text.bno055_set_temp_source,"ax",%progbits
 16537              		.align	2
 16538              		.global	bno055_set_temp_source
 16539              		.thumb
 16540              		.thumb_func
 16542              	bno055_set_temp_source:
 16543              	.LFB158:
8044:Src/bno055.c  **** /*!
8045:Src/bno055.c  ****  *	@brief This API used to write the temperature source
8046:Src/bno055.c  ****  *	from register from 0x40 bit 0 and 1
8047:Src/bno055.c  ****  *
8048:Src/bno055.c  ****  *	@param temp_source_u8 : The value of selected temperature source
8049:Src/bno055.c  ****  *
8050:Src/bno055.c  ****  *     temp_source_u8 | result
8051:Src/bno055.c  ****  *    ----------------  |---------------
8052:Src/bno055.c  ****  *      0x00            | BNO055_ACCEL_TEMP_EN
8053:Src/bno055.c  ****  *      0X01            | BNO055_GYRO_TEMP_EN
8054:Src/bno055.c  ****  *      0X03            | BNO055_MCU_TEMP_EN
8055:Src/bno055.c  ****  *
8056:Src/bno055.c  ****  *	@return results of bus communication function
8057:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8058:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8059:Src/bno055.c  ****  *
8060:Src/bno055.c  ****  */
8061:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_temp_source(u8 temp_source_u8)
8062:Src/bno055.c  **** {
 16544              		.loc 1 8062 0
 16545              		.cfi_startproc
 16546              		@ args = 0, pretend = 0, frame = 8
 16547              		@ frame_needed = 0, uses_anonymous_args = 0
 16548              	.LVL2103:
 16549 0000 30B5     		push	{r4, r5, lr}
 16550              	.LCFI718:
 16551              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 463


 16552              		.cfi_offset 4, -12
 16553              		.cfi_offset 5, -8
 16554              		.cfi_offset 14, -4
8063:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8064:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
8065:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
8066:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
8067:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
8068:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 16555              		.loc 1 8068 0
 16556 0002 244C     		ldr	r4, .L1821
8062:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 16557              		.loc 1 8062 0
 16558 0004 83B0     		sub	sp, sp, #12
 16559              	.LCFI719:
 16560              		.cfi_def_cfa_offset 24
 16561              		.loc 1 8068 0
 16562 0006 2268     		ldr	r2, [r4]
8064:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 16563              		.loc 1 8064 0
 16564 0008 0023     		movs	r3, #0
 16565 000a 8DF80630 		strb	r3, [sp, #6]
8065:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 16566              		.loc 1 8065 0
 16567 000e 8DF80730 		strb	r3, [sp, #7]
 16568              	.LVL2104:
 16569              		.loc 1 8068 0
 16570 0012 002A     		cmp	r2, #0
 16571 0014 3BD0     		beq	.L1813
 16572 0016 0546     		mov	r5, r0
8069:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
8070:Src/bno055.c  **** 	} else {
8071:Src/bno055.c  **** 		/* The write operation effective only if the operation
8072:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
8073:Src/bno055.c  **** 		current operation mode and set the config mode */
8074:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 16573              		.loc 1 8074 0
 16574 0018 0DF10700 		add	r0, sp, #7
 16575              	.LVL2105:
 16576 001c FFF7FEFF 		bl	bno055_get_operation_mode
 16577              	.LVL2106:
8075:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 16578              		.loc 1 8075 0
 16579 0020 38B1     		cbz	r0, .L1807
 16580              	.L1812:
8076:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
8077:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
8078:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
8079:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
8080:Src/bno055.c  **** 				/* Write the value of temperature source*/
8081:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
8082:Src/bno055.c  **** 				(p_bno055->dev_addr,
8083:Src/bno055.c  **** 				BNO055_TEMP_SOURCE_REG,
8084:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8085:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
8086:Src/bno055.c  **** 					data_u8r =
8087:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 464


8088:Src/bno055.c  **** 					BNO055_TEMP_SOURCE, temp_source_u8);
8089:Src/bno055.c  **** 					com_rslt +=
8090:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
8091:Src/bno055.c  **** 					(p_bno055->dev_addr,
8092:Src/bno055.c  **** 					BNO055_TEMP_SOURCE_REG,
8093:Src/bno055.c  **** 					&data_u8r,
8094:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8095:Src/bno055.c  **** 				}
8096:Src/bno055.c  **** 			} else {
8097:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
8098:Src/bno055.c  **** 			}
8099:Src/bno055.c  **** 		} else {
8100:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 16581              		.loc 1 8100 0
 16582 0022 FF24     		movs	r4, #255
 16583              	.LVL2107:
 16584              	.L1808:
8101:Src/bno055.c  **** 		}
8102:Src/bno055.c  **** 	}
8103:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 16585              		.loc 1 8103 0
 16586 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 16587 0028 28BB     		cbnz	r0, .L1820
 16588 002a 2046     		mov	r0, r4
 16589              	.LVL2108:
 16590              	.L1806:
8104:Src/bno055.c  **** 		/* set the operation mode
8105:Src/bno055.c  **** 		of previous operation mode*/
8106:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
8107:Src/bno055.c  **** 		(prev_opmode_u8);
8108:Src/bno055.c  **** 	return com_rslt;
8109:Src/bno055.c  **** }
 16591              		.loc 1 8109 0
 16592 002c 40B2     		sxtb	r0, r0
 16593 002e 03B0     		add	sp, sp, #12
 16594              	.LCFI720:
 16595              		.cfi_remember_state
 16596              		.cfi_def_cfa_offset 12
 16597              		@ sp needed
 16598 0030 30BD     		pop	{r4, r5, pc}
 16599              	.LVL2109:
 16600              	.L1807:
 16601              	.LCFI721:
 16602              		.cfi_restore_state
8076:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 16603              		.loc 1 8076 0
 16604 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16605 0036 2BBB     		cbnz	r3, .L1809
 16606              	.L1811:
 16607              	.LVL2110:
8081:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16608              		.loc 1 8081 0
 16609 0038 2368     		ldr	r3, [r4]
 16610 003a 0DF10602 		add	r2, sp, #6
 16611 003e 1C69     		ldr	r4, [r3, #16]
 16612 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16613 0042 4021     		movs	r1, #64
ARM GAS  /tmp/ccVWLGiI.s 			page 465


 16614 0044 0123     		movs	r3, #1
 16615 0046 A047     		blx	r4
 16616              	.LVL2111:
 16617 0048 124B     		ldr	r3, .L1821
8085:Src/bno055.c  **** 					data_u8r =
 16618              		.loc 1 8085 0
 16619 004a 0446     		mov	r4, r0
 16620 004c 0028     		cmp	r0, #0
 16621 004e E9D1     		bne	.L1808
8086:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 16622              		.loc 1 8086 0
 16623 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
8090:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16624              		.loc 1 8090 0
 16625 0054 1B68     		ldr	r3, [r3]
8086:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 16626              		.loc 1 8086 0
 16627 0056 05F00300 		and	r0, r5, #3
 16628              	.LVL2112:
 16629 005a 22F00305 		bic	r5, r2, #3
 16630 005e 2843     		orrs	r0, r0, r5
8090:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16631              		.loc 1 8090 0
 16632 0060 DC68     		ldr	r4, [r3, #12]
8086:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 16633              		.loc 1 8086 0
 16634 0062 8DF80600 		strb	r0, [sp, #6]
8090:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16635              		.loc 1 8090 0
 16636 0066 0DF10602 		add	r2, sp, #6
 16637 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16638 006c 4021     		movs	r1, #64
 16639 006e 0123     		movs	r3, #1
 16640 0070 A047     		blx	r4
 16641              	.LVL2113:
 16642 0072 0446     		mov	r4, r0
 16643              	.LVL2114:
 16644 0074 D6E7     		b	.L1808
 16645              	.L1820:
8106:Src/bno055.c  **** 		(prev_opmode_u8);
 16646              		.loc 1 8106 0
 16647 0076 FFF7FEFF 		bl	bno055_set_operation_mode
 16648              	.LVL2115:
 16649 007a 2044     		add	r0, r0, r4
 16650 007c C0B2     		uxtb	r0, r0
 16651              	.LVL2116:
 16652              		.loc 1 8109 0
 16653 007e 40B2     		sxtb	r0, r0
 16654 0080 03B0     		add	sp, sp, #12
 16655              	.LCFI722:
 16656              		.cfi_remember_state
 16657              		.cfi_def_cfa_offset 12
 16658              		@ sp needed
 16659 0082 30BD     		pop	{r4, r5, pc}
 16660              	.LVL2117:
 16661              	.L1809:
 16662              	.LCFI723:
ARM GAS  /tmp/ccVWLGiI.s 			page 466


 16663              		.cfi_restore_state
8077:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 16664              		.loc 1 8077 0
 16665 0084 FFF7FEFF 		bl	bno055_set_operation_mode
 16666              	.LVL2118:
8079:Src/bno055.c  **** 				/* Write the value of temperature source*/
 16667              		.loc 1 8079 0
 16668 0088 0028     		cmp	r0, #0
 16669 008a CAD1     		bne	.L1812
 16670 008c D4E7     		b	.L1811
 16671              	.LVL2119:
 16672              	.L1813:
8069:Src/bno055.c  **** 	} else {
 16673              		.loc 1 8069 0
 16674 008e 8120     		movs	r0, #129
 16675              	.LVL2120:
 16676 0090 CCE7     		b	.L1806
 16677              	.L1822:
 16678 0092 00BF     		.align	2
 16679              	.L1821:
 16680 0094 00000000 		.word	.LANCHOR0
 16681              		.cfi_endproc
 16682              	.LFE158:
 16684              		.section	.text.bno055_get_axis_remap_value,"ax",%progbits
 16685              		.align	2
 16686              		.global	bno055_get_axis_remap_value
 16687              		.thumb
 16688              		.thumb_func
 16690              	bno055_get_axis_remap_value:
 16691              	.LFB159:
8110:Src/bno055.c  **** /*!
8111:Src/bno055.c  ****  *	@brief This API used to read the axis remap value
8112:Src/bno055.c  ****  *	from register from 0x41 bit 0 and 5
8113:Src/bno055.c  ****  *
8114:Src/bno055.c  ****  *	@param remap_axis_u8 : The value of axis remapping
8115:Src/bno055.c  ****  *
8116:Src/bno055.c  ****  *    remap_axis_u8 |   result     | comments
8117:Src/bno055.c  ****  *   ------------|-------------------|------------
8118:Src/bno055.c  ****  *      0X21     | BNO055_REMAP_X_Y         | Z=Z;X=Y;Y=X
8119:Src/bno055.c  ****  *      0X18     | BNO055_REMAP_Y_Z         | X=X;Y=Z;Z=Y
8120:Src/bno055.c  ****  *      0X06     | BNO055_REMAP_Z_X         | Y=Y;X=Z;Z=X
8121:Src/bno055.c  ****  *      0X12     | BNO055_REMAP_X_Y_Z_TYPE0 | X=Z;Y=X;Z=Y
8122:Src/bno055.c  ****  *      0X09     | BNO055_REMAP_X_Y_Z_TYPE1 | X=Y;Y=Z;Z=X
8123:Src/bno055.c  ****  *      0X24     | BNO055_DEFAULT_AXIS      | X=X;Y=Y;Z=Z
8124:Src/bno055.c  ****  *
8125:Src/bno055.c  ****  *	@return results of bus communication function
8126:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8127:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8128:Src/bno055.c  ****  *
8129:Src/bno055.c  ****  *	@note : For axis sign remap refer the following APIs
8130:Src/bno055.c  ****  *	x-axis :
8131:Src/bno055.c  ****  *
8132:Src/bno055.c  ****  *	bno055_set_x_remap_sign()
8133:Src/bno055.c  ****  *
8134:Src/bno055.c  ****  *	y-axis :
8135:Src/bno055.c  ****  *
8136:Src/bno055.c  ****  *	bno055_set_y_remap_sign()
ARM GAS  /tmp/ccVWLGiI.s 			page 467


8137:Src/bno055.c  ****  *
8138:Src/bno055.c  ****  *	z-axis :
8139:Src/bno055.c  ****  *
8140:Src/bno055.c  ****  *	bno055_set_z_remap_sign()
8141:Src/bno055.c  ****  *
8142:Src/bno055.c  ****  */
8143:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_axis_remap_value(
8144:Src/bno055.c  **** u8 *remap_axis_u8)
8145:Src/bno055.c  **** {
 16692              		.loc 1 8145 0
 16693              		.cfi_startproc
 16694              		@ args = 0, pretend = 0, frame = 8
 16695              		@ frame_needed = 0, uses_anonymous_args = 0
 16696              	.LVL2121:
 16697 0000 30B5     		push	{r4, r5, lr}
 16698              	.LCFI724:
 16699              		.cfi_def_cfa_offset 12
 16700              		.cfi_offset 4, -12
 16701              		.cfi_offset 5, -8
 16702              		.cfi_offset 14, -4
8146:Src/bno055.c  **** 	/* Variable used to return value of
8147:Src/bno055.c  **** 	communication routine*/
8148:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8149:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
8150:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
8151:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
8152:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 16703              		.loc 1 8152 0
 16704 0002 134C     		ldr	r4, .L1834
8145:Src/bno055.c  **** 	/* Variable used to return value of
 16705              		.loc 1 8145 0
 16706 0004 83B0     		sub	sp, sp, #12
 16707              	.LCFI725:
 16708              		.cfi_def_cfa_offset 24
 16709              		.loc 1 8152 0
 16710 0006 2368     		ldr	r3, [r4]
8149:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 16711              		.loc 1 8149 0
 16712 0008 0022     		movs	r2, #0
 16713 000a 8DF80720 		strb	r2, [sp, #7]
 16714              	.LVL2122:
 16715              		.loc 1 8152 0
 16716 000e E3B1     		cbz	r3, .L1827
8153:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
8154:Src/bno055.c  **** 		} else {
8155:Src/bno055.c  **** 		/*condition check for page, axis remap is
8156:Src/bno055.c  **** 		available in the page zero*/
8157:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 16717              		.loc 1 8157 0
 16718 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 16719 0012 0546     		mov	r5, r0
 16720 0014 71B9     		cbnz	r1, .L1833
 16721              	.LVL2123:
 16722              	.L1825:
8158:Src/bno055.c  **** 			/* Write the page zero*/
8159:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
8160:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
ARM GAS  /tmp/ccVWLGiI.s 			page 468


8161:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
8162:Src/bno055.c  **** 			/* Read the value of axis remap*/
8163:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 16723              		.loc 1 8163 0
 16724 0016 1C69     		ldr	r4, [r3, #16]
 16725 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16726 001a 4121     		movs	r1, #65
 16727 001c 0123     		movs	r3, #1
 16728 001e 0DF10702 		add	r2, sp, #7
 16729 0022 A047     		blx	r4
 16730              	.LVL2124:
8164:Src/bno055.c  **** 			(p_bno055->dev_addr,
8165:Src/bno055.c  **** 			BNO055_REMAP_AXIS_VALUE_REG,
8166:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8167:Src/bno055.c  **** 			*remap_axis_u8 =
 16731              		.loc 1 8167 0
 16732 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16733 0028 03F03F03 		and	r3, r3, #63
 16734 002c 2B70     		strb	r3, [r5]
 16735              	.LVL2125:
 16736              	.L1824:
8168:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
8169:Src/bno055.c  **** 			BNO055_REMAP_AXIS_VALUE);
8170:Src/bno055.c  **** 		} else {
8171:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
8172:Src/bno055.c  **** 		}
8173:Src/bno055.c  **** 	}
8174:Src/bno055.c  **** 	return com_rslt;
8175:Src/bno055.c  **** }
 16737              		.loc 1 8175 0
 16738 002e 40B2     		sxtb	r0, r0
 16739 0030 03B0     		add	sp, sp, #12
 16740              	.LCFI726:
 16741              		.cfi_remember_state
 16742              		.cfi_def_cfa_offset 12
 16743              		@ sp needed
 16744 0032 30BD     		pop	{r4, r5, pc}
 16745              	.LVL2126:
 16746              	.L1833:
 16747              	.LCFI727:
 16748              		.cfi_restore_state
8159:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 16749              		.loc 1 8159 0
 16750 0034 1046     		mov	r0, r2
 16751              	.LVL2127:
 16752 0036 FFF7FEFF 		bl	bno055_write_page_id
 16753              	.LVL2128:
 16754 003a 2368     		ldr	r3, [r4]
8160:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16755              		.loc 1 8160 0
 16756 003c 0028     		cmp	r0, #0
 16757 003e EAD0     		beq	.L1825
 16758              	.LVL2129:
8160:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16759              		.loc 1 8160 0 is_stmt 0 discriminator 1
 16760 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
8171:Src/bno055.c  **** 		}
ARM GAS  /tmp/ccVWLGiI.s 			page 469


 16761              		.loc 1 8171 0 is_stmt 1 discriminator 1
 16762 0042 FF20     		movs	r0, #255
8160:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 16763              		.loc 1 8160 0 discriminator 1
 16764 0044 002A     		cmp	r2, #0
 16765 0046 F2D1     		bne	.L1824
 16766 0048 E5E7     		b	.L1825
 16767              	.LVL2130:
 16768              	.L1827:
8153:Src/bno055.c  **** 		} else {
 16769              		.loc 1 8153 0
 16770 004a 8120     		movs	r0, #129
 16771              	.LVL2131:
 16772 004c EFE7     		b	.L1824
 16773              	.L1835:
 16774 004e 00BF     		.align	2
 16775              	.L1834:
 16776 0050 00000000 		.word	.LANCHOR0
 16777              		.cfi_endproc
 16778              	.LFE159:
 16780              		.section	.text.bno055_set_axis_remap_value,"ax",%progbits
 16781              		.align	2
 16782              		.global	bno055_set_axis_remap_value
 16783              		.thumb
 16784              		.thumb_func
 16786              	bno055_set_axis_remap_value:
 16787              	.LFB160:
8176:Src/bno055.c  **** /*!
8177:Src/bno055.c  ****  *	@brief This API used to write the axis remap value
8178:Src/bno055.c  ****  *	from register from 0x41 bit 0 and 5
8179:Src/bno055.c  ****  *
8180:Src/bno055.c  ****  *	@param remap_axis_u8 : The value of axis remapping
8181:Src/bno055.c  ****  *
8182:Src/bno055.c  ****  *    remap_axis_u8 |   result     | comments
8183:Src/bno055.c  ****  *   ------------|-------------------|------------
8184:Src/bno055.c  ****  *      0X21     | BNO055_REMAP_X_Y         | Z=Z;X=Y;Y=X
8185:Src/bno055.c  ****  *      0X18     | BNO055_REMAP_Y_Z         | X=X;Y=Z;Z=Y
8186:Src/bno055.c  ****  *      0X06     | BNO055_REMAP_Z_X         | Y=Y;X=Z;Z=X
8187:Src/bno055.c  ****  *      0X12     | BNO055_REMAP_X_Y_Z_TYPE0 | X=Z;Y=X;Z=Y
8188:Src/bno055.c  ****  *      0X09     | BNO055_REMAP_X_Y_Z_TYPE1 | X=Y;Y=Z;Z=X
8189:Src/bno055.c  ****  *      0X24     | BNO055_DEFAULT_AXIS      | X=X;Y=Y;Z=Z
8190:Src/bno055.c  ****  *
8191:Src/bno055.c  ****  *	@return results of bus communication function
8192:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8193:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8194:Src/bno055.c  ****  *
8195:Src/bno055.c  ****  *	@note : For axis sign remap refer the following APIs
8196:Src/bno055.c  ****  *	x-axis :
8197:Src/bno055.c  ****  *
8198:Src/bno055.c  ****  *	bno055_set_x_remap_sign()
8199:Src/bno055.c  ****  *
8200:Src/bno055.c  ****  *	y-axis :
8201:Src/bno055.c  ****  *
8202:Src/bno055.c  ****  *	bno055_set_y_remap_sign()
8203:Src/bno055.c  ****  *
8204:Src/bno055.c  ****  *	z-axis :
8205:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 470


8206:Src/bno055.c  ****  *	bno055_set_z_remap_sign()
8207:Src/bno055.c  ****  *
8208:Src/bno055.c  ****  */
8209:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_axis_remap_value(
8210:Src/bno055.c  **** u8 remap_axis_u8)
8211:Src/bno055.c  **** {
 16788              		.loc 1 8211 0
 16789              		.cfi_startproc
 16790              		@ args = 0, pretend = 0, frame = 8
 16791              		@ frame_needed = 0, uses_anonymous_args = 0
 16792              	.LVL2132:
 16793 0000 70B5     		push	{r4, r5, r6, lr}
 16794              	.LCFI728:
 16795              		.cfi_def_cfa_offset 16
 16796              		.cfi_offset 4, -16
 16797              		.cfi_offset 5, -12
 16798              		.cfi_offset 6, -8
 16799              		.cfi_offset 14, -4
8212:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8213:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
8214:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
8215:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
8216:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
8217:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 16800              		.loc 1 8217 0
 16801 0002 374C     		ldr	r4, .L1858
8211:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 16802              		.loc 1 8211 0
 16803 0004 82B0     		sub	sp, sp, #8
 16804              	.LCFI729:
 16805              		.cfi_def_cfa_offset 24
 16806              		.loc 1 8217 0
 16807 0006 2268     		ldr	r2, [r4]
8213:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 16808              		.loc 1 8213 0
 16809 0008 0023     		movs	r3, #0
 16810 000a 8DF80630 		strb	r3, [sp, #6]
8214:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 16811              		.loc 1 8214 0
 16812 000e 8DF80730 		strb	r3, [sp, #7]
 16813              	.LVL2133:
 16814              		.loc 1 8217 0
 16815 0012 002A     		cmp	r2, #0
 16816 0014 61D0     		beq	.L1845
 16817 0016 0546     		mov	r5, r0
8218:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
8219:Src/bno055.c  **** 	} else {
8220:Src/bno055.c  **** 	/* The write operation effective only if the operation
8221:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
8222:Src/bno055.c  **** 	current operation mode and set the config mode */
8223:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 16818              		.loc 1 8223 0
 16819 0018 0DF10700 		add	r0, sp, #7
 16820              	.LVL2134:
 16821 001c FFF7FEFF 		bl	bno055_get_operation_mode
 16822              	.LVL2135:
8224:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 471


 16823              		.loc 1 8224 0
 16824 0020 38B1     		cbz	r0, .L1838
 16825              	.L1844:
8225:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
8226:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
8227:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
8228:Src/bno055.c  **** 			/* Write the value of axis remap */
8229:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
8230:Src/bno055.c  **** 			switch (remap_axis_u8) {
8231:Src/bno055.c  **** 			case BNO055_REMAP_X_Y:
8232:Src/bno055.c  **** 			case BNO055_REMAP_Y_Z:
8233:Src/bno055.c  **** 			case BNO055_REMAP_Z_X:
8234:Src/bno055.c  **** 			case BNO055_REMAP_X_Y_Z_TYPE0:
8235:Src/bno055.c  **** 			case BNO055_REMAP_X_Y_Z_TYPE1:
8236:Src/bno055.c  **** 			case BNO055_DEFAULT_AXIS:
8237:Src/bno055.c  **** 				com_rslt =
8238:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
8239:Src/bno055.c  **** 				(p_bno055->dev_addr,
8240:Src/bno055.c  **** 				BNO055_REMAP_AXIS_VALUE_REG,
8241:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8242:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
8243:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
8244:Src/bno055.c  **** 					(data_u8r,
8245:Src/bno055.c  **** 					BNO055_REMAP_AXIS_VALUE,
8246:Src/bno055.c  **** 					remap_axis_u8);
8247:Src/bno055.c  **** 					com_rslt +=
8248:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
8249:Src/bno055.c  **** 					(p_bno055->dev_addr,
8250:Src/bno055.c  **** 					BNO055_REMAP_AXIS_VALUE_REG,
8251:Src/bno055.c  **** 					&data_u8r,
8252:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8253:Src/bno055.c  **** 				}
8254:Src/bno055.c  **** 			break;
8255:Src/bno055.c  **** 			default:
8256:Src/bno055.c  **** 				/* Write the default axis remap value */
8257:Src/bno055.c  **** 				com_rslt =
8258:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
8259:Src/bno055.c  **** 				(p_bno055->dev_addr,
8260:Src/bno055.c  **** 				BNO055_REMAP_AXIS_VALUE_REG,
8261:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8262:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
8263:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
8264:Src/bno055.c  **** 					(data_u8r,
8265:Src/bno055.c  **** 					BNO055_REMAP_AXIS_VALUE,
8266:Src/bno055.c  **** 					BNO055_DEFAULT_AXIS);
8267:Src/bno055.c  **** 					com_rslt +=
8268:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
8269:Src/bno055.c  **** 					(p_bno055->dev_addr,
8270:Src/bno055.c  **** 					BNO055_REMAP_AXIS_VALUE_REG,
8271:Src/bno055.c  **** 					&data_u8r,
8272:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8273:Src/bno055.c  **** 				}
8274:Src/bno055.c  **** 			break;
8275:Src/bno055.c  **** 			}
8276:Src/bno055.c  **** 		} else {
8277:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
8278:Src/bno055.c  **** 		}
ARM GAS  /tmp/ccVWLGiI.s 			page 472


8279:Src/bno055.c  **** 	} else {
8280:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 16826              		.loc 1 8280 0
 16827 0022 FF24     		movs	r4, #255
 16828              	.LVL2136:
 16829              	.L1839:
8281:Src/bno055.c  **** 	}
8282:Src/bno055.c  **** }
8283:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 16830              		.loc 1 8283 0
 16831 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 16832 0028 70BB     		cbnz	r0, .L1856
 16833 002a 2046     		mov	r0, r4
 16834              	.LVL2137:
 16835              	.L1837:
8284:Src/bno055.c  **** 	/* set the operation mode
8285:Src/bno055.c  **** 	of previous operation mode*/
8286:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
8287:Src/bno055.c  **** 	(prev_opmode_u8);
8288:Src/bno055.c  **** return com_rslt;
8289:Src/bno055.c  **** }
 16836              		.loc 1 8289 0
 16837 002c 40B2     		sxtb	r0, r0
 16838 002e 02B0     		add	sp, sp, #8
 16839              	.LCFI730:
 16840              		.cfi_remember_state
 16841              		.cfi_def_cfa_offset 16
 16842              		@ sp needed
 16843 0030 70BD     		pop	{r4, r5, r6, pc}
 16844              	.LVL2138:
 16845              	.L1838:
 16846              	.LCFI731:
 16847              		.cfi_restore_state
8225:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 16848              		.loc 1 8225 0
 16849 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 16850 0036 73BB     		cbnz	r3, .L1840
 16851              	.L1843:
 16852              	.LVL2139:
 16853 0038 AB1F     		subs	r3, r5, #6
 16854 003a DBB2     		uxtb	r3, r3
 16855 003c 1E2B     		cmp	r3, #30
 16856 003e 05D8     		bhi	.L1841
 16857 0040 0126     		movs	r6, #1
 16858 0042 284A     		ldr	r2, .L1858+4
 16859 0044 06FA03F3 		lsl	r3, r6, r3
 16860 0048 1A40     		ands	r2, r2, r3
 16861 004a 4ABB     		cbnz	r2, .L1857
 16862              	.L1841:
8258:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16863              		.loc 1 8258 0
 16864 004c 2368     		ldr	r3, [r4]
8257:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 16865              		.loc 1 8257 0
 16866 004e 0DF10602 		add	r2, sp, #6
 16867 0052 1C69     		ldr	r4, [r3, #16]
 16868 0054 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 473


 16869 0056 4121     		movs	r1, #65
 16870 0058 0123     		movs	r3, #1
 16871 005a A047     		blx	r4
 16872              	.LVL2140:
8258:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16873              		.loc 1 8258 0
 16874 005c 204A     		ldr	r2, .L1858
8262:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 16875              		.loc 1 8262 0
 16876 005e 0446     		mov	r4, r0
 16877 0060 0028     		cmp	r0, #0
 16878 0062 DFD1     		bne	.L1839
8263:Src/bno055.c  **** 					(data_u8r,
 16879              		.loc 1 8263 0
 16880 0064 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
8268:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16881              		.loc 1 8268 0
 16882 0068 1168     		ldr	r1, [r2]
8263:Src/bno055.c  **** 					(data_u8r,
 16883              		.loc 1 8263 0
 16884 006a 23F03F03 		bic	r3, r3, #63
 16885 006e 43F02403 		orr	r3, r3, #36
8268:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16886              		.loc 1 8268 0
 16887 0072 CC68     		ldr	r4, [r1, #12]
8263:Src/bno055.c  **** 					(data_u8r,
 16888              		.loc 1 8263 0
 16889 0074 8DF80630 		strb	r3, [sp, #6]
8268:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16890              		.loc 1 8268 0
 16891 0078 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 16892              	.LVL2141:
 16893 007a 0DF10602 		add	r2, sp, #6
 16894 007e 4121     		movs	r1, #65
 16895 0080 0123     		movs	r3, #1
 16896 0082 A047     		blx	r4
 16897              	.LVL2142:
 16898 0084 0446     		mov	r4, r0
 16899              	.LVL2143:
 16900 0086 CDE7     		b	.L1839
 16901              	.L1856:
8286:Src/bno055.c  **** 	(prev_opmode_u8);
 16902              		.loc 1 8286 0
 16903 0088 FFF7FEFF 		bl	bno055_set_operation_mode
 16904              	.LVL2144:
 16905 008c 2044     		add	r0, r0, r4
 16906 008e C0B2     		uxtb	r0, r0
 16907              	.LVL2145:
 16908              		.loc 1 8289 0
 16909 0090 40B2     		sxtb	r0, r0
 16910 0092 02B0     		add	sp, sp, #8
 16911              	.LCFI732:
 16912              		.cfi_remember_state
 16913              		.cfi_def_cfa_offset 16
 16914              		@ sp needed
 16915 0094 70BD     		pop	{r4, r5, r6, pc}
 16916              	.LVL2146:
ARM GAS  /tmp/ccVWLGiI.s 			page 474


 16917              	.L1840:
 16918              	.LCFI733:
 16919              		.cfi_restore_state
8226:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 16920              		.loc 1 8226 0
 16921 0096 FFF7FEFF 		bl	bno055_set_operation_mode
 16922              	.LVL2147:
8229:Src/bno055.c  **** 			switch (remap_axis_u8) {
 16923              		.loc 1 8229 0
 16924 009a 0028     		cmp	r0, #0
 16925 009c C1D1     		bne	.L1844
 16926 009e CBE7     		b	.L1843
 16927              	.LVL2148:
 16928              	.L1857:
8238:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16929              		.loc 1 8238 0
 16930 00a0 2368     		ldr	r3, [r4]
8237:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 16931              		.loc 1 8237 0
 16932 00a2 0DF10602 		add	r2, sp, #6
 16933 00a6 1C69     		ldr	r4, [r3, #16]
 16934 00a8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 16935 00aa 4121     		movs	r1, #65
 16936 00ac 3346     		mov	r3, r6
 16937 00ae A047     		blx	r4
 16938              	.LVL2149:
8238:Src/bno055.c  **** 				(p_bno055->dev_addr,
 16939              		.loc 1 8238 0
 16940 00b0 0B4B     		ldr	r3, .L1858
8242:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 16941              		.loc 1 8242 0
 16942 00b2 0446     		mov	r4, r0
 16943 00b4 0028     		cmp	r0, #0
 16944 00b6 B5D1     		bne	.L1839
8243:Src/bno055.c  **** 					(data_u8r,
 16945              		.loc 1 8243 0
 16946 00b8 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 16947              	.LVL2150:
8248:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16948              		.loc 1 8248 0
 16949 00bc 1968     		ldr	r1, [r3]
8243:Src/bno055.c  **** 					(data_u8r,
 16950              		.loc 1 8243 0
 16951 00be 20F03F00 		bic	r0, r0, #63
 16952 00c2 2843     		orrs	r0, r0, r5
8248:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16953              		.loc 1 8248 0
 16954 00c4 CC68     		ldr	r4, [r1, #12]
8243:Src/bno055.c  **** 					(data_u8r,
 16955              		.loc 1 8243 0
 16956 00c6 8DF80600 		strb	r0, [sp, #6]
8248:Src/bno055.c  **** 					(p_bno055->dev_addr,
 16957              		.loc 1 8248 0
 16958 00ca 0DF10602 		add	r2, sp, #6
 16959 00ce 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 16960 00d0 3346     		mov	r3, r6
 16961 00d2 4121     		movs	r1, #65
ARM GAS  /tmp/ccVWLGiI.s 			page 475


 16962 00d4 A047     		blx	r4
 16963              	.LVL2151:
 16964 00d6 0446     		mov	r4, r0
 16965              	.LVL2152:
 16966 00d8 A4E7     		b	.L1839
 16967              	.LVL2153:
 16968              	.L1845:
8218:Src/bno055.c  **** 	} else {
 16969              		.loc 1 8218 0
 16970 00da 8120     		movs	r0, #129
 16971              	.LVL2154:
 16972 00dc A6E7     		b	.L1837
 16973              	.L1859:
 16974 00de 00BF     		.align	2
 16975              	.L1858:
 16976 00e0 00000000 		.word	.LANCHOR0
 16977 00e4 09100448 		.word	1208225801
 16978              		.cfi_endproc
 16979              	.LFE160:
 16981              		.section	.text.bno055_get_remap_x_sign,"ax",%progbits
 16982              		.align	2
 16983              		.global	bno055_get_remap_x_sign
 16984              		.thumb
 16985              		.thumb_func
 16987              	bno055_get_remap_x_sign:
 16988              	.LFB161:
8290:Src/bno055.c  **** /*!
8291:Src/bno055.c  ****  *	@brief This API used to read the x-axis remap
8292:Src/bno055.c  ****  *	sign from register from 0x42 bit 2
8293:Src/bno055.c  ****  *
8294:Src/bno055.c  ****  *	@param remap_x_sign_u8 : The value of x-axis remap sign
8295:Src/bno055.c  ****  *
8296:Src/bno055.c  ****  *    remap_x_sign_u8  |    result
8297:Src/bno055.c  ****  *   ------------------- |--------------------
8298:Src/bno055.c  ****  *      0X00             | BNO055_REMAP_AXIS_POSITIVE
8299:Src/bno055.c  ****  *      0X01             | BNO055_REMAP_AXIS_NEGATIVE
8300:Src/bno055.c  ****  *
8301:Src/bno055.c  ****  *	@return results of bus communication function
8302:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8303:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8304:Src/bno055.c  ****  *
8305:Src/bno055.c  ****  */
8306:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_remap_x_sign(
8307:Src/bno055.c  **** u8 *remap_x_sign_u8)
8308:Src/bno055.c  **** {
 16989              		.loc 1 8308 0
 16990              		.cfi_startproc
 16991              		@ args = 0, pretend = 0, frame = 8
 16992              		@ frame_needed = 0, uses_anonymous_args = 0
 16993              	.LVL2155:
 16994 0000 30B5     		push	{r4, r5, lr}
 16995              	.LCFI734:
 16996              		.cfi_def_cfa_offset 12
 16997              		.cfi_offset 4, -12
 16998              		.cfi_offset 5, -8
 16999              		.cfi_offset 14, -4
8309:Src/bno055.c  **** 	/* Variable used to return value of
ARM GAS  /tmp/ccVWLGiI.s 			page 476


8310:Src/bno055.c  **** 	communication routine*/
8311:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8312:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
8313:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
8314:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
8315:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 17000              		.loc 1 8315 0
 17001 0002 134C     		ldr	r4, .L1871
8308:Src/bno055.c  **** 	/* Variable used to return value of
 17002              		.loc 1 8308 0
 17003 0004 83B0     		sub	sp, sp, #12
 17004              	.LCFI735:
 17005              		.cfi_def_cfa_offset 24
 17006              		.loc 1 8315 0
 17007 0006 2368     		ldr	r3, [r4]
8312:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 17008              		.loc 1 8312 0
 17009 0008 0022     		movs	r2, #0
 17010 000a 8DF80720 		strb	r2, [sp, #7]
 17011              	.LVL2156:
 17012              		.loc 1 8315 0
 17013 000e E3B1     		cbz	r3, .L1864
8316:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
8317:Src/bno055.c  **** 		} else {
8318:Src/bno055.c  **** 		/*condition check for page, x-axis remap sign is
8319:Src/bno055.c  **** 		available in the page zero*/
8320:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 17014              		.loc 1 8320 0
 17015 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 17016 0012 0546     		mov	r5, r0
 17017 0014 71B9     		cbnz	r1, .L1870
 17018              	.LVL2157:
 17019              	.L1862:
8321:Src/bno055.c  **** 			/* Write the page zero*/
8322:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
8323:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
8324:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
8325:Src/bno055.c  **** 			/* Read the value of x-axis remap sign */
8326:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 17020              		.loc 1 8326 0
 17021 0016 1C69     		ldr	r4, [r3, #16]
 17022 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17023 001a 4221     		movs	r1, #66
 17024 001c 0123     		movs	r3, #1
 17025 001e 0DF10702 		add	r2, sp, #7
 17026 0022 A047     		blx	r4
 17027              	.LVL2158:
8327:Src/bno055.c  **** 			(p_bno055->dev_addr,
8328:Src/bno055.c  **** 			BNO055_REMAP_X_SIGN_REG,
8329:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8330:Src/bno055.c  **** 			*remap_x_sign_u8 =
8331:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 17028              		.loc 1 8331 0
 17029 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17030 0028 C3F38003 		ubfx	r3, r3, #2, #1
8330:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 17031              		.loc 1 8330 0
ARM GAS  /tmp/ccVWLGiI.s 			page 477


 17032 002c 2B70     		strb	r3, [r5]
 17033              	.LVL2159:
 17034              	.L1861:
8332:Src/bno055.c  **** 			BNO055_REMAP_X_SIGN);
8333:Src/bno055.c  **** 		} else {
8334:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
8335:Src/bno055.c  **** 		}
8336:Src/bno055.c  **** 	}
8337:Src/bno055.c  **** 	return com_rslt;
8338:Src/bno055.c  **** }
 17035              		.loc 1 8338 0
 17036 002e 40B2     		sxtb	r0, r0
 17037 0030 03B0     		add	sp, sp, #12
 17038              	.LCFI736:
 17039              		.cfi_remember_state
 17040              		.cfi_def_cfa_offset 12
 17041              		@ sp needed
 17042 0032 30BD     		pop	{r4, r5, pc}
 17043              	.LVL2160:
 17044              	.L1870:
 17045              	.LCFI737:
 17046              		.cfi_restore_state
8322:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 17047              		.loc 1 8322 0
 17048 0034 1046     		mov	r0, r2
 17049              	.LVL2161:
 17050 0036 FFF7FEFF 		bl	bno055_write_page_id
 17051              	.LVL2162:
 17052 003a 2368     		ldr	r3, [r4]
8323:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17053              		.loc 1 8323 0
 17054 003c 0028     		cmp	r0, #0
 17055 003e EAD0     		beq	.L1862
 17056              	.LVL2163:
8323:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17057              		.loc 1 8323 0 is_stmt 0 discriminator 1
 17058 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
8334:Src/bno055.c  **** 		}
 17059              		.loc 1 8334 0 is_stmt 1 discriminator 1
 17060 0042 FF20     		movs	r0, #255
8323:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17061              		.loc 1 8323 0 discriminator 1
 17062 0044 002A     		cmp	r2, #0
 17063 0046 F2D1     		bne	.L1861
 17064 0048 E5E7     		b	.L1862
 17065              	.LVL2164:
 17066              	.L1864:
8316:Src/bno055.c  **** 		} else {
 17067              		.loc 1 8316 0
 17068 004a 8120     		movs	r0, #129
 17069              	.LVL2165:
 17070 004c EFE7     		b	.L1861
 17071              	.L1872:
 17072 004e 00BF     		.align	2
 17073              	.L1871:
 17074 0050 00000000 		.word	.LANCHOR0
 17075              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 478


 17076              	.LFE161:
 17078              		.section	.text.bno055_set_remap_x_sign,"ax",%progbits
 17079              		.align	2
 17080              		.global	bno055_set_remap_x_sign
 17081              		.thumb
 17082              		.thumb_func
 17084              	bno055_set_remap_x_sign:
 17085              	.LFB162:
8339:Src/bno055.c  **** /*!
8340:Src/bno055.c  ****  *	@brief This API used to write the x-axis remap
8341:Src/bno055.c  ****  *	sign from register from 0x42 bit 2
8342:Src/bno055.c  ****  *
8343:Src/bno055.c  ****  *	@param remap_x_sign_u8 : The value of x-axis remap sign
8344:Src/bno055.c  ****  *
8345:Src/bno055.c  ****  *    remap_x_sign_u8  |    result
8346:Src/bno055.c  ****  *   ------------------- |--------------------
8347:Src/bno055.c  ****  *      0X00             | BNO055_REMAP_AXIS_POSITIVE
8348:Src/bno055.c  ****  *      0X01             | BNO055_REMAP_AXIS_NEGATIVE
8349:Src/bno055.c  ****  *
8350:Src/bno055.c  ****  *	@return results of bus communication function
8351:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8352:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8353:Src/bno055.c  ****  *
8354:Src/bno055.c  ****  */
8355:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_remap_x_sign(
8356:Src/bno055.c  **** u8 remap_x_sign_u8)
8357:Src/bno055.c  **** {
 17086              		.loc 1 8357 0
 17087              		.cfi_startproc
 17088              		@ args = 0, pretend = 0, frame = 8
 17089              		@ frame_needed = 0, uses_anonymous_args = 0
 17090              	.LVL2166:
 17091 0000 30B5     		push	{r4, r5, lr}
 17092              	.LCFI738:
 17093              		.cfi_def_cfa_offset 12
 17094              		.cfi_offset 4, -12
 17095              		.cfi_offset 5, -8
 17096              		.cfi_offset 14, -4
8358:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8359:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
8360:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
8361:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
8362:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
8363:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 17097              		.loc 1 8363 0
 17098 0002 244C     		ldr	r4, .L1889
8357:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 17099              		.loc 1 8357 0
 17100 0004 83B0     		sub	sp, sp, #12
 17101              	.LCFI739:
 17102              		.cfi_def_cfa_offset 24
 17103              		.loc 1 8363 0
 17104 0006 2268     		ldr	r2, [r4]
8359:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 17105              		.loc 1 8359 0
 17106 0008 0023     		movs	r3, #0
 17107 000a 8DF80630 		strb	r3, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 479


8360:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 17108              		.loc 1 8360 0
 17109 000e 8DF80730 		strb	r3, [sp, #7]
 17110              	.LVL2167:
 17111              		.loc 1 8363 0
 17112 0012 002A     		cmp	r2, #0
 17113 0014 3CD0     		beq	.L1881
 17114 0016 0546     		mov	r5, r0
8364:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
8365:Src/bno055.c  **** 	} else {
8366:Src/bno055.c  **** 		/* The write operation effective only if the operation
8367:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
8368:Src/bno055.c  **** 		current operation mode and set the config mode */
8369:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 17115              		.loc 1 8369 0
 17116 0018 0DF10700 		add	r0, sp, #7
 17117              	.LVL2168:
 17118 001c FFF7FEFF 		bl	bno055_get_operation_mode
 17119              	.LVL2169:
8370:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 17120              		.loc 1 8370 0
 17121 0020 38B1     		cbz	r0, .L1875
 17122              	.L1880:
8371:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
8372:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
8373:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
8374:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
8375:Src/bno055.c  **** 				/* Write the value of x-axis remap */
8376:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
8377:Src/bno055.c  **** 				(p_bno055->dev_addr,
8378:Src/bno055.c  **** 				BNO055_REMAP_X_SIGN_REG,
8379:Src/bno055.c  **** 				&data_u8r,
8380:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
8381:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
8382:Src/bno055.c  **** 					data_u8r =
8383:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
8384:Src/bno055.c  **** 					BNO055_REMAP_X_SIGN,
8385:Src/bno055.c  **** 					remap_x_sign_u8);
8386:Src/bno055.c  **** 					com_rslt +=
8387:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
8388:Src/bno055.c  **** 					(p_bno055->dev_addr,
8389:Src/bno055.c  **** 					BNO055_REMAP_X_SIGN_REG,
8390:Src/bno055.c  **** 					&data_u8r,
8391:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8392:Src/bno055.c  **** 				}
8393:Src/bno055.c  **** 			} else {
8394:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
8395:Src/bno055.c  **** 			}
8396:Src/bno055.c  **** 		} else {
8397:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 17123              		.loc 1 8397 0
 17124 0022 FF24     		movs	r4, #255
 17125              	.LVL2170:
 17126              	.L1876:
8398:Src/bno055.c  **** 		}
8399:Src/bno055.c  **** 	}
8400:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
ARM GAS  /tmp/ccVWLGiI.s 			page 480


 17127              		.loc 1 8400 0
 17128 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 17129 0028 30BB     		cbnz	r0, .L1888
 17130 002a 2046     		mov	r0, r4
 17131              	.LVL2171:
 17132              	.L1874:
8401:Src/bno055.c  **** 		/* set the operation mode
8402:Src/bno055.c  **** 		of previous operation mode*/
8403:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
8404:Src/bno055.c  **** 		(prev_opmode_u8);
8405:Src/bno055.c  **** 	return com_rslt;
8406:Src/bno055.c  **** }
 17133              		.loc 1 8406 0
 17134 002c 40B2     		sxtb	r0, r0
 17135 002e 03B0     		add	sp, sp, #12
 17136              	.LCFI740:
 17137              		.cfi_remember_state
 17138              		.cfi_def_cfa_offset 12
 17139              		@ sp needed
 17140 0030 30BD     		pop	{r4, r5, pc}
 17141              	.LVL2172:
 17142              	.L1875:
 17143              	.LCFI741:
 17144              		.cfi_restore_state
8371:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 17145              		.loc 1 8371 0
 17146 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17147 0036 33BB     		cbnz	r3, .L1877
 17148              	.L1879:
 17149              	.LVL2173:
8376:Src/bno055.c  **** 				(p_bno055->dev_addr,
 17150              		.loc 1 8376 0
 17151 0038 2368     		ldr	r3, [r4]
 17152 003a 0DF10602 		add	r2, sp, #6
 17153 003e 1C69     		ldr	r4, [r3, #16]
 17154 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17155 0042 4221     		movs	r1, #66
 17156 0044 0123     		movs	r3, #1
 17157 0046 A047     		blx	r4
 17158              	.LVL2174:
 17159 0048 124B     		ldr	r3, .L1889
8381:Src/bno055.c  **** 					data_u8r =
 17160              		.loc 1 8381 0
 17161 004a 0446     		mov	r4, r0
 17162 004c 0028     		cmp	r0, #0
 17163 004e E9D1     		bne	.L1876
8382:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17164              		.loc 1 8382 0
 17165 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
8383:Src/bno055.c  **** 					BNO055_REMAP_X_SIGN,
 17166              		.loc 1 8383 0
 17167 0054 A800     		lsls	r0, r5, #2
 17168              	.LVL2175:
8387:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17169              		.loc 1 8387 0
 17170 0056 1968     		ldr	r1, [r3]
8382:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 481


 17171              		.loc 1 8382 0
 17172 0058 00F00400 		and	r0, r0, #4
 17173 005c 22F00403 		bic	r3, r2, #4
 17174 0060 1843     		orrs	r0, r0, r3
8387:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17175              		.loc 1 8387 0
 17176 0062 CC68     		ldr	r4, [r1, #12]
8382:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17177              		.loc 1 8382 0
 17178 0064 8DF80600 		strb	r0, [sp, #6]
8387:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17179              		.loc 1 8387 0
 17180 0068 0DF10602 		add	r2, sp, #6
 17181 006c 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 17182 006e 0123     		movs	r3, #1
 17183 0070 4221     		movs	r1, #66
 17184 0072 A047     		blx	r4
 17185              	.LVL2176:
 17186 0074 0446     		mov	r4, r0
 17187              	.LVL2177:
 17188 0076 D5E7     		b	.L1876
 17189              	.L1888:
8403:Src/bno055.c  **** 		(prev_opmode_u8);
 17190              		.loc 1 8403 0
 17191 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 17192              	.LVL2178:
 17193 007c 2044     		add	r0, r0, r4
 17194 007e C0B2     		uxtb	r0, r0
 17195              	.LVL2179:
 17196              		.loc 1 8406 0
 17197 0080 40B2     		sxtb	r0, r0
 17198 0082 03B0     		add	sp, sp, #12
 17199              	.LCFI742:
 17200              		.cfi_remember_state
 17201              		.cfi_def_cfa_offset 12
 17202              		@ sp needed
 17203 0084 30BD     		pop	{r4, r5, pc}
 17204              	.LVL2180:
 17205              	.L1877:
 17206              	.LCFI743:
 17207              		.cfi_restore_state
8372:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 17208              		.loc 1 8372 0
 17209 0086 FFF7FEFF 		bl	bno055_set_operation_mode
 17210              	.LVL2181:
8374:Src/bno055.c  **** 				/* Write the value of x-axis remap */
 17211              		.loc 1 8374 0
 17212 008a 0028     		cmp	r0, #0
 17213 008c C9D1     		bne	.L1880
 17214 008e D3E7     		b	.L1879
 17215              	.LVL2182:
 17216              	.L1881:
8364:Src/bno055.c  **** 	} else {
 17217              		.loc 1 8364 0
 17218 0090 8120     		movs	r0, #129
 17219              	.LVL2183:
 17220 0092 CBE7     		b	.L1874
ARM GAS  /tmp/ccVWLGiI.s 			page 482


 17221              	.L1890:
 17222              		.align	2
 17223              	.L1889:
 17224 0094 00000000 		.word	.LANCHOR0
 17225              		.cfi_endproc
 17226              	.LFE162:
 17228              		.section	.text.bno055_get_remap_y_sign,"ax",%progbits
 17229              		.align	2
 17230              		.global	bno055_get_remap_y_sign
 17231              		.thumb
 17232              		.thumb_func
 17234              	bno055_get_remap_y_sign:
 17235              	.LFB163:
8407:Src/bno055.c  **** /*!
8408:Src/bno055.c  ****  *	@brief This API used to read the y-axis remap
8409:Src/bno055.c  ****  *	sign from register from 0x42 bit 1
8410:Src/bno055.c  ****  *
8411:Src/bno055.c  ****  *	@param remap_y_sign_u8 : The value of y-axis remap sign
8412:Src/bno055.c  ****  *
8413:Src/bno055.c  ****  *    remap_y_sign_u8  |   result
8414:Src/bno055.c  ****  *   ------------------- |--------------------
8415:Src/bno055.c  ****  *      0X00             | BNO055_REMAP_AXIS_POSITIVE
8416:Src/bno055.c  ****  *      0X01             | BNO055_REMAP_AXIS_NEGATIVE
8417:Src/bno055.c  ****  *
8418:Src/bno055.c  ****  *	@return results of bus communication function
8419:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8420:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8421:Src/bno055.c  ****  *
8422:Src/bno055.c  ****  */
8423:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_remap_y_sign(
8424:Src/bno055.c  **** u8 *remap_y_sign_u8)
8425:Src/bno055.c  **** {
 17236              		.loc 1 8425 0
 17237              		.cfi_startproc
 17238              		@ args = 0, pretend = 0, frame = 8
 17239              		@ frame_needed = 0, uses_anonymous_args = 0
 17240              	.LVL2184:
 17241 0000 30B5     		push	{r4, r5, lr}
 17242              	.LCFI744:
 17243              		.cfi_def_cfa_offset 12
 17244              		.cfi_offset 4, -12
 17245              		.cfi_offset 5, -8
 17246              		.cfi_offset 14, -4
8426:Src/bno055.c  **** 	/* Variable used to return value of
8427:Src/bno055.c  **** 	communication routine*/
8428:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8429:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
8430:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
8431:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
8432:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 17247              		.loc 1 8432 0
 17248 0002 134C     		ldr	r4, .L1902
8425:Src/bno055.c  **** 	/* Variable used to return value of
 17249              		.loc 1 8425 0
 17250 0004 83B0     		sub	sp, sp, #12
 17251              	.LCFI745:
 17252              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccVWLGiI.s 			page 483


 17253              		.loc 1 8432 0
 17254 0006 2368     		ldr	r3, [r4]
8429:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 17255              		.loc 1 8429 0
 17256 0008 0022     		movs	r2, #0
 17257 000a 8DF80720 		strb	r2, [sp, #7]
 17258              	.LVL2185:
 17259              		.loc 1 8432 0
 17260 000e E3B1     		cbz	r3, .L1895
8433:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
8434:Src/bno055.c  **** 		} else {
8435:Src/bno055.c  **** 		/*condition check for page, y-axis remap sign is
8436:Src/bno055.c  **** 		available in the page zero*/
8437:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 17261              		.loc 1 8437 0
 17262 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 17263 0012 0546     		mov	r5, r0
 17264 0014 71B9     		cbnz	r1, .L1901
 17265              	.LVL2186:
 17266              	.L1893:
8438:Src/bno055.c  **** 			/* Write the page zero*/
8439:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
8440:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
8441:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
8442:Src/bno055.c  **** 			/* Read the value of y-axis remap sign*/
8443:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 17267              		.loc 1 8443 0
 17268 0016 1C69     		ldr	r4, [r3, #16]
 17269 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17270 001a 4221     		movs	r1, #66
 17271 001c 0123     		movs	r3, #1
 17272 001e 0DF10702 		add	r2, sp, #7
 17273 0022 A047     		blx	r4
 17274              	.LVL2187:
8444:Src/bno055.c  **** 			(p_bno055->dev_addr,
8445:Src/bno055.c  **** 			BNO055_REMAP_Y_SIGN_REG,
8446:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8447:Src/bno055.c  **** 			*remap_y_sign_u8 =
8448:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 17275              		.loc 1 8448 0
 17276 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17277 0028 C3F34003 		ubfx	r3, r3, #1, #1
8447:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 17278              		.loc 1 8447 0
 17279 002c 2B70     		strb	r3, [r5]
 17280              	.LVL2188:
 17281              	.L1892:
8449:Src/bno055.c  **** 			BNO055_REMAP_Y_SIGN);
8450:Src/bno055.c  **** 		} else {
8451:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
8452:Src/bno055.c  **** 		}
8453:Src/bno055.c  **** 	}
8454:Src/bno055.c  **** 	return com_rslt;
8455:Src/bno055.c  **** }
 17282              		.loc 1 8455 0
 17283 002e 40B2     		sxtb	r0, r0
 17284 0030 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 484


 17285              	.LCFI746:
 17286              		.cfi_remember_state
 17287              		.cfi_def_cfa_offset 12
 17288              		@ sp needed
 17289 0032 30BD     		pop	{r4, r5, pc}
 17290              	.LVL2189:
 17291              	.L1901:
 17292              	.LCFI747:
 17293              		.cfi_restore_state
8439:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 17294              		.loc 1 8439 0
 17295 0034 1046     		mov	r0, r2
 17296              	.LVL2190:
 17297 0036 FFF7FEFF 		bl	bno055_write_page_id
 17298              	.LVL2191:
 17299 003a 2368     		ldr	r3, [r4]
8440:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17300              		.loc 1 8440 0
 17301 003c 0028     		cmp	r0, #0
 17302 003e EAD0     		beq	.L1893
 17303              	.LVL2192:
8440:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17304              		.loc 1 8440 0 is_stmt 0 discriminator 1
 17305 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
8451:Src/bno055.c  **** 		}
 17306              		.loc 1 8451 0 is_stmt 1 discriminator 1
 17307 0042 FF20     		movs	r0, #255
8440:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17308              		.loc 1 8440 0 discriminator 1
 17309 0044 002A     		cmp	r2, #0
 17310 0046 F2D1     		bne	.L1892
 17311 0048 E5E7     		b	.L1893
 17312              	.LVL2193:
 17313              	.L1895:
8433:Src/bno055.c  **** 		} else {
 17314              		.loc 1 8433 0
 17315 004a 8120     		movs	r0, #129
 17316              	.LVL2194:
 17317 004c EFE7     		b	.L1892
 17318              	.L1903:
 17319 004e 00BF     		.align	2
 17320              	.L1902:
 17321 0050 00000000 		.word	.LANCHOR0
 17322              		.cfi_endproc
 17323              	.LFE163:
 17325              		.section	.text.bno055_set_remap_y_sign,"ax",%progbits
 17326              		.align	2
 17327              		.global	bno055_set_remap_y_sign
 17328              		.thumb
 17329              		.thumb_func
 17331              	bno055_set_remap_y_sign:
 17332              	.LFB164:
8456:Src/bno055.c  **** /*!
8457:Src/bno055.c  ****  *	@brief This API used to write the y-axis remap
8458:Src/bno055.c  ****  *	sign from register from 0x42 bit 1
8459:Src/bno055.c  ****  *
8460:Src/bno055.c  ****  *	@param remap_y_sign_u8 : The value of y-axis remap sign
ARM GAS  /tmp/ccVWLGiI.s 			page 485


8461:Src/bno055.c  ****  *
8462:Src/bno055.c  ****  *    remap_y_sign_u8  |   result
8463:Src/bno055.c  ****  *   ------------------- |--------------------
8464:Src/bno055.c  ****  *      0X00             | BNO055_REMAP_AXIS_POSITIVE
8465:Src/bno055.c  ****  *      0X01             | BNO055_REMAP_AXIS_NEGATIVE
8466:Src/bno055.c  ****  *
8467:Src/bno055.c  ****  *	@return results of bus communication function
8468:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8469:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8470:Src/bno055.c  ****  *
8471:Src/bno055.c  ****  */
8472:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_remap_y_sign(
8473:Src/bno055.c  **** u8 remap_y_sign_u8)
8474:Src/bno055.c  **** {
 17333              		.loc 1 8474 0
 17334              		.cfi_startproc
 17335              		@ args = 0, pretend = 0, frame = 8
 17336              		@ frame_needed = 0, uses_anonymous_args = 0
 17337              	.LVL2195:
 17338 0000 30B5     		push	{r4, r5, lr}
 17339              	.LCFI748:
 17340              		.cfi_def_cfa_offset 12
 17341              		.cfi_offset 4, -12
 17342              		.cfi_offset 5, -8
 17343              		.cfi_offset 14, -4
8475:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8476:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
8477:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
8478:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
8479:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
8480:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 17344              		.loc 1 8480 0
 17345 0002 244C     		ldr	r4, .L1920
8474:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 17346              		.loc 1 8474 0
 17347 0004 83B0     		sub	sp, sp, #12
 17348              	.LCFI749:
 17349              		.cfi_def_cfa_offset 24
 17350              		.loc 1 8480 0
 17351 0006 2268     		ldr	r2, [r4]
8476:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 17352              		.loc 1 8476 0
 17353 0008 0023     		movs	r3, #0
 17354 000a 8DF80630 		strb	r3, [sp, #6]
8477:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 17355              		.loc 1 8477 0
 17356 000e 8DF80730 		strb	r3, [sp, #7]
 17357              	.LVL2196:
 17358              		.loc 1 8480 0
 17359 0012 002A     		cmp	r2, #0
 17360 0014 3CD0     		beq	.L1912
 17361 0016 0546     		mov	r5, r0
8481:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
8482:Src/bno055.c  **** 	} else {
8483:Src/bno055.c  **** 		/* The write operation effective only if the operation
8484:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
8485:Src/bno055.c  **** 		current operation mode and set the config mode */
ARM GAS  /tmp/ccVWLGiI.s 			page 486


8486:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 17362              		.loc 1 8486 0
 17363 0018 0DF10700 		add	r0, sp, #7
 17364              	.LVL2197:
 17365 001c FFF7FEFF 		bl	bno055_get_operation_mode
 17366              	.LVL2198:
8487:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 17367              		.loc 1 8487 0
 17368 0020 38B1     		cbz	r0, .L1906
 17369              	.L1911:
8488:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
8489:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
8490:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
8491:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
8492:Src/bno055.c  **** 				/* Write the value of y-axis remap sign*/
8493:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
8494:Src/bno055.c  **** 				(p_bno055->dev_addr,
8495:Src/bno055.c  **** 				BNO055_REMAP_Y_SIGN_REG,
8496:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8497:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
8498:Src/bno055.c  **** 					data_u8r =
8499:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
8500:Src/bno055.c  **** 					BNO055_REMAP_Y_SIGN,
8501:Src/bno055.c  **** 					remap_y_sign_u8);
8502:Src/bno055.c  **** 					com_rslt +=
8503:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
8504:Src/bno055.c  **** 					(p_bno055->dev_addr,
8505:Src/bno055.c  **** 					BNO055_REMAP_Y_SIGN_REG,
8506:Src/bno055.c  **** 					&data_u8r,
8507:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8508:Src/bno055.c  **** 				}
8509:Src/bno055.c  **** 			} else {
8510:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
8511:Src/bno055.c  **** 			}
8512:Src/bno055.c  **** 		} else {
8513:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 17370              		.loc 1 8513 0
 17371 0022 FF24     		movs	r4, #255
 17372              	.LVL2199:
 17373              	.L1907:
8514:Src/bno055.c  **** 		}
8515:Src/bno055.c  **** 	}
8516:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 17374              		.loc 1 8516 0
 17375 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 17376 0028 30BB     		cbnz	r0, .L1919
 17377 002a 2046     		mov	r0, r4
 17378              	.LVL2200:
 17379              	.L1905:
8517:Src/bno055.c  **** 		/* set the operation mode
8518:Src/bno055.c  **** 		of previous operation mode*/
8519:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
8520:Src/bno055.c  **** 		(prev_opmode_u8);
8521:Src/bno055.c  **** 	return com_rslt;
8522:Src/bno055.c  **** }
 17380              		.loc 1 8522 0
 17381 002c 40B2     		sxtb	r0, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 487


 17382 002e 03B0     		add	sp, sp, #12
 17383              	.LCFI750:
 17384              		.cfi_remember_state
 17385              		.cfi_def_cfa_offset 12
 17386              		@ sp needed
 17387 0030 30BD     		pop	{r4, r5, pc}
 17388              	.LVL2201:
 17389              	.L1906:
 17390              	.LCFI751:
 17391              		.cfi_restore_state
8488:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 17392              		.loc 1 8488 0
 17393 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17394 0036 33BB     		cbnz	r3, .L1908
 17395              	.L1910:
 17396              	.LVL2202:
8493:Src/bno055.c  **** 				(p_bno055->dev_addr,
 17397              		.loc 1 8493 0
 17398 0038 2368     		ldr	r3, [r4]
 17399 003a 0DF10602 		add	r2, sp, #6
 17400 003e 1C69     		ldr	r4, [r3, #16]
 17401 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17402 0042 4221     		movs	r1, #66
 17403 0044 0123     		movs	r3, #1
 17404 0046 A047     		blx	r4
 17405              	.LVL2203:
 17406 0048 124B     		ldr	r3, .L1920
8497:Src/bno055.c  **** 					data_u8r =
 17407              		.loc 1 8497 0
 17408 004a 0446     		mov	r4, r0
 17409 004c 0028     		cmp	r0, #0
 17410 004e E9D1     		bne	.L1907
8498:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17411              		.loc 1 8498 0
 17412 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
8499:Src/bno055.c  **** 					BNO055_REMAP_Y_SIGN,
 17413              		.loc 1 8499 0
 17414 0054 6800     		lsls	r0, r5, #1
 17415              	.LVL2204:
8503:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17416              		.loc 1 8503 0
 17417 0056 1968     		ldr	r1, [r3]
8498:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17418              		.loc 1 8498 0
 17419 0058 00F00200 		and	r0, r0, #2
 17420 005c 22F00203 		bic	r3, r2, #2
 17421 0060 1843     		orrs	r0, r0, r3
8503:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17422              		.loc 1 8503 0
 17423 0062 CC68     		ldr	r4, [r1, #12]
8498:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17424              		.loc 1 8498 0
 17425 0064 8DF80600 		strb	r0, [sp, #6]
8503:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17426              		.loc 1 8503 0
 17427 0068 0DF10602 		add	r2, sp, #6
 17428 006c 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 488


 17429 006e 0123     		movs	r3, #1
 17430 0070 4221     		movs	r1, #66
 17431 0072 A047     		blx	r4
 17432              	.LVL2205:
 17433 0074 0446     		mov	r4, r0
 17434              	.LVL2206:
 17435 0076 D5E7     		b	.L1907
 17436              	.L1919:
8519:Src/bno055.c  **** 		(prev_opmode_u8);
 17437              		.loc 1 8519 0
 17438 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 17439              	.LVL2207:
 17440 007c 2044     		add	r0, r0, r4
 17441 007e C0B2     		uxtb	r0, r0
 17442              	.LVL2208:
 17443              		.loc 1 8522 0
 17444 0080 40B2     		sxtb	r0, r0
 17445 0082 03B0     		add	sp, sp, #12
 17446              	.LCFI752:
 17447              		.cfi_remember_state
 17448              		.cfi_def_cfa_offset 12
 17449              		@ sp needed
 17450 0084 30BD     		pop	{r4, r5, pc}
 17451              	.LVL2209:
 17452              	.L1908:
 17453              	.LCFI753:
 17454              		.cfi_restore_state
8489:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 17455              		.loc 1 8489 0
 17456 0086 FFF7FEFF 		bl	bno055_set_operation_mode
 17457              	.LVL2210:
8491:Src/bno055.c  **** 				/* Write the value of y-axis remap sign*/
 17458              		.loc 1 8491 0
 17459 008a 0028     		cmp	r0, #0
 17460 008c C9D1     		bne	.L1911
 17461 008e D3E7     		b	.L1910
 17462              	.LVL2211:
 17463              	.L1912:
8481:Src/bno055.c  **** 	} else {
 17464              		.loc 1 8481 0
 17465 0090 8120     		movs	r0, #129
 17466              	.LVL2212:
 17467 0092 CBE7     		b	.L1905
 17468              	.L1921:
 17469              		.align	2
 17470              	.L1920:
 17471 0094 00000000 		.word	.LANCHOR0
 17472              		.cfi_endproc
 17473              	.LFE164:
 17475              		.section	.text.bno055_get_remap_z_sign,"ax",%progbits
 17476              		.align	2
 17477              		.global	bno055_get_remap_z_sign
 17478              		.thumb
 17479              		.thumb_func
 17481              	bno055_get_remap_z_sign:
 17482              	.LFB165:
8523:Src/bno055.c  **** /*!
ARM GAS  /tmp/ccVWLGiI.s 			page 489


8524:Src/bno055.c  ****  *	@brief This API used to read the z-axis remap
8525:Src/bno055.c  ****  *	sign from register from 0x42 bit 0
8526:Src/bno055.c  ****  *
8527:Src/bno055.c  ****  *	@param remap_z_sign_u8 : The value of z-axis remap sign
8528:Src/bno055.c  ****  *
8529:Src/bno055.c  ****  *    remap_z_sign_u8  |   result
8530:Src/bno055.c  ****  *   ------------------- |--------------------
8531:Src/bno055.c  ****  *      0X00             | BNO055_REMAP_AXIS_POSITIVE
8532:Src/bno055.c  ****  *      0X01             | BNO055_REMAP_AXIS_NEGATIVE
8533:Src/bno055.c  ****  *
8534:Src/bno055.c  ****  *	@return results of bus communication function
8535:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8536:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8537:Src/bno055.c  ****  *
8538:Src/bno055.c  ****  */
8539:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_remap_z_sign(
8540:Src/bno055.c  **** u8 *remap_z_sign_u8)
8541:Src/bno055.c  **** {
 17483              		.loc 1 8541 0
 17484              		.cfi_startproc
 17485              		@ args = 0, pretend = 0, frame = 8
 17486              		@ frame_needed = 0, uses_anonymous_args = 0
 17487              	.LVL2213:
 17488 0000 30B5     		push	{r4, r5, lr}
 17489              	.LCFI754:
 17490              		.cfi_def_cfa_offset 12
 17491              		.cfi_offset 4, -12
 17492              		.cfi_offset 5, -8
 17493              		.cfi_offset 14, -4
8542:Src/bno055.c  **** 	/* Variable used to return value of
8543:Src/bno055.c  **** 	communication routine*/
8544:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8545:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
8546:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
8547:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
8548:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 17494              		.loc 1 8548 0
 17495 0002 134C     		ldr	r4, .L1933
8541:Src/bno055.c  **** 	/* Variable used to return value of
 17496              		.loc 1 8541 0
 17497 0004 83B0     		sub	sp, sp, #12
 17498              	.LCFI755:
 17499              		.cfi_def_cfa_offset 24
 17500              		.loc 1 8548 0
 17501 0006 2368     		ldr	r3, [r4]
8545:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 17502              		.loc 1 8545 0
 17503 0008 0022     		movs	r2, #0
 17504 000a 8DF80720 		strb	r2, [sp, #7]
 17505              	.LVL2214:
 17506              		.loc 1 8548 0
 17507 000e E3B1     		cbz	r3, .L1926
8549:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
8550:Src/bno055.c  **** 		} else {
8551:Src/bno055.c  **** 		/*condition check for page, z-axis remap sign is
8552:Src/bno055.c  **** 		available in the page zero*/
8553:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
ARM GAS  /tmp/ccVWLGiI.s 			page 490


 17508              		.loc 1 8553 0
 17509 0010 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 17510 0012 0546     		mov	r5, r0
 17511 0014 71B9     		cbnz	r1, .L1932
 17512              	.LVL2215:
 17513              	.L1924:
8554:Src/bno055.c  **** 			/* Write the page zero*/
8555:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
8556:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
8557:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
8558:Src/bno055.c  **** 			/* Read the value of z-axis remap sign*/
8559:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 17514              		.loc 1 8559 0
 17515 0016 1C69     		ldr	r4, [r3, #16]
 17516 0018 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17517 001a 4221     		movs	r1, #66
 17518 001c 0123     		movs	r3, #1
 17519 001e 0DF10702 		add	r2, sp, #7
 17520 0022 A047     		blx	r4
 17521              	.LVL2216:
8560:Src/bno055.c  **** 			(p_bno055->dev_addr,
8561:Src/bno055.c  **** 			BNO055_REMAP_Z_SIGN_REG,
8562:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8563:Src/bno055.c  **** 			*remap_z_sign_u8 =
 17522              		.loc 1 8563 0
 17523 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17524 0028 03F00103 		and	r3, r3, #1
 17525 002c 2B70     		strb	r3, [r5]
 17526              	.LVL2217:
 17527              	.L1923:
8564:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
8565:Src/bno055.c  **** 			BNO055_REMAP_Z_SIGN);
8566:Src/bno055.c  **** 		} else {
8567:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
8568:Src/bno055.c  **** 		}
8569:Src/bno055.c  **** 	}
8570:Src/bno055.c  **** 	return com_rslt;
8571:Src/bno055.c  **** }
 17528              		.loc 1 8571 0
 17529 002e 40B2     		sxtb	r0, r0
 17530 0030 03B0     		add	sp, sp, #12
 17531              	.LCFI756:
 17532              		.cfi_remember_state
 17533              		.cfi_def_cfa_offset 12
 17534              		@ sp needed
 17535 0032 30BD     		pop	{r4, r5, pc}
 17536              	.LVL2218:
 17537              	.L1932:
 17538              	.LCFI757:
 17539              		.cfi_restore_state
8555:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 17540              		.loc 1 8555 0
 17541 0034 1046     		mov	r0, r2
 17542              	.LVL2219:
 17543 0036 FFF7FEFF 		bl	bno055_write_page_id
 17544              	.LVL2220:
 17545 003a 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 491


8556:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17546              		.loc 1 8556 0
 17547 003c 0028     		cmp	r0, #0
 17548 003e EAD0     		beq	.L1924
 17549              	.LVL2221:
8556:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17550              		.loc 1 8556 0 is_stmt 0 discriminator 1
 17551 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
8567:Src/bno055.c  **** 		}
 17552              		.loc 1 8567 0 is_stmt 1 discriminator 1
 17553 0042 FF20     		movs	r0, #255
8556:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17554              		.loc 1 8556 0 discriminator 1
 17555 0044 002A     		cmp	r2, #0
 17556 0046 F2D1     		bne	.L1923
 17557 0048 E5E7     		b	.L1924
 17558              	.LVL2222:
 17559              	.L1926:
8549:Src/bno055.c  **** 		} else {
 17560              		.loc 1 8549 0
 17561 004a 8120     		movs	r0, #129
 17562              	.LVL2223:
 17563 004c EFE7     		b	.L1923
 17564              	.L1934:
 17565 004e 00BF     		.align	2
 17566              	.L1933:
 17567 0050 00000000 		.word	.LANCHOR0
 17568              		.cfi_endproc
 17569              	.LFE165:
 17571              		.section	.text.bno055_set_remap_z_sign,"ax",%progbits
 17572              		.align	2
 17573              		.global	bno055_set_remap_z_sign
 17574              		.thumb
 17575              		.thumb_func
 17577              	bno055_set_remap_z_sign:
 17578              	.LFB166:
8572:Src/bno055.c  **** /*!
8573:Src/bno055.c  ****  *	@brief This API used to write the z-axis remap
8574:Src/bno055.c  ****  *	sign from register from 0x42 bit 0
8575:Src/bno055.c  ****  *
8576:Src/bno055.c  ****  *	@param remap_z_sign_u8 : The value of z-axis remap sign
8577:Src/bno055.c  ****  *
8578:Src/bno055.c  ****  *    remap_z_sign_u8  |   result
8579:Src/bno055.c  ****  *   ------------------- |--------------------
8580:Src/bno055.c  ****  *      0X00             | BNO055_REMAP_AXIS_POSITIVE
8581:Src/bno055.c  ****  *      0X01             | BNO055_REMAP_AXIS_NEGATIVE
8582:Src/bno055.c  ****  *
8583:Src/bno055.c  ****  *	@return results of bus communication function
8584:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8585:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8586:Src/bno055.c  ****  *
8587:Src/bno055.c  ****  */
8588:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_remap_z_sign(
8589:Src/bno055.c  **** u8 remap_z_sign_u8)
8590:Src/bno055.c  **** {
 17579              		.loc 1 8590 0
 17580              		.cfi_startproc
ARM GAS  /tmp/ccVWLGiI.s 			page 492


 17581              		@ args = 0, pretend = 0, frame = 8
 17582              		@ frame_needed = 0, uses_anonymous_args = 0
 17583              	.LVL2224:
 17584 0000 30B5     		push	{r4, r5, lr}
 17585              	.LCFI758:
 17586              		.cfi_def_cfa_offset 12
 17587              		.cfi_offset 4, -12
 17588              		.cfi_offset 5, -8
 17589              		.cfi_offset 14, -4
8591:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8592:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
8593:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
8594:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
8595:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
8596:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 17590              		.loc 1 8596 0
 17591 0002 244C     		ldr	r4, .L1951
8590:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 17592              		.loc 1 8590 0
 17593 0004 83B0     		sub	sp, sp, #12
 17594              	.LCFI759:
 17595              		.cfi_def_cfa_offset 24
 17596              		.loc 1 8596 0
 17597 0006 2268     		ldr	r2, [r4]
8592:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 17598              		.loc 1 8592 0
 17599 0008 0023     		movs	r3, #0
 17600 000a 8DF80630 		strb	r3, [sp, #6]
8593:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 17601              		.loc 1 8593 0
 17602 000e 8DF80730 		strb	r3, [sp, #7]
 17603              	.LVL2225:
 17604              		.loc 1 8596 0
 17605 0012 002A     		cmp	r2, #0
 17606 0014 3BD0     		beq	.L1943
 17607 0016 0546     		mov	r5, r0
8597:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
8598:Src/bno055.c  **** 	} else {
8599:Src/bno055.c  **** 		/* The write operation effective only if the operation
8600:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
8601:Src/bno055.c  **** 		current operation mode and set the config mode */
8602:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 17608              		.loc 1 8602 0
 17609 0018 0DF10700 		add	r0, sp, #7
 17610              	.LVL2226:
 17611 001c FFF7FEFF 		bl	bno055_get_operation_mode
 17612              	.LVL2227:
8603:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 17613              		.loc 1 8603 0
 17614 0020 38B1     		cbz	r0, .L1937
 17615              	.L1942:
8604:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
8605:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
8606:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
8607:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
8608:Src/bno055.c  **** 				/* Write the value of z-axis remap sign*/
8609:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 493


8610:Src/bno055.c  **** 				(p_bno055->dev_addr,
8611:Src/bno055.c  **** 				BNO055_REMAP_Z_SIGN_REG,
8612:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
8613:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
8614:Src/bno055.c  **** 					data_u8r =
8615:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
8616:Src/bno055.c  **** 					BNO055_REMAP_Z_SIGN,
8617:Src/bno055.c  **** 					remap_z_sign_u8);
8618:Src/bno055.c  **** 					com_rslt +=
8619:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
8620:Src/bno055.c  **** 					(p_bno055->dev_addr,
8621:Src/bno055.c  **** 					BNO055_REMAP_Z_SIGN_REG,
8622:Src/bno055.c  **** 					&data_u8r,
8623:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8624:Src/bno055.c  **** 				}
8625:Src/bno055.c  **** 			} else {
8626:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
8627:Src/bno055.c  **** 			}
8628:Src/bno055.c  **** 		} else {
8629:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 17616              		.loc 1 8629 0
 17617 0022 FF24     		movs	r4, #255
 17618              	.LVL2228:
 17619              	.L1938:
8630:Src/bno055.c  **** 		}
8631:Src/bno055.c  **** 	}
8632:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 17620              		.loc 1 8632 0
 17621 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 17622 0028 28BB     		cbnz	r0, .L1950
 17623 002a 2046     		mov	r0, r4
 17624              	.LVL2229:
 17625              	.L1936:
8633:Src/bno055.c  **** 		/* set the operation mode
8634:Src/bno055.c  **** 		of previous operation mode*/
8635:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
8636:Src/bno055.c  **** 		(prev_opmode_u8);
8637:Src/bno055.c  **** 	return com_rslt;
8638:Src/bno055.c  **** }
 17626              		.loc 1 8638 0
 17627 002c 40B2     		sxtb	r0, r0
 17628 002e 03B0     		add	sp, sp, #12
 17629              	.LCFI760:
 17630              		.cfi_remember_state
 17631              		.cfi_def_cfa_offset 12
 17632              		@ sp needed
 17633 0030 30BD     		pop	{r4, r5, pc}
 17634              	.LVL2230:
 17635              	.L1937:
 17636              	.LCFI761:
 17637              		.cfi_restore_state
8604:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 17638              		.loc 1 8604 0
 17639 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17640 0036 2BBB     		cbnz	r3, .L1939
 17641              	.L1941:
 17642              	.LVL2231:
ARM GAS  /tmp/ccVWLGiI.s 			page 494


8609:Src/bno055.c  **** 				(p_bno055->dev_addr,
 17643              		.loc 1 8609 0
 17644 0038 2368     		ldr	r3, [r4]
 17645 003a 0DF10602 		add	r2, sp, #6
 17646 003e 1C69     		ldr	r4, [r3, #16]
 17647 0040 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17648 0042 4221     		movs	r1, #66
 17649 0044 0123     		movs	r3, #1
 17650 0046 A047     		blx	r4
 17651              	.LVL2232:
 17652 0048 124B     		ldr	r3, .L1951
8613:Src/bno055.c  **** 					data_u8r =
 17653              		.loc 1 8613 0
 17654 004a 0446     		mov	r4, r0
 17655 004c 0028     		cmp	r0, #0
 17656 004e E9D1     		bne	.L1938
8614:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17657              		.loc 1 8614 0
 17658 0050 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
8619:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17659              		.loc 1 8619 0
 17660 0054 1B68     		ldr	r3, [r3]
8614:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17661              		.loc 1 8614 0
 17662 0056 05F00100 		and	r0, r5, #1
 17663              	.LVL2233:
 17664 005a 22F00105 		bic	r5, r2, #1
 17665 005e 2843     		orrs	r0, r0, r5
8619:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17666              		.loc 1 8619 0
 17667 0060 DC68     		ldr	r4, [r3, #12]
8614:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 17668              		.loc 1 8614 0
 17669 0062 8DF80600 		strb	r0, [sp, #6]
8619:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17670              		.loc 1 8619 0
 17671 0066 0DF10602 		add	r2, sp, #6
 17672 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17673 006c 4221     		movs	r1, #66
 17674 006e 0123     		movs	r3, #1
 17675 0070 A047     		blx	r4
 17676              	.LVL2234:
 17677 0072 0446     		mov	r4, r0
 17678              	.LVL2235:
 17679 0074 D6E7     		b	.L1938
 17680              	.L1950:
8635:Src/bno055.c  **** 		(prev_opmode_u8);
 17681              		.loc 1 8635 0
 17682 0076 FFF7FEFF 		bl	bno055_set_operation_mode
 17683              	.LVL2236:
 17684 007a 2044     		add	r0, r0, r4
 17685 007c C0B2     		uxtb	r0, r0
 17686              	.LVL2237:
 17687              		.loc 1 8638 0
 17688 007e 40B2     		sxtb	r0, r0
 17689 0080 03B0     		add	sp, sp, #12
 17690              	.LCFI762:
ARM GAS  /tmp/ccVWLGiI.s 			page 495


 17691              		.cfi_remember_state
 17692              		.cfi_def_cfa_offset 12
 17693              		@ sp needed
 17694 0082 30BD     		pop	{r4, r5, pc}
 17695              	.LVL2238:
 17696              	.L1939:
 17697              	.LCFI763:
 17698              		.cfi_restore_state
8605:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 17699              		.loc 1 8605 0
 17700 0084 FFF7FEFF 		bl	bno055_set_operation_mode
 17701              	.LVL2239:
8607:Src/bno055.c  **** 				/* Write the value of z-axis remap sign*/
 17702              		.loc 1 8607 0
 17703 0088 0028     		cmp	r0, #0
 17704 008a CAD1     		bne	.L1942
 17705 008c D4E7     		b	.L1941
 17706              	.LVL2240:
 17707              	.L1943:
8597:Src/bno055.c  **** 	} else {
 17708              		.loc 1 8597 0
 17709 008e 8120     		movs	r0, #129
 17710              	.LVL2241:
 17711 0090 CCE7     		b	.L1936
 17712              	.L1952:
 17713 0092 00BF     		.align	2
 17714              	.L1951:
 17715 0094 00000000 		.word	.LANCHOR0
 17716              		.cfi_endproc
 17717              	.LFE166:
 17719              		.section	.text.bno055_read_sic_matrix,"ax",%progbits
 17720              		.align	2
 17721              		.global	bno055_read_sic_matrix
 17722              		.thumb
 17723              		.thumb_func
 17725              	bno055_read_sic_matrix:
 17726              	.LFB167:
8639:Src/bno055.c  **** /*!
8640:Src/bno055.c  ****  *	@brief This API is used to read soft iron calibration matrix
8641:Src/bno055.c  ****  *	from the register 0x43 to 0x53 it is a 18 bytes of data
8642:Src/bno055.c  ****  *
8643:Src/bno055.c  ****  *	@param sic_matrix : The value of soft iron calibration matrix
8644:Src/bno055.c  ****  *
8645:Src/bno055.c  ****  *	sic_matrix         |           result
8646:Src/bno055.c  ****  * --------------------|----------------------------------
8647:Src/bno055.c  ****  *       sic_0         | soft iron calibration matrix zero
8648:Src/bno055.c  ****  *       sic_1         | soft iron calibration matrix one
8649:Src/bno055.c  ****  *       sic_2         | soft iron calibration matrix two
8650:Src/bno055.c  ****  *       sic_3         | soft iron calibration matrix three
8651:Src/bno055.c  ****  *       sic_4         | soft iron calibration matrix four
8652:Src/bno055.c  ****  *       sic_5         | soft iron calibration matrix five
8653:Src/bno055.c  ****  *       sic_6         | soft iron calibration matrix six
8654:Src/bno055.c  ****  *       sic_7         | soft iron calibration matrix seven
8655:Src/bno055.c  ****  *       sic_8         | soft iron calibration matrix eight
8656:Src/bno055.c  ****  *
8657:Src/bno055.c  ****  *
8658:Src/bno055.c  ****  *	@return results of bus communication function
ARM GAS  /tmp/ccVWLGiI.s 			page 496


8659:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8660:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8661:Src/bno055.c  ****  *
8662:Src/bno055.c  ****  *	@note : Each soft iron calibration matrix range from -32768 to +32767
8663:Src/bno055.c  ****  */
8664:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_sic_matrix(
8665:Src/bno055.c  **** struct bno055_sic_matrix_t  *sic_matrix)
8666:Src/bno055.c  **** {
 17727              		.loc 1 8666 0
 17728              		.cfi_startproc
 17729              		@ args = 0, pretend = 0, frame = 24
 17730              		@ frame_needed = 0, uses_anonymous_args = 0
 17731              	.LVL2242:
 17732 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 17733              	.LCFI764:
 17734              		.cfi_def_cfa_offset 36
 17735              		.cfi_offset 4, -36
 17736              		.cfi_offset 5, -32
 17737              		.cfi_offset 6, -28
 17738              		.cfi_offset 7, -24
 17739              		.cfi_offset 8, -20
 17740              		.cfi_offset 9, -16
 17741              		.cfi_offset 10, -12
 17742              		.cfi_offset 11, -8
 17743              		.cfi_offset 14, -4
8667:Src/bno055.c  **** 	/* Variable used to return value of
8668:Src/bno055.c  **** 	communication routine*/
8669:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8670:Src/bno055.c  **** 	/* Array holding the soft iron calibration matrix values
8671:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_0_LSB] - sic_0->LSB
8672:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_0_MSB] - sic_0->MSB
8673:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_1_LSB] - sic_1->LSB
8674:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_1_MSB] - sic_1->MSB
8675:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_2_LSB] - sic_2->LSB
8676:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_2_MSB] - sic_2->MSB
8677:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_3_LSB] - sic_3->LSB
8678:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_3_MSB] - sic_3->MSB
8679:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_4_LSB] - sic_4->LSB
8680:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_4_MSB] - sic_4->MSB
8681:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_5_LSB] - sic_5->LSB
8682:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_5_MSB] - sic_5->MSB
8683:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_6_LSB] - sic_6->LSB
8684:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_6_MSB] - sic_6->MSB
8685:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_7_LSB] - sic_7->LSB
8686:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_7_MSB] - sic_7->MSB
8687:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_8_LSB] - sic_8->LSB
8688:Src/bno055.c  **** 	data_u8[BNO055_SOFT_IRON_CALIB_8_MSB] - sic_8->MSB
8689:Src/bno055.c  **** 	*/
8690:Src/bno055.c  **** 	u8 data_u8[BNO055_SOFT_IRON_CALIBRATION_MATRIX_SIZE] = {
8691:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8692:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8693:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8694:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8695:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8696:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8697:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
8698:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
ARM GAS  /tmp/ccVWLGiI.s 			page 497


8699:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
8700:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
8701:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
8702:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 17744              		.loc 1 8702 0
 17745 0004 364D     		ldr	r5, .L1968
8666:Src/bno055.c  **** 	/* Variable used to return value of
 17746              		.loc 1 8666 0
 17747 0006 87B0     		sub	sp, sp, #28
 17748              	.LCFI765:
 17749              		.cfi_def_cfa_offset 64
 17750              		.loc 1 8702 0
 17751 0008 2A68     		ldr	r2, [r5]
8690:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 17752              		.loc 1 8690 0
 17753 000a 0023     		movs	r3, #0
 17754 000c 0193     		str	r3, [sp, #4]
 17755 000e 0293     		str	r3, [sp, #8]
 17756 0010 0393     		str	r3, [sp, #12]
 17757 0012 0493     		str	r3, [sp, #16]
 17758 0014 ADF81430 		strh	r3, [sp, #20]	@ movhi
 17759              	.LVL2243:
 17760              		.loc 1 8702 0
 17761 0018 002A     		cmp	r2, #0
 17762 001a 5FD0     		beq	.L1958
8703:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
8704:Src/bno055.c  **** 		} else {
8705:Src/bno055.c  **** 		/*condition check for page, soft iron calibration matrix is
8706:Src/bno055.c  **** 		available in the page zero*/
8707:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 17763              		.loc 1 8707 0
 17764 001c 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 17765 001e 0446     		mov	r4, r0
 17766 0020 0029     		cmp	r1, #0
 17767 0022 51D1     		bne	.L1966
 17768              	.LVL2244:
 17769              	.L1955:
8708:Src/bno055.c  **** 			/* Write the page zero*/
8709:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
8710:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
8711:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
8712:Src/bno055.c  **** 			/* Read soft iron calibration matrix value
8713:Src/bno055.c  **** 			it is eighteen bytes of data */
8714:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 17770              		.loc 1 8714 0
 17771 0024 1569     		ldr	r5, [r2, #16]
 17772 0026 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 17773 0028 4321     		movs	r1, #67
 17774 002a 01AA     		add	r2, sp, #4
 17775 002c 1223     		movs	r3, #18
 17776 002e A847     		blx	r5
 17777              	.LVL2245:
8715:Src/bno055.c  **** 			(p_bno055->dev_addr,
8716:Src/bno055.c  **** 			BNO055_SIC_MATRIX_0_LSB_REG,
8717:Src/bno055.c  **** 			data_u8, BNO055_SOFT_IRON_CALIBRATION_MATRIX_SIZE);
8718:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 17778              		.loc 1 8718 0
ARM GAS  /tmp/ccVWLGiI.s 			page 498


 17779 0030 20B1     		cbz	r0, .L1967
 17780              	.LVL2246:
 17781              	.L1957:
8719:Src/bno055.c  **** 				/*soft iron calibration matrix zero*/
8720:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_0_LSB] =
8721:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8722:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_0_LSB],
8723:Src/bno055.c  **** 				BNO055_SIC_MATRIX_0_LSB);
8724:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_0_MSB] =
8725:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8726:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_0_MSB],
8727:Src/bno055.c  **** 				BNO055_SIC_MATRIX_0_MSB);
8728:Src/bno055.c  **** 				sic_matrix->sic_0 = (s16)((((s32)
8729:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_0_MSB])) <<
8730:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS))
8731:Src/bno055.c  **** 				| (data_u8[BNO055_SOFT_IRON_CALIB_0_LSB]));
8732:Src/bno055.c  **** 
8733:Src/bno055.c  **** 				/*soft iron calibration matrix one*/
8734:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_1_LSB] =
8735:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8736:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_1_LSB],
8737:Src/bno055.c  **** 				BNO055_SIC_MATRIX_1_LSB);
8738:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_1_MSB] =
8739:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8740:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_1_MSB],
8741:Src/bno055.c  **** 				BNO055_SIC_MATRIX_1_MSB);
8742:Src/bno055.c  **** 				sic_matrix->sic_1 = (s16)((((s32)
8743:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_1_MSB])) <<
8744:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS))
8745:Src/bno055.c  **** 				| (data_u8[BNO055_SOFT_IRON_CALIB_1_LSB]));
8746:Src/bno055.c  **** 
8747:Src/bno055.c  **** 				/*soft iron calibration matrix two*/
8748:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_2_LSB] =
8749:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8750:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_2_LSB],
8751:Src/bno055.c  **** 				BNO055_SIC_MATRIX_2_LSB);
8752:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_2_MSB] =
8753:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8754:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_2_MSB],
8755:Src/bno055.c  **** 				BNO055_SIC_MATRIX_2_MSB);
8756:Src/bno055.c  **** 				sic_matrix->sic_2 = (s16)((((s32)
8757:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_2_MSB])) <<
8758:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS))
8759:Src/bno055.c  **** 				| (data_u8[BNO055_SOFT_IRON_CALIB_2_LSB]));
8760:Src/bno055.c  **** 
8761:Src/bno055.c  **** 				/*soft iron calibration matrix three*/
8762:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_3_LSB] =
8763:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8764:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_3_LSB],
8765:Src/bno055.c  **** 				BNO055_SIC_MATRIX_3_LSB);
8766:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_3_MSB] =
8767:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8768:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_3_MSB],
8769:Src/bno055.c  **** 				BNO055_SIC_MATRIX_3_LSB);
8770:Src/bno055.c  **** 				sic_matrix->sic_3  = (s16)((((s32)
8771:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_3_MSB])) <<
8772:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
ARM GAS  /tmp/ccVWLGiI.s 			page 499


8773:Src/bno055.c  **** 				(data_u8[BNO055_SOFT_IRON_CALIB_3_LSB]));
8774:Src/bno055.c  **** 
8775:Src/bno055.c  **** 				/*soft iron calibration matrix four*/
8776:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_4_LSB] =
8777:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8778:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_4_LSB],
8779:Src/bno055.c  **** 				BNO055_SIC_MATRIX_4_LSB);
8780:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_4_MSB] =
8781:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8782:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_4_MSB],
8783:Src/bno055.c  **** 				BNO055_SIC_MATRIX_4_LSB);
8784:Src/bno055.c  **** 				sic_matrix->sic_4  = (s16)((((s32)
8785:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_4_MSB])) <<
8786:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
8787:Src/bno055.c  **** 				(data_u8[BNO055_SOFT_IRON_CALIB_4_LSB]));
8788:Src/bno055.c  **** 
8789:Src/bno055.c  **** 				/*soft iron calibration matrix five*/
8790:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_5_LSB] =
8791:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8792:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_5_LSB],
8793:Src/bno055.c  **** 				BNO055_SIC_MATRIX_5_LSB);
8794:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_5_MSB] =
8795:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8796:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_5_MSB],
8797:Src/bno055.c  **** 				BNO055_SIC_MATRIX_5_LSB);
8798:Src/bno055.c  **** 				sic_matrix->sic_5 = (s16)((((s32)
8799:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_5_MSB])) <<
8800:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
8801:Src/bno055.c  **** 				(data_u8[BNO055_SOFT_IRON_CALIB_5_LSB]));
8802:Src/bno055.c  **** 
8803:Src/bno055.c  **** 				/*soft iron calibration matrix six*/
8804:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_6_LSB] =
8805:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8806:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_6_LSB],
8807:Src/bno055.c  **** 				BNO055_SIC_MATRIX_6_LSB);
8808:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_6_MSB] =
8809:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8810:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_6_MSB],
8811:Src/bno055.c  **** 				BNO055_SIC_MATRIX_6_LSB);
8812:Src/bno055.c  **** 				sic_matrix->sic_6  = (s16)((((s32)
8813:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_6_MSB])) <<
8814:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
8815:Src/bno055.c  **** 				(data_u8[BNO055_SOFT_IRON_CALIB_6_LSB]));
8816:Src/bno055.c  **** 
8817:Src/bno055.c  **** 				/*soft iron calibration matrix seven*/
8818:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_7_LSB] =
8819:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8820:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_7_LSB],
8821:Src/bno055.c  **** 				BNO055_SIC_MATRIX_7_LSB);
8822:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_7_MSB] =
8823:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8824:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_7_MSB],
8825:Src/bno055.c  **** 				BNO055_SIC_MATRIX_7_LSB);
8826:Src/bno055.c  **** 				sic_matrix->sic_7  = (s16)((((s32)
8827:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_7_MSB])) <<
8828:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
8829:Src/bno055.c  **** 				(data_u8[BNO055_SOFT_IRON_CALIB_7_LSB]));
ARM GAS  /tmp/ccVWLGiI.s 			page 500


8830:Src/bno055.c  **** 
8831:Src/bno055.c  **** 				/*soft iron calibration matrix eight*/
8832:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_8_LSB] =
8833:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8834:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_8_LSB],
8835:Src/bno055.c  **** 				BNO055_SIC_MATRIX_8_LSB);
8836:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_8_MSB] =
8837:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
8838:Src/bno055.c  **** 				data_u8[BNO055_SOFT_IRON_CALIB_8_MSB],
8839:Src/bno055.c  **** 				BNO055_SIC_MATRIX_8_LSB);
8840:Src/bno055.c  **** 				sic_matrix->sic_8  = (s16)((((s32)
8841:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_8_MSB])) <<
8842:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
8843:Src/bno055.c  **** 				(data_u8[BNO055_SOFT_IRON_CALIB_8_LSB]));
8844:Src/bno055.c  **** 			} else {
8845:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
8846:Src/bno055.c  **** 			}
8847:Src/bno055.c  **** 		} else {
8848:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 17782              		.loc 1 8848 0
 17783 0032 FF20     		movs	r0, #255
 17784              	.LVL2247:
 17785              	.L1954:
8849:Src/bno055.c  **** 		}
8850:Src/bno055.c  **** 	}
8851:Src/bno055.c  **** 	return com_rslt;
8852:Src/bno055.c  **** }
 17786              		.loc 1 8852 0
 17787 0034 40B2     		sxtb	r0, r0
 17788 0036 07B0     		add	sp, sp, #28
 17789              	.LCFI766:
 17790              		.cfi_remember_state
 17791              		.cfi_def_cfa_offset 36
 17792              		@ sp needed
 17793 0038 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 17794              	.LVL2248:
 17795              	.L1967:
 17796              	.LCFI767:
 17797              		.cfi_restore_state
8728:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_0_MSB])) <<
 17798              		.loc 1 8728 0
 17799 003c 9DF905B0 		ldrsb	fp, [sp, #5]
8742:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_1_MSB])) <<
 17800              		.loc 1 8742 0
 17801 0040 9DF80610 		ldrb	r1, [sp, #6]	@ zero_extendqisi2
8756:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_2_MSB])) <<
 17802              		.loc 1 8756 0
 17803 0044 9DF909A0 		ldrsb	r10, [sp, #9]
8770:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_3_MSB])) <<
 17804              		.loc 1 8770 0
 17805 0048 9DF80A20 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
8784:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_4_MSB])) <<
 17806              		.loc 1 8784 0
 17807 004c 9DF90D90 		ldrsb	r9, [sp, #13]
8798:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_5_MSB])) <<
 17808              		.loc 1 8798 0
 17809 0050 9DF80E30 		ldrb	r3, [sp, #14]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 501


8728:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_0_MSB])) <<
 17810              		.loc 1 8728 0
 17811 0054 9DF80480 		ldrb	r8, [sp, #4]	@ zero_extendqisi2
8742:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_1_MSB])) <<
 17812              		.loc 1 8742 0
 17813 0058 9DF907C0 		ldrsb	ip, [sp, #7]
8756:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_2_MSB])) <<
 17814              		.loc 1 8756 0
 17815 005c 9DF808E0 		ldrb	lr, [sp, #8]	@ zero_extendqisi2
8770:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_3_MSB])) <<
 17816              		.loc 1 8770 0
 17817 0060 9DF90B70 		ldrsb	r7, [sp, #11]
8784:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_4_MSB])) <<
 17818              		.loc 1 8784 0
 17819 0064 9DF80C60 		ldrb	r6, [sp, #12]	@ zero_extendqisi2
8798:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_5_MSB])) <<
 17820              		.loc 1 8798 0
 17821 0068 9DF90F50 		ldrsb	r5, [sp, #15]
8728:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_0_MSB])) <<
 17822              		.loc 1 8728 0
 17823 006c 48EA0B28 		orr	r8, r8, fp, lsl #8
8742:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_1_MSB])) <<
 17824              		.loc 1 8742 0
 17825 0070 41EA0C2C 		orr	ip, r1, ip, lsl #8
8756:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_2_MSB])) <<
 17826              		.loc 1 8756 0
 17827 0074 4EEA0A2E 		orr	lr, lr, r10, lsl #8
8770:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_3_MSB])) <<
 17828              		.loc 1 8770 0
 17829 0078 42EA0727 		orr	r7, r2, r7, lsl #8
8784:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_4_MSB])) <<
 17830              		.loc 1 8784 0
 17831 007c 46EA0926 		orr	r6, r6, r9, lsl #8
8798:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_5_MSB])) <<
 17832              		.loc 1 8798 0
 17833 0080 43EA0525 		orr	r5, r3, r5, lsl #8
8812:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_6_MSB])) <<
 17834              		.loc 1 8812 0
 17835 0084 9DF911B0 		ldrsb	fp, [sp, #17]
 17836 0088 9DF81010 		ldrb	r1, [sp, #16]	@ zero_extendqisi2
8826:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_7_MSB])) <<
 17837              		.loc 1 8826 0
 17838 008c 9DF913A0 		ldrsb	r10, [sp, #19]
 17839 0090 9DF81220 		ldrb	r2, [sp, #18]	@ zero_extendqisi2
8840:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_8_MSB])) <<
 17840              		.loc 1 8840 0
 17841 0094 9DF91590 		ldrsb	r9, [sp, #21]
 17842 0098 9DF81430 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
8812:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_6_MSB])) <<
 17843              		.loc 1 8812 0
 17844 009c 41EA0B21 		orr	r1, r1, fp, lsl #8
8826:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_7_MSB])) <<
 17845              		.loc 1 8826 0
 17846 00a0 42EA0A22 		orr	r2, r2, r10, lsl #8
8840:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_8_MSB])) <<
 17847              		.loc 1 8840 0
 17848 00a4 43EA0923 		orr	r3, r3, r9, lsl #8
ARM GAS  /tmp/ccVWLGiI.s 			page 502


 17849              		.loc 1 8852 0
 17850 00a8 40B2     		sxtb	r0, r0
8728:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_0_MSB])) <<
 17851              		.loc 1 8728 0
 17852 00aa A4F80080 		strh	r8, [r4]	@ movhi
8742:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_1_MSB])) <<
 17853              		.loc 1 8742 0
 17854 00ae A4F802C0 		strh	ip, [r4, #2]	@ movhi
8756:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_2_MSB])) <<
 17855              		.loc 1 8756 0
 17856 00b2 A4F804E0 		strh	lr, [r4, #4]	@ movhi
8770:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_3_MSB])) <<
 17857              		.loc 1 8770 0
 17858 00b6 E780     		strh	r7, [r4, #6]	@ movhi
8784:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_4_MSB])) <<
 17859              		.loc 1 8784 0
 17860 00b8 2681     		strh	r6, [r4, #8]	@ movhi
8798:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_5_MSB])) <<
 17861              		.loc 1 8798 0
 17862 00ba 6581     		strh	r5, [r4, #10]	@ movhi
8812:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_6_MSB])) <<
 17863              		.loc 1 8812 0
 17864 00bc A181     		strh	r1, [r4, #12]	@ movhi
8826:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_7_MSB])) <<
 17865              		.loc 1 8826 0
 17866 00be E281     		strh	r2, [r4, #14]	@ movhi
8840:Src/bno055.c  **** 				(s8)(data_u8[BNO055_SOFT_IRON_CALIB_8_MSB])) <<
 17867              		.loc 1 8840 0
 17868 00c0 2382     		strh	r3, [r4, #16]	@ movhi
 17869              		.loc 1 8852 0
 17870 00c2 07B0     		add	sp, sp, #28
 17871              	.LCFI768:
 17872              		.cfi_remember_state
 17873              		.cfi_def_cfa_offset 36
 17874              		@ sp needed
 17875 00c4 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 17876              	.LVL2249:
 17877              	.L1966:
 17878              	.LCFI769:
 17879              		.cfi_restore_state
8709:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 17880              		.loc 1 8709 0
 17881 00c8 1846     		mov	r0, r3
 17882              	.LVL2250:
 17883 00ca FFF7FEFF 		bl	bno055_write_page_id
 17884              	.LVL2251:
 17885 00ce 2A68     		ldr	r2, [r5]
8710:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17886              		.loc 1 8710 0
 17887 00d0 0028     		cmp	r0, #0
 17888 00d2 A7D0     		beq	.L1955
 17889              	.LVL2252:
8710:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 17890              		.loc 1 8710 0 is_stmt 0 discriminator 1
 17891 00d4 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 17892 00d6 002B     		cmp	r3, #0
 17893 00d8 ABD1     		bne	.L1957
ARM GAS  /tmp/ccVWLGiI.s 			page 503


 17894 00da A3E7     		b	.L1955
 17895              	.LVL2253:
 17896              	.L1958:
8703:Src/bno055.c  **** 		} else {
 17897              		.loc 1 8703 0 is_stmt 1
 17898 00dc 8120     		movs	r0, #129
 17899              	.LVL2254:
 17900 00de A9E7     		b	.L1954
 17901              	.L1969:
 17902              		.align	2
 17903              	.L1968:
 17904 00e0 00000000 		.word	.LANCHOR0
 17905              		.cfi_endproc
 17906              	.LFE167:
 17908              		.section	.text.bno055_write_sic_matrix,"ax",%progbits
 17909              		.align	2
 17910              		.global	bno055_write_sic_matrix
 17911              		.thumb
 17912              		.thumb_func
 17914              	bno055_write_sic_matrix:
 17915              	.LFB168:
8853:Src/bno055.c  **** /*!
8854:Src/bno055.c  ****  *	@brief This API is used to write soft iron calibration matrix
8855:Src/bno055.c  ****  *	from the register 0x43 to 0x53 it is a 18 bytes of data
8856:Src/bno055.c  ****  *
8857:Src/bno055.c  ****  *	@param sic_matrix : The value of soft iron calibration matrix
8858:Src/bno055.c  ****  *
8859:Src/bno055.c  ****  *	sic_matrix         |           result
8860:Src/bno055.c  ****  * --------------------|----------------------------------
8861:Src/bno055.c  ****  *       sic_0         | soft iron calibration matrix zero
8862:Src/bno055.c  ****  *       sic_1         | soft iron calibration matrix one
8863:Src/bno055.c  ****  *       sic_2         | soft iron calibration matrix two
8864:Src/bno055.c  ****  *       sic_3         | soft iron calibration matrix three
8865:Src/bno055.c  ****  *       sic_4         | soft iron calibration matrix four
8866:Src/bno055.c  ****  *       sic_5         | soft iron calibration matrix five
8867:Src/bno055.c  ****  *       sic_6         | soft iron calibration matrix six
8868:Src/bno055.c  ****  *       sic_7         | soft iron calibration matrix seven
8869:Src/bno055.c  ****  *       sic_8         | soft iron calibration matrix eight
8870:Src/bno055.c  ****  *
8871:Src/bno055.c  ****  *
8872:Src/bno055.c  ****  *	@return results of bus communication function
8873:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
8874:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
8875:Src/bno055.c  ****  *
8876:Src/bno055.c  ****  *	@note : Each soft iron calibration matrix range from -32768 to +32767
8877:Src/bno055.c  ****  */
8878:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_write_sic_matrix(
8879:Src/bno055.c  **** struct bno055_sic_matrix_t  *sic_matrix)
8880:Src/bno055.c  **** {
 17916              		.loc 1 8880 0
 17917              		.cfi_startproc
 17918              		@ args = 0, pretend = 0, frame = 8
 17919              		@ frame_needed = 0, uses_anonymous_args = 0
 17920              	.LVL2255:
 17921 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 17922              	.LCFI770:
 17923              		.cfi_def_cfa_offset 20
ARM GAS  /tmp/ccVWLGiI.s 			page 504


 17924              		.cfi_offset 4, -20
 17925              		.cfi_offset 5, -16
 17926              		.cfi_offset 6, -12
 17927              		.cfi_offset 7, -8
 17928              		.cfi_offset 14, -4
8881:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
8882:Src/bno055.c  **** u8 data1_u8r = BNO055_INIT_VALUE;
8883:Src/bno055.c  **** u8 data2_u8r = BNO055_INIT_VALUE;
8884:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
8885:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
8886:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
8887:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 17929              		.loc 1 8887 0
 17930 0002 AB4C     		ldr	r4, .L2020
8880:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 17931              		.loc 1 8880 0
 17932 0004 83B0     		sub	sp, sp, #12
 17933              	.LCFI771:
 17934              		.cfi_def_cfa_offset 32
 17935              		.loc 1 8887 0
 17936 0006 2268     		ldr	r2, [r4]
8883:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 17937              		.loc 1 8883 0
 17938 0008 0023     		movs	r3, #0
 17939 000a 8DF80630 		strb	r3, [sp, #6]
8884:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 17940              		.loc 1 8884 0
 17941 000e 8DF80730 		strb	r3, [sp, #7]
 17942              	.LVL2256:
 17943              		.loc 1 8887 0
 17944 0012 002A     		cmp	r2, #0
 17945 0014 00F04382 		beq	.L1995
 17946 0018 0546     		mov	r5, r0
8888:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
8889:Src/bno055.c  **** 	} else {
8890:Src/bno055.c  **** 	/* The write operation effective only if the operation
8891:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
8892:Src/bno055.c  **** 		current operation mode and set the config mode */
8893:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 17947              		.loc 1 8893 0
 17948 001a 0DF10700 		add	r0, sp, #7
 17949              	.LVL2257:
 17950 001e FFF7FEFF 		bl	bno055_get_operation_mode
 17951              	.LVL2258:
8894:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 17952              		.loc 1 8894 0
 17953 0022 48B1     		cbz	r0, .L1972
 17954              	.L1978:
8895:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
8896:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
8897:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
8898:Src/bno055.c  **** 				if (stat_s8 == BNO055_SUCCESS) {
8899:Src/bno055.c  **** 					/* write soft iron calibration
8900:Src/bno055.c  **** 					matrix zero value*/
8901:Src/bno055.c  **** 					com_rslt =
8902:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
8903:Src/bno055.c  **** 					(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 505


8904:Src/bno055.c  **** 					BNO055_SIC_MATRIX_0_LSB_REG,
8905:Src/bno055.c  **** 					&data2_u8r,
8906:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8907:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
8908:Src/bno055.c  **** 						data1_u8r = ((s8)
8909:Src/bno055.c  **** 						(sic_matrix->sic_0
8910:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
8911:Src/bno055.c  **** 						data2_u8r =
8912:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
8913:Src/bno055.c  **** 						BNO055_SIC_MATRIX_0_LSB,
8914:Src/bno055.c  **** 						data1_u8r);
8915:Src/bno055.c  **** 						com_rslt +=
8916:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
8917:Src/bno055.c  **** 						(p_bno055->dev_addr,
8918:Src/bno055.c  **** 						BNO055_SIC_MATRIX_0_LSB_REG,
8919:Src/bno055.c  **** 						&data2_u8r,
8920:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
8921:Src/bno055.c  **** 					}
8922:Src/bno055.c  **** 
8923:Src/bno055.c  **** 					com_rslt +=
8924:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
8925:Src/bno055.c  **** 					(p_bno055->dev_addr,
8926:Src/bno055.c  **** 					BNO055_SIC_MATRIX_0_MSB_REG,
8927:Src/bno055.c  **** 					&data2_u8r,
8928:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8929:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
8930:Src/bno055.c  **** 						data1_u8r = ((s8)
8931:Src/bno055.c  **** 						(sic_matrix->sic_0  >>
8932:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
8933:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
8934:Src/bno055.c  **** 						data2_u8r =
8935:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
8936:Src/bno055.c  **** 						BNO055_SIC_MATRIX_0_MSB,
8937:Src/bno055.c  **** 						data1_u8r);
8938:Src/bno055.c  **** 						com_rslt +=
8939:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
8940:Src/bno055.c  **** 						(p_bno055->dev_addr,
8941:Src/bno055.c  **** 						BNO055_SIC_MATRIX_0_MSB_REG,
8942:Src/bno055.c  **** 						&data2_u8r,
8943:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
8944:Src/bno055.c  **** 					}
8945:Src/bno055.c  **** 
8946:Src/bno055.c  **** 					/* write soft iron calibration
8947:Src/bno055.c  **** 					matrix one value*/
8948:Src/bno055.c  **** 					com_rslt +=
8949:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
8950:Src/bno055.c  **** 					(p_bno055->dev_addr,
8951:Src/bno055.c  **** 					BNO055_SIC_MATRIX_1_LSB_REG,
8952:Src/bno055.c  **** 					&data2_u8r,
8953:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8954:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
8955:Src/bno055.c  **** 						data1_u8r = ((s8)
8956:Src/bno055.c  **** 						(sic_matrix->sic_1
8957:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
8958:Src/bno055.c  **** 						data2_u8r =
8959:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
8960:Src/bno055.c  **** 						BNO055_SIC_MATRIX_1_LSB,
ARM GAS  /tmp/ccVWLGiI.s 			page 506


8961:Src/bno055.c  **** 						data1_u8r);
8962:Src/bno055.c  **** 						com_rslt +=
8963:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
8964:Src/bno055.c  **** 						(p_bno055->dev_addr,
8965:Src/bno055.c  **** 						BNO055_SIC_MATRIX_1_LSB_REG,
8966:Src/bno055.c  **** 						&data2_u8r,
8967:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
8968:Src/bno055.c  **** 					}
8969:Src/bno055.c  **** 
8970:Src/bno055.c  **** 					com_rslt +=
8971:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
8972:Src/bno055.c  **** 					(p_bno055->dev_addr,
8973:Src/bno055.c  **** 					BNO055_SIC_MATRIX_1_MSB_REG,
8974:Src/bno055.c  **** 					&data2_u8r,
8975:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
8976:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
8977:Src/bno055.c  **** 						data1_u8r = ((s8)
8978:Src/bno055.c  **** 						(sic_matrix->sic_1  >>
8979:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
8980:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
8981:Src/bno055.c  **** 						data2_u8r =
8982:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
8983:Src/bno055.c  **** 						BNO055_SIC_MATRIX_1_MSB,
8984:Src/bno055.c  **** 						data1_u8r);
8985:Src/bno055.c  **** 						com_rslt +=
8986:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
8987:Src/bno055.c  **** 						(p_bno055->dev_addr,
8988:Src/bno055.c  **** 						BNO055_SIC_MATRIX_1_MSB_REG,
8989:Src/bno055.c  **** 						&data2_u8r,
8990:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
8991:Src/bno055.c  **** 					}
8992:Src/bno055.c  **** 
8993:Src/bno055.c  **** 				/* write soft iron calibration
8994:Src/bno055.c  **** 				matrix two value*/
8995:Src/bno055.c  **** 					com_rslt +=
8996:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
8997:Src/bno055.c  **** 					(p_bno055->dev_addr,
8998:Src/bno055.c  **** 					BNO055_SIC_MATRIX_2_LSB_REG,
8999:Src/bno055.c  **** 					&data2_u8r,
9000:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9001:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9002:Src/bno055.c  **** 						data1_u8r = ((s8)
9003:Src/bno055.c  **** 						(sic_matrix->sic_2
9004:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9005:Src/bno055.c  **** 						data2_u8r =
9006:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9007:Src/bno055.c  **** 						BNO055_SIC_MATRIX_2_LSB,
9008:Src/bno055.c  **** 						data1_u8r);
9009:Src/bno055.c  **** 						com_rslt +=
9010:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9011:Src/bno055.c  **** 						(p_bno055->dev_addr,
9012:Src/bno055.c  **** 						BNO055_SIC_MATRIX_2_LSB_REG,
9013:Src/bno055.c  **** 						&data2_u8r,
9014:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9015:Src/bno055.c  **** 					}
9016:Src/bno055.c  **** 
9017:Src/bno055.c  **** 					com_rslt +=
ARM GAS  /tmp/ccVWLGiI.s 			page 507


9018:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9019:Src/bno055.c  **** 					(p_bno055->dev_addr,
9020:Src/bno055.c  **** 					BNO055_SIC_MATRIX_2_MSB_REG,
9021:Src/bno055.c  **** 					&data2_u8r,
9022:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9023:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9024:Src/bno055.c  **** 						data1_u8r = ((s8)
9025:Src/bno055.c  **** 						(sic_matrix->sic_2 >>
9026:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9027:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9028:Src/bno055.c  **** 						data2_u8r =
9029:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9030:Src/bno055.c  **** 						BNO055_SIC_MATRIX_2_MSB,
9031:Src/bno055.c  **** 						data1_u8r);
9032:Src/bno055.c  **** 						com_rslt +=
9033:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9034:Src/bno055.c  **** 						(p_bno055->dev_addr,
9035:Src/bno055.c  **** 						BNO055_SIC_MATRIX_2_MSB_REG,
9036:Src/bno055.c  **** 						&data2_u8r,
9037:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9038:Src/bno055.c  **** 					}
9039:Src/bno055.c  **** 
9040:Src/bno055.c  **** 					/* write soft iron calibration
9041:Src/bno055.c  **** 					matrix three value*/
9042:Src/bno055.c  **** 					com_rslt +=
9043:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9044:Src/bno055.c  **** 					(p_bno055->dev_addr,
9045:Src/bno055.c  **** 					BNO055_SIC_MATRIX_3_LSB_REG,
9046:Src/bno055.c  **** 					&data2_u8r,
9047:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9048:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9049:Src/bno055.c  **** 						data1_u8r = ((s8)
9050:Src/bno055.c  **** 						(sic_matrix->sic_3
9051:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9052:Src/bno055.c  **** 						data2_u8r =
9053:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9054:Src/bno055.c  **** 						BNO055_SIC_MATRIX_3_LSB,
9055:Src/bno055.c  **** 						data1_u8r);
9056:Src/bno055.c  **** 						com_rslt +=
9057:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9058:Src/bno055.c  **** 						(p_bno055->dev_addr,
9059:Src/bno055.c  **** 						BNO055_SIC_MATRIX_3_LSB_REG,
9060:Src/bno055.c  **** 						&data2_u8r,
9061:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9062:Src/bno055.c  **** 					}
9063:Src/bno055.c  **** 
9064:Src/bno055.c  **** 					com_rslt +=
9065:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9066:Src/bno055.c  **** 					(p_bno055->dev_addr,
9067:Src/bno055.c  **** 					BNO055_SIC_MATRIX_3_MSB_REG,
9068:Src/bno055.c  **** 					&data2_u8r,
9069:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9070:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9071:Src/bno055.c  **** 						data1_u8r = ((s8)
9072:Src/bno055.c  **** 						(sic_matrix->sic_3 >>
9073:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9074:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
ARM GAS  /tmp/ccVWLGiI.s 			page 508


9075:Src/bno055.c  **** 						data2_u8r =
9076:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9077:Src/bno055.c  **** 						BNO055_SIC_MATRIX_3_MSB,
9078:Src/bno055.c  **** 						data1_u8r);
9079:Src/bno055.c  **** 						com_rslt +=
9080:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9081:Src/bno055.c  **** 						(p_bno055->dev_addr,
9082:Src/bno055.c  **** 						BNO055_SIC_MATRIX_3_MSB_REG,
9083:Src/bno055.c  **** 						&data2_u8r,
9084:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9085:Src/bno055.c  **** 					}
9086:Src/bno055.c  **** 
9087:Src/bno055.c  **** 					/* write soft iron calibration
9088:Src/bno055.c  **** 					matrix four value*/
9089:Src/bno055.c  **** 					com_rslt +=
9090:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9091:Src/bno055.c  **** 					(p_bno055->dev_addr,
9092:Src/bno055.c  **** 					BNO055_SIC_MATRIX_4_LSB_REG,
9093:Src/bno055.c  **** 					&data2_u8r,
9094:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9095:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9096:Src/bno055.c  **** 						data1_u8r = ((s8)
9097:Src/bno055.c  **** 						(sic_matrix->sic_4
9098:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9099:Src/bno055.c  **** 						data2_u8r =
9100:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9101:Src/bno055.c  **** 						BNO055_SIC_MATRIX_4_LSB,
9102:Src/bno055.c  **** 						data1_u8r);
9103:Src/bno055.c  **** 						com_rslt +=
9104:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9105:Src/bno055.c  **** 						(p_bno055->dev_addr,
9106:Src/bno055.c  **** 						BNO055_SIC_MATRIX_4_LSB_REG,
9107:Src/bno055.c  **** 						&data2_u8r,
9108:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9109:Src/bno055.c  **** 					}
9110:Src/bno055.c  **** 
9111:Src/bno055.c  **** 					com_rslt +=
9112:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9113:Src/bno055.c  **** 					(p_bno055->dev_addr,
9114:Src/bno055.c  **** 					BNO055_SIC_MATRIX_4_MSB_REG,
9115:Src/bno055.c  **** 					&data2_u8r,
9116:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9117:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9118:Src/bno055.c  **** 						data1_u8r = ((s8)
9119:Src/bno055.c  **** 						(sic_matrix->sic_4 >>
9120:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9121:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9122:Src/bno055.c  **** 						data2_u8r =
9123:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9124:Src/bno055.c  **** 						BNO055_SIC_MATRIX_4_MSB,
9125:Src/bno055.c  **** 						data1_u8r);
9126:Src/bno055.c  **** 						com_rslt +=
9127:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9128:Src/bno055.c  **** 						(p_bno055->dev_addr,
9129:Src/bno055.c  **** 						BNO055_SIC_MATRIX_4_MSB_REG,
9130:Src/bno055.c  **** 						&data2_u8r,
9131:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 509


9132:Src/bno055.c  **** 					}
9133:Src/bno055.c  **** 
9134:Src/bno055.c  **** 					/* write soft iron calibration
9135:Src/bno055.c  **** 					matrix five value*/
9136:Src/bno055.c  **** 					com_rslt +=
9137:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9138:Src/bno055.c  **** 					(p_bno055->dev_addr,
9139:Src/bno055.c  **** 					BNO055_SIC_MATRIX_5_LSB_REG,
9140:Src/bno055.c  **** 					&data2_u8r,
9141:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9142:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9143:Src/bno055.c  **** 						data1_u8r = ((s8)
9144:Src/bno055.c  **** 						(sic_matrix->sic_5
9145:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9146:Src/bno055.c  **** 						data2_u8r =
9147:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9148:Src/bno055.c  **** 						BNO055_SIC_MATRIX_5_LSB,
9149:Src/bno055.c  **** 						data1_u8r);
9150:Src/bno055.c  **** 						com_rslt +=
9151:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9152:Src/bno055.c  **** 						(p_bno055->dev_addr,
9153:Src/bno055.c  **** 						BNO055_SIC_MATRIX_5_LSB_REG,
9154:Src/bno055.c  **** 						&data2_u8r,
9155:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9156:Src/bno055.c  **** 					}
9157:Src/bno055.c  **** 
9158:Src/bno055.c  **** 					com_rslt +=
9159:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9160:Src/bno055.c  **** 					(p_bno055->dev_addr,
9161:Src/bno055.c  **** 					BNO055_SIC_MATRIX_5_MSB_REG,
9162:Src/bno055.c  **** 					&data2_u8r,
9163:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9164:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9165:Src/bno055.c  **** 						data1_u8r = ((s8)
9166:Src/bno055.c  **** 						(sic_matrix->sic_5 >>
9167:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9168:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9169:Src/bno055.c  **** 						data2_u8r =
9170:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9171:Src/bno055.c  **** 						BNO055_SIC_MATRIX_5_MSB,
9172:Src/bno055.c  **** 						data1_u8r);
9173:Src/bno055.c  **** 						com_rslt +=
9174:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9175:Src/bno055.c  **** 						(p_bno055->dev_addr,
9176:Src/bno055.c  **** 						BNO055_SIC_MATRIX_5_MSB_REG,
9177:Src/bno055.c  **** 						&data2_u8r,
9178:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9179:Src/bno055.c  **** 					}
9180:Src/bno055.c  **** 
9181:Src/bno055.c  **** 					/* write soft iron calibration
9182:Src/bno055.c  **** 					matrix six value*/
9183:Src/bno055.c  **** 					com_rslt +=
9184:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9185:Src/bno055.c  **** 					(p_bno055->dev_addr,
9186:Src/bno055.c  **** 					BNO055_SIC_MATRIX_6_LSB_REG,
9187:Src/bno055.c  **** 					&data2_u8r,
9188:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 510


9189:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9190:Src/bno055.c  **** 						data1_u8r = ((s8)
9191:Src/bno055.c  **** 						(sic_matrix->sic_6
9192:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9193:Src/bno055.c  **** 						data2_u8r =
9194:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9195:Src/bno055.c  **** 						BNO055_SIC_MATRIX_6_LSB,
9196:Src/bno055.c  **** 						data1_u8r);
9197:Src/bno055.c  **** 						com_rslt +=
9198:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9199:Src/bno055.c  **** 						(p_bno055->dev_addr,
9200:Src/bno055.c  **** 						BNO055_SIC_MATRIX_6_LSB_REG,
9201:Src/bno055.c  **** 						&data2_u8r,
9202:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9203:Src/bno055.c  **** 					}
9204:Src/bno055.c  **** 
9205:Src/bno055.c  **** 					com_rslt +=
9206:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9207:Src/bno055.c  **** 					(p_bno055->dev_addr,
9208:Src/bno055.c  **** 					BNO055_SIC_MATRIX_6_MSB_REG,
9209:Src/bno055.c  **** 					&data2_u8r,
9210:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9211:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9212:Src/bno055.c  **** 						data1_u8r = ((s8)
9213:Src/bno055.c  **** 						(sic_matrix->sic_6 >>
9214:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9215:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9216:Src/bno055.c  **** 						data2_u8r =
9217:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9218:Src/bno055.c  **** 						BNO055_SIC_MATRIX_6_MSB,
9219:Src/bno055.c  **** 						data1_u8r);
9220:Src/bno055.c  **** 						com_rslt +=
9221:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9222:Src/bno055.c  **** 						(p_bno055->dev_addr,
9223:Src/bno055.c  **** 						BNO055_SIC_MATRIX_6_MSB_REG,
9224:Src/bno055.c  **** 						&data2_u8r,
9225:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9226:Src/bno055.c  **** 					}
9227:Src/bno055.c  **** 
9228:Src/bno055.c  **** 					/* write soft iron calibration
9229:Src/bno055.c  **** 					matrix seven value*/
9230:Src/bno055.c  **** 					com_rslt +=
9231:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9232:Src/bno055.c  **** 					(p_bno055->dev_addr,
9233:Src/bno055.c  **** 					BNO055_SIC_MATRIX_7_LSB_REG,
9234:Src/bno055.c  **** 					&data2_u8r,
9235:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9236:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9237:Src/bno055.c  **** 						data1_u8r = ((s8)
9238:Src/bno055.c  **** 						(sic_matrix->sic_7
9239:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9240:Src/bno055.c  **** 						data2_u8r =
9241:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9242:Src/bno055.c  **** 						BNO055_SIC_MATRIX_7_LSB,
9243:Src/bno055.c  **** 						data1_u8r);
9244:Src/bno055.c  **** 						com_rslt +=
9245:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 511


9246:Src/bno055.c  **** 						(p_bno055->dev_addr,
9247:Src/bno055.c  **** 						BNO055_SIC_MATRIX_7_LSB_REG,
9248:Src/bno055.c  **** 						&data2_u8r,
9249:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9250:Src/bno055.c  **** 					}
9251:Src/bno055.c  **** 
9252:Src/bno055.c  **** 					com_rslt +=
9253:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9254:Src/bno055.c  **** 					(p_bno055->dev_addr,
9255:Src/bno055.c  **** 					BNO055_SIC_MATRIX_7_MSB_REG,
9256:Src/bno055.c  **** 					&data2_u8r,
9257:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9258:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9259:Src/bno055.c  **** 						data1_u8r = ((s8)
9260:Src/bno055.c  **** 						(sic_matrix->sic_7 >>
9261:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9262:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9263:Src/bno055.c  **** 						data2_u8r =
9264:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9265:Src/bno055.c  **** 						BNO055_SIC_MATRIX_7_MSB,
9266:Src/bno055.c  **** 						data1_u8r);
9267:Src/bno055.c  **** 						com_rslt +=
9268:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9269:Src/bno055.c  **** 						(p_bno055->dev_addr,
9270:Src/bno055.c  **** 						BNO055_SIC_MATRIX_7_MSB_REG,
9271:Src/bno055.c  **** 						&data2_u8r,
9272:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9273:Src/bno055.c  **** 					}
9274:Src/bno055.c  **** 
9275:Src/bno055.c  **** 					/* write soft iron calibration
9276:Src/bno055.c  **** 					matrix eight value*/
9277:Src/bno055.c  **** 					com_rslt +=
9278:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9279:Src/bno055.c  **** 					(p_bno055->dev_addr,
9280:Src/bno055.c  **** 					BNO055_SIC_MATRIX_8_LSB_REG,
9281:Src/bno055.c  **** 					&data2_u8r,
9282:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9283:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9284:Src/bno055.c  **** 						data1_u8r = ((s8)
9285:Src/bno055.c  **** 						(sic_matrix->sic_8
9286:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9287:Src/bno055.c  **** 						data2_u8r =
9288:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9289:Src/bno055.c  **** 						BNO055_SIC_MATRIX_8_LSB,
9290:Src/bno055.c  **** 						data1_u8r);
9291:Src/bno055.c  **** 						com_rslt +=
9292:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9293:Src/bno055.c  **** 						(p_bno055->dev_addr,
9294:Src/bno055.c  **** 						BNO055_SIC_MATRIX_8_LSB_REG,
9295:Src/bno055.c  **** 						&data2_u8r,
9296:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9297:Src/bno055.c  **** 					}
9298:Src/bno055.c  **** 
9299:Src/bno055.c  **** 					com_rslt +=
9300:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9301:Src/bno055.c  **** 					(p_bno055->dev_addr,
9302:Src/bno055.c  **** 					BNO055_SIC_MATRIX_8_MSB_REG,
ARM GAS  /tmp/ccVWLGiI.s 			page 512


9303:Src/bno055.c  **** 					&data2_u8r,
9304:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9305:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9306:Src/bno055.c  **** 						data1_u8r = ((s8)
9307:Src/bno055.c  **** 						(sic_matrix->sic_8 >>
9308:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9309:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9310:Src/bno055.c  **** 						data2_u8r =
9311:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9312:Src/bno055.c  **** 						BNO055_SIC_MATRIX_8_MSB,
9313:Src/bno055.c  **** 						data1_u8r);
9314:Src/bno055.c  **** 						com_rslt +=
9315:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9316:Src/bno055.c  **** 						(p_bno055->dev_addr,
9317:Src/bno055.c  **** 						BNO055_SIC_MATRIX_8_MSB_REG,
9318:Src/bno055.c  **** 						&data2_u8r,
9319:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9320:Src/bno055.c  **** 					}
9321:Src/bno055.c  **** 			} else {
9322:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
9323:Src/bno055.c  **** 			}
9324:Src/bno055.c  **** 		} else {
9325:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 17955              		.loc 1 9325 0
 17956 0024 FF24     		movs	r4, #255
 17957              	.LVL2259:
 17958              	.L1973:
9326:Src/bno055.c  **** 		}
9327:Src/bno055.c  **** 	}
9328:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 17959              		.loc 1 9328 0
 17960 0026 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 17961 002a 0028     		cmp	r0, #0
 17962 002c 40F03381 		bne	.L2002
 17963 0030 2046     		mov	r0, r4
 17964              	.LVL2260:
 17965              	.L1971:
9329:Src/bno055.c  **** 		/* set the operation mode
9330:Src/bno055.c  **** 		of previous operation mode*/
9331:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
9332:Src/bno055.c  **** 		(prev_opmode_u8);
9333:Src/bno055.c  **** 	return com_rslt;
9334:Src/bno055.c  **** }
 17966              		.loc 1 9334 0
 17967 0032 40B2     		sxtb	r0, r0
 17968 0034 03B0     		add	sp, sp, #12
 17969              	.LCFI772:
 17970              		.cfi_remember_state
 17971              		.cfi_def_cfa_offset 20
 17972              		@ sp needed
 17973 0036 F0BD     		pop	{r4, r5, r6, r7, pc}
 17974              	.LVL2261:
 17975              	.L1972:
 17976              	.LCFI773:
 17977              		.cfi_restore_state
8895:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 17978              		.loc 1 8895 0
ARM GAS  /tmp/ccVWLGiI.s 			page 513


 17979 0038 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 17980 003c 002B     		cmp	r3, #0
 17981 003e 40F03181 		bne	.L1974
 17982              	.L1977:
 17983              	.LVL2262:
8902:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17984              		.loc 1 8902 0
 17985 0042 2368     		ldr	r3, [r4]
8901:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 17986              		.loc 1 8901 0
 17987 0044 0DF10602 		add	r2, sp, #6
 17988 0048 1E69     		ldr	r6, [r3, #16]
 17989 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 17990 004c 4321     		movs	r1, #67
 17991 004e 0123     		movs	r3, #1
 17992 0050 B047     		blx	r6
 17993              	.LVL2263:
8902:Src/bno055.c  **** 					(p_bno055->dev_addr,
 17994              		.loc 1 8902 0
 17995 0052 974B     		ldr	r3, .L2020
8907:Src/bno055.c  **** 						data1_u8r = ((s8)
 17996              		.loc 1 8907 0
 17997 0054 0646     		mov	r6, r0
 17998 0056 0028     		cmp	r0, #0
 17999 0058 00F03B81 		beq	.L2003
 18000              	.LVL2264:
 18001              	.L1976:
8924:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18002              		.loc 1 8924 0
 18003 005c 2368     		ldr	r3, [r4]
 18004 005e 4421     		movs	r1, #68
 18005 0060 1F69     		ldr	r7, [r3, #16]
 18006 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18007 0064 0DF10602 		add	r2, sp, #6
 18008 0068 0123     		movs	r3, #1
 18009 006a B847     		blx	r7
 18010              	.LVL2265:
8923:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18011              		.loc 1 8923 0
 18012 006c 3044     		add	r0, r0, r6
 18013 006e C6B2     		uxtb	r6, r0
 18014              	.LVL2266:
8929:Src/bno055.c  **** 						data1_u8r = ((s8)
 18015              		.loc 1 8929 0
 18016 0070 06F0FF07 		and	r7, r6, #255
8924:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18017              		.loc 1 8924 0
 18018 0074 8E4B     		ldr	r3, .L2020
8929:Src/bno055.c  **** 						data1_u8r = ((s8)
 18019              		.loc 1 8929 0
 18020 0076 002E     		cmp	r6, #0
 18021 0078 00F01C81 		beq	.L2004
 18022              	.LVL2267:
 18023              	.L1979:
8949:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18024              		.loc 1 8949 0
 18025 007c 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 514


 18026 007e 4521     		movs	r1, #69
 18027 0080 1E69     		ldr	r6, [r3, #16]
 18028 0082 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18029 0084 0DF10602 		add	r2, sp, #6
 18030 0088 0123     		movs	r3, #1
 18031 008a B047     		blx	r6
 18032              	.LVL2268:
8948:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18033              		.loc 1 8948 0
 18034 008c 3844     		add	r0, r0, r7
 18035 008e C7B2     		uxtb	r7, r0
 18036              	.LVL2269:
8954:Src/bno055.c  **** 						data1_u8r = ((s8)
 18037              		.loc 1 8954 0
 18038 0090 07F0FF06 		and	r6, r7, #255
8949:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18039              		.loc 1 8949 0
 18040 0094 864B     		ldr	r3, .L2020
8954:Src/bno055.c  **** 						data1_u8r = ((s8)
 18041              		.loc 1 8954 0
 18042 0096 002F     		cmp	r7, #0
 18043 0098 00F04581 		beq	.L2005
 18044              	.LVL2270:
 18045              	.L1980:
8971:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18046              		.loc 1 8971 0
 18047 009c 2368     		ldr	r3, [r4]
 18048 009e 4621     		movs	r1, #70
 18049 00a0 1F69     		ldr	r7, [r3, #16]
 18050 00a2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18051 00a4 0DF10602 		add	r2, sp, #6
 18052 00a8 0123     		movs	r3, #1
 18053 00aa B847     		blx	r7
 18054              	.LVL2271:
8970:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18055              		.loc 1 8970 0
 18056 00ac 3044     		add	r0, r0, r6
 18057 00ae C6B2     		uxtb	r6, r0
 18058              	.LVL2272:
8976:Src/bno055.c  **** 						data1_u8r = ((s8)
 18059              		.loc 1 8976 0
 18060 00b0 06F0FF07 		and	r7, r6, #255
8971:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18061              		.loc 1 8971 0
 18062 00b4 7E4B     		ldr	r3, .L2020
8976:Src/bno055.c  **** 						data1_u8r = ((s8)
 18063              		.loc 1 8976 0
 18064 00b6 002E     		cmp	r6, #0
 18065 00b8 00F06E81 		beq	.L2006
 18066              	.LVL2273:
 18067              	.L1981:
8996:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18068              		.loc 1 8996 0
 18069 00bc 2368     		ldr	r3, [r4]
 18070 00be 4721     		movs	r1, #71
 18071 00c0 1E69     		ldr	r6, [r3, #16]
 18072 00c2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 515


 18073 00c4 0DF10602 		add	r2, sp, #6
 18074 00c8 0123     		movs	r3, #1
 18075 00ca B047     		blx	r6
 18076              	.LVL2274:
8995:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18077              		.loc 1 8995 0
 18078 00cc 3844     		add	r0, r0, r7
 18079 00ce C7B2     		uxtb	r7, r0
 18080              	.LVL2275:
9001:Src/bno055.c  **** 						data1_u8r = ((s8)
 18081              		.loc 1 9001 0
 18082 00d0 07F0FF06 		and	r6, r7, #255
8996:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18083              		.loc 1 8996 0
 18084 00d4 764B     		ldr	r3, .L2020
9001:Src/bno055.c  **** 						data1_u8r = ((s8)
 18085              		.loc 1 9001 0
 18086 00d6 002F     		cmp	r7, #0
 18087 00d8 00F05081 		beq	.L2007
 18088              	.LVL2276:
 18089              	.L1982:
9018:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18090              		.loc 1 9018 0
 18091 00dc 2368     		ldr	r3, [r4]
 18092 00de 4821     		movs	r1, #72
 18093 00e0 1F69     		ldr	r7, [r3, #16]
 18094 00e2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18095 00e4 0DF10602 		add	r2, sp, #6
 18096 00e8 0123     		movs	r3, #1
 18097 00ea B847     		blx	r7
 18098              	.LVL2277:
9017:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18099              		.loc 1 9017 0
 18100 00ec 3044     		add	r0, r0, r6
 18101 00ee C6B2     		uxtb	r6, r0
 18102              	.LVL2278:
9023:Src/bno055.c  **** 						data1_u8r = ((s8)
 18103              		.loc 1 9023 0
 18104 00f0 06F0FF07 		and	r7, r6, #255
9018:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18105              		.loc 1 9018 0
 18106 00f4 6E4B     		ldr	r3, .L2020
9023:Src/bno055.c  **** 						data1_u8r = ((s8)
 18107              		.loc 1 9023 0
 18108 00f6 002E     		cmp	r6, #0
 18109 00f8 00F03181 		beq	.L2008
 18110              	.LVL2279:
 18111              	.L1983:
9043:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18112              		.loc 1 9043 0
 18113 00fc 2368     		ldr	r3, [r4]
 18114 00fe 4921     		movs	r1, #73
 18115 0100 1E69     		ldr	r6, [r3, #16]
 18116 0102 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18117 0104 0DF10602 		add	r2, sp, #6
 18118 0108 0123     		movs	r3, #1
 18119 010a B047     		blx	r6
ARM GAS  /tmp/ccVWLGiI.s 			page 516


 18120              	.LVL2280:
9042:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18121              		.loc 1 9042 0
 18122 010c 3844     		add	r0, r0, r7
 18123 010e C7B2     		uxtb	r7, r0
 18124              	.LVL2281:
9048:Src/bno055.c  **** 						data1_u8r = ((s8)
 18125              		.loc 1 9048 0
 18126 0110 07F0FF06 		and	r6, r7, #255
9043:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18127              		.loc 1 9043 0
 18128 0114 664B     		ldr	r3, .L2020
9048:Src/bno055.c  **** 						data1_u8r = ((s8)
 18129              		.loc 1 9048 0
 18130 0116 002F     		cmp	r7, #0
 18131 0118 00F01381 		beq	.L2009
 18132              	.LVL2282:
 18133              	.L1984:
9065:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18134              		.loc 1 9065 0
 18135 011c 2368     		ldr	r3, [r4]
 18136 011e 4A21     		movs	r1, #74
 18137 0120 1F69     		ldr	r7, [r3, #16]
 18138 0122 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18139 0124 0DF10602 		add	r2, sp, #6
 18140 0128 0123     		movs	r3, #1
 18141 012a B847     		blx	r7
 18142              	.LVL2283:
9064:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18143              		.loc 1 9064 0
 18144 012c 3044     		add	r0, r0, r6
 18145 012e C6B2     		uxtb	r6, r0
 18146              	.LVL2284:
9070:Src/bno055.c  **** 						data1_u8r = ((s8)
 18147              		.loc 1 9070 0
 18148 0130 06F0FF07 		and	r7, r6, #255
9065:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18149              		.loc 1 9065 0
 18150 0134 5E4B     		ldr	r3, .L2020
9070:Src/bno055.c  **** 						data1_u8r = ((s8)
 18151              		.loc 1 9070 0
 18152 0136 002E     		cmp	r6, #0
 18153 0138 00F0A281 		beq	.L2010
 18154              	.LVL2285:
 18155              	.L1985:
9090:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18156              		.loc 1 9090 0
 18157 013c 2368     		ldr	r3, [r4]
 18158 013e 4B21     		movs	r1, #75
 18159 0140 1E69     		ldr	r6, [r3, #16]
 18160 0142 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18161 0144 0DF10602 		add	r2, sp, #6
 18162 0148 0123     		movs	r3, #1
 18163 014a B047     		blx	r6
 18164              	.LVL2286:
9089:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18165              		.loc 1 9089 0
ARM GAS  /tmp/ccVWLGiI.s 			page 517


 18166 014c 3844     		add	r0, r0, r7
 18167 014e C7B2     		uxtb	r7, r0
 18168              	.LVL2287:
9095:Src/bno055.c  **** 						data1_u8r = ((s8)
 18169              		.loc 1 9095 0
 18170 0150 07F0FF06 		and	r6, r7, #255
9090:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18171              		.loc 1 9090 0
 18172 0154 564B     		ldr	r3, .L2020
9095:Src/bno055.c  **** 						data1_u8r = ((s8)
 18173              		.loc 1 9095 0
 18174 0156 002F     		cmp	r7, #0
 18175 0158 00F08481 		beq	.L2011
 18176              	.LVL2288:
 18177              	.L1986:
9112:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18178              		.loc 1 9112 0
 18179 015c 2368     		ldr	r3, [r4]
 18180 015e 4C21     		movs	r1, #76
 18181 0160 1F69     		ldr	r7, [r3, #16]
 18182 0162 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18183 0164 0DF10602 		add	r2, sp, #6
 18184 0168 0123     		movs	r3, #1
 18185 016a B847     		blx	r7
 18186              	.LVL2289:
9111:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18187              		.loc 1 9111 0
 18188 016c 3044     		add	r0, r0, r6
 18189 016e C6B2     		uxtb	r6, r0
 18190              	.LVL2290:
9117:Src/bno055.c  **** 						data1_u8r = ((s8)
 18191              		.loc 1 9117 0
 18192 0170 06F0FF07 		and	r7, r6, #255
9112:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18193              		.loc 1 9112 0
 18194 0174 4E4B     		ldr	r3, .L2020
9117:Src/bno055.c  **** 						data1_u8r = ((s8)
 18195              		.loc 1 9117 0
 18196 0176 002E     		cmp	r6, #0
 18197 0178 00F06581 		beq	.L2012
 18198              	.LVL2291:
 18199              	.L1987:
9137:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18200              		.loc 1 9137 0
 18201 017c 2368     		ldr	r3, [r4]
 18202 017e 4D21     		movs	r1, #77
 18203 0180 1E69     		ldr	r6, [r3, #16]
 18204 0182 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18205 0184 0DF10602 		add	r2, sp, #6
 18206 0188 0123     		movs	r3, #1
 18207 018a B047     		blx	r6
 18208              	.LVL2292:
9136:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18209              		.loc 1 9136 0
 18210 018c 3844     		add	r0, r0, r7
 18211 018e C7B2     		uxtb	r7, r0
 18212              	.LVL2293:
ARM GAS  /tmp/ccVWLGiI.s 			page 518


9142:Src/bno055.c  **** 						data1_u8r = ((s8)
 18213              		.loc 1 9142 0
 18214 0190 07F0FF06 		and	r6, r7, #255
9137:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18215              		.loc 1 9137 0
 18216 0194 464B     		ldr	r3, .L2020
9142:Src/bno055.c  **** 						data1_u8r = ((s8)
 18217              		.loc 1 9142 0
 18218 0196 002F     		cmp	r7, #0
 18219 0198 00F04781 		beq	.L2013
 18220              	.LVL2294:
 18221              	.L1988:
9159:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18222              		.loc 1 9159 0
 18223 019c 2368     		ldr	r3, [r4]
 18224 019e 4E21     		movs	r1, #78
 18225 01a0 1F69     		ldr	r7, [r3, #16]
 18226 01a2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18227 01a4 0DF10602 		add	r2, sp, #6
 18228 01a8 0123     		movs	r3, #1
 18229 01aa B847     		blx	r7
 18230              	.LVL2295:
9158:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18231              		.loc 1 9158 0
 18232 01ac 3044     		add	r0, r0, r6
 18233 01ae C6B2     		uxtb	r6, r0
 18234              	.LVL2296:
9164:Src/bno055.c  **** 						data1_u8r = ((s8)
 18235              		.loc 1 9164 0
 18236 01b0 06F0FF07 		and	r7, r6, #255
9159:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18237              		.loc 1 9159 0
 18238 01b4 3E4B     		ldr	r3, .L2020
9164:Src/bno055.c  **** 						data1_u8r = ((s8)
 18239              		.loc 1 9164 0
 18240 01b6 002E     		cmp	r6, #0
 18241 01b8 00F02881 		beq	.L2014
 18242              	.LVL2297:
 18243              	.L1989:
9184:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18244              		.loc 1 9184 0
 18245 01bc 2368     		ldr	r3, [r4]
 18246 01be 4F21     		movs	r1, #79
 18247 01c0 1E69     		ldr	r6, [r3, #16]
 18248 01c2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18249 01c4 0DF10602 		add	r2, sp, #6
 18250 01c8 0123     		movs	r3, #1
 18251 01ca B047     		blx	r6
 18252              	.LVL2298:
9183:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18253              		.loc 1 9183 0
 18254 01cc 3844     		add	r0, r0, r7
 18255 01ce C7B2     		uxtb	r7, r0
 18256              	.LVL2299:
9189:Src/bno055.c  **** 						data1_u8r = ((s8)
 18257              		.loc 1 9189 0
 18258 01d0 07F0FF06 		and	r6, r7, #255
ARM GAS  /tmp/ccVWLGiI.s 			page 519


9184:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18259              		.loc 1 9184 0
 18260 01d4 364B     		ldr	r3, .L2020
9189:Src/bno055.c  **** 						data1_u8r = ((s8)
 18261              		.loc 1 9189 0
 18262 01d6 002F     		cmp	r7, #0
 18263 01d8 00F00A81 		beq	.L2015
 18264              	.LVL2300:
 18265              	.L1990:
9206:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18266              		.loc 1 9206 0
 18267 01dc 2368     		ldr	r3, [r4]
 18268 01de 5021     		movs	r1, #80
 18269 01e0 1F69     		ldr	r7, [r3, #16]
 18270 01e2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18271 01e4 0DF10602 		add	r2, sp, #6
 18272 01e8 0123     		movs	r3, #1
 18273 01ea B847     		blx	r7
 18274              	.LVL2301:
9205:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18275              		.loc 1 9205 0
 18276 01ec 3044     		add	r0, r0, r6
 18277 01ee C6B2     		uxtb	r6, r0
 18278              	.LVL2302:
9211:Src/bno055.c  **** 						data1_u8r = ((s8)
 18279              		.loc 1 9211 0
 18280 01f0 06F0FF07 		and	r7, r6, #255
9206:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18281              		.loc 1 9206 0
 18282 01f4 2E4B     		ldr	r3, .L2020
9211:Src/bno055.c  **** 						data1_u8r = ((s8)
 18283              		.loc 1 9211 0
 18284 01f6 002E     		cmp	r6, #0
 18285 01f8 00F0EB80 		beq	.L2016
 18286              	.LVL2303:
 18287              	.L1991:
9231:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18288              		.loc 1 9231 0
 18289 01fc 2368     		ldr	r3, [r4]
 18290 01fe 5121     		movs	r1, #81
 18291 0200 1E69     		ldr	r6, [r3, #16]
 18292 0202 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18293 0204 0DF10602 		add	r2, sp, #6
 18294 0208 0123     		movs	r3, #1
 18295 020a B047     		blx	r6
 18296              	.LVL2304:
9230:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18297              		.loc 1 9230 0
 18298 020c 3844     		add	r0, r0, r7
 18299 020e C7B2     		uxtb	r7, r0
 18300              	.LVL2305:
9236:Src/bno055.c  **** 						data1_u8r = ((s8)
 18301              		.loc 1 9236 0
 18302 0210 07F0FF06 		and	r6, r7, #255
9231:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18303              		.loc 1 9231 0
 18304 0214 264B     		ldr	r3, .L2020
ARM GAS  /tmp/ccVWLGiI.s 			page 520


9236:Src/bno055.c  **** 						data1_u8r = ((s8)
 18305              		.loc 1 9236 0
 18306 0216 002F     		cmp	r7, #0
 18307 0218 00F0CD80 		beq	.L2017
 18308              	.LVL2306:
 18309              	.L1992:
9253:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18310              		.loc 1 9253 0
 18311 021c 2368     		ldr	r3, [r4]
 18312 021e 5221     		movs	r1, #82
 18313 0220 1F69     		ldr	r7, [r3, #16]
 18314 0222 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18315 0224 0DF10602 		add	r2, sp, #6
 18316 0228 0123     		movs	r3, #1
 18317 022a B847     		blx	r7
 18318              	.LVL2307:
9252:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18319              		.loc 1 9252 0
 18320 022c 3044     		add	r0, r0, r6
 18321 022e C6B2     		uxtb	r6, r0
 18322              	.LVL2308:
9258:Src/bno055.c  **** 						data1_u8r = ((s8)
 18323              		.loc 1 9258 0
 18324 0230 06F0FF07 		and	r7, r6, #255
9253:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18325              		.loc 1 9253 0
 18326 0234 1E4B     		ldr	r3, .L2020
9258:Src/bno055.c  **** 						data1_u8r = ((s8)
 18327              		.loc 1 9258 0
 18328 0236 002E     		cmp	r6, #0
 18329 0238 66D0     		beq	.L2018
 18330              	.LVL2309:
 18331              	.L1993:
9278:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18332              		.loc 1 9278 0
 18333 023a 2368     		ldr	r3, [r4]
 18334 023c 5321     		movs	r1, #83
 18335 023e 1E69     		ldr	r6, [r3, #16]
 18336 0240 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18337 0242 0DF10602 		add	r2, sp, #6
 18338 0246 0123     		movs	r3, #1
 18339 0248 B047     		blx	r6
 18340              	.LVL2310:
9277:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18341              		.loc 1 9277 0
 18342 024a 3844     		add	r0, r0, r7
 18343 024c C7B2     		uxtb	r7, r0
 18344              	.LVL2311:
9283:Src/bno055.c  **** 						data1_u8r = ((s8)
 18345              		.loc 1 9283 0
 18346 024e 07F0FF06 		and	r6, r7, #255
9278:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18347              		.loc 1 9278 0
 18348 0252 174B     		ldr	r3, .L2020
9283:Src/bno055.c  **** 						data1_u8r = ((s8)
 18349              		.loc 1 9283 0
 18350 0254 002F     		cmp	r7, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 521


 18351 0256 49D0     		beq	.L2019
 18352              	.LVL2312:
 18353              	.L1994:
9300:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18354              		.loc 1 9300 0
 18355 0258 2368     		ldr	r3, [r4]
 18356 025a 5421     		movs	r1, #84
 18357 025c 1C69     		ldr	r4, [r3, #16]
 18358 025e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18359 0260 0DF10602 		add	r2, sp, #6
 18360 0264 0123     		movs	r3, #1
 18361 0266 A047     		blx	r4
 18362              	.LVL2313:
9299:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 18363              		.loc 1 9299 0
 18364 0268 3044     		add	r0, r0, r6
 18365 026a C6B2     		uxtb	r6, r0
 18366              	.LVL2314:
9305:Src/bno055.c  **** 						data1_u8r = ((s8)
 18367              		.loc 1 9305 0
 18368 026c 06F0FF04 		and	r4, r6, #255
9300:Src/bno055.c  **** 					(p_bno055->dev_addr,
 18369              		.loc 1 9300 0
 18370 0270 0F4B     		ldr	r3, .L2020
9305:Src/bno055.c  **** 						data1_u8r = ((s8)
 18371              		.loc 1 9305 0
 18372 0272 002E     		cmp	r6, #0
 18373 0274 7FF4D7AE 		bne	.L1973
 18374              	.LVL2315:
9315:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18375              		.loc 1 9315 0
 18376 0278 1B68     		ldr	r3, [r3]
9306:Src/bno055.c  **** 						(sic_matrix->sic_8 >>
 18377              		.loc 1 9306 0
 18378 027a 95F91120 		ldrsb	r2, [r5, #17]
9315:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18379              		.loc 1 9315 0
 18380 027e DC68     		ldr	r4, [r3, #12]
9306:Src/bno055.c  **** 						(sic_matrix->sic_8 >>
 18381              		.loc 1 9306 0
 18382 0280 8DF80620 		strb	r2, [sp, #6]
9315:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18383              		.loc 1 9315 0
 18384 0284 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18385 0286 0DF10602 		add	r2, sp, #6
 18386 028a 5421     		movs	r1, #84
 18387 028c 0123     		movs	r3, #1
 18388 028e A047     		blx	r4
 18389              	.LVL2316:
9314:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18390              		.loc 1 9314 0
 18391 0290 3044     		add	r0, r0, r6
 18392 0292 C4B2     		uxtb	r4, r0
 18393              	.LVL2317:
 18394 0294 C7E6     		b	.L1973
 18395              	.L2002:
9331:Src/bno055.c  **** 		(prev_opmode_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 522


 18396              		.loc 1 9331 0
 18397 0296 FFF7FEFF 		bl	bno055_set_operation_mode
 18398              	.LVL2318:
 18399 029a 2044     		add	r0, r0, r4
 18400 029c C0B2     		uxtb	r0, r0
 18401              	.LVL2319:
 18402              		.loc 1 9334 0
 18403 029e 40B2     		sxtb	r0, r0
 18404 02a0 03B0     		add	sp, sp, #12
 18405              	.LCFI774:
 18406              		.cfi_remember_state
 18407              		.cfi_def_cfa_offset 20
 18408              		@ sp needed
 18409 02a2 F0BD     		pop	{r4, r5, r6, r7, pc}
 18410              	.LVL2320:
 18411              	.L1974:
 18412              	.LCFI775:
 18413              		.cfi_restore_state
8896:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 18414              		.loc 1 8896 0
 18415 02a4 FFF7FEFF 		bl	bno055_set_operation_mode
 18416              	.LVL2321:
8898:Src/bno055.c  **** 					/* write soft iron calibration
 18417              		.loc 1 8898 0
 18418 02a8 0028     		cmp	r0, #0
 18419 02aa 7FF4BBAE 		bne	.L1978
 18420 02ae C8E6     		b	.L1977
 18421              	.L2021:
 18422              		.align	2
 18423              	.L2020:
 18424 02b0 00000000 		.word	.LANCHOR0
 18425              	.LVL2322:
 18426              	.L2004:
8939:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18427              		.loc 1 8939 0
 18428 02b4 1B68     		ldr	r3, [r3]
8930:Src/bno055.c  **** 						(sic_matrix->sic_0  >>
 18429              		.loc 1 8930 0
 18430 02b6 95F90120 		ldrsb	r2, [r5, #1]
8939:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18431              		.loc 1 8939 0
 18432 02ba DF68     		ldr	r7, [r3, #12]
 18433 02bc 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
8930:Src/bno055.c  **** 						(sic_matrix->sic_0  >>
 18434              		.loc 1 8930 0
 18435 02be 8DF80620 		strb	r2, [sp, #6]
8939:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18436              		.loc 1 8939 0
 18437 02c2 4421     		movs	r1, #68
 18438 02c4 0DF10602 		add	r2, sp, #6
 18439 02c8 0123     		movs	r3, #1
 18440 02ca B847     		blx	r7
 18441              	.LVL2323:
8938:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18442              		.loc 1 8938 0
 18443 02cc 3044     		add	r0, r0, r6
 18444 02ce C7B2     		uxtb	r7, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 523


 18445              	.LVL2324:
 18446 02d0 D4E6     		b	.L1979
 18447              	.LVL2325:
 18448              	.L2003:
8916:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18449              		.loc 1 8916 0
 18450 02d2 1B68     		ldr	r3, [r3]
8908:Src/bno055.c  **** 						(sic_matrix->sic_0
 18451              		.loc 1 8908 0
 18452 02d4 2A88     		ldrh	r2, [r5]
8916:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18453              		.loc 1 8916 0
 18454 02d6 DE68     		ldr	r6, [r3, #12]
 18455 02d8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 18456              	.LVL2326:
8908:Src/bno055.c  **** 						(sic_matrix->sic_0
 18457              		.loc 1 8908 0
 18458 02da 8DF80620 		strb	r2, [sp, #6]
8916:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18459              		.loc 1 8916 0
 18460 02de 4321     		movs	r1, #67
 18461 02e0 0DF10602 		add	r2, sp, #6
 18462 02e4 0123     		movs	r3, #1
 18463 02e6 B047     		blx	r6
 18464              	.LVL2327:
 18465 02e8 0646     		mov	r6, r0
 18466              	.LVL2328:
 18467 02ea B7E6     		b	.L1976
 18468              	.LVL2329:
 18469              	.L2019:
9292:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18470              		.loc 1 9292 0
 18471 02ec 1B68     		ldr	r3, [r3]
9284:Src/bno055.c  **** 						(sic_matrix->sic_8
 18472              		.loc 1 9284 0
 18473 02ee 2A8A     		ldrh	r2, [r5, #16]
9292:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18474              		.loc 1 9292 0
 18475 02f0 DE68     		ldr	r6, [r3, #12]
 18476 02f2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9284:Src/bno055.c  **** 						(sic_matrix->sic_8
 18477              		.loc 1 9284 0
 18478 02f4 8DF80620 		strb	r2, [sp, #6]
9292:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18479              		.loc 1 9292 0
 18480 02f8 5321     		movs	r1, #83
 18481 02fa 0DF10602 		add	r2, sp, #6
 18482 02fe 0123     		movs	r3, #1
 18483 0300 B047     		blx	r6
 18484              	.LVL2330:
9291:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18485              		.loc 1 9291 0
 18486 0302 3844     		add	r0, r0, r7
 18487 0304 C6B2     		uxtb	r6, r0
 18488              	.LVL2331:
 18489 0306 A7E7     		b	.L1994
 18490              	.L2018:
ARM GAS  /tmp/ccVWLGiI.s 			page 524


 18491              	.LVL2332:
9268:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18492              		.loc 1 9268 0
 18493 0308 1B68     		ldr	r3, [r3]
9259:Src/bno055.c  **** 						(sic_matrix->sic_7 >>
 18494              		.loc 1 9259 0
 18495 030a 95F90F20 		ldrsb	r2, [r5, #15]
9268:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18496              		.loc 1 9268 0
 18497 030e DF68     		ldr	r7, [r3, #12]
 18498 0310 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9259:Src/bno055.c  **** 						(sic_matrix->sic_7 >>
 18499              		.loc 1 9259 0
 18500 0312 8DF80620 		strb	r2, [sp, #6]
9268:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18501              		.loc 1 9268 0
 18502 0316 5221     		movs	r1, #82
 18503 0318 0DF10602 		add	r2, sp, #6
 18504 031c 0123     		movs	r3, #1
 18505 031e B847     		blx	r7
 18506              	.LVL2333:
9267:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18507              		.loc 1 9267 0
 18508 0320 3044     		add	r0, r0, r6
 18509 0322 C7B2     		uxtb	r7, r0
 18510              	.LVL2334:
 18511 0324 89E7     		b	.L1993
 18512              	.L2005:
 18513              	.LVL2335:
8963:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18514              		.loc 1 8963 0
 18515 0326 1B68     		ldr	r3, [r3]
8955:Src/bno055.c  **** 						(sic_matrix->sic_1
 18516              		.loc 1 8955 0
 18517 0328 6A88     		ldrh	r2, [r5, #2]
8963:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18518              		.loc 1 8963 0
 18519 032a DE68     		ldr	r6, [r3, #12]
 18520 032c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
8955:Src/bno055.c  **** 						(sic_matrix->sic_1
 18521              		.loc 1 8955 0
 18522 032e 8DF80620 		strb	r2, [sp, #6]
8963:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18523              		.loc 1 8963 0
 18524 0332 4521     		movs	r1, #69
 18525 0334 0DF10602 		add	r2, sp, #6
 18526 0338 0123     		movs	r3, #1
 18527 033a B047     		blx	r6
 18528              	.LVL2336:
8962:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18529              		.loc 1 8962 0
 18530 033c 3844     		add	r0, r0, r7
 18531 033e C6B2     		uxtb	r6, r0
 18532              	.LVL2337:
 18533 0340 ACE6     		b	.L1980
 18534              	.LVL2338:
 18535              	.L2009:
ARM GAS  /tmp/ccVWLGiI.s 			page 525


9057:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18536              		.loc 1 9057 0
 18537 0342 1B68     		ldr	r3, [r3]
9049:Src/bno055.c  **** 						(sic_matrix->sic_3
 18538              		.loc 1 9049 0
 18539 0344 EA88     		ldrh	r2, [r5, #6]
9057:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18540              		.loc 1 9057 0
 18541 0346 DE68     		ldr	r6, [r3, #12]
 18542 0348 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9049:Src/bno055.c  **** 						(sic_matrix->sic_3
 18543              		.loc 1 9049 0
 18544 034a 8DF80620 		strb	r2, [sp, #6]
9057:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18545              		.loc 1 9057 0
 18546 034e 4921     		movs	r1, #73
 18547 0350 0DF10602 		add	r2, sp, #6
 18548 0354 0123     		movs	r3, #1
 18549 0356 B047     		blx	r6
 18550              	.LVL2339:
9056:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18551              		.loc 1 9056 0
 18552 0358 3844     		add	r0, r0, r7
 18553 035a C6B2     		uxtb	r6, r0
 18554              	.LVL2340:
 18555 035c DEE6     		b	.L1984
 18556              	.L2008:
 18557              	.LVL2341:
9033:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18558              		.loc 1 9033 0
 18559 035e 1B68     		ldr	r3, [r3]
9024:Src/bno055.c  **** 						(sic_matrix->sic_2 >>
 18560              		.loc 1 9024 0
 18561 0360 95F90520 		ldrsb	r2, [r5, #5]
9033:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18562              		.loc 1 9033 0
 18563 0364 DF68     		ldr	r7, [r3, #12]
 18564 0366 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9024:Src/bno055.c  **** 						(sic_matrix->sic_2 >>
 18565              		.loc 1 9024 0
 18566 0368 8DF80620 		strb	r2, [sp, #6]
9033:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18567              		.loc 1 9033 0
 18568 036c 4821     		movs	r1, #72
 18569 036e 0DF10602 		add	r2, sp, #6
 18570 0372 0123     		movs	r3, #1
 18571 0374 B847     		blx	r7
 18572              	.LVL2342:
9032:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18573              		.loc 1 9032 0
 18574 0376 3044     		add	r0, r0, r6
 18575 0378 C7B2     		uxtb	r7, r0
 18576              	.LVL2343:
 18577 037a BFE6     		b	.L1983
 18578              	.L2007:
 18579              	.LVL2344:
9010:Src/bno055.c  **** 						(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 526


 18580              		.loc 1 9010 0
 18581 037c 1B68     		ldr	r3, [r3]
9002:Src/bno055.c  **** 						(sic_matrix->sic_2
 18582              		.loc 1 9002 0
 18583 037e AA88     		ldrh	r2, [r5, #4]
9010:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18584              		.loc 1 9010 0
 18585 0380 DE68     		ldr	r6, [r3, #12]
 18586 0382 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9002:Src/bno055.c  **** 						(sic_matrix->sic_2
 18587              		.loc 1 9002 0
 18588 0384 8DF80620 		strb	r2, [sp, #6]
9010:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18589              		.loc 1 9010 0
 18590 0388 4721     		movs	r1, #71
 18591 038a 0DF10602 		add	r2, sp, #6
 18592 038e 0123     		movs	r3, #1
 18593 0390 B047     		blx	r6
 18594              	.LVL2345:
9009:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18595              		.loc 1 9009 0
 18596 0392 3844     		add	r0, r0, r7
 18597 0394 C6B2     		uxtb	r6, r0
 18598              	.LVL2346:
 18599 0396 A1E6     		b	.L1982
 18600              	.L2006:
 18601              	.LVL2347:
8986:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18602              		.loc 1 8986 0
 18603 0398 1B68     		ldr	r3, [r3]
8977:Src/bno055.c  **** 						(sic_matrix->sic_1  >>
 18604              		.loc 1 8977 0
 18605 039a 95F90320 		ldrsb	r2, [r5, #3]
8986:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18606              		.loc 1 8986 0
 18607 039e DF68     		ldr	r7, [r3, #12]
 18608 03a0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
8977:Src/bno055.c  **** 						(sic_matrix->sic_1  >>
 18609              		.loc 1 8977 0
 18610 03a2 8DF80620 		strb	r2, [sp, #6]
8986:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18611              		.loc 1 8986 0
 18612 03a6 4621     		movs	r1, #70
 18613 03a8 0DF10602 		add	r2, sp, #6
 18614 03ac 0123     		movs	r3, #1
 18615 03ae B847     		blx	r7
 18616              	.LVL2348:
8985:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18617              		.loc 1 8985 0
 18618 03b0 3044     		add	r0, r0, r6
 18619 03b2 C7B2     		uxtb	r7, r0
 18620              	.LVL2349:
 18621 03b4 82E6     		b	.L1981
 18622              	.L2017:
 18623              	.LVL2350:
9245:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18624              		.loc 1 9245 0
ARM GAS  /tmp/ccVWLGiI.s 			page 527


 18625 03b6 1B68     		ldr	r3, [r3]
9237:Src/bno055.c  **** 						(sic_matrix->sic_7
 18626              		.loc 1 9237 0
 18627 03b8 EA89     		ldrh	r2, [r5, #14]
9245:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18628              		.loc 1 9245 0
 18629 03ba DE68     		ldr	r6, [r3, #12]
 18630 03bc 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9237:Src/bno055.c  **** 						(sic_matrix->sic_7
 18631              		.loc 1 9237 0
 18632 03be 8DF80620 		strb	r2, [sp, #6]
9245:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18633              		.loc 1 9245 0
 18634 03c2 5121     		movs	r1, #81
 18635 03c4 0DF10602 		add	r2, sp, #6
 18636 03c8 0123     		movs	r3, #1
 18637 03ca B047     		blx	r6
 18638              	.LVL2351:
9244:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18639              		.loc 1 9244 0
 18640 03cc 3844     		add	r0, r0, r7
 18641 03ce C6B2     		uxtb	r6, r0
 18642              	.LVL2352:
 18643 03d0 24E7     		b	.L1992
 18644              	.L2016:
 18645              	.LVL2353:
9221:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18646              		.loc 1 9221 0
 18647 03d2 1B68     		ldr	r3, [r3]
9212:Src/bno055.c  **** 						(sic_matrix->sic_6 >>
 18648              		.loc 1 9212 0
 18649 03d4 95F90D20 		ldrsb	r2, [r5, #13]
9221:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18650              		.loc 1 9221 0
 18651 03d8 DF68     		ldr	r7, [r3, #12]
 18652 03da 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9212:Src/bno055.c  **** 						(sic_matrix->sic_6 >>
 18653              		.loc 1 9212 0
 18654 03dc 8DF80620 		strb	r2, [sp, #6]
9221:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18655              		.loc 1 9221 0
 18656 03e0 5021     		movs	r1, #80
 18657 03e2 0DF10602 		add	r2, sp, #6
 18658 03e6 0123     		movs	r3, #1
 18659 03e8 B847     		blx	r7
 18660              	.LVL2354:
9220:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18661              		.loc 1 9220 0
 18662 03ea 3044     		add	r0, r0, r6
 18663 03ec C7B2     		uxtb	r7, r0
 18664              	.LVL2355:
 18665 03ee 05E7     		b	.L1991
 18666              	.L2015:
 18667              	.LVL2356:
9198:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18668              		.loc 1 9198 0
 18669 03f0 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccVWLGiI.s 			page 528


9190:Src/bno055.c  **** 						(sic_matrix->sic_6
 18670              		.loc 1 9190 0
 18671 03f2 AA89     		ldrh	r2, [r5, #12]
9198:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18672              		.loc 1 9198 0
 18673 03f4 DE68     		ldr	r6, [r3, #12]
 18674 03f6 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9190:Src/bno055.c  **** 						(sic_matrix->sic_6
 18675              		.loc 1 9190 0
 18676 03f8 8DF80620 		strb	r2, [sp, #6]
9198:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18677              		.loc 1 9198 0
 18678 03fc 4F21     		movs	r1, #79
 18679 03fe 0DF10602 		add	r2, sp, #6
 18680 0402 0123     		movs	r3, #1
 18681 0404 B047     		blx	r6
 18682              	.LVL2357:
9197:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18683              		.loc 1 9197 0
 18684 0406 3844     		add	r0, r0, r7
 18685 0408 C6B2     		uxtb	r6, r0
 18686              	.LVL2358:
 18687 040a E7E6     		b	.L1990
 18688              	.L2014:
 18689              	.LVL2359:
9174:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18690              		.loc 1 9174 0
 18691 040c 1B68     		ldr	r3, [r3]
9165:Src/bno055.c  **** 						(sic_matrix->sic_5 >>
 18692              		.loc 1 9165 0
 18693 040e 95F90B20 		ldrsb	r2, [r5, #11]
9174:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18694              		.loc 1 9174 0
 18695 0412 DF68     		ldr	r7, [r3, #12]
 18696 0414 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9165:Src/bno055.c  **** 						(sic_matrix->sic_5 >>
 18697              		.loc 1 9165 0
 18698 0416 8DF80620 		strb	r2, [sp, #6]
9174:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18699              		.loc 1 9174 0
 18700 041a 4E21     		movs	r1, #78
 18701 041c 0DF10602 		add	r2, sp, #6
 18702 0420 0123     		movs	r3, #1
 18703 0422 B847     		blx	r7
 18704              	.LVL2360:
9173:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18705              		.loc 1 9173 0
 18706 0424 3044     		add	r0, r0, r6
 18707 0426 C7B2     		uxtb	r7, r0
 18708              	.LVL2361:
 18709 0428 C8E6     		b	.L1989
 18710              	.L2013:
 18711              	.LVL2362:
9151:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18712              		.loc 1 9151 0
 18713 042a 1B68     		ldr	r3, [r3]
9143:Src/bno055.c  **** 						(sic_matrix->sic_5
ARM GAS  /tmp/ccVWLGiI.s 			page 529


 18714              		.loc 1 9143 0
 18715 042c 6A89     		ldrh	r2, [r5, #10]
9151:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18716              		.loc 1 9151 0
 18717 042e DE68     		ldr	r6, [r3, #12]
 18718 0430 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9143:Src/bno055.c  **** 						(sic_matrix->sic_5
 18719              		.loc 1 9143 0
 18720 0432 8DF80620 		strb	r2, [sp, #6]
9151:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18721              		.loc 1 9151 0
 18722 0436 4D21     		movs	r1, #77
 18723 0438 0DF10602 		add	r2, sp, #6
 18724 043c 0123     		movs	r3, #1
 18725 043e B047     		blx	r6
 18726              	.LVL2363:
9150:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18727              		.loc 1 9150 0
 18728 0440 3844     		add	r0, r0, r7
 18729 0442 C6B2     		uxtb	r6, r0
 18730              	.LVL2364:
 18731 0444 AAE6     		b	.L1988
 18732              	.L2012:
 18733              	.LVL2365:
9127:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18734              		.loc 1 9127 0
 18735 0446 1B68     		ldr	r3, [r3]
9118:Src/bno055.c  **** 						(sic_matrix->sic_4 >>
 18736              		.loc 1 9118 0
 18737 0448 95F90920 		ldrsb	r2, [r5, #9]
9127:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18738              		.loc 1 9127 0
 18739 044c DF68     		ldr	r7, [r3, #12]
 18740 044e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9118:Src/bno055.c  **** 						(sic_matrix->sic_4 >>
 18741              		.loc 1 9118 0
 18742 0450 8DF80620 		strb	r2, [sp, #6]
9127:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18743              		.loc 1 9127 0
 18744 0454 4C21     		movs	r1, #76
 18745 0456 0DF10602 		add	r2, sp, #6
 18746 045a 0123     		movs	r3, #1
 18747 045c B847     		blx	r7
 18748              	.LVL2366:
9126:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18749              		.loc 1 9126 0
 18750 045e 3044     		add	r0, r0, r6
 18751 0460 C7B2     		uxtb	r7, r0
 18752              	.LVL2367:
 18753 0462 8BE6     		b	.L1987
 18754              	.L2011:
 18755              	.LVL2368:
9104:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18756              		.loc 1 9104 0
 18757 0464 1B68     		ldr	r3, [r3]
9096:Src/bno055.c  **** 						(sic_matrix->sic_4
 18758              		.loc 1 9096 0
ARM GAS  /tmp/ccVWLGiI.s 			page 530


 18759 0466 2A89     		ldrh	r2, [r5, #8]
9104:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18760              		.loc 1 9104 0
 18761 0468 DE68     		ldr	r6, [r3, #12]
 18762 046a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9096:Src/bno055.c  **** 						(sic_matrix->sic_4
 18763              		.loc 1 9096 0
 18764 046c 8DF80620 		strb	r2, [sp, #6]
9104:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18765              		.loc 1 9104 0
 18766 0470 4B21     		movs	r1, #75
 18767 0472 0DF10602 		add	r2, sp, #6
 18768 0476 0123     		movs	r3, #1
 18769 0478 B047     		blx	r6
 18770              	.LVL2369:
9103:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18771              		.loc 1 9103 0
 18772 047a 3844     		add	r0, r0, r7
 18773 047c C6B2     		uxtb	r6, r0
 18774              	.LVL2370:
 18775 047e 6DE6     		b	.L1986
 18776              	.L2010:
 18777              	.LVL2371:
9080:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18778              		.loc 1 9080 0
 18779 0480 1B68     		ldr	r3, [r3]
9071:Src/bno055.c  **** 						(sic_matrix->sic_3 >>
 18780              		.loc 1 9071 0
 18781 0482 95F90720 		ldrsb	r2, [r5, #7]
9080:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18782              		.loc 1 9080 0
 18783 0486 DF68     		ldr	r7, [r3, #12]
 18784 0488 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9071:Src/bno055.c  **** 						(sic_matrix->sic_3 >>
 18785              		.loc 1 9071 0
 18786 048a 8DF80620 		strb	r2, [sp, #6]
9080:Src/bno055.c  **** 						(p_bno055->dev_addr,
 18787              		.loc 1 9080 0
 18788 048e 4A21     		movs	r1, #74
 18789 0490 0DF10602 		add	r2, sp, #6
 18790 0494 0123     		movs	r3, #1
 18791 0496 B847     		blx	r7
 18792              	.LVL2372:
9079:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 18793              		.loc 1 9079 0
 18794 0498 3044     		add	r0, r0, r6
 18795 049a C7B2     		uxtb	r7, r0
 18796              	.LVL2373:
 18797 049c 4EE6     		b	.L1985
 18798              	.LVL2374:
 18799              	.L1995:
8888:Src/bno055.c  **** 	} else {
 18800              		.loc 1 8888 0
 18801 049e 8120     		movs	r0, #129
 18802              	.LVL2375:
 18803 04a0 C7E5     		b	.L1971
 18804              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 531


 18805              	.LFE168:
 18807 04a2 00BF     		.section	.text.bno055_read_accel_offset,"ax",%progbits
 18808              		.align	2
 18809              		.global	bno055_read_accel_offset
 18810              		.thumb
 18811              		.thumb_func
 18813              	bno055_read_accel_offset:
 18814              	.LFB169:
9335:Src/bno055.c  **** /*!
9336:Src/bno055.c  ****  *	@brief This API is used to read accel offset and accel radius
9337:Src/bno055.c  ****  *	offset form register 0x55 to 0x5A and radius form 0x67 and 0x68
9338:Src/bno055.c  ****  *
9339:Src/bno055.c  ****  *	@param accel_offset : The value of accel offset and radius
9340:Src/bno055.c  ****  *
9341:Src/bno055.c  ****  *	    bno055_accel_offset_t |     result
9342:Src/bno055.c  ****  *      ------------------- | ----------------
9343:Src/bno055.c  ****  *	             x          |  accel offset x
9344:Src/bno055.c  ****  *               y          |  accel offset y
9345:Src/bno055.c  ****  *	             z          |  accel offset z
9346:Src/bno055.c  ****  *               r          |  accel offset r
9347:Src/bno055.c  ****  *
9348:Src/bno055.c  ****  *
9349:Src/bno055.c  ****  *	@return results of bus communication function
9350:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
9351:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
9352:Src/bno055.c  ****  *
9353:Src/bno055.c  ****  *	@note  The range of the accel offset varies based on
9354:Src/bno055.c  ****  *	the G-range of accel sensor.
9355:Src/bno055.c  ****  *
9356:Src/bno055.c  ****  *  accel G range   |  offset range
9357:Src/bno055.c  ****  * ---------------  |  --------------
9358:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_2G  |   +/-2000
9359:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_4G  |   +/-4000
9360:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_8G  |   +/-8000
9361:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_16G |   +/-16000
9362:Src/bno055.c  ****  *
9363:Src/bno055.c  ****  *	accel G range can be configured by using the
9364:Src/bno055.c  ****  *	bno055_set_accel_range() API
9365:Src/bno055.c  ****  */
9366:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_accel_offset(
9367:Src/bno055.c  **** struct bno055_accel_offset_t  *accel_offset)
9368:Src/bno055.c  **** {
 18815              		.loc 1 9368 0
 18816              		.cfi_startproc
 18817              		@ args = 0, pretend = 0, frame = 8
 18818              		@ frame_needed = 0, uses_anonymous_args = 0
 18819              	.LVL2376:
 18820 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 18821              	.LCFI776:
 18822              		.cfi_def_cfa_offset 20
 18823              		.cfi_offset 4, -20
 18824              		.cfi_offset 5, -16
 18825              		.cfi_offset 6, -12
 18826              		.cfi_offset 7, -8
 18827              		.cfi_offset 14, -4
9369:Src/bno055.c  **** 	/* Variable used to return value of
9370:Src/bno055.c  **** 	communication routine*/
ARM GAS  /tmp/ccVWLGiI.s 			page 532


9371:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
9372:Src/bno055.c  **** 	/* Array holding the accel offset values
9373:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB] - offset x->LSB
9374:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB] - offset x->MSB
9375:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB] - offset y->LSB
9376:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB] - offset y->MSB
9377:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB] - offset z->LSB
9378:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB] - offset z->MSB
9379:Src/bno055.c  **** 	*/
9380:Src/bno055.c  **** 	u8 data_u8[BNO055_ACCEL_OFFSET_ARRAY] = {
9381:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
9382:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
9383:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
9384:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
9385:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
9386:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 18828              		.loc 1 9386 0
 18829 0002 294C     		ldr	r4, .L2037
9368:Src/bno055.c  **** 	/* Variable used to return value of
 18830              		.loc 1 9368 0
 18831 0004 83B0     		sub	sp, sp, #12
 18832              	.LCFI777:
 18833              		.cfi_def_cfa_offset 32
 18834              		.loc 1 9386 0
 18835 0006 2168     		ldr	r1, [r4]
9380:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 18836              		.loc 1 9380 0
 18837 0008 0023     		movs	r3, #0
 18838 000a 8DF80030 		strb	r3, [sp]
 18839 000e 8DF80130 		strb	r3, [sp, #1]
 18840 0012 8DF80230 		strb	r3, [sp, #2]
 18841 0016 8DF80330 		strb	r3, [sp, #3]
 18842 001a 8DF80430 		strb	r3, [sp, #4]
 18843 001e 8DF80530 		strb	r3, [sp, #5]
 18844              	.LVL2377:
 18845              		.loc 1 9386 0
 18846 0022 0029     		cmp	r1, #0
 18847 0024 3DD0     		beq	.L2027
9387:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
9388:Src/bno055.c  **** 		} else {
9389:Src/bno055.c  **** 		/*condition check for page, accel offset is
9390:Src/bno055.c  **** 		available in the page zero*/
9391:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 18848              		.loc 1 9391 0
 18849 0026 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
 18850 0028 0546     		mov	r5, r0
 18851 002a 52B9     		cbnz	r2, .L2035
 18852              	.LVL2378:
 18853              	.L2024:
9392:Src/bno055.c  **** 			/* Write the page zero*/
9393:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
9394:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
9395:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
9396:Src/bno055.c  **** 			/* Read accel offset value it is six bytes of data*/
9397:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 18854              		.loc 1 9397 0
 18855 002c 0E69     		ldr	r6, [r1, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 533


 18856 002e 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 18857 0030 6A46     		mov	r2, sp
 18858 0032 5521     		movs	r1, #85
 18859 0034 0623     		movs	r3, #6
 18860 0036 B047     		blx	r6
 18861              	.LVL2379:
9398:Src/bno055.c  **** 			(p_bno055->dev_addr,
9399:Src/bno055.c  **** 			BNO055_ACCEL_OFFSET_X_LSB_REG,
9400:Src/bno055.c  **** 			data_u8, BNO055_ACCEL_OFFSET_ARRAY);
9401:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 18862              		.loc 1 9401 0
 18863 0038 68B1     		cbz	r0, .L2036
 18864              	.LVL2380:
 18865              	.L2026:
9402:Src/bno055.c  **** 				/* Read accel x offset value*/
9403:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB] =
9404:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9405:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB],
9406:Src/bno055.c  **** 				BNO055_ACCEL_OFFSET_X_LSB);
9407:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB] =
9408:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9409:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB],
9410:Src/bno055.c  **** 				BNO055_ACCEL_OFFSET_X_MSB);
9411:Src/bno055.c  **** 				accel_offset->x = (s16)((((s32)(s8)
9412:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
9413:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
9414:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB]));
9415:Src/bno055.c  **** 
9416:Src/bno055.c  **** 				/* Read accel y offset value*/
9417:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB] =
9418:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9419:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB],
9420:Src/bno055.c  **** 				BNO055_ACCEL_OFFSET_Y_LSB);
9421:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB] =
9422:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9423:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB],
9424:Src/bno055.c  **** 				BNO055_ACCEL_OFFSET_Y_MSB);
9425:Src/bno055.c  **** 				accel_offset->y = (s16)((((s32)(s8)
9426:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
9427:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS))
9428:Src/bno055.c  **** 				| (data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB]));
9429:Src/bno055.c  **** 
9430:Src/bno055.c  **** 				/* Read accel z offset value*/
9431:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB] =
9432:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9433:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB],
9434:Src/bno055.c  **** 				BNO055_ACCEL_OFFSET_Z_LSB);
9435:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB] =
9436:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9437:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB],
9438:Src/bno055.c  **** 				BNO055_ACCEL_OFFSET_Z_MSB);
9439:Src/bno055.c  **** 				accel_offset->z = (s16)((((s32)(s8)
9440:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
9441:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
9442:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB]));
9443:Src/bno055.c  **** 
9444:Src/bno055.c  **** 				/* Read accel radius value
ARM GAS  /tmp/ccVWLGiI.s 			page 534


9445:Src/bno055.c  **** 				it is two bytes of data*/
9446:Src/bno055.c  **** 				com_rslt += p_bno055->BNO055_BUS_READ_FUNC
9447:Src/bno055.c  **** 				(p_bno055->dev_addr,
9448:Src/bno055.c  **** 				BNO055_ACCEL_RADIUS_LSB_REG,
9449:Src/bno055.c  **** 				data_u8,
9450:Src/bno055.c  **** 				BNO055_LSB_MSB_READ_LENGTH);
9451:Src/bno055.c  **** 				/* Array holding the accel radius values
9452:Src/bno055.c  **** 				data_u8[BNO055_OFFSET_RADIUS_LSB] - radius->LSB
9453:Src/bno055.c  **** 				data_u8[BNO055_OFFSET_RADIUS_MSB] - radius->MSB
9454:Src/bno055.c  **** 				*/
9455:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
9456:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_LSB] =
9457:Src/bno055.c  **** 					BNO055_GET_BITSLICE(
9458:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_LSB],
9459:Src/bno055.c  **** 					BNO055_ACCEL_RADIUS_LSB);
9460:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_MSB] =
9461:Src/bno055.c  **** 					BNO055_GET_BITSLICE(
9462:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_MSB],
9463:Src/bno055.c  **** 					BNO055_ACCEL_RADIUS_MSB);
9464:Src/bno055.c  **** 					accel_offset->r = (s16)((((s32)(s8)
9465:Src/bno055.c  **** 					(data_u8[BNO055_OFFSET_RADIUS_MSB])) <<
9466:Src/bno055.c  **** 					(BNO055_SHIFT_EIGHT_BITS)) |
9467:Src/bno055.c  **** 					(data_u8[BNO055_OFFSET_RADIUS_LSB]));
9468:Src/bno055.c  **** 				} else {
9469:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
9470:Src/bno055.c  **** 				}
9471:Src/bno055.c  **** 			} else {
9472:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
9473:Src/bno055.c  **** 			}
9474:Src/bno055.c  **** 		} else {
9475:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 18866              		.loc 1 9475 0
 18867 003a FF20     		movs	r0, #255
 18868              	.LVL2381:
 18869              	.L2023:
9476:Src/bno055.c  **** 		}
9477:Src/bno055.c  **** 	}
9478:Src/bno055.c  **** 	return com_rslt;
9479:Src/bno055.c  **** }
 18870              		.loc 1 9479 0
 18871 003c 40B2     		sxtb	r0, r0
 18872 003e 03B0     		add	sp, sp, #12
 18873              	.LCFI778:
 18874              		.cfi_remember_state
 18875              		.cfi_def_cfa_offset 20
 18876              		@ sp needed
 18877 0040 F0BD     		pop	{r4, r5, r6, r7, pc}
 18878              	.LVL2382:
 18879              	.L2035:
 18880              	.LCFI779:
 18881              		.cfi_restore_state
9393:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 18882              		.loc 1 9393 0
 18883 0042 1846     		mov	r0, r3
 18884              	.LVL2383:
 18885 0044 FFF7FEFF 		bl	bno055_write_page_id
 18886              	.LVL2384:
ARM GAS  /tmp/ccVWLGiI.s 			page 535


 18887 0048 2168     		ldr	r1, [r4]
9394:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 18888              		.loc 1 9394 0
 18889 004a 0028     		cmp	r0, #0
 18890 004c EED0     		beq	.L2024
 18891              	.LVL2385:
9394:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 18892              		.loc 1 9394 0 is_stmt 0 discriminator 1
 18893 004e 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 18894 0050 002B     		cmp	r3, #0
 18895 0052 F2D1     		bne	.L2026
 18896 0054 EAE7     		b	.L2024
 18897              	.LVL2386:
 18898              	.L2036:
9439:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 18899              		.loc 1 9439 0 is_stmt 1
 18900 0056 9DF90500 		ldrsb	r0, [sp, #5]
 18901              	.LVL2387:
9411:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 18902              		.loc 1 9411 0
 18903 005a 9DF90170 		ldrsb	r7, [sp, #1]
 18904 005e 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
9425:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 18905              		.loc 1 9425 0
 18906 0062 9DF90360 		ldrsb	r6, [sp, #3]
 18907 0066 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
9439:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 18908              		.loc 1 9439 0
 18909 006a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
9446:Src/bno055.c  **** 				(p_bno055->dev_addr,
 18910              		.loc 1 9446 0
 18911 006e 2468     		ldr	r4, [r4]
9439:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 18912              		.loc 1 9439 0
 18913 0070 43EA0023 		orr	r3, r3, r0, lsl #8
9411:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 18914              		.loc 1 9411 0
 18915 0074 41EA0721 		orr	r1, r1, r7, lsl #8
9425:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 18916              		.loc 1 9425 0
 18917 0078 42EA0622 		orr	r2, r2, r6, lsl #8
9411:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 18918              		.loc 1 9411 0
 18919 007c 2980     		strh	r1, [r5]	@ movhi
9425:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 18920              		.loc 1 9425 0
 18921 007e 6A80     		strh	r2, [r5, #2]	@ movhi
9439:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 18922              		.loc 1 9439 0
 18923 0080 AB80     		strh	r3, [r5, #4]	@ movhi
9446:Src/bno055.c  **** 				(p_bno055->dev_addr,
 18924              		.loc 1 9446 0
 18925 0082 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 18926 0084 6A46     		mov	r2, sp
 18927 0086 2469     		ldr	r4, [r4, #16]
 18928 0088 6721     		movs	r1, #103
 18929 008a 0223     		movs	r3, #2
ARM GAS  /tmp/ccVWLGiI.s 			page 536


 18930 008c A047     		blx	r4
 18931              	.LVL2388:
9455:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_LSB] =
 18932              		.loc 1 9455 0
 18933 008e 0028     		cmp	r0, #0
 18934 0090 D3D1     		bne	.L2026
9464:Src/bno055.c  **** 					(data_u8[BNO055_OFFSET_RADIUS_MSB])) <<
 18935              		.loc 1 9464 0
 18936 0092 9DF90120 		ldrsb	r2, [sp, #1]
 18937 0096 9DF80030 		ldrb	r3, [sp]	@ zero_extendqisi2
 18938 009a 43EA0223 		orr	r3, r3, r2, lsl #8
 18939 009e EB80     		strh	r3, [r5, #6]	@ movhi
 18940 00a0 CCE7     		b	.L2023
 18941              	.LVL2389:
 18942              	.L2027:
9387:Src/bno055.c  **** 		} else {
 18943              		.loc 1 9387 0
 18944 00a2 8120     		movs	r0, #129
 18945              	.LVL2390:
 18946 00a4 CAE7     		b	.L2023
 18947              	.L2038:
 18948 00a6 00BF     		.align	2
 18949              	.L2037:
 18950 00a8 00000000 		.word	.LANCHOR0
 18951              		.cfi_endproc
 18952              	.LFE169:
 18954              		.section	.text.bno055_write_accel_offset,"ax",%progbits
 18955              		.align	2
 18956              		.global	bno055_write_accel_offset
 18957              		.thumb
 18958              		.thumb_func
 18960              	bno055_write_accel_offset:
 18961              	.LFB170:
9480:Src/bno055.c  **** /*!
9481:Src/bno055.c  ****  *	@brief This API is used to write accel offset and accel radius
9482:Src/bno055.c  ****  *	offset form register 0x55 to 0x5A and radius form 0x67 and 0x68
9483:Src/bno055.c  ****  *
9484:Src/bno055.c  ****  *	@param accel_offset : The value of accel offset and radius
9485:Src/bno055.c  ****  *
9486:Src/bno055.c  ****  *	    bno055_accel_offset_t |     result
9487:Src/bno055.c  ****  *      ------------------- | ----------------
9488:Src/bno055.c  ****  *	             x          |  accel offset x
9489:Src/bno055.c  ****  *               y          |  accel offset y
9490:Src/bno055.c  ****  *	             z          |  accel offset z
9491:Src/bno055.c  ****  *               r          |  accel offset r
9492:Src/bno055.c  ****  *
9493:Src/bno055.c  ****  *
9494:Src/bno055.c  ****  *	@return results of bus communication function
9495:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
9496:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
9497:Src/bno055.c  ****  *
9498:Src/bno055.c  ****  *	@note  The range of the accel offset varies based on
9499:Src/bno055.c  ****  *	the G-range of accel sensor.
9500:Src/bno055.c  ****  *
9501:Src/bno055.c  ****  *  accel G range   |  offset range
9502:Src/bno055.c  ****  * ---------------  |  --------------
9503:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_2G  |   +/-2000
ARM GAS  /tmp/ccVWLGiI.s 			page 537


9504:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_4G  |   +/-4000
9505:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_8G  |   +/-8000
9506:Src/bno055.c  ****  *  BNO055_ACCEL_RANGE_16G |   +/-16000
9507:Src/bno055.c  ****  *
9508:Src/bno055.c  ****  *	accel G range can be configured by using the
9509:Src/bno055.c  ****  *	bno055_set_accel_range() API
9510:Src/bno055.c  ****  */
9511:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_write_accel_offset(
9512:Src/bno055.c  **** struct bno055_accel_offset_t  *accel_offset)
9513:Src/bno055.c  **** {
 18962              		.loc 1 9513 0
 18963              		.cfi_startproc
 18964              		@ args = 0, pretend = 0, frame = 8
 18965              		@ frame_needed = 0, uses_anonymous_args = 0
 18966              	.LVL2391:
 18967 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 18968              	.LCFI780:
 18969              		.cfi_def_cfa_offset 20
 18970              		.cfi_offset 4, -20
 18971              		.cfi_offset 5, -16
 18972              		.cfi_offset 6, -12
 18973              		.cfi_offset 7, -8
 18974              		.cfi_offset 14, -4
9514:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
9515:Src/bno055.c  **** u8 data1_u8r = BNO055_INIT_VALUE;
9516:Src/bno055.c  **** u8 data2_u8r = BNO055_INIT_VALUE;
9517:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
9518:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
9519:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
9520:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 18975              		.loc 1 9520 0
 18976 0002 8B4D     		ldr	r5, .L2069
9513:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 18977              		.loc 1 9513 0
 18978 0004 83B0     		sub	sp, sp, #12
 18979              	.LCFI781:
 18980              		.cfi_def_cfa_offset 32
 18981              		.loc 1 9520 0
 18982 0006 2A68     		ldr	r2, [r5]
9516:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 18983              		.loc 1 9516 0
 18984 0008 0023     		movs	r3, #0
 18985 000a 8DF80630 		strb	r3, [sp, #6]
9517:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 18986              		.loc 1 9517 0
 18987 000e 8DF80730 		strb	r3, [sp, #7]
 18988              	.LVL2392:
 18989              		.loc 1 9520 0
 18990 0012 002A     		cmp	r2, #0
 18991 0014 00F00981 		beq	.L2054
 18992 0018 0646     		mov	r6, r0
9521:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
9522:Src/bno055.c  **** 	} else {
9523:Src/bno055.c  **** 	/* The write operation effective only if the operation
9524:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
9525:Src/bno055.c  **** 		current operation mode and set the config mode */
9526:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 538


 18993              		.loc 1 9526 0
 18994 001a 0DF10700 		add	r0, sp, #7
 18995              	.LVL2393:
 18996 001e FFF7FEFF 		bl	bno055_get_operation_mode
 18997              	.LVL2394:
9527:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 18998              		.loc 1 9527 0
 18999 0022 48B1     		cbz	r0, .L2041
 19000              	.L2047:
9528:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
9529:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
9530:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
9531:Src/bno055.c  **** 				if (stat_s8 == BNO055_SUCCESS) {
9532:Src/bno055.c  **** 					/* write accel offset x value*/
9533:Src/bno055.c  **** 					com_rslt =
9534:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9535:Src/bno055.c  **** 					(p_bno055->dev_addr,
9536:Src/bno055.c  **** 					BNO055_ACCEL_OFFSET_X_LSB_REG,
9537:Src/bno055.c  **** 					&data2_u8r,
9538:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9539:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9540:Src/bno055.c  **** 						data1_u8r = ((s8)
9541:Src/bno055.c  **** 						(accel_offset->x
9542:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9543:Src/bno055.c  **** 						data2_u8r =
9544:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9545:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_X_LSB,
9546:Src/bno055.c  **** 						data1_u8r);
9547:Src/bno055.c  **** 						com_rslt +=
9548:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9549:Src/bno055.c  **** 						(p_bno055->dev_addr,
9550:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_X_LSB_REG,
9551:Src/bno055.c  **** 						&data2_u8r,
9552:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9553:Src/bno055.c  **** 					}
9554:Src/bno055.c  **** 
9555:Src/bno055.c  **** 					com_rslt +=
9556:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9557:Src/bno055.c  **** 					(p_bno055->dev_addr,
9558:Src/bno055.c  **** 					BNO055_ACCEL_OFFSET_X_MSB_REG,
9559:Src/bno055.c  **** 					&data2_u8r,
9560:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9561:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9562:Src/bno055.c  **** 						data1_u8r = ((s8)
9563:Src/bno055.c  **** 						(accel_offset->x  >>
9564:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9565:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9566:Src/bno055.c  **** 						data2_u8r =
9567:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9568:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_X_MSB,
9569:Src/bno055.c  **** 						data1_u8r);
9570:Src/bno055.c  **** 						com_rslt +=
9571:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9572:Src/bno055.c  **** 						(p_bno055->dev_addr,
9573:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_X_MSB_REG,
9574:Src/bno055.c  **** 						&data2_u8r,
9575:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 539


9576:Src/bno055.c  **** 					}
9577:Src/bno055.c  **** 
9578:Src/bno055.c  **** 					/* write accel offset y value*/
9579:Src/bno055.c  **** 					com_rslt +=
9580:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9581:Src/bno055.c  **** 					(p_bno055->dev_addr,
9582:Src/bno055.c  **** 					BNO055_ACCEL_OFFSET_Y_LSB_REG,
9583:Src/bno055.c  **** 					&data2_u8r,
9584:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9585:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9586:Src/bno055.c  **** 						data1_u8r = ((s8)
9587:Src/bno055.c  **** 						(accel_offset->y
9588:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9589:Src/bno055.c  **** 						data2_u8r =
9590:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9591:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Y_LSB,
9592:Src/bno055.c  **** 						data1_u8r);
9593:Src/bno055.c  **** 						com_rslt +=
9594:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9595:Src/bno055.c  **** 						(p_bno055->dev_addr,
9596:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Y_LSB_REG,
9597:Src/bno055.c  **** 						&data2_u8r,
9598:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9599:Src/bno055.c  **** 					}
9600:Src/bno055.c  **** 
9601:Src/bno055.c  **** 					com_rslt +=
9602:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9603:Src/bno055.c  **** 					(p_bno055->dev_addr,
9604:Src/bno055.c  **** 					BNO055_ACCEL_OFFSET_Y_MSB_REG,
9605:Src/bno055.c  **** 					&data2_u8r,
9606:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9607:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9608:Src/bno055.c  **** 						data1_u8r = ((s8)
9609:Src/bno055.c  **** 						(accel_offset->y >>
9610:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9611:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9612:Src/bno055.c  **** 						data2_u8r =
9613:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9614:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Y_MSB,
9615:Src/bno055.c  **** 						data1_u8r);
9616:Src/bno055.c  **** 						com_rslt +=
9617:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9618:Src/bno055.c  **** 						(p_bno055->dev_addr,
9619:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Y_MSB_REG,
9620:Src/bno055.c  **** 						&data2_u8r,
9621:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9622:Src/bno055.c  **** 					}
9623:Src/bno055.c  **** 				/* write accel offset z value*/
9624:Src/bno055.c  **** 					com_rslt +=
9625:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9626:Src/bno055.c  **** 					(p_bno055->dev_addr,
9627:Src/bno055.c  **** 					BNO055_ACCEL_OFFSET_Z_LSB_REG,
9628:Src/bno055.c  **** 					&data2_u8r,
9629:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9630:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9631:Src/bno055.c  **** 						data1_u8r = ((s8)
9632:Src/bno055.c  **** 						(accel_offset->z
ARM GAS  /tmp/ccVWLGiI.s 			page 540


9633:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9634:Src/bno055.c  **** 						data2_u8r =
9635:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9636:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Z_LSB,
9637:Src/bno055.c  **** 						data1_u8r);
9638:Src/bno055.c  **** 						com_rslt +=
9639:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9640:Src/bno055.c  **** 						(p_bno055->dev_addr,
9641:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Z_LSB_REG,
9642:Src/bno055.c  **** 						&data2_u8r,
9643:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9644:Src/bno055.c  **** 					}
9645:Src/bno055.c  **** 
9646:Src/bno055.c  **** 					com_rslt +=
9647:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9648:Src/bno055.c  **** 					(p_bno055->dev_addr,
9649:Src/bno055.c  **** 					BNO055_ACCEL_OFFSET_Z_MSB_REG,
9650:Src/bno055.c  **** 					&data2_u8r,
9651:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9652:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9653:Src/bno055.c  **** 						data1_u8r = ((s8)
9654:Src/bno055.c  **** 						(accel_offset->z >>
9655:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9656:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9657:Src/bno055.c  **** 						data2_u8r =
9658:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9659:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Z_MSB,
9660:Src/bno055.c  **** 						data1_u8r);
9661:Src/bno055.c  **** 						com_rslt +=
9662:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9663:Src/bno055.c  **** 						(p_bno055->dev_addr,
9664:Src/bno055.c  **** 						BNO055_ACCEL_OFFSET_Z_MSB_REG,
9665:Src/bno055.c  **** 						&data2_u8r,
9666:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9667:Src/bno055.c  **** 					}
9668:Src/bno055.c  **** 
9669:Src/bno055.c  **** 				/*write accel radius value*/
9670:Src/bno055.c  **** 					com_rslt +=
9671:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9672:Src/bno055.c  **** 					(p_bno055->dev_addr,
9673:Src/bno055.c  **** 					BNO055_ACCEL_RADIUS_LSB_REG,
9674:Src/bno055.c  **** 					&data2_u8r,
9675:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9676:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9677:Src/bno055.c  **** 						data1_u8r = ((s8)
9678:Src/bno055.c  **** 						(accel_offset->r
9679:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9680:Src/bno055.c  **** 						data2_u8r =
9681:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9682:Src/bno055.c  **** 						BNO055_ACCEL_RADIUS_LSB,
9683:Src/bno055.c  **** 						data1_u8r);
9684:Src/bno055.c  **** 						com_rslt =
9685:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9686:Src/bno055.c  **** 						(p_bno055->dev_addr,
9687:Src/bno055.c  **** 						BNO055_ACCEL_RADIUS_LSB_REG,
9688:Src/bno055.c  **** 						&data2_u8r,
9689:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 541


9690:Src/bno055.c  **** 					}
9691:Src/bno055.c  **** 
9692:Src/bno055.c  **** 					com_rslt +=
9693:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9694:Src/bno055.c  **** 					(p_bno055->dev_addr,
9695:Src/bno055.c  **** 					BNO055_ACCEL_RADIUS_MSB_REG,
9696:Src/bno055.c  **** 					&data2_u8r,
9697:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9698:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9699:Src/bno055.c  **** 						data1_u8r = ((s8)
9700:Src/bno055.c  **** 						(accel_offset->r >>
9701:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9702:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9703:Src/bno055.c  **** 						data2_u8r =
9704:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9705:Src/bno055.c  **** 						BNO055_ACCEL_RADIUS_MSB,
9706:Src/bno055.c  **** 						data1_u8r);
9707:Src/bno055.c  **** 						com_rslt =
9708:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9709:Src/bno055.c  **** 						(p_bno055->dev_addr,
9710:Src/bno055.c  **** 						BNO055_ACCEL_RADIUS_MSB_REG,
9711:Src/bno055.c  **** 						&data2_u8r,
9712:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9713:Src/bno055.c  **** 					}
9714:Src/bno055.c  **** 			} else {
9715:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
9716:Src/bno055.c  **** 			}
9717:Src/bno055.c  **** 		} else {
9718:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 19001              		.loc 1 9718 0
 19002 0024 FF24     		movs	r4, #255
 19003              	.LVL2395:
 19004              	.L2042:
9719:Src/bno055.c  **** 		}
9720:Src/bno055.c  **** 	}
9721:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 19005              		.loc 1 9721 0
 19006 0026 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 19007 002a 0028     		cmp	r0, #0
 19008 002c 40F08D80 		bne	.L2061
 19009 0030 2046     		mov	r0, r4
 19010              	.LVL2396:
 19011              	.L2040:
9722:Src/bno055.c  **** 		/* set the operation mode
9723:Src/bno055.c  **** 		of previous operation mode*/
9724:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
9725:Src/bno055.c  **** 		(prev_opmode_u8);
9726:Src/bno055.c  **** 	return com_rslt;
9727:Src/bno055.c  **** }
 19012              		.loc 1 9727 0
 19013 0032 40B2     		sxtb	r0, r0
 19014 0034 03B0     		add	sp, sp, #12
 19015              	.LCFI782:
 19016              		.cfi_remember_state
 19017              		.cfi_def_cfa_offset 20
 19018              		@ sp needed
 19019 0036 F0BD     		pop	{r4, r5, r6, r7, pc}
ARM GAS  /tmp/ccVWLGiI.s 			page 542


 19020              	.LVL2397:
 19021              	.L2041:
 19022              	.LCFI783:
 19023              		.cfi_restore_state
9528:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 19024              		.loc 1 9528 0
 19025 0038 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 19026 003c 002B     		cmp	r3, #0
 19027 003e 40F08B80 		bne	.L2043
 19028              	.L2046:
 19029              	.LVL2398:
9534:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19030              		.loc 1 9534 0
 19031 0042 2B68     		ldr	r3, [r5]
9533:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19032              		.loc 1 9533 0
 19033 0044 0DF10602 		add	r2, sp, #6
 19034 0048 1C69     		ldr	r4, [r3, #16]
 19035 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19036 004c 5521     		movs	r1, #85
 19037 004e 0123     		movs	r3, #1
 19038 0050 A047     		blx	r4
 19039              	.LVL2399:
9534:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19040              		.loc 1 9534 0
 19041 0052 774B     		ldr	r3, .L2069
9539:Src/bno055.c  **** 						data1_u8r = ((s8)
 19042              		.loc 1 9539 0
 19043 0054 0446     		mov	r4, r0
 19044 0056 0028     		cmp	r0, #0
 19045 0058 00F09380 		beq	.L2062
 19046              	.LVL2400:
 19047              	.L2045:
9556:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19048              		.loc 1 9556 0
 19049 005c 2B68     		ldr	r3, [r5]
 19050 005e 5621     		movs	r1, #86
 19051 0060 1F69     		ldr	r7, [r3, #16]
 19052 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19053 0064 0DF10602 		add	r2, sp, #6
 19054 0068 0123     		movs	r3, #1
 19055 006a B847     		blx	r7
 19056              	.LVL2401:
9555:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19057              		.loc 1 9555 0
 19058 006c 2044     		add	r0, r0, r4
 19059 006e C4B2     		uxtb	r4, r0
 19060              	.LVL2402:
9561:Src/bno055.c  **** 						data1_u8r = ((s8)
 19061              		.loc 1 9561 0
 19062 0070 04F0FF07 		and	r7, r4, #255
9556:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19063              		.loc 1 9556 0
 19064 0074 6E4B     		ldr	r3, .L2069
9561:Src/bno055.c  **** 						data1_u8r = ((s8)
 19065              		.loc 1 9561 0
 19066 0076 002C     		cmp	r4, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 543


 19067 0078 74D0     		beq	.L2063
 19068              	.LVL2403:
 19069              	.L2048:
9580:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19070              		.loc 1 9580 0
 19071 007a 2B68     		ldr	r3, [r5]
 19072 007c 5721     		movs	r1, #87
 19073 007e 1C69     		ldr	r4, [r3, #16]
 19074 0080 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19075 0082 0DF10602 		add	r2, sp, #6
 19076 0086 0123     		movs	r3, #1
 19077 0088 A047     		blx	r4
 19078              	.LVL2404:
9579:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19079              		.loc 1 9579 0
 19080 008a 3844     		add	r0, r0, r7
 19081 008c C4B2     		uxtb	r4, r0
 19082              	.LVL2405:
9585:Src/bno055.c  **** 						data1_u8r = ((s8)
 19083              		.loc 1 9585 0
 19084 008e 04F0FF07 		and	r7, r4, #255
9580:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19085              		.loc 1 9580 0
 19086 0092 674B     		ldr	r3, .L2069
9585:Src/bno055.c  **** 						data1_u8r = ((s8)
 19087              		.loc 1 9585 0
 19088 0094 002C     		cmp	r4, #0
 19089 0096 00F08180 		beq	.L2064
 19090              	.LVL2406:
 19091              	.L2049:
9602:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19092              		.loc 1 9602 0
 19093 009a 2B68     		ldr	r3, [r5]
 19094 009c 5821     		movs	r1, #88
 19095 009e 1C69     		ldr	r4, [r3, #16]
 19096 00a0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19097 00a2 0DF10602 		add	r2, sp, #6
 19098 00a6 0123     		movs	r3, #1
 19099 00a8 A047     		blx	r4
 19100              	.LVL2407:
9601:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19101              		.loc 1 9601 0
 19102 00aa 3844     		add	r0, r0, r7
 19103 00ac C7B2     		uxtb	r7, r0
 19104              	.LVL2408:
9607:Src/bno055.c  **** 						data1_u8r = ((s8)
 19105              		.loc 1 9607 0
 19106 00ae 07F0FF04 		and	r4, r7, #255
9602:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19107              		.loc 1 9602 0
 19108 00b2 5F4B     		ldr	r3, .L2069
9607:Src/bno055.c  **** 						data1_u8r = ((s8)
 19109              		.loc 1 9607 0
 19110 00b4 002F     		cmp	r7, #0
 19111 00b6 00F0A980 		beq	.L2065
 19112              	.LVL2409:
 19113              	.L2050:
ARM GAS  /tmp/ccVWLGiI.s 			page 544


9625:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19114              		.loc 1 9625 0
 19115 00ba 2B68     		ldr	r3, [r5]
 19116 00bc 5921     		movs	r1, #89
 19117 00be 1F69     		ldr	r7, [r3, #16]
 19118 00c0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19119 00c2 0DF10602 		add	r2, sp, #6
 19120 00c6 0123     		movs	r3, #1
 19121 00c8 B847     		blx	r7
 19122              	.LVL2410:
9624:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19123              		.loc 1 9624 0
 19124 00ca 2044     		add	r0, r0, r4
 19125 00cc C4B2     		uxtb	r4, r0
 19126              	.LVL2411:
9630:Src/bno055.c  **** 						data1_u8r = ((s8)
 19127              		.loc 1 9630 0
 19128 00ce 04F0FF07 		and	r7, r4, #255
9625:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19129              		.loc 1 9625 0
 19130 00d2 574B     		ldr	r3, .L2069
9630:Src/bno055.c  **** 						data1_u8r = ((s8)
 19131              		.loc 1 9630 0
 19132 00d4 002C     		cmp	r4, #0
 19133 00d6 00F08B80 		beq	.L2066
 19134              	.LVL2412:
 19135              	.L2051:
9647:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19136              		.loc 1 9647 0
 19137 00da 2B68     		ldr	r3, [r5]
 19138 00dc 5A21     		movs	r1, #90
 19139 00de 1C69     		ldr	r4, [r3, #16]
 19140 00e0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19141 00e2 0DF10602 		add	r2, sp, #6
 19142 00e6 0123     		movs	r3, #1
 19143 00e8 A047     		blx	r4
 19144              	.LVL2413:
9646:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19145              		.loc 1 9646 0
 19146 00ea 3844     		add	r0, r0, r7
 19147 00ec C7B2     		uxtb	r7, r0
 19148              	.LVL2414:
9652:Src/bno055.c  **** 						data1_u8r = ((s8)
 19149              		.loc 1 9652 0
 19150 00ee 07F0FF04 		and	r4, r7, #255
9647:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19151              		.loc 1 9647 0
 19152 00f2 4F4B     		ldr	r3, .L2069
9652:Src/bno055.c  **** 						data1_u8r = ((s8)
 19153              		.loc 1 9652 0
 19154 00f4 002F     		cmp	r7, #0
 19155 00f6 6CD0     		beq	.L2067
 19156              	.LVL2415:
 19157              	.L2052:
9671:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19158              		.loc 1 9671 0
 19159 00f8 2B68     		ldr	r3, [r5]
ARM GAS  /tmp/ccVWLGiI.s 			page 545


 19160 00fa 6721     		movs	r1, #103
 19161 00fc 1F69     		ldr	r7, [r3, #16]
 19162 00fe 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19163 0100 0DF10602 		add	r2, sp, #6
 19164 0104 0123     		movs	r3, #1
 19165 0106 B847     		blx	r7
 19166              	.LVL2416:
9670:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19167              		.loc 1 9670 0
 19168 0108 2044     		add	r0, r0, r4
 19169              	.LVL2417:
9676:Src/bno055.c  **** 						data1_u8r = ((s8)
 19170              		.loc 1 9676 0
 19171 010a 10F0FF04 		ands	r4, r0, #255
9671:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19172              		.loc 1 9671 0
 19173 010e 484B     		ldr	r3, .L2069
9676:Src/bno055.c  **** 						data1_u8r = ((s8)
 19174              		.loc 1 9676 0
 19175 0110 52D0     		beq	.L2068
 19176              	.LVL2418:
 19177              	.L2053:
9693:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19178              		.loc 1 9693 0
 19179 0112 2B68     		ldr	r3, [r5]
 19180 0114 6821     		movs	r1, #104
 19181 0116 1D69     		ldr	r5, [r3, #16]
 19182 0118 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19183 011a 0DF10602 		add	r2, sp, #6
 19184 011e 0123     		movs	r3, #1
 19185 0120 A847     		blx	r5
 19186              	.LVL2419:
9692:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19187              		.loc 1 9692 0
 19188 0122 2044     		add	r0, r0, r4
 19189              	.LVL2420:
9698:Src/bno055.c  **** 						data1_u8r = ((s8)
 19190              		.loc 1 9698 0
 19191 0124 10F0FF04 		ands	r4, r0, #255
9693:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19192              		.loc 1 9693 0
 19193 0128 414B     		ldr	r3, .L2069
9698:Src/bno055.c  **** 						data1_u8r = ((s8)
 19194              		.loc 1 9698 0
 19195 012a 7FF47CAF 		bne	.L2042
 19196              	.LVL2421:
9708:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19197              		.loc 1 9708 0
 19198 012e 1B68     		ldr	r3, [r3]
9699:Src/bno055.c  **** 						(accel_offset->r >>
 19199              		.loc 1 9699 0
 19200 0130 96F90720 		ldrsb	r2, [r6, #7]
9707:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19201              		.loc 1 9707 0
 19202 0134 DC68     		ldr	r4, [r3, #12]
9699:Src/bno055.c  **** 						(accel_offset->r >>
 19203              		.loc 1 9699 0
ARM GAS  /tmp/ccVWLGiI.s 			page 546


 19204 0136 8DF80620 		strb	r2, [sp, #6]
9707:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19205              		.loc 1 9707 0
 19206 013a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19207              	.LVL2422:
 19208 013c 0DF10602 		add	r2, sp, #6
 19209 0140 6821     		movs	r1, #104
 19210 0142 0123     		movs	r3, #1
 19211 0144 A047     		blx	r4
 19212              	.LVL2423:
 19213 0146 0446     		mov	r4, r0
 19214              	.LVL2424:
 19215 0148 6DE7     		b	.L2042
 19216              	.L2061:
9724:Src/bno055.c  **** 		(prev_opmode_u8);
 19217              		.loc 1 9724 0
 19218 014a FFF7FEFF 		bl	bno055_set_operation_mode
 19219              	.LVL2425:
 19220 014e 2044     		add	r0, r0, r4
 19221 0150 C0B2     		uxtb	r0, r0
 19222              	.LVL2426:
 19223              		.loc 1 9727 0
 19224 0152 40B2     		sxtb	r0, r0
 19225 0154 03B0     		add	sp, sp, #12
 19226              	.LCFI784:
 19227              		.cfi_remember_state
 19228              		.cfi_def_cfa_offset 20
 19229              		@ sp needed
 19230 0156 F0BD     		pop	{r4, r5, r6, r7, pc}
 19231              	.LVL2427:
 19232              	.L2043:
 19233              	.LCFI785:
 19234              		.cfi_restore_state
9529:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 19235              		.loc 1 9529 0
 19236 0158 FFF7FEFF 		bl	bno055_set_operation_mode
 19237              	.LVL2428:
9531:Src/bno055.c  **** 					/* write accel offset x value*/
 19238              		.loc 1 9531 0
 19239 015c 0028     		cmp	r0, #0
 19240 015e 7FF461AF 		bne	.L2047
 19241 0162 6EE7     		b	.L2046
 19242              	.LVL2429:
 19243              	.L2063:
9571:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19244              		.loc 1 9571 0
 19245 0164 1B68     		ldr	r3, [r3]
9562:Src/bno055.c  **** 						(accel_offset->x  >>
 19246              		.loc 1 9562 0
 19247 0166 96F90120 		ldrsb	r2, [r6, #1]
9571:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19248              		.loc 1 9571 0
 19249 016a DF68     		ldr	r7, [r3, #12]
 19250 016c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9562:Src/bno055.c  **** 						(accel_offset->x  >>
 19251              		.loc 1 9562 0
 19252 016e 8DF80620 		strb	r2, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 547


9571:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19253              		.loc 1 9571 0
 19254 0172 5621     		movs	r1, #86
 19255 0174 0DF10602 		add	r2, sp, #6
 19256 0178 0123     		movs	r3, #1
 19257 017a B847     		blx	r7
 19258              	.LVL2430:
9570:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19259              		.loc 1 9570 0
 19260 017c 2044     		add	r0, r0, r4
 19261 017e C7B2     		uxtb	r7, r0
 19262              	.LVL2431:
 19263 0180 7BE7     		b	.L2048
 19264              	.LVL2432:
 19265              	.L2062:
9548:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19266              		.loc 1 9548 0
 19267 0182 1B68     		ldr	r3, [r3]
9540:Src/bno055.c  **** 						(accel_offset->x
 19268              		.loc 1 9540 0
 19269 0184 3288     		ldrh	r2, [r6]
9548:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19270              		.loc 1 9548 0
 19271 0186 DC68     		ldr	r4, [r3, #12]
 19272 0188 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19273              	.LVL2433:
9540:Src/bno055.c  **** 						(accel_offset->x
 19274              		.loc 1 9540 0
 19275 018a 8DF80620 		strb	r2, [sp, #6]
9548:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19276              		.loc 1 9548 0
 19277 018e 5521     		movs	r1, #85
 19278 0190 0DF10602 		add	r2, sp, #6
 19279 0194 0123     		movs	r3, #1
 19280 0196 A047     		blx	r4
 19281              	.LVL2434:
 19282 0198 0446     		mov	r4, r0
 19283              	.LVL2435:
 19284 019a 5FE7     		b	.L2045
 19285              	.L2064:
 19286              	.LVL2436:
9594:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19287              		.loc 1 9594 0
 19288 019c 1B68     		ldr	r3, [r3]
9586:Src/bno055.c  **** 						(accel_offset->y
 19289              		.loc 1 9586 0
 19290 019e 7288     		ldrh	r2, [r6, #2]
9594:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19291              		.loc 1 9594 0
 19292 01a0 DF68     		ldr	r7, [r3, #12]
 19293 01a2 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9586:Src/bno055.c  **** 						(accel_offset->y
 19294              		.loc 1 9586 0
 19295 01a4 8DF80620 		strb	r2, [sp, #6]
9594:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19296              		.loc 1 9594 0
 19297 01a8 5721     		movs	r1, #87
ARM GAS  /tmp/ccVWLGiI.s 			page 548


 19298 01aa 0DF10602 		add	r2, sp, #6
 19299 01ae 0123     		movs	r3, #1
 19300 01b0 B847     		blx	r7
 19301              	.LVL2437:
9593:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19302              		.loc 1 9593 0
 19303 01b2 2044     		add	r0, r0, r4
 19304 01b4 C7B2     		uxtb	r7, r0
 19305              	.LVL2438:
 19306 01b6 70E7     		b	.L2049
 19307              	.LVL2439:
 19308              	.L2068:
9685:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19309              		.loc 1 9685 0
 19310 01b8 1B68     		ldr	r3, [r3]
9677:Src/bno055.c  **** 						(accel_offset->r
 19311              		.loc 1 9677 0
 19312 01ba F288     		ldrh	r2, [r6, #6]
9684:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19313              		.loc 1 9684 0
 19314 01bc DC68     		ldr	r4, [r3, #12]
 19315 01be 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19316              	.LVL2440:
9677:Src/bno055.c  **** 						(accel_offset->r
 19317              		.loc 1 9677 0
 19318 01c0 8DF80620 		strb	r2, [sp, #6]
9684:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19319              		.loc 1 9684 0
 19320 01c4 6721     		movs	r1, #103
 19321 01c6 0DF10602 		add	r2, sp, #6
 19322 01ca 0123     		movs	r3, #1
 19323 01cc A047     		blx	r4
 19324              	.LVL2441:
 19325 01ce 0446     		mov	r4, r0
 19326              	.LVL2442:
 19327 01d0 9FE7     		b	.L2053
 19328              	.LVL2443:
 19329              	.L2067:
9662:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19330              		.loc 1 9662 0
 19331 01d2 1B68     		ldr	r3, [r3]
9653:Src/bno055.c  **** 						(accel_offset->z >>
 19332              		.loc 1 9653 0
 19333 01d4 96F90520 		ldrsb	r2, [r6, #5]
9662:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19334              		.loc 1 9662 0
 19335 01d8 DC68     		ldr	r4, [r3, #12]
 19336 01da 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9653:Src/bno055.c  **** 						(accel_offset->z >>
 19337              		.loc 1 9653 0
 19338 01dc 8DF80620 		strb	r2, [sp, #6]
9662:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19339              		.loc 1 9662 0
 19340 01e0 5A21     		movs	r1, #90
 19341 01e2 0DF10602 		add	r2, sp, #6
 19342 01e6 0123     		movs	r3, #1
 19343 01e8 A047     		blx	r4
ARM GAS  /tmp/ccVWLGiI.s 			page 549


 19344              	.LVL2444:
9661:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19345              		.loc 1 9661 0
 19346 01ea 3844     		add	r0, r0, r7
 19347 01ec C4B2     		uxtb	r4, r0
 19348              	.LVL2445:
 19349 01ee 83E7     		b	.L2052
 19350              	.L2066:
 19351              	.LVL2446:
9639:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19352              		.loc 1 9639 0
 19353 01f0 1B68     		ldr	r3, [r3]
9631:Src/bno055.c  **** 						(accel_offset->z
 19354              		.loc 1 9631 0
 19355 01f2 B288     		ldrh	r2, [r6, #4]
9639:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19356              		.loc 1 9639 0
 19357 01f4 DF68     		ldr	r7, [r3, #12]
 19358 01f6 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9631:Src/bno055.c  **** 						(accel_offset->z
 19359              		.loc 1 9631 0
 19360 01f8 8DF80620 		strb	r2, [sp, #6]
9639:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19361              		.loc 1 9639 0
 19362 01fc 5921     		movs	r1, #89
 19363 01fe 0DF10602 		add	r2, sp, #6
 19364 0202 0123     		movs	r3, #1
 19365 0204 B847     		blx	r7
 19366              	.LVL2447:
9638:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19367              		.loc 1 9638 0
 19368 0206 2044     		add	r0, r0, r4
 19369 0208 C7B2     		uxtb	r7, r0
 19370              	.LVL2448:
 19371 020a 66E7     		b	.L2051
 19372              	.L2065:
 19373              	.LVL2449:
9617:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19374              		.loc 1 9617 0
 19375 020c 1B68     		ldr	r3, [r3]
9608:Src/bno055.c  **** 						(accel_offset->y >>
 19376              		.loc 1 9608 0
 19377 020e 96F90320 		ldrsb	r2, [r6, #3]
9617:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19378              		.loc 1 9617 0
 19379 0212 DC68     		ldr	r4, [r3, #12]
 19380 0214 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9608:Src/bno055.c  **** 						(accel_offset->y >>
 19381              		.loc 1 9608 0
 19382 0216 8DF80620 		strb	r2, [sp, #6]
9617:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19383              		.loc 1 9617 0
 19384 021a 5821     		movs	r1, #88
 19385 021c 0DF10602 		add	r2, sp, #6
 19386 0220 0123     		movs	r3, #1
 19387 0222 A047     		blx	r4
 19388              	.LVL2450:
ARM GAS  /tmp/ccVWLGiI.s 			page 550


9616:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19389              		.loc 1 9616 0
 19390 0224 3844     		add	r0, r0, r7
 19391 0226 C4B2     		uxtb	r4, r0
 19392              	.LVL2451:
 19393 0228 47E7     		b	.L2050
 19394              	.LVL2452:
 19395              	.L2054:
9521:Src/bno055.c  **** 	} else {
 19396              		.loc 1 9521 0
 19397 022a 8120     		movs	r0, #129
 19398              	.LVL2453:
 19399 022c 01E7     		b	.L2040
 19400              	.L2070:
 19401 022e 00BF     		.align	2
 19402              	.L2069:
 19403 0230 00000000 		.word	.LANCHOR0
 19404              		.cfi_endproc
 19405              	.LFE170:
 19407              		.section	.text.bno055_read_mag_offset,"ax",%progbits
 19408              		.align	2
 19409              		.global	bno055_read_mag_offset
 19410              		.thumb
 19411              		.thumb_func
 19413              	bno055_read_mag_offset:
 19414              	.LFB171:
9728:Src/bno055.c  **** 
9729:Src/bno055.c  **** /*!
9730:Src/bno055.c  ****  *	@brief This API is used to read mag offset
9731:Src/bno055.c  ****  *	offset form register 0x69 to 0x6A
9732:Src/bno055.c  ****  *
9733:Src/bno055.c  ****  *	@param mag_offset :  The value of mag offset and radius
9734:Src/bno055.c  ****  *
9735:Src/bno055.c  ****  *	    bno055_mag_offset_t   |     result
9736:Src/bno055.c  ****  *      ------------------- | ----------------
9737:Src/bno055.c  ****  *	             x          |  mag offset x
9738:Src/bno055.c  ****  *               y          |  mag offset y
9739:Src/bno055.c  ****  *	             z          |  mag offset z
9740:Src/bno055.c  ****  *               r          |  mag radius r
9741:Src/bno055.c  ****  *
9742:Src/bno055.c  ****  *
9743:Src/bno055.c  ****  *	@return results of bus communication function
9744:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
9745:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
9746:Src/bno055.c  ****  *
9747:Src/bno055.c  ****  *	@note  The range of the magnetometer offset is +/-6400 in LSB
9748:Src/bno055.c  ****  */
9749:Src/bno055.c  **** 
9750:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_mag_offset(
9751:Src/bno055.c  **** struct bno055_mag_offset_t  *mag_offset)
9752:Src/bno055.c  **** {
 19415              		.loc 1 9752 0
 19416              		.cfi_startproc
 19417              		@ args = 0, pretend = 0, frame = 8
 19418              		@ frame_needed = 0, uses_anonymous_args = 0
 19419              	.LVL2454:
 19420 0000 F0B5     		push	{r4, r5, r6, r7, lr}
ARM GAS  /tmp/ccVWLGiI.s 			page 551


 19421              	.LCFI786:
 19422              		.cfi_def_cfa_offset 20
 19423              		.cfi_offset 4, -20
 19424              		.cfi_offset 5, -16
 19425              		.cfi_offset 6, -12
 19426              		.cfi_offset 7, -8
 19427              		.cfi_offset 14, -4
9753:Src/bno055.c  **** 	/* Variable used to return value of
9754:Src/bno055.c  **** 	communication routine*/
9755:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
9756:Src/bno055.c  **** 	/* Array holding the mag offset values
9757:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB] - offset x->LSB
9758:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB] - offset x->MSB
9759:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB] - offset y->LSB
9760:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB] - offset y->MSB
9761:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB] - offset z->LSB
9762:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB] - offset z->MSB
9763:Src/bno055.c  **** 	*/
9764:Src/bno055.c  **** 	u8 data_u8[BNO055_MAG_OFFSET_ARRAY] = {
9765:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
9766:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
9767:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
9768:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
9769:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
9770:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 19428              		.loc 1 9770 0
 19429 0002 294C     		ldr	r4, .L2086
9752:Src/bno055.c  **** 	/* Variable used to return value of
 19430              		.loc 1 9752 0
 19431 0004 83B0     		sub	sp, sp, #12
 19432              	.LCFI787:
 19433              		.cfi_def_cfa_offset 32
 19434              		.loc 1 9770 0
 19435 0006 2168     		ldr	r1, [r4]
9764:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 19436              		.loc 1 9764 0
 19437 0008 0023     		movs	r3, #0
 19438 000a 8DF80030 		strb	r3, [sp]
 19439 000e 8DF80130 		strb	r3, [sp, #1]
 19440 0012 8DF80230 		strb	r3, [sp, #2]
 19441 0016 8DF80330 		strb	r3, [sp, #3]
 19442 001a 8DF80430 		strb	r3, [sp, #4]
 19443 001e 8DF80530 		strb	r3, [sp, #5]
 19444              	.LVL2455:
 19445              		.loc 1 9770 0
 19446 0022 0029     		cmp	r1, #0
 19447 0024 3DD0     		beq	.L2076
9771:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
9772:Src/bno055.c  **** 		} else {
9773:Src/bno055.c  **** 		/*condition check for page, mag offset is
9774:Src/bno055.c  **** 		available in the page zero*/
9775:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 19448              		.loc 1 9775 0
 19449 0026 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
 19450 0028 0546     		mov	r5, r0
 19451 002a 52B9     		cbnz	r2, .L2084
 19452              	.LVL2456:
ARM GAS  /tmp/ccVWLGiI.s 			page 552


 19453              	.L2073:
9776:Src/bno055.c  **** 			/* Write the page zero*/
9777:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
9778:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
9779:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
9780:Src/bno055.c  **** 			/* Read mag offset value it the six bytes of data */
9781:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 19454              		.loc 1 9781 0
 19455 002c 0E69     		ldr	r6, [r1, #16]
 19456 002e 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 19457 0030 6A46     		mov	r2, sp
 19458 0032 5B21     		movs	r1, #91
 19459 0034 0623     		movs	r3, #6
 19460 0036 B047     		blx	r6
 19461              	.LVL2457:
9782:Src/bno055.c  **** 			(p_bno055->dev_addr,
9783:Src/bno055.c  **** 			BNO055_MAG_OFFSET_X_LSB_REG,
9784:Src/bno055.c  **** 			data_u8, BNO055_MAG_OFFSET_ARRAY);
9785:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 19462              		.loc 1 9785 0
 19463 0038 68B1     		cbz	r0, .L2085
 19464              	.LVL2458:
 19465              	.L2075:
9786:Src/bno055.c  **** 				/* Read mag x offset value*/
9787:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB] =
9788:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9789:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB],
9790:Src/bno055.c  **** 				BNO055_MAG_OFFSET_X_LSB);
9791:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB] =
9792:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9793:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB],
9794:Src/bno055.c  **** 				BNO055_MAG_OFFSET_X_MSB);
9795:Src/bno055.c  **** 				mag_offset->x = (s16)((((s32)(s8)
9796:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
9797:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
9798:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB]));
9799:Src/bno055.c  **** 
9800:Src/bno055.c  **** 				/* Read mag y offset value*/
9801:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB] =
9802:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9803:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB],
9804:Src/bno055.c  **** 				BNO055_MAG_OFFSET_Y_LSB);
9805:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB] =
9806:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9807:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB],
9808:Src/bno055.c  **** 				BNO055_MAG_OFFSET_Y_MSB);
9809:Src/bno055.c  **** 				mag_offset->y = (s16)((((s32)(s8)
9810:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
9811:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS))
9812:Src/bno055.c  **** 				| (data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB]));
9813:Src/bno055.c  **** 
9814:Src/bno055.c  **** 				/* Read mag z offset value*/
9815:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB] =
9816:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9817:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB],
9818:Src/bno055.c  **** 				BNO055_MAG_OFFSET_Z_LSB);
9819:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB] =
ARM GAS  /tmp/ccVWLGiI.s 			page 553


9820:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
9821:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB],
9822:Src/bno055.c  **** 				BNO055_MAG_OFFSET_Z_MSB);
9823:Src/bno055.c  **** 				mag_offset->z = (s16)((((s32)(s8)
9824:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
9825:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS))
9826:Src/bno055.c  **** 				| (data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB]));
9827:Src/bno055.c  **** 
9828:Src/bno055.c  **** 				/* Read mag radius value
9829:Src/bno055.c  **** 				it the two bytes of data */
9830:Src/bno055.c  **** 				com_rslt += p_bno055->BNO055_BUS_READ_FUNC
9831:Src/bno055.c  **** 				(p_bno055->dev_addr,
9832:Src/bno055.c  **** 				BNO055_MAG_RADIUS_LSB_REG,
9833:Src/bno055.c  **** 				data_u8,
9834:Src/bno055.c  **** 				BNO055_LSB_MSB_READ_LENGTH);
9835:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
9836:Src/bno055.c  **** 					/* Array holding the mag radius values
9837:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_LSB] -
9838:Src/bno055.c  **** 					radius->LSB
9839:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_MSB] -
9840:Src/bno055.c  **** 					radius->MSB
9841:Src/bno055.c  **** 					*/
9842:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_LSB] =
9843:Src/bno055.c  **** 					BNO055_GET_BITSLICE(
9844:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_LSB],
9845:Src/bno055.c  **** 					BNO055_MAG_RADIUS_LSB);
9846:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_MSB] =
9847:Src/bno055.c  **** 					BNO055_GET_BITSLICE(
9848:Src/bno055.c  **** 					data_u8[BNO055_OFFSET_RADIUS_MSB],
9849:Src/bno055.c  **** 					BNO055_MAG_RADIUS_MSB);
9850:Src/bno055.c  **** 					mag_offset->r = (s16)((((s32)(s8)
9851:Src/bno055.c  **** 					(data_u8[BNO055_OFFSET_RADIUS_MSB])) <<
9852:Src/bno055.c  **** 					(BNO055_SHIFT_EIGHT_BITS)) |
9853:Src/bno055.c  **** 					(data_u8[BNO055_OFFSET_RADIUS_LSB]));
9854:Src/bno055.c  **** 			} else {
9855:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
9856:Src/bno055.c  **** 			}
9857:Src/bno055.c  **** 		} else {
9858:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
9859:Src/bno055.c  **** 		}
9860:Src/bno055.c  **** 		} else {
9861:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 19466              		.loc 1 9861 0
 19467 003a FF20     		movs	r0, #255
 19468              	.LVL2459:
 19469              	.L2072:
9862:Src/bno055.c  **** 		}
9863:Src/bno055.c  **** 	}
9864:Src/bno055.c  **** 	return com_rslt;
9865:Src/bno055.c  **** }
 19470              		.loc 1 9865 0
 19471 003c 40B2     		sxtb	r0, r0
 19472 003e 03B0     		add	sp, sp, #12
 19473              	.LCFI788:
 19474              		.cfi_remember_state
 19475              		.cfi_def_cfa_offset 20
 19476              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 554


 19477 0040 F0BD     		pop	{r4, r5, r6, r7, pc}
 19478              	.LVL2460:
 19479              	.L2084:
 19480              	.LCFI789:
 19481              		.cfi_restore_state
9777:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 19482              		.loc 1 9777 0
 19483 0042 1846     		mov	r0, r3
 19484              	.LVL2461:
 19485 0044 FFF7FEFF 		bl	bno055_write_page_id
 19486              	.LVL2462:
 19487 0048 2168     		ldr	r1, [r4]
9778:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 19488              		.loc 1 9778 0
 19489 004a 0028     		cmp	r0, #0
 19490 004c EED0     		beq	.L2073
 19491              	.LVL2463:
9778:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 19492              		.loc 1 9778 0 is_stmt 0 discriminator 1
 19493 004e 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 19494 0050 002B     		cmp	r3, #0
 19495 0052 F2D1     		bne	.L2075
 19496 0054 EAE7     		b	.L2073
 19497              	.LVL2464:
 19498              	.L2085:
9823:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 19499              		.loc 1 9823 0 is_stmt 1
 19500 0056 9DF90500 		ldrsb	r0, [sp, #5]
 19501              	.LVL2465:
9795:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 19502              		.loc 1 9795 0
 19503 005a 9DF90170 		ldrsb	r7, [sp, #1]
 19504 005e 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
9809:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 19505              		.loc 1 9809 0
 19506 0062 9DF90360 		ldrsb	r6, [sp, #3]
 19507 0066 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
9823:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 19508              		.loc 1 9823 0
 19509 006a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
9830:Src/bno055.c  **** 				(p_bno055->dev_addr,
 19510              		.loc 1 9830 0
 19511 006e 2468     		ldr	r4, [r4]
9823:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 19512              		.loc 1 9823 0
 19513 0070 43EA0023 		orr	r3, r3, r0, lsl #8
9795:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 19514              		.loc 1 9795 0
 19515 0074 41EA0721 		orr	r1, r1, r7, lsl #8
9809:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 19516              		.loc 1 9809 0
 19517 0078 42EA0622 		orr	r2, r2, r6, lsl #8
9795:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 19518              		.loc 1 9795 0
 19519 007c 2980     		strh	r1, [r5]	@ movhi
9809:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 19520              		.loc 1 9809 0
ARM GAS  /tmp/ccVWLGiI.s 			page 555


 19521 007e 6A80     		strh	r2, [r5, #2]	@ movhi
9823:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 19522              		.loc 1 9823 0
 19523 0080 AB80     		strh	r3, [r5, #4]	@ movhi
9830:Src/bno055.c  **** 				(p_bno055->dev_addr,
 19524              		.loc 1 9830 0
 19525 0082 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 19526 0084 6A46     		mov	r2, sp
 19527 0086 2469     		ldr	r4, [r4, #16]
 19528 0088 6921     		movs	r1, #105
 19529 008a 0223     		movs	r3, #2
 19530 008c A047     		blx	r4
 19531              	.LVL2466:
9835:Src/bno055.c  **** 					/* Array holding the mag radius values
 19532              		.loc 1 9835 0
 19533 008e 0028     		cmp	r0, #0
 19534 0090 D3D1     		bne	.L2075
9850:Src/bno055.c  **** 					(data_u8[BNO055_OFFSET_RADIUS_MSB])) <<
 19535              		.loc 1 9850 0
 19536 0092 9DF90120 		ldrsb	r2, [sp, #1]
 19537 0096 9DF80030 		ldrb	r3, [sp]	@ zero_extendqisi2
 19538 009a 43EA0223 		orr	r3, r3, r2, lsl #8
 19539 009e EB80     		strh	r3, [r5, #6]	@ movhi
 19540 00a0 CCE7     		b	.L2072
 19541              	.LVL2467:
 19542              	.L2076:
9771:Src/bno055.c  **** 		} else {
 19543              		.loc 1 9771 0
 19544 00a2 8120     		movs	r0, #129
 19545              	.LVL2468:
 19546 00a4 CAE7     		b	.L2072
 19547              	.L2087:
 19548 00a6 00BF     		.align	2
 19549              	.L2086:
 19550 00a8 00000000 		.word	.LANCHOR0
 19551              		.cfi_endproc
 19552              	.LFE171:
 19554              		.section	.text.bno055_write_mag_offset,"ax",%progbits
 19555              		.align	2
 19556              		.global	bno055_write_mag_offset
 19557              		.thumb
 19558              		.thumb_func
 19560              	bno055_write_mag_offset:
 19561              	.LFB172:
9866:Src/bno055.c  **** 
9867:Src/bno055.c  **** /*!
9868:Src/bno055.c  ****  *	@brief This API is used to read mag offset
9869:Src/bno055.c  ****  *	offset form register 0x69 to 0x6A
9870:Src/bno055.c  ****  *
9871:Src/bno055.c  ****  *	@param mag_offset :  The value of mag offset and radius
9872:Src/bno055.c  ****  *
9873:Src/bno055.c  ****  *	    bno055_mag_offset_t |     result
9874:Src/bno055.c  ****  *      ------------------- | ----------------
9875:Src/bno055.c  ****  *	             x          |  mag offset x
9876:Src/bno055.c  ****  *               y          |  mag offset y
9877:Src/bno055.c  ****  *	             z          |  mag offset z
9878:Src/bno055.c  ****  *               r          |  mag radius r
ARM GAS  /tmp/ccVWLGiI.s 			page 556


9879:Src/bno055.c  ****  *
9880:Src/bno055.c  ****  *
9881:Src/bno055.c  ****  *	@return results of bus communication function
9882:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
9883:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
9884:Src/bno055.c  ****  *
9885:Src/bno055.c  ****  *	@note  The range of the magnetometer offset is +/-6400 in LSB
9886:Src/bno055.c  ****  */
9887:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_write_mag_offset(
9888:Src/bno055.c  **** struct bno055_mag_offset_t *mag_offset)
9889:Src/bno055.c  **** {
 19562              		.loc 1 9889 0
 19563              		.cfi_startproc
 19564              		@ args = 0, pretend = 0, frame = 8
 19565              		@ frame_needed = 0, uses_anonymous_args = 0
 19566              	.LVL2469:
 19567 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 19568              	.LCFI790:
 19569              		.cfi_def_cfa_offset 20
 19570              		.cfi_offset 4, -20
 19571              		.cfi_offset 5, -16
 19572              		.cfi_offset 6, -12
 19573              		.cfi_offset 7, -8
 19574              		.cfi_offset 14, -4
9890:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
9891:Src/bno055.c  **** u8 data1_u8r = BNO055_INIT_VALUE;
9892:Src/bno055.c  **** u8 data2_u8r = BNO055_INIT_VALUE;
9893:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
9894:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
9895:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
9896:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 19575              		.loc 1 9896 0
 19576 0002 8E4C     		ldr	r4, .L2118
9889:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 19577              		.loc 1 9889 0
 19578 0004 83B0     		sub	sp, sp, #12
 19579              	.LCFI791:
 19580              		.cfi_def_cfa_offset 32
 19581              		.loc 1 9896 0
 19582 0006 2268     		ldr	r2, [r4]
9892:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 19583              		.loc 1 9892 0
 19584 0008 0023     		movs	r3, #0
 19585 000a 8DF80630 		strb	r3, [sp, #6]
9893:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 19586              		.loc 1 9893 0
 19587 000e 8DF80730 		strb	r3, [sp, #7]
 19588              	.LVL2470:
 19589              		.loc 1 9896 0
 19590 0012 002A     		cmp	r2, #0
 19591 0014 00F00F81 		beq	.L2103
 19592 0018 0546     		mov	r5, r0
9897:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
9898:Src/bno055.c  **** 	} else {
9899:Src/bno055.c  **** 	/* The write operation effective only if the operation
9900:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
9901:Src/bno055.c  **** 		current operation mode and set the config mode */
ARM GAS  /tmp/ccVWLGiI.s 			page 557


9902:Src/bno055.c  **** 		stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 19593              		.loc 1 9902 0
 19594 001a 0DF10700 		add	r0, sp, #7
 19595              	.LVL2471:
 19596 001e FFF7FEFF 		bl	bno055_get_operation_mode
 19597              	.LVL2472:
9903:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
 19598              		.loc 1 9903 0
 19599 0022 48B1     		cbz	r0, .L2090
 19600              	.L2096:
9904:Src/bno055.c  **** 			if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
9905:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
9906:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
9907:Src/bno055.c  **** 				if (stat_s8 == BNO055_SUCCESS) {
9908:Src/bno055.c  **** 					/* write Mag offset x value*/
9909:Src/bno055.c  **** 					com_rslt =
9910:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9911:Src/bno055.c  **** 					(p_bno055->dev_addr,
9912:Src/bno055.c  **** 					BNO055_MAG_OFFSET_X_LSB_REG,
9913:Src/bno055.c  **** 					&data2_u8r,
9914:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9915:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9916:Src/bno055.c  **** 						data1_u8r = ((s8)
9917:Src/bno055.c  **** 						(mag_offset->x
9918:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
9919:Src/bno055.c  **** 						data2_u8r =
9920:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9921:Src/bno055.c  **** 						BNO055_MAG_OFFSET_X_LSB,
9922:Src/bno055.c  **** 						data1_u8r);
9923:Src/bno055.c  **** 						com_rslt +=
9924:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9925:Src/bno055.c  **** 						(p_bno055->dev_addr,
9926:Src/bno055.c  **** 						BNO055_MAG_OFFSET_X_LSB_REG,
9927:Src/bno055.c  **** 						&data2_u8r,
9928:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9929:Src/bno055.c  **** 					}
9930:Src/bno055.c  **** 
9931:Src/bno055.c  **** 					com_rslt +=
9932:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9933:Src/bno055.c  **** 					(p_bno055->dev_addr,
9934:Src/bno055.c  **** 					BNO055_MAG_OFFSET_X_MSB_REG,
9935:Src/bno055.c  **** 					&data2_u8r,
9936:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9937:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9938:Src/bno055.c  **** 						data1_u8r = ((s8)
9939:Src/bno055.c  **** 						(mag_offset->x  >>
9940:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9941:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9942:Src/bno055.c  **** 						data2_u8r =
9943:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9944:Src/bno055.c  **** 						BNO055_MAG_OFFSET_X_MSB,
9945:Src/bno055.c  **** 						data1_u8r);
9946:Src/bno055.c  **** 						com_rslt +=
9947:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9948:Src/bno055.c  **** 						(p_bno055->dev_addr,
9949:Src/bno055.c  **** 						BNO055_MAG_OFFSET_X_MSB_REG,
9950:Src/bno055.c  **** 						&data2_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 558


9951:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9952:Src/bno055.c  **** 					}
9953:Src/bno055.c  **** 
9954:Src/bno055.c  **** 					/* write Mag offset y value*/
9955:Src/bno055.c  **** 					com_rslt +=
9956:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9957:Src/bno055.c  **** 					(p_bno055->dev_addr,
9958:Src/bno055.c  **** 					BNO055_MAG_OFFSET_Y_LSB_REG,
9959:Src/bno055.c  **** 					&data2_u8r,
9960:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9961:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9962:Src/bno055.c  **** 						data1_u8r = ((s8)
9963:Src/bno055.c  **** 						(mag_offset->y &
9964:Src/bno055.c  **** 						BNO055_SIC_HEX_0_0_F_F_DATA));
9965:Src/bno055.c  **** 						data2_u8r =
9966:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9967:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Y_LSB,
9968:Src/bno055.c  **** 						data1_u8r);
9969:Src/bno055.c  **** 						com_rslt +=
9970:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9971:Src/bno055.c  **** 						(p_bno055->dev_addr,
9972:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Y_LSB_REG,
9973:Src/bno055.c  **** 						&data2_u8r,
9974:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9975:Src/bno055.c  **** 					}
9976:Src/bno055.c  **** 
9977:Src/bno055.c  **** 					com_rslt +=
9978:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
9979:Src/bno055.c  **** 					(p_bno055->dev_addr,
9980:Src/bno055.c  **** 					BNO055_MAG_OFFSET_Y_MSB_REG,
9981:Src/bno055.c  **** 					&data2_u8r,
9982:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
9983:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
9984:Src/bno055.c  **** 						data1_u8r = ((s8)
9985:Src/bno055.c  **** 						(mag_offset->y >>
9986:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
9987:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
9988:Src/bno055.c  **** 						data2_u8r =
9989:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
9990:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Y_MSB,
9991:Src/bno055.c  **** 						data1_u8r);
9992:Src/bno055.c  **** 						com_rslt +=
9993:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
9994:Src/bno055.c  **** 						(p_bno055->dev_addr,
9995:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Y_MSB_REG,
9996:Src/bno055.c  **** 						&data2_u8r,
9997:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
9998:Src/bno055.c  **** 					}
9999:Src/bno055.c  **** 				/* write Mag offset z value*/
10000:Src/bno055.c  **** 					com_rslt +=
10001:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10002:Src/bno055.c  **** 					(p_bno055->dev_addr,
10003:Src/bno055.c  **** 					BNO055_MAG_OFFSET_Z_LSB_REG,
10004:Src/bno055.c  **** 					&data2_u8r,
10005:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10006:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10007:Src/bno055.c  **** 						data1_u8r = ((s8)
ARM GAS  /tmp/ccVWLGiI.s 			page 559


10008:Src/bno055.c  **** 						(mag_offset->z &
10009:Src/bno055.c  **** 						BNO055_SIC_HEX_0_0_F_F_DATA));
10010:Src/bno055.c  **** 						data2_u8r =
10011:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10012:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Z_LSB,
10013:Src/bno055.c  **** 						data1_u8r);
10014:Src/bno055.c  **** 						com_rslt +=
10015:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10016:Src/bno055.c  **** 						(p_bno055->dev_addr,
10017:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Z_LSB_REG,
10018:Src/bno055.c  **** 						&data2_u8r,
10019:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10020:Src/bno055.c  **** 					}
10021:Src/bno055.c  **** 
10022:Src/bno055.c  **** 					com_rslt +=
10023:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10024:Src/bno055.c  **** 					(p_bno055->dev_addr,
10025:Src/bno055.c  **** 					BNO055_MAG_OFFSET_Z_MSB_REG,
10026:Src/bno055.c  **** 					&data2_u8r,
10027:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10028:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10029:Src/bno055.c  **** 						data1_u8r = ((s8)
10030:Src/bno055.c  **** 						(mag_offset->z >>
10031:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
10032:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
10033:Src/bno055.c  **** 						data2_u8r =
10034:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10035:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Z_MSB,
10036:Src/bno055.c  **** 						data1_u8r);
10037:Src/bno055.c  **** 						com_rslt +=
10038:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10039:Src/bno055.c  **** 						(p_bno055->dev_addr,
10040:Src/bno055.c  **** 						BNO055_MAG_OFFSET_Z_MSB_REG,
10041:Src/bno055.c  **** 						&data2_u8r,
10042:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10043:Src/bno055.c  **** 					}
10044:Src/bno055.c  **** 
10045:Src/bno055.c  **** 					/* write Mag radius value*/
10046:Src/bno055.c  **** 					com_rslt +=
10047:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10048:Src/bno055.c  **** 					(p_bno055->dev_addr,
10049:Src/bno055.c  **** 					BNO055_MAG_RADIUS_LSB_REG,
10050:Src/bno055.c  **** 					&data2_u8r,
10051:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10052:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10053:Src/bno055.c  **** 						data1_u8r = ((s8)
10054:Src/bno055.c  **** 						(mag_offset->r &
10055:Src/bno055.c  **** 						BNO055_SIC_HEX_0_0_F_F_DATA));
10056:Src/bno055.c  **** 						data2_u8r =
10057:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10058:Src/bno055.c  **** 						BNO055_MAG_RADIUS_LSB,
10059:Src/bno055.c  **** 						data1_u8r);
10060:Src/bno055.c  **** 						com_rslt +=
10061:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10062:Src/bno055.c  **** 						(p_bno055->dev_addr,
10063:Src/bno055.c  **** 						BNO055_MAG_RADIUS_LSB_REG,
10064:Src/bno055.c  **** 						&data2_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 560


10065:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10066:Src/bno055.c  **** 					}
10067:Src/bno055.c  **** 
10068:Src/bno055.c  **** 					com_rslt +=
10069:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10070:Src/bno055.c  **** 					(p_bno055->dev_addr,
10071:Src/bno055.c  **** 					BNO055_MAG_RADIUS_MSB_REG,
10072:Src/bno055.c  **** 					&data2_u8r,
10073:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10074:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10075:Src/bno055.c  **** 						data1_u8r = ((s8)
10076:Src/bno055.c  **** 						(mag_offset->r >>
10077:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
10078:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
10079:Src/bno055.c  **** 						data2_u8r =
10080:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10081:Src/bno055.c  **** 						BNO055_MAG_RADIUS_MSB,
10082:Src/bno055.c  **** 						data1_u8r);
10083:Src/bno055.c  **** 						com_rslt +=
10084:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10085:Src/bno055.c  **** 						(p_bno055->dev_addr,
10086:Src/bno055.c  **** 						BNO055_MAG_RADIUS_MSB_REG,
10087:Src/bno055.c  **** 						&data2_u8r,
10088:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10089:Src/bno055.c  **** 					}
10090:Src/bno055.c  **** 			} else {
10091:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
10092:Src/bno055.c  **** 			}
10093:Src/bno055.c  **** 		} else {
10094:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 19601              		.loc 1 10094 0
 19602 0024 FF24     		movs	r4, #255
 19603              	.LVL2473:
 19604              	.L2091:
10095:Src/bno055.c  **** 		}
10096:Src/bno055.c  **** 	}
10097:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 19605              		.loc 1 10097 0
 19606 0026 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 19607 002a 0028     		cmp	r0, #0
 19608 002c 40F09280 		bne	.L2110
 19609 0030 2046     		mov	r0, r4
 19610              	.LVL2474:
 19611              	.L2089:
10098:Src/bno055.c  **** 		/* set the operation mode
10099:Src/bno055.c  **** 		of previous operation mode*/
10100:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
10101:Src/bno055.c  **** 		(prev_opmode_u8);
10102:Src/bno055.c  **** 	return com_rslt;
10103:Src/bno055.c  **** }
 19612              		.loc 1 10103 0
 19613 0032 40B2     		sxtb	r0, r0
 19614 0034 03B0     		add	sp, sp, #12
 19615              	.LCFI792:
 19616              		.cfi_remember_state
 19617              		.cfi_def_cfa_offset 20
 19618              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 561


 19619 0036 F0BD     		pop	{r4, r5, r6, r7, pc}
 19620              	.LVL2475:
 19621              	.L2090:
 19622              	.LCFI793:
 19623              		.cfi_restore_state
9904:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
 19624              		.loc 1 9904 0
 19625 0038 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 19626 003c 002B     		cmp	r3, #0
 19627 003e 40F09080 		bne	.L2092
 19628              	.L2095:
 19629              	.LVL2476:
9910:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19630              		.loc 1 9910 0
 19631 0042 2368     		ldr	r3, [r4]
9909:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19632              		.loc 1 9909 0
 19633 0044 0DF10602 		add	r2, sp, #6
 19634 0048 1E69     		ldr	r6, [r3, #16]
 19635 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19636 004c 5B21     		movs	r1, #91
 19637 004e 0123     		movs	r3, #1
 19638 0050 B047     		blx	r6
 19639              	.LVL2477:
9910:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19640              		.loc 1 9910 0
 19641 0052 7A4B     		ldr	r3, .L2118
9915:Src/bno055.c  **** 						data1_u8r = ((s8)
 19642              		.loc 1 9915 0
 19643 0054 0646     		mov	r6, r0
 19644 0056 0028     		cmp	r0, #0
 19645 0058 00F09880 		beq	.L2111
 19646              	.LVL2478:
 19647              	.L2094:
9932:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19648              		.loc 1 9932 0
 19649 005c 2368     		ldr	r3, [r4]
 19650 005e 5C21     		movs	r1, #92
 19651 0060 1F69     		ldr	r7, [r3, #16]
 19652 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19653 0064 0DF10602 		add	r2, sp, #6
 19654 0068 0123     		movs	r3, #1
 19655 006a B847     		blx	r7
 19656              	.LVL2479:
9931:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19657              		.loc 1 9931 0
 19658 006c 3044     		add	r0, r0, r6
 19659 006e C6B2     		uxtb	r6, r0
 19660              	.LVL2480:
9937:Src/bno055.c  **** 						data1_u8r = ((s8)
 19661              		.loc 1 9937 0
 19662 0070 06F0FF07 		and	r7, r6, #255
9932:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19663              		.loc 1 9932 0
 19664 0074 714B     		ldr	r3, .L2118
9937:Src/bno055.c  **** 						data1_u8r = ((s8)
 19665              		.loc 1 9937 0
ARM GAS  /tmp/ccVWLGiI.s 			page 562


 19666 0076 002E     		cmp	r6, #0
 19667 0078 79D0     		beq	.L2112
 19668              	.LVL2481:
 19669              	.L2097:
9956:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19670              		.loc 1 9956 0
 19671 007a 2368     		ldr	r3, [r4]
 19672 007c 5D21     		movs	r1, #93
 19673 007e 1E69     		ldr	r6, [r3, #16]
 19674 0080 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19675 0082 0DF10602 		add	r2, sp, #6
 19676 0086 0123     		movs	r3, #1
 19677 0088 B047     		blx	r6
 19678              	.LVL2482:
9955:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19679              		.loc 1 9955 0
 19680 008a 3844     		add	r0, r0, r7
 19681 008c C7B2     		uxtb	r7, r0
 19682              	.LVL2483:
9961:Src/bno055.c  **** 						data1_u8r = ((s8)
 19683              		.loc 1 9961 0
 19684 008e 07F0FF06 		and	r6, r7, #255
9956:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19685              		.loc 1 9956 0
 19686 0092 6A4B     		ldr	r3, .L2118
9961:Src/bno055.c  **** 						data1_u8r = ((s8)
 19687              		.loc 1 9961 0
 19688 0094 002F     		cmp	r7, #0
 19689 0096 00F08680 		beq	.L2113
 19690              	.LVL2484:
 19691              	.L2098:
9978:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19692              		.loc 1 9978 0
 19693 009a 2368     		ldr	r3, [r4]
 19694 009c 5E21     		movs	r1, #94
 19695 009e 1F69     		ldr	r7, [r3, #16]
 19696 00a0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19697 00a2 0DF10602 		add	r2, sp, #6
 19698 00a6 0123     		movs	r3, #1
 19699 00a8 B847     		blx	r7
 19700              	.LVL2485:
9977:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19701              		.loc 1 9977 0
 19702 00aa 3044     		add	r0, r0, r6
 19703 00ac C6B2     		uxtb	r6, r0
 19704              	.LVL2486:
9983:Src/bno055.c  **** 						data1_u8r = ((s8)
 19705              		.loc 1 9983 0
 19706 00ae 06F0FF07 		and	r7, r6, #255
9978:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19707              		.loc 1 9978 0
 19708 00b2 624B     		ldr	r3, .L2118
9983:Src/bno055.c  **** 						data1_u8r = ((s8)
 19709              		.loc 1 9983 0
 19710 00b4 002E     		cmp	r6, #0
 19711 00b6 00F0AF80 		beq	.L2114
 19712              	.LVL2487:
ARM GAS  /tmp/ccVWLGiI.s 			page 563


 19713              	.L2099:
10001:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19714              		.loc 1 10001 0
 19715 00ba 2368     		ldr	r3, [r4]
 19716 00bc 5F21     		movs	r1, #95
 19717 00be 1E69     		ldr	r6, [r3, #16]
 19718 00c0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19719 00c2 0DF10602 		add	r2, sp, #6
 19720 00c6 0123     		movs	r3, #1
 19721 00c8 B047     		blx	r6
 19722              	.LVL2488:
10000:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19723              		.loc 1 10000 0
 19724 00ca 3844     		add	r0, r0, r7
 19725 00cc C7B2     		uxtb	r7, r0
 19726              	.LVL2489:
10006:Src/bno055.c  **** 						data1_u8r = ((s8)
 19727              		.loc 1 10006 0
 19728 00ce 07F0FF06 		and	r6, r7, #255
10001:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19729              		.loc 1 10001 0
 19730 00d2 5A4B     		ldr	r3, .L2118
10006:Src/bno055.c  **** 						data1_u8r = ((s8)
 19731              		.loc 1 10006 0
 19732 00d4 002F     		cmp	r7, #0
 19733 00d6 00F09180 		beq	.L2115
 19734              	.LVL2490:
 19735              	.L2100:
10023:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19736              		.loc 1 10023 0
 19737 00da 2368     		ldr	r3, [r4]
 19738 00dc 6021     		movs	r1, #96
 19739 00de 1F69     		ldr	r7, [r3, #16]
 19740 00e0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19741 00e2 0DF10602 		add	r2, sp, #6
 19742 00e6 0123     		movs	r3, #1
 19743 00e8 B847     		blx	r7
 19744              	.LVL2491:
10022:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19745              		.loc 1 10022 0
 19746 00ea 3044     		add	r0, r0, r6
 19747 00ec C6B2     		uxtb	r6, r0
 19748              	.LVL2492:
10028:Src/bno055.c  **** 						data1_u8r = ((s8)
 19749              		.loc 1 10028 0
 19750 00ee 06F0FF07 		and	r7, r6, #255
10023:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19751              		.loc 1 10023 0
 19752 00f2 524B     		ldr	r3, .L2118
10028:Src/bno055.c  **** 						data1_u8r = ((s8)
 19753              		.loc 1 10028 0
 19754 00f4 002E     		cmp	r6, #0
 19755 00f6 72D0     		beq	.L2116
 19756              	.LVL2493:
 19757              	.L2101:
10047:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19758              		.loc 1 10047 0
ARM GAS  /tmp/ccVWLGiI.s 			page 564


 19759 00f8 2368     		ldr	r3, [r4]
 19760 00fa 6921     		movs	r1, #105
 19761 00fc 1E69     		ldr	r6, [r3, #16]
 19762 00fe 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19763 0100 0DF10602 		add	r2, sp, #6
 19764 0104 0123     		movs	r3, #1
 19765 0106 B047     		blx	r6
 19766              	.LVL2494:
10046:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19767              		.loc 1 10046 0
 19768 0108 3844     		add	r0, r0, r7
 19769 010a C7B2     		uxtb	r7, r0
 19770              	.LVL2495:
10052:Src/bno055.c  **** 						data1_u8r = ((s8)
 19771              		.loc 1 10052 0
 19772 010c 07F0FF06 		and	r6, r7, #255
10047:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19773              		.loc 1 10047 0
 19774 0110 4A4B     		ldr	r3, .L2118
10052:Src/bno055.c  **** 						data1_u8r = ((s8)
 19775              		.loc 1 10052 0
 19776 0112 002F     		cmp	r7, #0
 19777 0114 55D0     		beq	.L2117
 19778              	.LVL2496:
 19779              	.L2102:
10069:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19780              		.loc 1 10069 0
 19781 0116 2368     		ldr	r3, [r4]
 19782 0118 6A21     		movs	r1, #106
 19783 011a 1C69     		ldr	r4, [r3, #16]
 19784 011c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19785 011e 0DF10602 		add	r2, sp, #6
 19786 0122 0123     		movs	r3, #1
 19787 0124 A047     		blx	r4
 19788              	.LVL2497:
10068:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 19789              		.loc 1 10068 0
 19790 0126 3044     		add	r0, r0, r6
 19791 0128 C6B2     		uxtb	r6, r0
 19792              	.LVL2498:
10074:Src/bno055.c  **** 						data1_u8r = ((s8)
 19793              		.loc 1 10074 0
 19794 012a 06F0FF04 		and	r4, r6, #255
10069:Src/bno055.c  **** 					(p_bno055->dev_addr,
 19795              		.loc 1 10069 0
 19796 012e 434B     		ldr	r3, .L2118
10074:Src/bno055.c  **** 						data1_u8r = ((s8)
 19797              		.loc 1 10074 0
 19798 0130 002E     		cmp	r6, #0
 19799 0132 7FF478AF 		bne	.L2091
 19800              	.LVL2499:
10084:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19801              		.loc 1 10084 0
 19802 0136 1B68     		ldr	r3, [r3]
10075:Src/bno055.c  **** 						(mag_offset->r >>
 19803              		.loc 1 10075 0
 19804 0138 95F90720 		ldrsb	r2, [r5, #7]
ARM GAS  /tmp/ccVWLGiI.s 			page 565


10084:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19805              		.loc 1 10084 0
 19806 013c DC68     		ldr	r4, [r3, #12]
10075:Src/bno055.c  **** 						(mag_offset->r >>
 19807              		.loc 1 10075 0
 19808 013e 8DF80620 		strb	r2, [sp, #6]
10084:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19809              		.loc 1 10084 0
 19810 0142 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19811 0144 0DF10602 		add	r2, sp, #6
 19812 0148 6A21     		movs	r1, #106
 19813 014a 0123     		movs	r3, #1
 19814 014c A047     		blx	r4
 19815              	.LVL2500:
10083:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19816              		.loc 1 10083 0
 19817 014e 3044     		add	r0, r0, r6
 19818 0150 C4B2     		uxtb	r4, r0
 19819              	.LVL2501:
 19820 0152 68E7     		b	.L2091
 19821              	.L2110:
10100:Src/bno055.c  **** 		(prev_opmode_u8);
 19822              		.loc 1 10100 0
 19823 0154 FFF7FEFF 		bl	bno055_set_operation_mode
 19824              	.LVL2502:
 19825 0158 2044     		add	r0, r0, r4
 19826 015a C0B2     		uxtb	r0, r0
 19827              	.LVL2503:
 19828              		.loc 1 10103 0
 19829 015c 40B2     		sxtb	r0, r0
 19830 015e 03B0     		add	sp, sp, #12
 19831              	.LCFI794:
 19832              		.cfi_remember_state
 19833              		.cfi_def_cfa_offset 20
 19834              		@ sp needed
 19835 0160 F0BD     		pop	{r4, r5, r6, r7, pc}
 19836              	.LVL2504:
 19837              	.L2092:
 19838              	.LCFI795:
 19839              		.cfi_restore_state
9905:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 19840              		.loc 1 9905 0
 19841 0162 FFF7FEFF 		bl	bno055_set_operation_mode
 19842              	.LVL2505:
9907:Src/bno055.c  **** 					/* write Mag offset x value*/
 19843              		.loc 1 9907 0
 19844 0166 0028     		cmp	r0, #0
 19845 0168 7FF45CAF 		bne	.L2096
 19846 016c 69E7     		b	.L2095
 19847              	.LVL2506:
 19848              	.L2112:
9947:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19849              		.loc 1 9947 0
 19850 016e 1B68     		ldr	r3, [r3]
9938:Src/bno055.c  **** 						(mag_offset->x  >>
 19851              		.loc 1 9938 0
 19852 0170 95F90120 		ldrsb	r2, [r5, #1]
ARM GAS  /tmp/ccVWLGiI.s 			page 566


9947:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19853              		.loc 1 9947 0
 19854 0174 DF68     		ldr	r7, [r3, #12]
 19855 0176 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9938:Src/bno055.c  **** 						(mag_offset->x  >>
 19856              		.loc 1 9938 0
 19857 0178 8DF80620 		strb	r2, [sp, #6]
9947:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19858              		.loc 1 9947 0
 19859 017c 5C21     		movs	r1, #92
 19860 017e 0DF10602 		add	r2, sp, #6
 19861 0182 0123     		movs	r3, #1
 19862 0184 B847     		blx	r7
 19863              	.LVL2507:
9946:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19864              		.loc 1 9946 0
 19865 0186 3044     		add	r0, r0, r6
 19866 0188 C7B2     		uxtb	r7, r0
 19867              	.LVL2508:
 19868 018a 76E7     		b	.L2097
 19869              	.LVL2509:
 19870              	.L2111:
9924:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19871              		.loc 1 9924 0
 19872 018c 1B68     		ldr	r3, [r3]
9916:Src/bno055.c  **** 						(mag_offset->x
 19873              		.loc 1 9916 0
 19874 018e 2A88     		ldrh	r2, [r5]
9924:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19875              		.loc 1 9924 0
 19876 0190 DE68     		ldr	r6, [r3, #12]
 19877 0192 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 19878              	.LVL2510:
9916:Src/bno055.c  **** 						(mag_offset->x
 19879              		.loc 1 9916 0
 19880 0194 8DF80620 		strb	r2, [sp, #6]
9924:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19881              		.loc 1 9924 0
 19882 0198 5B21     		movs	r1, #91
 19883 019a 0DF10602 		add	r2, sp, #6
 19884 019e 0123     		movs	r3, #1
 19885 01a0 B047     		blx	r6
 19886              	.LVL2511:
 19887 01a2 0646     		mov	r6, r0
 19888              	.LVL2512:
 19889 01a4 5AE7     		b	.L2094
 19890              	.LVL2513:
 19891              	.L2113:
9970:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19892              		.loc 1 9970 0
 19893 01a6 1B68     		ldr	r3, [r3]
9962:Src/bno055.c  **** 						(mag_offset->y &
 19894              		.loc 1 9962 0
 19895 01a8 6A88     		ldrh	r2, [r5, #2]
9970:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19896              		.loc 1 9970 0
 19897 01aa DE68     		ldr	r6, [r3, #12]
ARM GAS  /tmp/ccVWLGiI.s 			page 567


 19898 01ac 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9962:Src/bno055.c  **** 						(mag_offset->y &
 19899              		.loc 1 9962 0
 19900 01ae 8DF80620 		strb	r2, [sp, #6]
9970:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19901              		.loc 1 9970 0
 19902 01b2 5D21     		movs	r1, #93
 19903 01b4 0DF10602 		add	r2, sp, #6
 19904 01b8 0123     		movs	r3, #1
 19905 01ba B047     		blx	r6
 19906              	.LVL2514:
9969:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19907              		.loc 1 9969 0
 19908 01bc 3844     		add	r0, r0, r7
 19909 01be C6B2     		uxtb	r6, r0
 19910              	.LVL2515:
 19911 01c0 6BE7     		b	.L2098
 19912              	.LVL2516:
 19913              	.L2117:
10061:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19914              		.loc 1 10061 0
 19915 01c2 1B68     		ldr	r3, [r3]
10053:Src/bno055.c  **** 						(mag_offset->r &
 19916              		.loc 1 10053 0
 19917 01c4 EA88     		ldrh	r2, [r5, #6]
10061:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19918              		.loc 1 10061 0
 19919 01c6 DE68     		ldr	r6, [r3, #12]
 19920 01c8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
10053:Src/bno055.c  **** 						(mag_offset->r &
 19921              		.loc 1 10053 0
 19922 01ca 8DF80620 		strb	r2, [sp, #6]
10061:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19923              		.loc 1 10061 0
 19924 01ce 6921     		movs	r1, #105
 19925 01d0 0DF10602 		add	r2, sp, #6
 19926 01d4 0123     		movs	r3, #1
 19927 01d6 B047     		blx	r6
 19928              	.LVL2517:
10060:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19929              		.loc 1 10060 0
 19930 01d8 3844     		add	r0, r0, r7
 19931 01da C6B2     		uxtb	r6, r0
 19932              	.LVL2518:
 19933 01dc 9BE7     		b	.L2102
 19934              	.L2116:
 19935              	.LVL2519:
10038:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19936              		.loc 1 10038 0
 19937 01de 1B68     		ldr	r3, [r3]
10029:Src/bno055.c  **** 						(mag_offset->z >>
 19938              		.loc 1 10029 0
 19939 01e0 95F90520 		ldrsb	r2, [r5, #5]
10038:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19940              		.loc 1 10038 0
 19941 01e4 DF68     		ldr	r7, [r3, #12]
 19942 01e6 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 568


10029:Src/bno055.c  **** 						(mag_offset->z >>
 19943              		.loc 1 10029 0
 19944 01e8 8DF80620 		strb	r2, [sp, #6]
10038:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19945              		.loc 1 10038 0
 19946 01ec 6021     		movs	r1, #96
 19947 01ee 0DF10602 		add	r2, sp, #6
 19948 01f2 0123     		movs	r3, #1
 19949 01f4 B847     		blx	r7
 19950              	.LVL2520:
10037:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19951              		.loc 1 10037 0
 19952 01f6 3044     		add	r0, r0, r6
 19953 01f8 C7B2     		uxtb	r7, r0
 19954              	.LVL2521:
 19955 01fa 7DE7     		b	.L2101
 19956              	.L2115:
 19957              	.LVL2522:
10015:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19958              		.loc 1 10015 0
 19959 01fc 1B68     		ldr	r3, [r3]
10007:Src/bno055.c  **** 						(mag_offset->z &
 19960              		.loc 1 10007 0
 19961 01fe AA88     		ldrh	r2, [r5, #4]
10015:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19962              		.loc 1 10015 0
 19963 0200 DE68     		ldr	r6, [r3, #12]
 19964 0202 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
10007:Src/bno055.c  **** 						(mag_offset->z &
 19965              		.loc 1 10007 0
 19966 0204 8DF80620 		strb	r2, [sp, #6]
10015:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19967              		.loc 1 10015 0
 19968 0208 5F21     		movs	r1, #95
 19969 020a 0DF10602 		add	r2, sp, #6
 19970 020e 0123     		movs	r3, #1
 19971 0210 B047     		blx	r6
 19972              	.LVL2523:
10014:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19973              		.loc 1 10014 0
 19974 0212 3844     		add	r0, r0, r7
 19975 0214 C6B2     		uxtb	r6, r0
 19976              	.LVL2524:
 19977 0216 60E7     		b	.L2100
 19978              	.L2114:
 19979              	.LVL2525:
9993:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19980              		.loc 1 9993 0
 19981 0218 1B68     		ldr	r3, [r3]
9984:Src/bno055.c  **** 						(mag_offset->y >>
 19982              		.loc 1 9984 0
 19983 021a 95F90320 		ldrsb	r2, [r5, #3]
9993:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19984              		.loc 1 9993 0
 19985 021e DF68     		ldr	r7, [r3, #12]
 19986 0220 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
9984:Src/bno055.c  **** 						(mag_offset->y >>
ARM GAS  /tmp/ccVWLGiI.s 			page 569


 19987              		.loc 1 9984 0
 19988 0222 8DF80620 		strb	r2, [sp, #6]
9993:Src/bno055.c  **** 						(p_bno055->dev_addr,
 19989              		.loc 1 9993 0
 19990 0226 5E21     		movs	r1, #94
 19991 0228 0DF10602 		add	r2, sp, #6
 19992 022c 0123     		movs	r3, #1
 19993 022e B847     		blx	r7
 19994              	.LVL2526:
9992:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 19995              		.loc 1 9992 0
 19996 0230 3044     		add	r0, r0, r6
 19997 0232 C7B2     		uxtb	r7, r0
 19998              	.LVL2527:
 19999 0234 41E7     		b	.L2099
 20000              	.LVL2528:
 20001              	.L2103:
9897:Src/bno055.c  **** 	} else {
 20002              		.loc 1 9897 0
 20003 0236 8120     		movs	r0, #129
 20004              	.LVL2529:
 20005 0238 FBE6     		b	.L2089
 20006              	.L2119:
 20007 023a 00BF     		.align	2
 20008              	.L2118:
 20009 023c 00000000 		.word	.LANCHOR0
 20010              		.cfi_endproc
 20011              	.LFE172:
 20013              		.section	.text.bno055_read_gyro_offset,"ax",%progbits
 20014              		.align	2
 20015              		.global	bno055_read_gyro_offset
 20016              		.thumb
 20017              		.thumb_func
 20019              	bno055_read_gyro_offset:
 20020              	.LFB173:
10104:Src/bno055.c  **** /*!
10105:Src/bno055.c  ****  *	@brief This API is used to read gyro offset
10106:Src/bno055.c  ****  *	offset form register 0x61 to 0x66
10107:Src/bno055.c  ****  *
10108:Src/bno055.c  ****  *	@param gyro_offset : The value of gyro offset
10109:Src/bno055.c  ****  *
10110:Src/bno055.c  ****  *	    bno055_gyro_offset_t  |     result
10111:Src/bno055.c  ****  *      ------------------- | ----------------
10112:Src/bno055.c  ****  *	             x          |  gyro offset x
10113:Src/bno055.c  ****  *               y          |  gyro offset y
10114:Src/bno055.c  ****  *	             z          |  gyro offset z
10115:Src/bno055.c  ****  *
10116:Src/bno055.c  ****  *
10117:Src/bno055.c  ****  *	@return results of bus communication function
10118:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10119:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10120:Src/bno055.c  ****  *
10121:Src/bno055.c  ****  *	@note  The range of the gyro offset varies based on
10122:Src/bno055.c  ****  *	the range of gyro sensor
10123:Src/bno055.c  ****  *
10124:Src/bno055.c  ****  *	gyro G range         | offset range
10125:Src/bno055.c  ****  * --------------------  | ------------
ARM GAS  /tmp/ccVWLGiI.s 			page 570


10126:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_2000DPS   | +/-32000
10127:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_1000DPS   | +/-16000
10128:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_500DPS    | +/-8000
10129:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_250DPS    | +/-4000
10130:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_125DPS    | +/-2000
10131:Src/bno055.c  ****  *
10132:Src/bno055.c  ****  *	Gyro range can be configured by using the
10133:Src/bno055.c  ****  *	bno055_set_gyro_range() API
10134:Src/bno055.c  ****  */
10135:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_read_gyro_offset(
10136:Src/bno055.c  **** struct bno055_gyro_offset_t  *gyro_offset)
10137:Src/bno055.c  **** {
 20021              		.loc 1 10137 0
 20022              		.cfi_startproc
 20023              		@ args = 0, pretend = 0, frame = 8
 20024              		@ frame_needed = 0, uses_anonymous_args = 0
 20025              	.LVL2530:
 20026 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 20027              	.LCFI796:
 20028              		.cfi_def_cfa_offset 20
 20029              		.cfi_offset 4, -20
 20030              		.cfi_offset 5, -16
 20031              		.cfi_offset 6, -12
 20032              		.cfi_offset 7, -8
 20033              		.cfi_offset 14, -4
10138:Src/bno055.c  **** 	/* Variable used to return value of
10139:Src/bno055.c  **** 	communication routine*/
10140:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10141:Src/bno055.c  **** 	/* Array holding the gyro offset values
10142:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB] - offset x->LSB
10143:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB] - offset x->MSB
10144:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB] - offset y->LSB
10145:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB] - offset y->MSB
10146:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB] - offset z->LSB
10147:Src/bno055.c  **** 	data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB] - offset z->MSB
10148:Src/bno055.c  **** 	*/
10149:Src/bno055.c  **** 	u8 data_u8[BNO055_GYRO_OFFSET_ARRAY] = {
10150:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
10151:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
10152:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE};
10153:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
10154:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
10155:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 20034              		.loc 1 10155 0
 20035 0002 224C     		ldr	r4, .L2135
10137:Src/bno055.c  **** 	/* Variable used to return value of
 20036              		.loc 1 10137 0
 20037 0004 83B0     		sub	sp, sp, #12
 20038              	.LCFI797:
 20039              		.cfi_def_cfa_offset 32
 20040              		.loc 1 10155 0
 20041 0006 2268     		ldr	r2, [r4]
10149:Src/bno055.c  **** 	BNO055_INIT_VALUE, BNO055_INIT_VALUE,
 20042              		.loc 1 10149 0
 20043 0008 0023     		movs	r3, #0
 20044 000a 8DF80030 		strb	r3, [sp]
 20045 000e 8DF80130 		strb	r3, [sp, #1]
ARM GAS  /tmp/ccVWLGiI.s 			page 571


 20046 0012 8DF80230 		strb	r3, [sp, #2]
 20047 0016 8DF80330 		strb	r3, [sp, #3]
 20048 001a 8DF80430 		strb	r3, [sp, #4]
 20049 001e 8DF80530 		strb	r3, [sp, #5]
 20050              	.LVL2531:
 20051              		.loc 1 10155 0
 20052 0022 002A     		cmp	r2, #0
 20053 0024 2FD0     		beq	.L2125
10156:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
10157:Src/bno055.c  **** 		} else {
10158:Src/bno055.c  **** 		/*condition check for page, gyro offset is
10159:Src/bno055.c  **** 		available in the page zero*/
10160:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ZERO)
 20054              		.loc 1 10160 0
 20055 0026 1179     		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 20056 0028 0546     		mov	r5, r0
 20057 002a 11BB     		cbnz	r1, .L2133
 20058              	.LVL2532:
 20059              	.L2122:
10161:Src/bno055.c  **** 			/* Write the page zero*/
10162:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ZERO);
10163:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
10164:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
10165:Src/bno055.c  **** 			/* Read gyro offset value it the six bytes of data*/
10166:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 20060              		.loc 1 10166 0
 20061 002c 1469     		ldr	r4, [r2, #16]
 20062 002e 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 20063 0030 6121     		movs	r1, #97
 20064 0032 6A46     		mov	r2, sp
 20065 0034 0623     		movs	r3, #6
 20066 0036 A047     		blx	r4
 20067              	.LVL2533:
10167:Src/bno055.c  **** 			(p_bno055->dev_addr,
10168:Src/bno055.c  **** 			BNO055_GYRO_OFFSET_X_LSB_REG,
10169:Src/bno055.c  **** 			data_u8, BNO055_GYRO_OFFSET_ARRAY);
10170:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 20068              		.loc 1 10170 0
 20069 0038 18B1     		cbz	r0, .L2134
 20070              	.LVL2534:
 20071              	.L2124:
10171:Src/bno055.c  **** 				/* Read gyro x offset value*/
10172:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB] =
10173:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
10174:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB],
10175:Src/bno055.c  **** 				BNO055_GYRO_OFFSET_X_LSB);
10176:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB] =
10177:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
10178:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB],
10179:Src/bno055.c  **** 				BNO055_GYRO_OFFSET_X_MSB);
10180:Src/bno055.c  **** 				gyro_offset->x = (s16)((((s32)(s8)
10181:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
10182:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
10183:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_LSB]));
10184:Src/bno055.c  **** 
10185:Src/bno055.c  **** 				/* Read gyro y offset value*/
10186:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB] =
ARM GAS  /tmp/ccVWLGiI.s 			page 572


10187:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
10188:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB],
10189:Src/bno055.c  **** 				BNO055_GYRO_OFFSET_Y_LSB);
10190:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB] =
10191:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
10192:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB],
10193:Src/bno055.c  **** 				BNO055_GYRO_OFFSET_Y_MSB);
10194:Src/bno055.c  **** 				gyro_offset->y = (s16)((((s32)(s8)
10195:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
10196:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
10197:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_LSB]));
10198:Src/bno055.c  **** 
10199:Src/bno055.c  **** 				/* Read gyro z offset value*/
10200:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB] =
10201:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
10202:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB],
10203:Src/bno055.c  **** 				BNO055_GYRO_OFFSET_Z_LSB);
10204:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB] =
10205:Src/bno055.c  **** 				BNO055_GET_BITSLICE(
10206:Src/bno055.c  **** 				data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB],
10207:Src/bno055.c  **** 				BNO055_GYRO_OFFSET_Z_MSB);
10208:Src/bno055.c  **** 				gyro_offset->z = (s16)((((s32)(s8)
10209:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
10210:Src/bno055.c  **** 				(BNO055_SHIFT_EIGHT_BITS)) |
10211:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_LSB]));
10212:Src/bno055.c  **** 			} else {
10213:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
10214:Src/bno055.c  **** 			}
10215:Src/bno055.c  **** 		} else {
10216:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 20072              		.loc 1 10216 0
 20073 003a FF20     		movs	r0, #255
 20074              	.LVL2535:
 20075              	.L2121:
10217:Src/bno055.c  **** 		}
10218:Src/bno055.c  **** 	}
10219:Src/bno055.c  **** 	return com_rslt;
10220:Src/bno055.c  **** }
 20076              		.loc 1 10220 0
 20077 003c 40B2     		sxtb	r0, r0
 20078 003e 03B0     		add	sp, sp, #12
 20079              	.LCFI798:
 20080              		.cfi_remember_state
 20081              		.cfi_def_cfa_offset 20
 20082              		@ sp needed
 20083 0040 F0BD     		pop	{r4, r5, r6, r7, pc}
 20084              	.LVL2536:
 20085              	.L2134:
 20086              	.LCFI799:
 20087              		.cfi_restore_state
10180:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 20088              		.loc 1 10180 0
 20089 0042 9DF90170 		ldrsb	r7, [sp, #1]
 20090 0046 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
10194:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 20091              		.loc 1 10194 0
 20092 004a 9DF90360 		ldrsb	r6, [sp, #3]
ARM GAS  /tmp/ccVWLGiI.s 			page 573


 20093 004e 9DF80220 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
10208:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 20094              		.loc 1 10208 0
 20095 0052 9DF90540 		ldrsb	r4, [sp, #5]
 20096 0056 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
10180:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 20097              		.loc 1 10180 0
 20098 005a 41EA0721 		orr	r1, r1, r7, lsl #8
10194:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 20099              		.loc 1 10194 0
 20100 005e 42EA0622 		orr	r2, r2, r6, lsl #8
10208:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 20101              		.loc 1 10208 0
 20102 0062 43EA0423 		orr	r3, r3, r4, lsl #8
 20103              		.loc 1 10220 0
 20104 0066 40B2     		sxtb	r0, r0
10180:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_X_MSB])) <<
 20105              		.loc 1 10180 0
 20106 0068 2980     		strh	r1, [r5]	@ movhi
10194:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Y_MSB])) <<
 20107              		.loc 1 10194 0
 20108 006a 6A80     		strh	r2, [r5, #2]	@ movhi
10208:Src/bno055.c  **** 				(data_u8[BNO055_SENSOR_OFFSET_DATA_Z_MSB])) <<
 20109              		.loc 1 10208 0
 20110 006c AB80     		strh	r3, [r5, #4]	@ movhi
 20111              		.loc 1 10220 0
 20112 006e 03B0     		add	sp, sp, #12
 20113              	.LCFI800:
 20114              		.cfi_remember_state
 20115              		.cfi_def_cfa_offset 20
 20116              		@ sp needed
 20117 0070 F0BD     		pop	{r4, r5, r6, r7, pc}
 20118              	.LVL2537:
 20119              	.L2133:
 20120              	.LCFI801:
 20121              		.cfi_restore_state
10162:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 20122              		.loc 1 10162 0
 20123 0072 1846     		mov	r0, r3
 20124              	.LVL2538:
 20125 0074 FFF7FEFF 		bl	bno055_write_page_id
 20126              	.LVL2539:
 20127 0078 2268     		ldr	r2, [r4]
10163:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 20128              		.loc 1 10163 0
 20129 007a 0028     		cmp	r0, #0
 20130 007c D6D0     		beq	.L2122
 20131              	.LVL2540:
10163:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ZERO)) {
 20132              		.loc 1 10163 0 is_stmt 0 discriminator 1
 20133 007e 1379     		ldrb	r3, [r2, #4]	@ zero_extendqisi2
 20134 0080 002B     		cmp	r3, #0
 20135 0082 DAD1     		bne	.L2124
 20136 0084 D2E7     		b	.L2122
 20137              	.LVL2541:
 20138              	.L2125:
10156:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 574


 20139              		.loc 1 10156 0 is_stmt 1
 20140 0086 8120     		movs	r0, #129
 20141              	.LVL2542:
 20142 0088 D8E7     		b	.L2121
 20143              	.L2136:
 20144 008a 00BF     		.align	2
 20145              	.L2135:
 20146 008c 00000000 		.word	.LANCHOR0
 20147              		.cfi_endproc
 20148              	.LFE173:
 20150              		.section	.text.bno055_write_gyro_offset,"ax",%progbits
 20151              		.align	2
 20152              		.global	bno055_write_gyro_offset
 20153              		.thumb
 20154              		.thumb_func
 20156              	bno055_write_gyro_offset:
 20157              	.LFB174:
10221:Src/bno055.c  **** /*!
10222:Src/bno055.c  ****  *	@brief This API is used to read gyro offset
10223:Src/bno055.c  ****  *	offset form register 0x61 to 0x66
10224:Src/bno055.c  ****  *
10225:Src/bno055.c  ****  *	@param gyro_offset : The value of gyro offset
10226:Src/bno055.c  ****  *
10227:Src/bno055.c  ****  *	    bno055_gyro_offset_t  |     result
10228:Src/bno055.c  ****  *      ------------------- | ----------------
10229:Src/bno055.c  ****  *	             x          |  gyro offset x
10230:Src/bno055.c  ****  *               y          |  gyro offset y
10231:Src/bno055.c  ****  *	             z          |  gyro offset z
10232:Src/bno055.c  ****  *
10233:Src/bno055.c  ****  *
10234:Src/bno055.c  ****  *	@return results of bus communication function
10235:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10236:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10237:Src/bno055.c  ****  *
10238:Src/bno055.c  ****  *	@note  The range of the gyro offset varies based on
10239:Src/bno055.c  ****  *	the range of gyro sensor
10240:Src/bno055.c  ****  *
10241:Src/bno055.c  ****  *	gyro G range         | offset range
10242:Src/bno055.c  ****  * --------------------  | ------------
10243:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_2000DPS   | +/-32000
10244:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_1000DPS   | +/-16000
10245:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_500DPS    | +/-8000
10246:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_250DPS    | +/-4000
10247:Src/bno055.c  ****  *  BNO055_GYRO_RANGE_125DPS    | +/-2000
10248:Src/bno055.c  ****  *
10249:Src/bno055.c  ****  *	Gyro range can be configured by using the
10250:Src/bno055.c  ****  *	bno055_set_gyro_range() API
10251:Src/bno055.c  ****  */
10252:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_write_gyro_offset(
10253:Src/bno055.c  **** struct bno055_gyro_offset_t  *gyro_offset)
10254:Src/bno055.c  **** {
 20158              		.loc 1 10254 0
 20159              		.cfi_startproc
 20160              		@ args = 0, pretend = 0, frame = 8
 20161              		@ frame_needed = 0, uses_anonymous_args = 0
 20162              	.LVL2543:
 20163 0000 F0B5     		push	{r4, r5, r6, r7, lr}
ARM GAS  /tmp/ccVWLGiI.s 			page 575


 20164              	.LCFI802:
 20165              		.cfi_def_cfa_offset 20
 20166              		.cfi_offset 4, -20
 20167              		.cfi_offset 5, -16
 20168              		.cfi_offset 6, -12
 20169              		.cfi_offset 7, -8
 20170              		.cfi_offset 14, -4
10255:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10256:Src/bno055.c  **** u8 data1_u8r = BNO055_INIT_VALUE;
10257:Src/bno055.c  **** u8 data2_u8r = BNO055_INIT_VALUE;
10258:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
10259:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
10260:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
10261:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 20171              		.loc 1 10261 0
 20172 0002 6D4C     		ldr	r4, .L2163
10254:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 20173              		.loc 1 10254 0
 20174 0004 83B0     		sub	sp, sp, #12
 20175              	.LCFI803:
 20176              		.cfi_def_cfa_offset 32
 20177              		.loc 1 10261 0
 20178 0006 2268     		ldr	r2, [r4]
10257:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
 20179              		.loc 1 10257 0
 20180 0008 0023     		movs	r3, #0
 20181 000a 8DF80630 		strb	r3, [sp, #6]
10258:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 20182              		.loc 1 10258 0
 20183 000e 8DF80730 		strb	r3, [sp, #7]
 20184              	.LVL2544:
 20185              		.loc 1 10261 0
 20186 0012 002A     		cmp	r2, #0
 20187 0014 00F0CD80 		beq	.L2150
 20188 0018 0546     		mov	r5, r0
10262:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
10263:Src/bno055.c  **** 	} else {
10264:Src/bno055.c  **** 	/* The write operation effective only if the operation
10265:Src/bno055.c  **** 		mode is in config mode, this part of code is checking the
10266:Src/bno055.c  **** 		current operation mode and set the config mode */
10267:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 20189              		.loc 1 10267 0
 20190 001a 0DF10700 		add	r0, sp, #7
 20191              	.LVL2545:
 20192 001e FFF7FEFF 		bl	bno055_get_operation_mode
 20193              	.LVL2546:
10268:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 20194              		.loc 1 10268 0
 20195 0022 40B1     		cbz	r0, .L2139
 20196              	.L2145:
10269:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
10270:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
10271:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
10272:Src/bno055.c  **** 				if (stat_s8 == BNO055_SUCCESS) {
10273:Src/bno055.c  **** 					/* write gryo offset x value*/
10274:Src/bno055.c  **** 					com_rslt =
10275:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 576


10276:Src/bno055.c  **** 					(p_bno055->dev_addr,
10277:Src/bno055.c  **** 					BNO055_GYRO_OFFSET_X_LSB_REG,
10278:Src/bno055.c  **** 					&data2_u8r,
10279:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10280:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10281:Src/bno055.c  **** 						data1_u8r = ((s8)
10282:Src/bno055.c  **** 						(gyro_offset->x
10283:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
10284:Src/bno055.c  **** 						data2_u8r =
10285:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10286:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_X_LSB,
10287:Src/bno055.c  **** 						data1_u8r);
10288:Src/bno055.c  **** 						com_rslt +=
10289:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10290:Src/bno055.c  **** 						(p_bno055->dev_addr,
10291:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_X_LSB_REG,
10292:Src/bno055.c  **** 						&data2_u8r,
10293:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10294:Src/bno055.c  **** 					}
10295:Src/bno055.c  **** 
10296:Src/bno055.c  **** 					com_rslt +=
10297:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10298:Src/bno055.c  **** 					(p_bno055->dev_addr,
10299:Src/bno055.c  **** 					BNO055_GYRO_OFFSET_X_MSB_REG,
10300:Src/bno055.c  **** 					&data2_u8r,
10301:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10302:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10303:Src/bno055.c  **** 						data1_u8r = ((s8)
10304:Src/bno055.c  **** 						(gyro_offset->x  >>
10305:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
10306:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
10307:Src/bno055.c  **** 						data2_u8r =
10308:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10309:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_X_MSB,
10310:Src/bno055.c  **** 						data1_u8r);
10311:Src/bno055.c  **** 						com_rslt +=
10312:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10313:Src/bno055.c  **** 						(p_bno055->dev_addr,
10314:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_X_MSB_REG,
10315:Src/bno055.c  **** 						&data2_u8r,
10316:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10317:Src/bno055.c  **** 					}
10318:Src/bno055.c  **** 
10319:Src/bno055.c  **** 					/* write gryo offset y value*/
10320:Src/bno055.c  **** 					com_rslt +=
10321:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10322:Src/bno055.c  **** 					(p_bno055->dev_addr,
10323:Src/bno055.c  **** 					BNO055_GYRO_OFFSET_Y_LSB_REG,
10324:Src/bno055.c  **** 					&data2_u8r,
10325:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10326:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10327:Src/bno055.c  **** 						data1_u8r = ((s8)
10328:Src/bno055.c  **** 						(gyro_offset->y
10329:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
10330:Src/bno055.c  **** 						data2_u8r =
10331:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10332:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Y_LSB,
ARM GAS  /tmp/ccVWLGiI.s 			page 577


10333:Src/bno055.c  **** 						data1_u8r);
10334:Src/bno055.c  **** 						com_rslt +=
10335:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10336:Src/bno055.c  **** 						(p_bno055->dev_addr,
10337:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Y_LSB_REG,
10338:Src/bno055.c  **** 						&data2_u8r,
10339:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10340:Src/bno055.c  **** 					}
10341:Src/bno055.c  **** 
10342:Src/bno055.c  **** 					com_rslt +=
10343:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10344:Src/bno055.c  **** 					(p_bno055->dev_addr,
10345:Src/bno055.c  **** 					BNO055_GYRO_OFFSET_Y_MSB_REG,
10346:Src/bno055.c  **** 					&data2_u8r,
10347:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10348:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10349:Src/bno055.c  **** 						data1_u8r = ((s8)
10350:Src/bno055.c  **** 						(gyro_offset->y >>
10351:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
10352:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
10353:Src/bno055.c  **** 						data2_u8r =
10354:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10355:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Y_MSB,
10356:Src/bno055.c  **** 						data1_u8r);
10357:Src/bno055.c  **** 						com_rslt +=
10358:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10359:Src/bno055.c  **** 						(p_bno055->dev_addr,
10360:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Y_MSB_REG,
10361:Src/bno055.c  **** 						&data2_u8r,
10362:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10363:Src/bno055.c  **** 					}
10364:Src/bno055.c  **** 				/* write gryo offset z value*/
10365:Src/bno055.c  **** 					com_rslt +=
10366:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10367:Src/bno055.c  **** 					(p_bno055->dev_addr,
10368:Src/bno055.c  **** 					BNO055_GYRO_OFFSET_Z_LSB_REG,
10369:Src/bno055.c  **** 					&data2_u8r,
10370:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10371:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10372:Src/bno055.c  **** 						data1_u8r = ((s8)
10373:Src/bno055.c  **** 						(gyro_offset->z
10374:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA));
10375:Src/bno055.c  **** 						data2_u8r =
10376:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10377:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Z_LSB,
10378:Src/bno055.c  **** 						data1_u8r);
10379:Src/bno055.c  **** 						com_rslt +=
10380:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10381:Src/bno055.c  **** 						(p_bno055->dev_addr,
10382:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Z_LSB_REG,
10383:Src/bno055.c  **** 						&data2_u8r,
10384:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10385:Src/bno055.c  **** 					}
10386:Src/bno055.c  **** 
10387:Src/bno055.c  **** 					com_rslt +=
10388:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10389:Src/bno055.c  **** 					(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 578


10390:Src/bno055.c  **** 					BNO055_GYRO_OFFSET_Z_MSB_REG,
10391:Src/bno055.c  **** 					&data2_u8r,
10392:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10393:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10394:Src/bno055.c  **** 						data1_u8r = ((s8)
10395:Src/bno055.c  **** 						(gyro_offset->z >>
10396:Src/bno055.c  **** 						BNO055_SHIFT_EIGHT_BITS)
10397:Src/bno055.c  **** 						& BNO055_SIC_HEX_0_0_F_F_DATA);
10398:Src/bno055.c  **** 						data2_u8r =
10399:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data2_u8r,
10400:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Z_MSB,
10401:Src/bno055.c  **** 						data1_u8r);
10402:Src/bno055.c  **** 						com_rslt +=
10403:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10404:Src/bno055.c  **** 						(p_bno055->dev_addr,
10405:Src/bno055.c  **** 						BNO055_GYRO_OFFSET_Z_MSB_REG,
10406:Src/bno055.c  **** 						&data2_u8r,
10407:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10408:Src/bno055.c  **** 					}
10409:Src/bno055.c  **** 			} else {
10410:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
10411:Src/bno055.c  **** 			}
10412:Src/bno055.c  **** 		} else {
10413:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 20197              		.loc 1 10413 0
 20198 0024 FF24     		movs	r4, #255
 20199              	.LVL2547:
 20200              	.L2140:
10414:Src/bno055.c  **** 		}
10415:Src/bno055.c  **** 	}
10416:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 20201              		.loc 1 10416 0
 20202 0026 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 20203 002a 0028     		cmp	r0, #0
 20204 002c 6ED1     		bne	.L2157
 20205 002e 2046     		mov	r0, r4
 20206              	.LVL2548:
 20207              	.L2138:
10417:Src/bno055.c  **** 		/* set the operation mode
10418:Src/bno055.c  **** 		of previous operation mode*/
10419:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
10420:Src/bno055.c  **** 		(prev_opmode_u8);
10421:Src/bno055.c  **** 	return com_rslt;
10422:Src/bno055.c  **** }
 20208              		.loc 1 10422 0
 20209 0030 40B2     		sxtb	r0, r0
 20210 0032 03B0     		add	sp, sp, #12
 20211              	.LCFI804:
 20212              		.cfi_remember_state
 20213              		.cfi_def_cfa_offset 20
 20214              		@ sp needed
 20215 0034 F0BD     		pop	{r4, r5, r6, r7, pc}
 20216              	.LVL2549:
 20217              	.L2139:
 20218              	.LCFI805:
 20219              		.cfi_restore_state
10269:Src/bno055.c  **** 				stat_s8 += bno055_set_operation_mode
ARM GAS  /tmp/ccVWLGiI.s 			page 579


 20220              		.loc 1 10269 0
 20221 0036 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 20222 003a 002B     		cmp	r3, #0
 20223 003c 6DD1     		bne	.L2141
 20224              	.L2144:
 20225              	.LVL2550:
10275:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20226              		.loc 1 10275 0
 20227 003e 2368     		ldr	r3, [r4]
10274:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20228              		.loc 1 10274 0
 20229 0040 0DF10602 		add	r2, sp, #6
 20230 0044 1E69     		ldr	r6, [r3, #16]
 20231 0046 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20232 0048 6121     		movs	r1, #97
 20233 004a 0123     		movs	r3, #1
 20234 004c B047     		blx	r6
 20235              	.LVL2551:
10275:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20236              		.loc 1 10275 0
 20237 004e 5A4B     		ldr	r3, .L2163
10280:Src/bno055.c  **** 						data1_u8r = ((s8)
 20238              		.loc 1 10280 0
 20239 0050 0646     		mov	r6, r0
 20240 0052 0028     		cmp	r0, #0
 20241 0054 75D0     		beq	.L2158
 20242              	.LVL2552:
 20243              	.L2143:
10297:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20244              		.loc 1 10297 0
 20245 0056 2368     		ldr	r3, [r4]
 20246 0058 6221     		movs	r1, #98
 20247 005a 1F69     		ldr	r7, [r3, #16]
 20248 005c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20249 005e 0DF10602 		add	r2, sp, #6
 20250 0062 0123     		movs	r3, #1
 20251 0064 B847     		blx	r7
 20252              	.LVL2553:
10296:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20253              		.loc 1 10296 0
 20254 0066 3044     		add	r0, r0, r6
 20255 0068 C6B2     		uxtb	r6, r0
 20256              	.LVL2554:
10302:Src/bno055.c  **** 						data1_u8r = ((s8)
 20257              		.loc 1 10302 0
 20258 006a 06F0FF07 		and	r7, r6, #255
10297:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20259              		.loc 1 10297 0
 20260 006e 524B     		ldr	r3, .L2163
10302:Src/bno055.c  **** 						data1_u8r = ((s8)
 20261              		.loc 1 10302 0
 20262 0070 002E     		cmp	r6, #0
 20263 0072 57D0     		beq	.L2159
 20264              	.LVL2555:
 20265              	.L2146:
10321:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20266              		.loc 1 10321 0
ARM GAS  /tmp/ccVWLGiI.s 			page 580


 20267 0074 2368     		ldr	r3, [r4]
 20268 0076 6321     		movs	r1, #99
 20269 0078 1E69     		ldr	r6, [r3, #16]
 20270 007a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20271 007c 0DF10602 		add	r2, sp, #6
 20272 0080 0123     		movs	r3, #1
 20273 0082 B047     		blx	r6
 20274              	.LVL2556:
10320:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20275              		.loc 1 10320 0
 20276 0084 3844     		add	r0, r0, r7
 20277 0086 C7B2     		uxtb	r7, r0
 20278              	.LVL2557:
10326:Src/bno055.c  **** 						data1_u8r = ((s8)
 20279              		.loc 1 10326 0
 20280 0088 07F0FF06 		and	r6, r7, #255
10321:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20281              		.loc 1 10321 0
 20282 008c 4A4B     		ldr	r3, .L2163
10326:Src/bno055.c  **** 						data1_u8r = ((s8)
 20283              		.loc 1 10326 0
 20284 008e 002F     		cmp	r7, #0
 20285 0090 00F08180 		beq	.L2160
 20286              	.LVL2558:
 20287              	.L2147:
10343:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20288              		.loc 1 10343 0
 20289 0094 2368     		ldr	r3, [r4]
 20290 0096 6421     		movs	r1, #100
 20291 0098 1F69     		ldr	r7, [r3, #16]
 20292 009a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20293 009c 0DF10602 		add	r2, sp, #6
 20294 00a0 0123     		movs	r3, #1
 20295 00a2 B847     		blx	r7
 20296              	.LVL2559:
10342:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20297              		.loc 1 10342 0
 20298 00a4 3044     		add	r0, r0, r6
 20299 00a6 C6B2     		uxtb	r6, r0
 20300              	.LVL2560:
10348:Src/bno055.c  **** 						data1_u8r = ((s8)
 20301              		.loc 1 10348 0
 20302 00a8 06F0FF07 		and	r7, r6, #255
10343:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20303              		.loc 1 10343 0
 20304 00ac 424B     		ldr	r3, .L2163
10348:Src/bno055.c  **** 						data1_u8r = ((s8)
 20305              		.loc 1 10348 0
 20306 00ae 002E     		cmp	r6, #0
 20307 00b0 62D0     		beq	.L2161
 20308              	.LVL2561:
 20309              	.L2148:
10366:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20310              		.loc 1 10366 0
 20311 00b2 2368     		ldr	r3, [r4]
 20312 00b4 6521     		movs	r1, #101
 20313 00b6 1E69     		ldr	r6, [r3, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 581


 20314 00b8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20315 00ba 0DF10602 		add	r2, sp, #6
 20316 00be 0123     		movs	r3, #1
 20317 00c0 B047     		blx	r6
 20318              	.LVL2562:
10365:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20319              		.loc 1 10365 0
 20320 00c2 3844     		add	r0, r0, r7
 20321 00c4 C7B2     		uxtb	r7, r0
 20322              	.LVL2563:
10371:Src/bno055.c  **** 						data1_u8r = ((s8)
 20323              		.loc 1 10371 0
 20324 00c6 07F0FF06 		and	r6, r7, #255
10366:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20325              		.loc 1 10366 0
 20326 00ca 3B4B     		ldr	r3, .L2163
10371:Src/bno055.c  **** 						data1_u8r = ((s8)
 20327              		.loc 1 10371 0
 20328 00cc 002F     		cmp	r7, #0
 20329 00ce 45D0     		beq	.L2162
 20330              	.LVL2564:
 20331              	.L2149:
10388:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20332              		.loc 1 10388 0
 20333 00d0 2368     		ldr	r3, [r4]
 20334 00d2 6621     		movs	r1, #102
 20335 00d4 1C69     		ldr	r4, [r3, #16]
 20336 00d6 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20337 00d8 0DF10602 		add	r2, sp, #6
 20338 00dc 0123     		movs	r3, #1
 20339 00de A047     		blx	r4
 20340              	.LVL2565:
10387:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20341              		.loc 1 10387 0
 20342 00e0 3044     		add	r0, r0, r6
 20343 00e2 C6B2     		uxtb	r6, r0
 20344              	.LVL2566:
10393:Src/bno055.c  **** 						data1_u8r = ((s8)
 20345              		.loc 1 10393 0
 20346 00e4 06F0FF04 		and	r4, r6, #255
10388:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20347              		.loc 1 10388 0
 20348 00e8 334B     		ldr	r3, .L2163
10393:Src/bno055.c  **** 						data1_u8r = ((s8)
 20349              		.loc 1 10393 0
 20350 00ea 002E     		cmp	r6, #0
 20351 00ec 9BD1     		bne	.L2140
 20352              	.LVL2567:
10403:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20353              		.loc 1 10403 0
 20354 00ee 1B68     		ldr	r3, [r3]
10394:Src/bno055.c  **** 						(gyro_offset->z >>
 20355              		.loc 1 10394 0
 20356 00f0 95F90520 		ldrsb	r2, [r5, #5]
10403:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20357              		.loc 1 10403 0
 20358 00f4 DC68     		ldr	r4, [r3, #12]
ARM GAS  /tmp/ccVWLGiI.s 			page 582


10394:Src/bno055.c  **** 						(gyro_offset->z >>
 20359              		.loc 1 10394 0
 20360 00f6 8DF80620 		strb	r2, [sp, #6]
10403:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20361              		.loc 1 10403 0
 20362 00fa 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20363 00fc 0DF10602 		add	r2, sp, #6
 20364 0100 6621     		movs	r1, #102
 20365 0102 0123     		movs	r3, #1
 20366 0104 A047     		blx	r4
 20367              	.LVL2568:
10402:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 20368              		.loc 1 10402 0
 20369 0106 3044     		add	r0, r0, r6
 20370 0108 C4B2     		uxtb	r4, r0
 20371              	.LVL2569:
 20372 010a 8CE7     		b	.L2140
 20373              	.L2157:
10419:Src/bno055.c  **** 		(prev_opmode_u8);
 20374              		.loc 1 10419 0
 20375 010c FFF7FEFF 		bl	bno055_set_operation_mode
 20376              	.LVL2570:
 20377 0110 2044     		add	r0, r0, r4
 20378 0112 C0B2     		uxtb	r0, r0
 20379              	.LVL2571:
 20380              		.loc 1 10422 0
 20381 0114 40B2     		sxtb	r0, r0
 20382 0116 03B0     		add	sp, sp, #12
 20383              	.LCFI806:
 20384              		.cfi_remember_state
 20385              		.cfi_def_cfa_offset 20
 20386              		@ sp needed
 20387 0118 F0BD     		pop	{r4, r5, r6, r7, pc}
 20388              	.LVL2572:
 20389              	.L2141:
 20390              	.LCFI807:
 20391              		.cfi_restore_state
10270:Src/bno055.c  **** 				(BNO055_OPERATION_MODE_CONFIG);
 20392              		.loc 1 10270 0
 20393 011a FFF7FEFF 		bl	bno055_set_operation_mode
 20394              	.LVL2573:
10272:Src/bno055.c  **** 					/* write gryo offset x value*/
 20395              		.loc 1 10272 0
 20396 011e 0028     		cmp	r0, #0
 20397 0120 80D1     		bne	.L2145
 20398 0122 8CE7     		b	.L2144
 20399              	.LVL2574:
 20400              	.L2159:
10312:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20401              		.loc 1 10312 0
 20402 0124 1B68     		ldr	r3, [r3]
10303:Src/bno055.c  **** 						(gyro_offset->x  >>
 20403              		.loc 1 10303 0
 20404 0126 95F90120 		ldrsb	r2, [r5, #1]
10312:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20405              		.loc 1 10312 0
 20406 012a DF68     		ldr	r7, [r3, #12]
ARM GAS  /tmp/ccVWLGiI.s 			page 583


 20407 012c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
10303:Src/bno055.c  **** 						(gyro_offset->x  >>
 20408              		.loc 1 10303 0
 20409 012e 8DF80620 		strb	r2, [sp, #6]
10312:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20410              		.loc 1 10312 0
 20411 0132 6221     		movs	r1, #98
 20412 0134 0DF10602 		add	r2, sp, #6
 20413 0138 0123     		movs	r3, #1
 20414 013a B847     		blx	r7
 20415              	.LVL2575:
10311:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 20416              		.loc 1 10311 0
 20417 013c 3044     		add	r0, r0, r6
 20418 013e C7B2     		uxtb	r7, r0
 20419              	.LVL2576:
 20420 0140 98E7     		b	.L2146
 20421              	.LVL2577:
 20422              	.L2158:
10289:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20423              		.loc 1 10289 0
 20424 0142 1B68     		ldr	r3, [r3]
10281:Src/bno055.c  **** 						(gyro_offset->x
 20425              		.loc 1 10281 0
 20426 0144 2A88     		ldrh	r2, [r5]
10289:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20427              		.loc 1 10289 0
 20428 0146 DE68     		ldr	r6, [r3, #12]
 20429 0148 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20430              	.LVL2578:
10281:Src/bno055.c  **** 						(gyro_offset->x
 20431              		.loc 1 10281 0
 20432 014a 8DF80620 		strb	r2, [sp, #6]
10289:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20433              		.loc 1 10289 0
 20434 014e 6121     		movs	r1, #97
 20435 0150 0DF10602 		add	r2, sp, #6
 20436 0154 0123     		movs	r3, #1
 20437 0156 B047     		blx	r6
 20438              	.LVL2579:
 20439 0158 0646     		mov	r6, r0
 20440              	.LVL2580:
 20441 015a 7CE7     		b	.L2143
 20442              	.LVL2581:
 20443              	.L2162:
10380:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20444              		.loc 1 10380 0
 20445 015c 1B68     		ldr	r3, [r3]
10372:Src/bno055.c  **** 						(gyro_offset->z
 20446              		.loc 1 10372 0
 20447 015e AA88     		ldrh	r2, [r5, #4]
10380:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20448              		.loc 1 10380 0
 20449 0160 DE68     		ldr	r6, [r3, #12]
 20450 0162 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
10372:Src/bno055.c  **** 						(gyro_offset->z
 20451              		.loc 1 10372 0
ARM GAS  /tmp/ccVWLGiI.s 			page 584


 20452 0164 8DF80620 		strb	r2, [sp, #6]
10380:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20453              		.loc 1 10380 0
 20454 0168 6521     		movs	r1, #101
 20455 016a 0DF10602 		add	r2, sp, #6
 20456 016e 0123     		movs	r3, #1
 20457 0170 B047     		blx	r6
 20458              	.LVL2582:
10379:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 20459              		.loc 1 10379 0
 20460 0172 3844     		add	r0, r0, r7
 20461 0174 C6B2     		uxtb	r6, r0
 20462              	.LVL2583:
 20463 0176 ABE7     		b	.L2149
 20464              	.L2161:
 20465              	.LVL2584:
10358:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20466              		.loc 1 10358 0
 20467 0178 1B68     		ldr	r3, [r3]
10349:Src/bno055.c  **** 						(gyro_offset->y >>
 20468              		.loc 1 10349 0
 20469 017a 95F90320 		ldrsb	r2, [r5, #3]
10358:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20470              		.loc 1 10358 0
 20471 017e DF68     		ldr	r7, [r3, #12]
 20472 0180 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
10349:Src/bno055.c  **** 						(gyro_offset->y >>
 20473              		.loc 1 10349 0
 20474 0182 8DF80620 		strb	r2, [sp, #6]
10358:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20475              		.loc 1 10358 0
 20476 0186 6421     		movs	r1, #100
 20477 0188 0DF10602 		add	r2, sp, #6
 20478 018c 0123     		movs	r3, #1
 20479 018e B847     		blx	r7
 20480              	.LVL2585:
10357:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 20481              		.loc 1 10357 0
 20482 0190 3044     		add	r0, r0, r6
 20483 0192 C7B2     		uxtb	r7, r0
 20484              	.LVL2586:
 20485 0194 8DE7     		b	.L2148
 20486              	.L2160:
 20487              	.LVL2587:
10335:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20488              		.loc 1 10335 0
 20489 0196 1B68     		ldr	r3, [r3]
10327:Src/bno055.c  **** 						(gyro_offset->y
 20490              		.loc 1 10327 0
 20491 0198 6A88     		ldrh	r2, [r5, #2]
10335:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20492              		.loc 1 10335 0
 20493 019a DE68     		ldr	r6, [r3, #12]
 20494 019c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
10327:Src/bno055.c  **** 						(gyro_offset->y
 20495              		.loc 1 10327 0
 20496 019e 8DF80620 		strb	r2, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 585


10335:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20497              		.loc 1 10335 0
 20498 01a2 6321     		movs	r1, #99
 20499 01a4 0DF10602 		add	r2, sp, #6
 20500 01a8 0123     		movs	r3, #1
 20501 01aa B047     		blx	r6
 20502              	.LVL2588:
10334:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
 20503              		.loc 1 10334 0
 20504 01ac 3844     		add	r0, r0, r7
 20505 01ae C6B2     		uxtb	r6, r0
 20506              	.LVL2589:
 20507 01b0 70E7     		b	.L2147
 20508              	.LVL2590:
 20509              	.L2150:
10262:Src/bno055.c  **** 	} else {
 20510              		.loc 1 10262 0
 20511 01b2 8120     		movs	r0, #129
 20512              	.LVL2591:
 20513 01b4 3CE7     		b	.L2138
 20514              	.L2164:
 20515 01b6 00BF     		.align	2
 20516              	.L2163:
 20517 01b8 00000000 		.word	.LANCHOR0
 20518              		.cfi_endproc
 20519              	.LFE174:
 20521              		.section	.text.bno055_get_accel_range,"ax",%progbits
 20522              		.align	2
 20523              		.global	bno055_get_accel_range
 20524              		.thumb
 20525              		.thumb_func
 20527              	bno055_get_accel_range:
 20528              	.LFB175:
10423:Src/bno055.c  **** /********************************************************/
10424:Src/bno055.c  ****  /************** PAGE1 Functions *********************/
10425:Src/bno055.c  **** /********************************************************/
10426:Src/bno055.c  **** /*!
10427:Src/bno055.c  ****  *	@brief This API used to read the accel range
10428:Src/bno055.c  ****  *	from page one register from 0x08 bit 0 and 1
10429:Src/bno055.c  ****  *
10430:Src/bno055.c  ****  *	@param accel_range_u8 : The value of accel range
10431:Src/bno055.c  ****  *		  accel_range_u8 |   result
10432:Src/bno055.c  ****  *       ----------------- | --------------
10433:Src/bno055.c  ****  *              0x00       | BNO055_ACCEL_RANGE_2G
10434:Src/bno055.c  ****  *              0x01       | BNO055_ACCEL_RANGE_4G
10435:Src/bno055.c  ****  *              0x02       | BNO055_ACCEL_RANGE_8G
10436:Src/bno055.c  ****  *              0x03       | BNO055_ACCEL_RANGE_16G
10437:Src/bno055.c  ****  *
10438:Src/bno055.c  ****  *	@return results of bus communication function
10439:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10440:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10441:Src/bno055.c  ****  *
10442:Src/bno055.c  ****  *
10443:Src/bno055.c  ****  */
10444:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_range(
10445:Src/bno055.c  **** u8 *accel_range_u8)
10446:Src/bno055.c  **** {
ARM GAS  /tmp/ccVWLGiI.s 			page 586


 20529              		.loc 1 10446 0
 20530              		.cfi_startproc
 20531              		@ args = 0, pretend = 0, frame = 8
 20532              		@ frame_needed = 0, uses_anonymous_args = 0
 20533              	.LVL2592:
 20534 0000 30B5     		push	{r4, r5, lr}
 20535              	.LCFI808:
 20536              		.cfi_def_cfa_offset 12
 20537              		.cfi_offset 4, -12
 20538              		.cfi_offset 5, -8
 20539              		.cfi_offset 14, -4
10447:Src/bno055.c  **** 	/* Variable used to return value of
10448:Src/bno055.c  **** 	communication routine*/
10449:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10450:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
10451:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
10452:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
10453:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 20540              		.loc 1 10453 0
 20541 0002 144C     		ldr	r4, .L2177
10446:Src/bno055.c  **** 	/* Variable used to return value of
 20542              		.loc 1 10446 0
 20543 0004 83B0     		sub	sp, sp, #12
 20544              	.LCFI809:
 20545              		.cfi_def_cfa_offset 24
 20546              		.loc 1 10453 0
 20547 0006 2368     		ldr	r3, [r4]
10450:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 20548              		.loc 1 10450 0
 20549 0008 0022     		movs	r2, #0
 20550 000a 8DF80720 		strb	r2, [sp, #7]
 20551              	.LVL2593:
 20552              		.loc 1 10453 0
 20553 000e FBB1     		cbz	r3, .L2169
10454:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
10455:Src/bno055.c  **** 		} else {
10456:Src/bno055.c  **** 		/*condition check for page, accel range is
10457:Src/bno055.c  **** 		available in the page one*/
10458:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 20554              		.loc 1 10458 0
 20555 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 20556 0012 0546     		mov	r5, r0
 20557 0014 012A     		cmp	r2, #1
 20558 0016 04D0     		beq	.L2167
10459:Src/bno055.c  **** 			/* Write page as one */
10460:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 20559              		.loc 1 10460 0
 20560 0018 0120     		movs	r0, #1
 20561              	.LVL2594:
 20562 001a FFF7FEFF 		bl	bno055_write_page_id
 20563              	.LVL2595:
 20564 001e 2368     		ldr	r3, [r4]
10461:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 20565              		.loc 1 10461 0
 20566 0020 70B9     		cbnz	r0, .L2176
 20567              	.LVL2596:
 20568              	.L2167:
ARM GAS  /tmp/ccVWLGiI.s 			page 587


10462:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
10463:Src/bno055.c  **** 			/* Read the value of accel g range */
10464:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 20569              		.loc 1 10464 0
 20570 0022 1C69     		ldr	r4, [r3, #16]
 20571 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20572 0026 0821     		movs	r1, #8
 20573 0028 0123     		movs	r3, #1
 20574 002a 0DF10702 		add	r2, sp, #7
 20575 002e A047     		blx	r4
 20576              	.LVL2597:
10465:Src/bno055.c  **** 			(p_bno055->dev_addr,
10466:Src/bno055.c  **** 			BNO055_ACCEL_RANGE_REG,
10467:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
10468:Src/bno055.c  **** 			*accel_range_u8 =
 20577              		.loc 1 10468 0
 20578 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 20579 0034 03F00303 		and	r3, r3, #3
 20580 0038 2B70     		strb	r3, [r5]
 20581              	.LVL2598:
 20582              	.L2166:
10469:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
10470:Src/bno055.c  **** 			BNO055_ACCEL_RANGE);
10471:Src/bno055.c  **** 		} else {
10472:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10473:Src/bno055.c  **** 		}
10474:Src/bno055.c  **** 	}
10475:Src/bno055.c  **** 	return com_rslt;
10476:Src/bno055.c  **** }
 20583              		.loc 1 10476 0
 20584 003a 40B2     		sxtb	r0, r0
 20585 003c 03B0     		add	sp, sp, #12
 20586              	.LCFI810:
 20587              		.cfi_remember_state
 20588              		.cfi_def_cfa_offset 12
 20589              		@ sp needed
 20590 003e 30BD     		pop	{r4, r5, pc}
 20591              	.LVL2599:
 20592              	.L2176:
 20593              	.LCFI811:
 20594              		.cfi_restore_state
10461:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 20595              		.loc 1 10461 0 discriminator 1
 20596 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 20597 0042 012A     		cmp	r2, #1
10472:Src/bno055.c  **** 		}
 20598              		.loc 1 10472 0 discriminator 1
 20599 0044 18BF     		it	ne
 20600 0046 FF20     		movne	r0, #255
10461:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 20601              		.loc 1 10461 0 discriminator 1
 20602 0048 EBD0     		beq	.L2167
 20603              		.loc 1 10476 0
 20604 004a 40B2     		sxtb	r0, r0
 20605 004c 03B0     		add	sp, sp, #12
 20606              	.LCFI812:
 20607              		.cfi_remember_state
ARM GAS  /tmp/ccVWLGiI.s 			page 588


 20608              		.cfi_def_cfa_offset 12
 20609              		@ sp needed
 20610 004e 30BD     		pop	{r4, r5, pc}
 20611              	.LVL2600:
 20612              	.L2169:
 20613              	.LCFI813:
 20614              		.cfi_restore_state
10454:Src/bno055.c  **** 		} else {
 20615              		.loc 1 10454 0
 20616 0050 8120     		movs	r0, #129
 20617              	.LVL2601:
 20618 0052 F2E7     		b	.L2166
 20619              	.L2178:
 20620              		.align	2
 20621              	.L2177:
 20622 0054 00000000 		.word	.LANCHOR0
 20623              		.cfi_endproc
 20624              	.LFE175:
 20626              		.section	.text.bno055_set_accel_range,"ax",%progbits
 20627              		.align	2
 20628              		.global	bno055_set_accel_range
 20629              		.thumb
 20630              		.thumb_func
 20632              	bno055_set_accel_range:
 20633              	.LFB176:
10477:Src/bno055.c  **** /*!
10478:Src/bno055.c  ****  *	@brief This API used to write the accel range
10479:Src/bno055.c  ****  *	from page one register from 0x08 bit 0 and 1
10480:Src/bno055.c  ****  *
10481:Src/bno055.c  ****  *	@param accel_range_u8 : The value of accel range
10482:Src/bno055.c  ****  *
10483:Src/bno055.c  ****  *		  accel_range_u8 |   result
10484:Src/bno055.c  ****  *       ----------------- | --------------
10485:Src/bno055.c  ****  *              0x00       | BNO055_ACCEL_RANGE_2G
10486:Src/bno055.c  ****  *              0x01       | BNO055_ACCEL_RANGE_4G
10487:Src/bno055.c  ****  *              0x02       | BNO055_ACCEL_RANGE_8G
10488:Src/bno055.c  ****  *              0x03       | BNO055_ACCEL_RANGE_16G
10489:Src/bno055.c  ****  *
10490:Src/bno055.c  ****  *	@return results of bus communication function
10491:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10492:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10493:Src/bno055.c  ****  *
10494:Src/bno055.c  ****  *
10495:Src/bno055.c  ****  */
10496:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_range(
10497:Src/bno055.c  **** u8 accel_range_u8)
10498:Src/bno055.c  **** {
 20634              		.loc 1 10498 0
 20635              		.cfi_startproc
 20636              		@ args = 0, pretend = 0, frame = 8
 20637              		@ frame_needed = 0, uses_anonymous_args = 0
 20638              	.LVL2602:
 20639 0000 30B5     		push	{r4, r5, lr}
 20640              	.LCFI814:
 20641              		.cfi_def_cfa_offset 12
 20642              		.cfi_offset 4, -12
 20643              		.cfi_offset 5, -8
ARM GAS  /tmp/ccVWLGiI.s 			page 589


 20644              		.cfi_offset 14, -4
10499:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10500:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
10501:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
10502:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
10503:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
10504:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
10505:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 20645              		.loc 1 10505 0
 20646 0002 284C     		ldr	r4, .L2196
10498:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 20647              		.loc 1 10498 0
 20648 0004 83B0     		sub	sp, sp, #12
 20649              	.LCFI815:
 20650              		.cfi_def_cfa_offset 24
 20651              		.loc 1 10505 0
 20652 0006 2268     		ldr	r2, [r4]
10500:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 20653              		.loc 1 10500 0
 20654 0008 0023     		movs	r3, #0
 20655 000a 8DF80630 		strb	r3, [sp, #6]
 20656              	.LVL2603:
10502:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 20657              		.loc 1 10502 0
 20658 000e 8DF80730 		strb	r3, [sp, #7]
 20659              	.LVL2604:
 20660              		.loc 1 10505 0
 20661 0012 002A     		cmp	r2, #0
 20662 0014 44D0     		beq	.L2187
 20663 0016 0546     		mov	r5, r0
10506:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
10507:Src/bno055.c  **** } else {
10508:Src/bno055.c  **** /* The write operation effective only if the operation
10509:Src/bno055.c  **** mode is in config mode, this part of code is checking the
10510:Src/bno055.c  **** current operation mode and set the config mode */
10511:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 20664              		.loc 1 10511 0
 20665 0018 0DF10700 		add	r0, sp, #7
 20666              	.LVL2605:
 20667 001c FFF7FEFF 		bl	bno055_get_operation_mode
 20668              	.LVL2606:
10512:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 20669              		.loc 1 10512 0
 20670 0020 38B1     		cbz	r0, .L2181
 20671              	.LVL2607:
 20672              	.L2185:
10513:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
10514:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
10515:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
10516:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
10517:Src/bno055.c  **** 			/* Write page as one */
10518:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
10519:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
10520:Src/bno055.c  **** 				if (accel_range_u8 < BNO055_ACCEL_RANGE) {
10521:Src/bno055.c  **** 					/* Write the value of accel range*/
10522:Src/bno055.c  **** 					com_rslt =
10523:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 590


10524:Src/bno055.c  **** 					(p_bno055->dev_addr,
10525:Src/bno055.c  **** 					BNO055_ACCEL_RANGE_REG,
10526:Src/bno055.c  **** 					&data_u8r,
10527:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10528:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10529:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
10530:Src/bno055.c  **** 						(data_u8r,
10531:Src/bno055.c  **** 						BNO055_ACCEL_RANGE,
10532:Src/bno055.c  **** 						accel_range_u8);
10533:Src/bno055.c  **** 						com_rslt +=
10534:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10535:Src/bno055.c  **** 						(p_bno055->dev_addr,
10536:Src/bno055.c  **** 						BNO055_ACCEL_RANGE_REG,
10537:Src/bno055.c  **** 						&data_u8r,
10538:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10539:Src/bno055.c  **** 					}
10540:Src/bno055.c  **** 				} else {
10541:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
10542:Src/bno055.c  **** 				}
10543:Src/bno055.c  **** 			} else {
10544:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
10545:Src/bno055.c  **** 			}
10546:Src/bno055.c  **** 		} else {
10547:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10548:Src/bno055.c  **** 		}
10549:Src/bno055.c  **** 	} else {
10550:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 20673              		.loc 1 10550 0
 20674 0022 FF24     		movs	r4, #255
 20675              	.LVL2608:
 20676              	.L2182:
10551:Src/bno055.c  **** 	}
10552:Src/bno055.c  **** }
10553:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 20677              		.loc 1 10553 0
 20678 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 20679 0028 78B9     		cbnz	r0, .L2194
 20680 002a 2046     		mov	r0, r4
 20681              	.LVL2609:
 20682              	.L2180:
10554:Src/bno055.c  **** 	/* set the operation mode of
10555:Src/bno055.c  **** 	previous operation mode*/
10556:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
10557:Src/bno055.c  **** 	(prev_opmode_u8);
10558:Src/bno055.c  **** return com_rslt;
10559:Src/bno055.c  **** }
 20683              		.loc 1 10559 0
 20684 002c 40B2     		sxtb	r0, r0
 20685 002e 03B0     		add	sp, sp, #12
 20686              	.LCFI816:
 20687              		.cfi_remember_state
 20688              		.cfi_def_cfa_offset 12
 20689              		@ sp needed
 20690 0030 30BD     		pop	{r4, r5, pc}
 20691              	.LVL2610:
 20692              	.L2181:
 20693              	.LCFI817:
ARM GAS  /tmp/ccVWLGiI.s 			page 591


 20694              		.cfi_restore_state
10513:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 20695              		.loc 1 10513 0
 20696 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 20697 0036 7BB9     		cbnz	r3, .L2183
 20698              	.L2186:
 20699              	.LVL2611:
10518:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 20700              		.loc 1 10518 0
 20701 0038 0120     		movs	r0, #1
 20702 003a FFF7FEFF 		bl	bno055_write_page_id
 20703              	.LVL2612:
10519:Src/bno055.c  **** 				if (accel_range_u8 < BNO055_ACCEL_RANGE) {
 20704              		.loc 1 10519 0
 20705 003e 0028     		cmp	r0, #0
 20706 0040 EFD1     		bne	.L2185
10520:Src/bno055.c  **** 					/* Write the value of accel range*/
 20707              		.loc 1 10520 0
 20708 0042 042D     		cmp	r5, #4
 20709 0044 0DD9     		bls	.L2195
10541:Src/bno055.c  **** 				}
 20710              		.loc 1 10541 0
 20711 0046 FE24     		movs	r4, #254
 20712 0048 ECE7     		b	.L2182
 20713              	.LVL2613:
 20714              	.L2194:
10556:Src/bno055.c  **** 	(prev_opmode_u8);
 20715              		.loc 1 10556 0
 20716 004a FFF7FEFF 		bl	bno055_set_operation_mode
 20717              	.LVL2614:
 20718 004e 2044     		add	r0, r0, r4
 20719 0050 C0B2     		uxtb	r0, r0
 20720              	.LVL2615:
 20721              		.loc 1 10559 0
 20722 0052 40B2     		sxtb	r0, r0
 20723 0054 03B0     		add	sp, sp, #12
 20724              	.LCFI818:
 20725              		.cfi_remember_state
 20726              		.cfi_def_cfa_offset 12
 20727              		@ sp needed
 20728 0056 30BD     		pop	{r4, r5, pc}
 20729              	.LVL2616:
 20730              	.L2183:
 20731              	.LCFI819:
 20732              		.cfi_restore_state
10514:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 20733              		.loc 1 10514 0
 20734 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 20735              	.LVL2617:
10516:Src/bno055.c  **** 			/* Write page as one */
 20736              		.loc 1 10516 0
 20737 005c 0028     		cmp	r0, #0
 20738 005e E0D1     		bne	.L2185
 20739 0060 EAE7     		b	.L2186
 20740              	.LVL2618:
 20741              	.L2195:
10523:Src/bno055.c  **** 					(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 592


 20742              		.loc 1 10523 0
 20743 0062 2368     		ldr	r3, [r4]
10522:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 20744              		.loc 1 10522 0
 20745 0064 0DF10602 		add	r2, sp, #6
 20746 0068 1C69     		ldr	r4, [r3, #16]
 20747 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20748              	.LVL2619:
 20749 006c 0821     		movs	r1, #8
 20750 006e 0123     		movs	r3, #1
 20751 0070 A047     		blx	r4
 20752              	.LVL2620:
10523:Src/bno055.c  **** 					(p_bno055->dev_addr,
 20753              		.loc 1 10523 0
 20754 0072 0C4A     		ldr	r2, .L2196
10528:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 20755              		.loc 1 10528 0
 20756 0074 0446     		mov	r4, r0
 20757 0076 0028     		cmp	r0, #0
 20758 0078 D4D1     		bne	.L2182
10529:Src/bno055.c  **** 						(data_u8r,
 20759              		.loc 1 10529 0
 20760 007a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
10534:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20761              		.loc 1 10534 0
 20762 007e 1168     		ldr	r1, [r2]
10529:Src/bno055.c  **** 						(data_u8r,
 20763              		.loc 1 10529 0
 20764 0080 23F00303 		bic	r3, r3, #3
 20765 0084 05F00300 		and	r0, r5, #3
 20766              	.LVL2621:
 20767 0088 1843     		orrs	r0, r0, r3
10534:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20768              		.loc 1 10534 0
 20769 008a CC68     		ldr	r4, [r1, #12]
10529:Src/bno055.c  **** 						(data_u8r,
 20770              		.loc 1 10529 0
 20771 008c 8DF80600 		strb	r0, [sp, #6]
10534:Src/bno055.c  **** 						(p_bno055->dev_addr,
 20772              		.loc 1 10534 0
 20773 0090 0DF10602 		add	r2, sp, #6
 20774 0094 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 20775 0096 0123     		movs	r3, #1
 20776 0098 0821     		movs	r1, #8
 20777 009a A047     		blx	r4
 20778              	.LVL2622:
 20779 009c 0446     		mov	r4, r0
 20780              	.LVL2623:
 20781 009e C1E7     		b	.L2182
 20782              	.LVL2624:
 20783              	.L2187:
10506:Src/bno055.c  **** } else {
 20784              		.loc 1 10506 0
 20785 00a0 8120     		movs	r0, #129
 20786              	.LVL2625:
 20787 00a2 C3E7     		b	.L2180
 20788              	.L2197:
ARM GAS  /tmp/ccVWLGiI.s 			page 593


 20789              		.align	2
 20790              	.L2196:
 20791 00a4 00000000 		.word	.LANCHOR0
 20792              		.cfi_endproc
 20793              	.LFE176:
 20795              		.section	.text.bno055_get_accel_bw,"ax",%progbits
 20796              		.align	2
 20797              		.global	bno055_get_accel_bw
 20798              		.thumb
 20799              		.thumb_func
 20801              	bno055_get_accel_bw:
 20802              	.LFB177:
10560:Src/bno055.c  **** /*!
10561:Src/bno055.c  ****  *	@brief This API used to read the accel bandwidth
10562:Src/bno055.c  ****  *	from page one register from 0x08 bit 2 to 4
10563:Src/bno055.c  ****  *
10564:Src/bno055.c  ****  *	@param accel_bw_u8 : The value of accel bandwidth
10565:Src/bno055.c  ****  *
10566:Src/bno055.c  ****  *		     accel_bw_u8 |     result
10567:Src/bno055.c  ****  *       ----------------- | ---------------
10568:Src/bno055.c  ****  *              0x00       | BNO055_ACCEL_BW_7_81HZ
10569:Src/bno055.c  ****  *              0x01       | BNO055_ACCEL_BW_15_63HZ
10570:Src/bno055.c  ****  *              0x02       | BNO055_ACCEL_BW_31_25HZ
10571:Src/bno055.c  ****  *              0x03       | BNO055_ACCEL_BW_62_5HZ
10572:Src/bno055.c  ****  *              0x04       | BNO055_ACCEL_BW_125HZ
10573:Src/bno055.c  ****  *              0x05       | BNO055_ACCEL_BW_250HZ
10574:Src/bno055.c  ****  *              0x06       | BNO055_ACCEL_BW_500HZ
10575:Src/bno055.c  ****  *              0x07       | BNO055_ACCEL_BW_1000HZ
10576:Src/bno055.c  ****  *
10577:Src/bno055.c  ****  *	@return results of bus communication function
10578:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10579:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10580:Src/bno055.c  ****  *
10581:Src/bno055.c  ****  *
10582:Src/bno055.c  ****  */
10583:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_bw(
10584:Src/bno055.c  **** u8 *accel_bw_u8)
10585:Src/bno055.c  **** {
 20803              		.loc 1 10585 0
 20804              		.cfi_startproc
 20805              		@ args = 0, pretend = 0, frame = 8
 20806              		@ frame_needed = 0, uses_anonymous_args = 0
 20807              	.LVL2626:
 20808 0000 30B5     		push	{r4, r5, lr}
 20809              	.LCFI820:
 20810              		.cfi_def_cfa_offset 12
 20811              		.cfi_offset 4, -12
 20812              		.cfi_offset 5, -8
 20813              		.cfi_offset 14, -4
10586:Src/bno055.c  **** 	/* Variable used to return value of
10587:Src/bno055.c  **** 	communication routine*/
10588:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10589:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
10590:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
10591:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
10592:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 20814              		.loc 1 10592 0
ARM GAS  /tmp/ccVWLGiI.s 			page 594


 20815 0002 144C     		ldr	r4, .L2210
10585:Src/bno055.c  **** 	/* Variable used to return value of
 20816              		.loc 1 10585 0
 20817 0004 83B0     		sub	sp, sp, #12
 20818              	.LCFI821:
 20819              		.cfi_def_cfa_offset 24
 20820              		.loc 1 10592 0
 20821 0006 2368     		ldr	r3, [r4]
10589:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 20822              		.loc 1 10589 0
 20823 0008 0022     		movs	r2, #0
 20824 000a 8DF80720 		strb	r2, [sp, #7]
 20825              	.LVL2627:
 20826              		.loc 1 10592 0
 20827 000e FBB1     		cbz	r3, .L2202
10593:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
10594:Src/bno055.c  **** 		} else {
10595:Src/bno055.c  **** 		/*condition check for page, accel bandwidth is
10596:Src/bno055.c  **** 		available in the page one*/
10597:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 20828              		.loc 1 10597 0
 20829 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 20830 0012 0546     		mov	r5, r0
 20831 0014 012A     		cmp	r2, #1
 20832 0016 04D0     		beq	.L2200
10598:Src/bno055.c  **** 			/* Write page as one */
10599:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 20833              		.loc 1 10599 0
 20834 0018 0120     		movs	r0, #1
 20835              	.LVL2628:
 20836 001a FFF7FEFF 		bl	bno055_write_page_id
 20837              	.LVL2629:
 20838 001e 2368     		ldr	r3, [r4]
10600:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 20839              		.loc 1 10600 0
 20840 0020 70B9     		cbnz	r0, .L2209
 20841              	.LVL2630:
 20842              	.L2200:
10601:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
10602:Src/bno055.c  **** 			/* Read the value of accel bandwidth */
10603:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 20843              		.loc 1 10603 0
 20844 0022 1C69     		ldr	r4, [r3, #16]
 20845 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 20846 0026 0821     		movs	r1, #8
 20847 0028 0123     		movs	r3, #1
 20848 002a 0DF10702 		add	r2, sp, #7
 20849 002e A047     		blx	r4
 20850              	.LVL2631:
10604:Src/bno055.c  **** 			(p_bno055->dev_addr,
10605:Src/bno055.c  **** 			BNO055_ACCEL_BW_REG,
10606:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
10607:Src/bno055.c  **** 			*accel_bw_u8 =
10608:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 20851              		.loc 1 10608 0
 20852 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 20853 0034 C3F38203 		ubfx	r3, r3, #2, #3
ARM GAS  /tmp/ccVWLGiI.s 			page 595


10607:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 20854              		.loc 1 10607 0
 20855 0038 2B70     		strb	r3, [r5]
 20856              	.LVL2632:
 20857              	.L2199:
10609:Src/bno055.c  **** 			BNO055_ACCEL_BW);
10610:Src/bno055.c  **** 		} else {
10611:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10612:Src/bno055.c  **** 		}
10613:Src/bno055.c  **** 	}
10614:Src/bno055.c  **** 	return com_rslt;
10615:Src/bno055.c  **** }
 20858              		.loc 1 10615 0
 20859 003a 40B2     		sxtb	r0, r0
 20860 003c 03B0     		add	sp, sp, #12
 20861              	.LCFI822:
 20862              		.cfi_remember_state
 20863              		.cfi_def_cfa_offset 12
 20864              		@ sp needed
 20865 003e 30BD     		pop	{r4, r5, pc}
 20866              	.LVL2633:
 20867              	.L2209:
 20868              	.LCFI823:
 20869              		.cfi_restore_state
10600:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 20870              		.loc 1 10600 0 discriminator 1
 20871 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 20872 0042 012A     		cmp	r2, #1
10611:Src/bno055.c  **** 		}
 20873              		.loc 1 10611 0 discriminator 1
 20874 0044 18BF     		it	ne
 20875 0046 FF20     		movne	r0, #255
10600:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 20876              		.loc 1 10600 0 discriminator 1
 20877 0048 EBD0     		beq	.L2200
 20878              		.loc 1 10615 0
 20879 004a 40B2     		sxtb	r0, r0
 20880 004c 03B0     		add	sp, sp, #12
 20881              	.LCFI824:
 20882              		.cfi_remember_state
 20883              		.cfi_def_cfa_offset 12
 20884              		@ sp needed
 20885 004e 30BD     		pop	{r4, r5, pc}
 20886              	.LVL2634:
 20887              	.L2202:
 20888              	.LCFI825:
 20889              		.cfi_restore_state
10593:Src/bno055.c  **** 		} else {
 20890              		.loc 1 10593 0
 20891 0050 8120     		movs	r0, #129
 20892              	.LVL2635:
 20893 0052 F2E7     		b	.L2199
 20894              	.L2211:
 20895              		.align	2
 20896              	.L2210:
 20897 0054 00000000 		.word	.LANCHOR0
 20898              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 596


 20899              	.LFE177:
 20901              		.section	.text.bno055_set_accel_bw,"ax",%progbits
 20902              		.align	2
 20903              		.global	bno055_set_accel_bw
 20904              		.thumb
 20905              		.thumb_func
 20907              	bno055_set_accel_bw:
 20908              	.LFB178:
10616:Src/bno055.c  **** /*!
10617:Src/bno055.c  ****  *	@brief This API used to write the accel bandwidth
10618:Src/bno055.c  ****  *	from page one register from 0x08 bit 2 to 4
10619:Src/bno055.c  ****  *
10620:Src/bno055.c  ****  *	@param accel_bw_u8 : The value of accel bandwidth
10621:Src/bno055.c  ****  *
10622:Src/bno055.c  ****  *		     accel_bw_u8 |     result
10623:Src/bno055.c  ****  *       ----------------- | ---------------
10624:Src/bno055.c  ****  *              0x00       | BNO055_ACCEL_BW_7_81HZ
10625:Src/bno055.c  ****  *              0x01       | BNO055_ACCEL_BW_15_63HZ
10626:Src/bno055.c  ****  *              0x02       | BNO055_ACCEL_BW_31_25HZ
10627:Src/bno055.c  ****  *              0x03       | BNO055_ACCEL_BW_62_5HZ
10628:Src/bno055.c  ****  *              0x04       | BNO055_ACCEL_BW_125HZ
10629:Src/bno055.c  ****  *              0x05       | BNO055_ACCEL_BW_250HZ
10630:Src/bno055.c  ****  *              0x06       | BNO055_ACCEL_BW_500HZ
10631:Src/bno055.c  ****  *              0x07       | BNO055_ACCEL_BW_1000HZ
10632:Src/bno055.c  ****  *
10633:Src/bno055.c  ****  *	@return results of bus communication function
10634:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10635:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10636:Src/bno055.c  ****  *
10637:Src/bno055.c  ****  *
10638:Src/bno055.c  ****  */
10639:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_bw(
10640:Src/bno055.c  **** u8 accel_bw_u8)
10641:Src/bno055.c  **** {
 20909              		.loc 1 10641 0
 20910              		.cfi_startproc
 20911              		@ args = 0, pretend = 0, frame = 8
 20912              		@ frame_needed = 0, uses_anonymous_args = 0
 20913              	.LVL2636:
 20914 0000 30B5     		push	{r4, r5, lr}
 20915              	.LCFI826:
 20916              		.cfi_def_cfa_offset 12
 20917              		.cfi_offset 4, -12
 20918              		.cfi_offset 5, -8
 20919              		.cfi_offset 14, -4
10642:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10643:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
10644:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
10645:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
10646:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
10647:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
10648:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 20920              		.loc 1 10648 0
 20921 0002 294C     		ldr	r4, .L2229
10641:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 20922              		.loc 1 10641 0
 20923 0004 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 597


 20924              	.LCFI827:
 20925              		.cfi_def_cfa_offset 24
 20926              		.loc 1 10648 0
 20927 0006 2268     		ldr	r2, [r4]
10643:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 20928              		.loc 1 10643 0
 20929 0008 0023     		movs	r3, #0
 20930 000a 8DF80630 		strb	r3, [sp, #6]
 20931              	.LVL2637:
10645:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 20932              		.loc 1 10645 0
 20933 000e 8DF80730 		strb	r3, [sp, #7]
 20934              	.LVL2638:
 20935              		.loc 1 10648 0
 20936 0012 002A     		cmp	r2, #0
 20937 0014 45D0     		beq	.L2220
 20938 0016 0546     		mov	r5, r0
10649:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
10650:Src/bno055.c  **** } else {
10651:Src/bno055.c  **** /* The write operation effective only if the operation
10652:Src/bno055.c  **** mode is in config mode, this part of code is checking the
10653:Src/bno055.c  **** current operation mode and set the config mode */
10654:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 20939              		.loc 1 10654 0
 20940 0018 0DF10700 		add	r0, sp, #7
 20941              	.LVL2639:
 20942 001c FFF7FEFF 		bl	bno055_get_operation_mode
 20943              	.LVL2640:
10655:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 20944              		.loc 1 10655 0
 20945 0020 38B1     		cbz	r0, .L2214
 20946              	.LVL2641:
 20947              	.L2218:
10656:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
10657:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
10658:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
10659:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
10660:Src/bno055.c  **** 			/* Write page as one */
10661:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
10662:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
10663:Src/bno055.c  **** 				if (accel_bw_u8 <
10664:Src/bno055.c  **** 				BNO055_ACCEL_GYRO_BW_RANGE) {
10665:Src/bno055.c  **** 					/* Write the accel */
10666:Src/bno055.c  **** 					com_rslt =
10667:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10668:Src/bno055.c  **** 					(p_bno055->dev_addr,
10669:Src/bno055.c  **** 					BNO055_ACCEL_BW_REG,
10670:Src/bno055.c  **** 					&data_u8r,
10671:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10672:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10673:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
10674:Src/bno055.c  **** 						(data_u8r, BNO055_ACCEL_BW,
10675:Src/bno055.c  **** 						accel_bw_u8);
10676:Src/bno055.c  **** 						com_rslt +=
10677:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10678:Src/bno055.c  **** 						(p_bno055->dev_addr,
10679:Src/bno055.c  **** 						BNO055_ACCEL_BW_REG,
ARM GAS  /tmp/ccVWLGiI.s 			page 598


10680:Src/bno055.c  **** 						&data_u8r,
10681:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10682:Src/bno055.c  **** 					}
10683:Src/bno055.c  **** 				} else {
10684:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
10685:Src/bno055.c  **** 				}
10686:Src/bno055.c  **** 			} else {
10687:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
10688:Src/bno055.c  **** 			}
10689:Src/bno055.c  **** 		} else {
10690:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10691:Src/bno055.c  **** 		}
10692:Src/bno055.c  **** 	} else {
10693:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 20948              		.loc 1 10693 0
 20949 0022 FF24     		movs	r4, #255
 20950              	.LVL2642:
 20951              	.L2215:
10694:Src/bno055.c  **** 	}
10695:Src/bno055.c  **** }
10696:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 20952              		.loc 1 10696 0
 20953 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 20954 0028 78B9     		cbnz	r0, .L2227
 20955 002a 2046     		mov	r0, r4
 20956              	.LVL2643:
 20957              	.L2213:
10697:Src/bno055.c  **** 	/* set the operation mode of
10698:Src/bno055.c  **** 	previous operation mode*/
10699:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
10700:Src/bno055.c  **** 	(prev_opmode_u8);
10701:Src/bno055.c  **** return com_rslt;
10702:Src/bno055.c  **** }
 20958              		.loc 1 10702 0
 20959 002c 40B2     		sxtb	r0, r0
 20960 002e 03B0     		add	sp, sp, #12
 20961              	.LCFI828:
 20962              		.cfi_remember_state
 20963              		.cfi_def_cfa_offset 12
 20964              		@ sp needed
 20965 0030 30BD     		pop	{r4, r5, pc}
 20966              	.LVL2644:
 20967              	.L2214:
 20968              	.LCFI829:
 20969              		.cfi_restore_state
10656:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 20970              		.loc 1 10656 0
 20971 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 20972 0036 7BB9     		cbnz	r3, .L2216
 20973              	.L2219:
 20974              	.LVL2645:
10661:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 20975              		.loc 1 10661 0
 20976 0038 0120     		movs	r0, #1
 20977 003a FFF7FEFF 		bl	bno055_write_page_id
 20978              	.LVL2646:
10662:Src/bno055.c  **** 				if (accel_bw_u8 <
ARM GAS  /tmp/ccVWLGiI.s 			page 599


 20979              		.loc 1 10662 0
 20980 003e 0028     		cmp	r0, #0
 20981 0040 EFD1     		bne	.L2218
10663:Src/bno055.c  **** 				BNO055_ACCEL_GYRO_BW_RANGE) {
 20982              		.loc 1 10663 0
 20983 0042 072D     		cmp	r5, #7
 20984 0044 0DD9     		bls	.L2228
10684:Src/bno055.c  **** 				}
 20985              		.loc 1 10684 0
 20986 0046 FE24     		movs	r4, #254
 20987 0048 ECE7     		b	.L2215
 20988              	.LVL2647:
 20989              	.L2227:
10699:Src/bno055.c  **** 	(prev_opmode_u8);
 20990              		.loc 1 10699 0
 20991 004a FFF7FEFF 		bl	bno055_set_operation_mode
 20992              	.LVL2648:
 20993 004e 2044     		add	r0, r0, r4
 20994 0050 C0B2     		uxtb	r0, r0
 20995              	.LVL2649:
 20996              		.loc 1 10702 0
 20997 0052 40B2     		sxtb	r0, r0
 20998 0054 03B0     		add	sp, sp, #12
 20999              	.LCFI830:
 21000              		.cfi_remember_state
 21001              		.cfi_def_cfa_offset 12
 21002              		@ sp needed
 21003 0056 30BD     		pop	{r4, r5, pc}
 21004              	.LVL2650:
 21005              	.L2216:
 21006              	.LCFI831:
 21007              		.cfi_restore_state
10657:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 21008              		.loc 1 10657 0
 21009 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 21010              	.LVL2651:
10659:Src/bno055.c  **** 			/* Write page as one */
 21011              		.loc 1 10659 0
 21012 005c 0028     		cmp	r0, #0
 21013 005e E0D1     		bne	.L2218
 21014 0060 EAE7     		b	.L2219
 21015              	.LVL2652:
 21016              	.L2228:
10667:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21017              		.loc 1 10667 0
 21018 0062 2368     		ldr	r3, [r4]
10666:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 21019              		.loc 1 10666 0
 21020 0064 0821     		movs	r1, #8
 21021 0066 1C69     		ldr	r4, [r3, #16]
 21022 0068 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21023              	.LVL2653:
 21024 006a 0DF10602 		add	r2, sp, #6
 21025 006e 0123     		movs	r3, #1
 21026 0070 A047     		blx	r4
 21027              	.LVL2654:
10667:Src/bno055.c  **** 					(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 600


 21028              		.loc 1 10667 0
 21029 0072 0D49     		ldr	r1, .L2229
10672:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 21030              		.loc 1 10672 0
 21031 0074 0446     		mov	r4, r0
 21032 0076 0028     		cmp	r0, #0
 21033 0078 D4D1     		bne	.L2215
10673:Src/bno055.c  **** 						(data_u8r, BNO055_ACCEL_BW,
 21034              		.loc 1 10673 0
 21035 007a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 21036 007e AB00     		lsls	r3, r5, #2
10677:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21037              		.loc 1 10677 0
 21038 0080 0968     		ldr	r1, [r1]
10673:Src/bno055.c  **** 						(data_u8r, BNO055_ACCEL_BW,
 21039              		.loc 1 10673 0
 21040 0082 22F01C02 		bic	r2, r2, #28
 21041 0086 03F01C03 		and	r3, r3, #28
 21042 008a 1343     		orrs	r3, r3, r2
10677:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21043              		.loc 1 10677 0
 21044 008c CC68     		ldr	r4, [r1, #12]
10673:Src/bno055.c  **** 						(data_u8r, BNO055_ACCEL_BW,
 21045              		.loc 1 10673 0
 21046 008e 8DF80630 		strb	r3, [sp, #6]
10677:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21047              		.loc 1 10677 0
 21048 0092 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 21049              	.LVL2655:
 21050 0094 0DF10602 		add	r2, sp, #6
 21051 0098 0821     		movs	r1, #8
 21052 009a 0123     		movs	r3, #1
 21053 009c A047     		blx	r4
 21054              	.LVL2656:
 21055 009e 0446     		mov	r4, r0
 21056              	.LVL2657:
 21057 00a0 C0E7     		b	.L2215
 21058              	.LVL2658:
 21059              	.L2220:
10649:Src/bno055.c  **** } else {
 21060              		.loc 1 10649 0
 21061 00a2 8120     		movs	r0, #129
 21062              	.LVL2659:
 21063 00a4 C2E7     		b	.L2213
 21064              	.L2230:
 21065 00a6 00BF     		.align	2
 21066              	.L2229:
 21067 00a8 00000000 		.word	.LANCHOR0
 21068              		.cfi_endproc
 21069              	.LFE178:
 21071              		.section	.text.bno055_get_accel_power_mode,"ax",%progbits
 21072              		.align	2
 21073              		.global	bno055_get_accel_power_mode
 21074              		.thumb
 21075              		.thumb_func
 21077              	bno055_get_accel_power_mode:
 21078              	.LFB179:
ARM GAS  /tmp/ccVWLGiI.s 			page 601


10703:Src/bno055.c  **** /*!
10704:Src/bno055.c  ****  *	@brief This API used to read the accel power mode
10705:Src/bno055.c  ****  *	from page one register from 0x08 bit 5 to 7
10706:Src/bno055.c  ****  *
10707:Src/bno055.c  ****  *	@param accel_power_mode_u8 : The value of accel power mode
10708:Src/bno055.c  ****  * accel_power_mode_u8 |   result
10709:Src/bno055.c  ****  *   -----------------   | -------------
10710:Src/bno055.c  ****  *              0x00     | BNO055_ACCEL_NORMAL
10711:Src/bno055.c  ****  *              0x01     | BNO055_ACCEL_SUSPEND
10712:Src/bno055.c  ****  *              0x02     | BNO055_ACCEL_LOWPOWER_1
10713:Src/bno055.c  ****  *              0x03     | BNO055_ACCEL_STANDBY
10714:Src/bno055.c  ****  *              0x04     | BNO055_ACCEL_LOWPOWER_2
10715:Src/bno055.c  ****  *              0x05     | BNO055_ACCEL_DEEPSUSPEND
10716:Src/bno055.c  ****  *
10717:Src/bno055.c  ****  *	@return results of bus communication function
10718:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10719:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10720:Src/bno055.c  ****  *
10721:Src/bno055.c  ****  *
10722:Src/bno055.c  ****  */
10723:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_power_mode(
10724:Src/bno055.c  **** u8 *accel_power_mode_u8)
10725:Src/bno055.c  **** {
 21079              		.loc 1 10725 0
 21080              		.cfi_startproc
 21081              		@ args = 0, pretend = 0, frame = 8
 21082              		@ frame_needed = 0, uses_anonymous_args = 0
 21083              	.LVL2660:
 21084 0000 30B5     		push	{r4, r5, lr}
 21085              	.LCFI832:
 21086              		.cfi_def_cfa_offset 12
 21087              		.cfi_offset 4, -12
 21088              		.cfi_offset 5, -8
 21089              		.cfi_offset 14, -4
10726:Src/bno055.c  **** 	/* Variable used to return value of
10727:Src/bno055.c  **** 	communication routine*/
10728:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10729:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
10730:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
10731:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
10732:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 21090              		.loc 1 10732 0
 21091 0002 144C     		ldr	r4, .L2243
10725:Src/bno055.c  **** 	/* Variable used to return value of
 21092              		.loc 1 10725 0
 21093 0004 83B0     		sub	sp, sp, #12
 21094              	.LCFI833:
 21095              		.cfi_def_cfa_offset 24
 21096              		.loc 1 10732 0
 21097 0006 2368     		ldr	r3, [r4]
10729:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 21098              		.loc 1 10729 0
 21099 0008 0022     		movs	r2, #0
 21100 000a 8DF80720 		strb	r2, [sp, #7]
 21101              	.LVL2661:
 21102              		.loc 1 10732 0
 21103 000e F3B1     		cbz	r3, .L2235
ARM GAS  /tmp/ccVWLGiI.s 			page 602


10733:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
10734:Src/bno055.c  **** 		} else {
10735:Src/bno055.c  **** 		/*condition check for page, accel power mode is
10736:Src/bno055.c  **** 		available in the page one*/
10737:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 21104              		.loc 1 10737 0
 21105 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21106 0012 0546     		mov	r5, r0
 21107 0014 012A     		cmp	r2, #1
 21108 0016 04D0     		beq	.L2233
10738:Src/bno055.c  **** 			/* Write page as one */
10739:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 21109              		.loc 1 10739 0
 21110 0018 0120     		movs	r0, #1
 21111              	.LVL2662:
 21112 001a FFF7FEFF 		bl	bno055_write_page_id
 21113              	.LVL2663:
 21114 001e 2368     		ldr	r3, [r4]
10740:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 21115              		.loc 1 10740 0
 21116 0020 68B9     		cbnz	r0, .L2242
 21117              	.LVL2664:
 21118              	.L2233:
10741:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
10742:Src/bno055.c  **** 			/* Read the value of accel bandwidth */
10743:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 21119              		.loc 1 10743 0
 21120 0022 1C69     		ldr	r4, [r3, #16]
 21121 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21122 0026 0821     		movs	r1, #8
 21123 0028 0123     		movs	r3, #1
 21124 002a 0DF10702 		add	r2, sp, #7
 21125 002e A047     		blx	r4
 21126              	.LVL2665:
10744:Src/bno055.c  **** 			(p_bno055->dev_addr,
10745:Src/bno055.c  **** 			BNO055_ACCEL_POWER_MODE_REG,
10746:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
10747:Src/bno055.c  **** 			*accel_power_mode_u8 =
10748:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 21127              		.loc 1 10748 0
 21128 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21129 0034 5B09     		lsrs	r3, r3, #5
10747:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 21130              		.loc 1 10747 0
 21131 0036 2B70     		strb	r3, [r5]
 21132              	.LVL2666:
 21133              	.L2232:
10749:Src/bno055.c  **** 			BNO055_ACCEL_POWER_MODE);
10750:Src/bno055.c  **** 		} else {
10751:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10752:Src/bno055.c  **** 		}
10753:Src/bno055.c  **** 	}
10754:Src/bno055.c  **** 	return com_rslt;
10755:Src/bno055.c  **** }
 21134              		.loc 1 10755 0
 21135 0038 40B2     		sxtb	r0, r0
 21136 003a 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 603


 21137              	.LCFI834:
 21138              		.cfi_remember_state
 21139              		.cfi_def_cfa_offset 12
 21140              		@ sp needed
 21141 003c 30BD     		pop	{r4, r5, pc}
 21142              	.LVL2667:
 21143              	.L2242:
 21144              	.LCFI835:
 21145              		.cfi_restore_state
10740:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21146              		.loc 1 10740 0 discriminator 1
 21147 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21148 0040 012A     		cmp	r2, #1
10751:Src/bno055.c  **** 		}
 21149              		.loc 1 10751 0 discriminator 1
 21150 0042 18BF     		it	ne
 21151 0044 FF20     		movne	r0, #255
10740:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21152              		.loc 1 10740 0 discriminator 1
 21153 0046 ECD0     		beq	.L2233
 21154              		.loc 1 10755 0
 21155 0048 40B2     		sxtb	r0, r0
 21156 004a 03B0     		add	sp, sp, #12
 21157              	.LCFI836:
 21158              		.cfi_remember_state
 21159              		.cfi_def_cfa_offset 12
 21160              		@ sp needed
 21161 004c 30BD     		pop	{r4, r5, pc}
 21162              	.LVL2668:
 21163              	.L2235:
 21164              	.LCFI837:
 21165              		.cfi_restore_state
10733:Src/bno055.c  **** 		} else {
 21166              		.loc 1 10733 0
 21167 004e 8120     		movs	r0, #129
 21168              	.LVL2669:
 21169 0050 F2E7     		b	.L2232
 21170              	.L2244:
 21171 0052 00BF     		.align	2
 21172              	.L2243:
 21173 0054 00000000 		.word	.LANCHOR0
 21174              		.cfi_endproc
 21175              	.LFE179:
 21177              		.section	.text.bno055_set_accel_power_mode,"ax",%progbits
 21178              		.align	2
 21179              		.global	bno055_set_accel_power_mode
 21180              		.thumb
 21181              		.thumb_func
 21183              	bno055_set_accel_power_mode:
 21184              	.LFB180:
10756:Src/bno055.c  **** /*!
10757:Src/bno055.c  ****  *	@brief This API used to write the accel power mode
10758:Src/bno055.c  ****  *	from page one register from 0x08 bit 5 to 7
10759:Src/bno055.c  ****  *
10760:Src/bno055.c  ****  *	@param accel_power_mode_u8 : The value of accel power mode
10761:Src/bno055.c  ****  * accel_power_mode_u8 |   result
10762:Src/bno055.c  ****  *   -----------------   | -------------
ARM GAS  /tmp/ccVWLGiI.s 			page 604


10763:Src/bno055.c  ****  *              0x00     | BNO055_ACCEL_NORMAL
10764:Src/bno055.c  ****  *              0x01     | BNO055_ACCEL_SUSPEND
10765:Src/bno055.c  ****  *              0x02     | BNO055_ACCEL_LOWPOWER_1
10766:Src/bno055.c  ****  *              0x03     | BNO055_ACCEL_STANDBY
10767:Src/bno055.c  ****  *              0x04     | BNO055_ACCEL_LOWPOWER_2
10768:Src/bno055.c  ****  *              0x05     | BNO055_ACCEL_DEEPSUSPEND
10769:Src/bno055.c  ****  *
10770:Src/bno055.c  ****  *	@return results of bus communication function
10771:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10772:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10773:Src/bno055.c  ****  *
10774:Src/bno055.c  ****  *
10775:Src/bno055.c  ****  */
10776:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_power_mode(
10777:Src/bno055.c  **** u8 accel_power_mode_u8)
10778:Src/bno055.c  **** {
 21185              		.loc 1 10778 0
 21186              		.cfi_startproc
 21187              		@ args = 0, pretend = 0, frame = 8
 21188              		@ frame_needed = 0, uses_anonymous_args = 0
 21189              	.LVL2670:
 21190 0000 30B5     		push	{r4, r5, lr}
 21191              	.LCFI838:
 21192              		.cfi_def_cfa_offset 12
 21193              		.cfi_offset 4, -12
 21194              		.cfi_offset 5, -8
 21195              		.cfi_offset 14, -4
10779:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10780:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
10781:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
10782:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
10783:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
10784:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
10785:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 21196              		.loc 1 10785 0
 21197 0002 284C     		ldr	r4, .L2262
10778:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 21198              		.loc 1 10778 0
 21199 0004 83B0     		sub	sp, sp, #12
 21200              	.LCFI839:
 21201              		.cfi_def_cfa_offset 24
 21202              		.loc 1 10785 0
 21203 0006 2268     		ldr	r2, [r4]
10780:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 21204              		.loc 1 10780 0
 21205 0008 0023     		movs	r3, #0
 21206 000a 8DF80630 		strb	r3, [sp, #6]
 21207              	.LVL2671:
10782:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 21208              		.loc 1 10782 0
 21209 000e 8DF80730 		strb	r3, [sp, #7]
 21210              	.LVL2672:
 21211              		.loc 1 10785 0
 21212 0012 002A     		cmp	r2, #0
 21213 0014 43D0     		beq	.L2253
 21214 0016 0546     		mov	r5, r0
10786:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
ARM GAS  /tmp/ccVWLGiI.s 			page 605


10787:Src/bno055.c  **** } else {
10788:Src/bno055.c  **** /* The write operation effective only if the operation
10789:Src/bno055.c  **** mode is in config mode, this part of code is checking the
10790:Src/bno055.c  **** current operation mode and set the config mode */
10791:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 21215              		.loc 1 10791 0
 21216 0018 0DF10700 		add	r0, sp, #7
 21217              	.LVL2673:
 21218 001c FFF7FEFF 		bl	bno055_get_operation_mode
 21219              	.LVL2674:
10792:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 21220              		.loc 1 10792 0
 21221 0020 38B1     		cbz	r0, .L2247
 21222              	.LVL2675:
 21223              	.L2251:
10793:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
10794:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
10795:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
10796:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
10797:Src/bno055.c  **** 			/* Write page as one */
10798:Src/bno055.c  **** 			pg_stat_s8  = bno055_write_page_id(BNO055_PAGE_ONE);
10799:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
10800:Src/bno055.c  **** 				if (accel_power_mode_u8 <
10801:Src/bno055.c  **** 				BNO055_ACCEL_POWER_MODE_RANGE) {
10802:Src/bno055.c  **** 					/* Write the value of accel bandwidth*/
10803:Src/bno055.c  **** 					com_rslt =
10804:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
10805:Src/bno055.c  **** 					(p_bno055->dev_addr,
10806:Src/bno055.c  **** 					BNO055_ACCEL_POWER_MODE_REG,
10807:Src/bno055.c  **** 					&data_u8r,
10808:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10809:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
10810:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
10811:Src/bno055.c  **** 						(data_u8r,
10812:Src/bno055.c  **** 						BNO055_ACCEL_POWER_MODE,
10813:Src/bno055.c  **** 						accel_power_mode_u8);
10814:Src/bno055.c  **** 						com_rslt +=
10815:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
10816:Src/bno055.c  **** 						(p_bno055->dev_addr,
10817:Src/bno055.c  **** 						BNO055_ACCEL_POWER_MODE_REG,
10818:Src/bno055.c  **** 						&data_u8r,
10819:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
10820:Src/bno055.c  **** 					}
10821:Src/bno055.c  **** 				} else {
10822:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
10823:Src/bno055.c  **** 				}
10824:Src/bno055.c  **** 			} else {
10825:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
10826:Src/bno055.c  **** 			}
10827:Src/bno055.c  **** 		} else {
10828:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10829:Src/bno055.c  **** 		}
10830:Src/bno055.c  **** 	} else {
10831:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 21224              		.loc 1 10831 0
 21225 0022 FF24     		movs	r4, #255
 21226              	.LVL2676:
ARM GAS  /tmp/ccVWLGiI.s 			page 606


 21227              	.L2248:
10832:Src/bno055.c  **** 	}
10833:Src/bno055.c  **** }
10834:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 21228              		.loc 1 10834 0
 21229 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 21230 0028 78B9     		cbnz	r0, .L2260
 21231 002a 2046     		mov	r0, r4
 21232              	.LVL2677:
 21233              	.L2246:
10835:Src/bno055.c  **** 	/* set the operation mode of
10836:Src/bno055.c  **** 	previous operation mode*/
10837:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
10838:Src/bno055.c  **** 	(prev_opmode_u8);
10839:Src/bno055.c  **** return com_rslt;
10840:Src/bno055.c  **** }
 21234              		.loc 1 10840 0
 21235 002c 40B2     		sxtb	r0, r0
 21236 002e 03B0     		add	sp, sp, #12
 21237              	.LCFI840:
 21238              		.cfi_remember_state
 21239              		.cfi_def_cfa_offset 12
 21240              		@ sp needed
 21241 0030 30BD     		pop	{r4, r5, pc}
 21242              	.LVL2678:
 21243              	.L2247:
 21244              	.LCFI841:
 21245              		.cfi_restore_state
10793:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 21246              		.loc 1 10793 0
 21247 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21248 0036 7BB9     		cbnz	r3, .L2249
 21249              	.L2252:
 21250              	.LVL2679:
10798:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 21251              		.loc 1 10798 0
 21252 0038 0120     		movs	r0, #1
 21253 003a FFF7FEFF 		bl	bno055_write_page_id
 21254              	.LVL2680:
10799:Src/bno055.c  **** 				if (accel_power_mode_u8 <
 21255              		.loc 1 10799 0
 21256 003e 0028     		cmp	r0, #0
 21257 0040 EFD1     		bne	.L2251
10800:Src/bno055.c  **** 				BNO055_ACCEL_POWER_MODE_RANGE) {
 21258              		.loc 1 10800 0
 21259 0042 052D     		cmp	r5, #5
 21260 0044 0DD9     		bls	.L2261
10822:Src/bno055.c  **** 				}
 21261              		.loc 1 10822 0
 21262 0046 FE24     		movs	r4, #254
 21263 0048 ECE7     		b	.L2248
 21264              	.LVL2681:
 21265              	.L2260:
10837:Src/bno055.c  **** 	(prev_opmode_u8);
 21266              		.loc 1 10837 0
 21267 004a FFF7FEFF 		bl	bno055_set_operation_mode
 21268              	.LVL2682:
ARM GAS  /tmp/ccVWLGiI.s 			page 607


 21269 004e 2044     		add	r0, r0, r4
 21270 0050 C0B2     		uxtb	r0, r0
 21271              	.LVL2683:
 21272              		.loc 1 10840 0
 21273 0052 40B2     		sxtb	r0, r0
 21274 0054 03B0     		add	sp, sp, #12
 21275              	.LCFI842:
 21276              		.cfi_remember_state
 21277              		.cfi_def_cfa_offset 12
 21278              		@ sp needed
 21279 0056 30BD     		pop	{r4, r5, pc}
 21280              	.LVL2684:
 21281              	.L2249:
 21282              	.LCFI843:
 21283              		.cfi_restore_state
10794:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 21284              		.loc 1 10794 0
 21285 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 21286              	.LVL2685:
10796:Src/bno055.c  **** 			/* Write page as one */
 21287              		.loc 1 10796 0
 21288 005c 0028     		cmp	r0, #0
 21289 005e E0D1     		bne	.L2251
 21290 0060 EAE7     		b	.L2252
 21291              	.LVL2686:
 21292              	.L2261:
10804:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21293              		.loc 1 10804 0
 21294 0062 2368     		ldr	r3, [r4]
10803:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 21295              		.loc 1 10803 0
 21296 0064 0DF10602 		add	r2, sp, #6
 21297 0068 1C69     		ldr	r4, [r3, #16]
 21298 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21299              	.LVL2687:
 21300 006c 0821     		movs	r1, #8
 21301 006e 0123     		movs	r3, #1
 21302 0070 A047     		blx	r4
 21303              	.LVL2688:
10804:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21304              		.loc 1 10804 0
 21305 0072 0C4B     		ldr	r3, .L2262
10809:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 21306              		.loc 1 10809 0
 21307 0074 0446     		mov	r4, r0
 21308 0076 0028     		cmp	r0, #0
 21309 0078 D4D1     		bne	.L2248
10810:Src/bno055.c  **** 						(data_u8r,
 21310              		.loc 1 10810 0
 21311 007a 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 21312              	.LVL2689:
10815:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21313              		.loc 1 10815 0
 21314 007e 1B68     		ldr	r3, [r3]
10810:Src/bno055.c  **** 						(data_u8r,
 21315              		.loc 1 10810 0
 21316 0080 00F01F00 		and	r0, r0, #31
ARM GAS  /tmp/ccVWLGiI.s 			page 608


 21317 0084 40EA4510 		orr	r0, r0, r5, lsl #5
10815:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21318              		.loc 1 10815 0
 21319 0088 DC68     		ldr	r4, [r3, #12]
10810:Src/bno055.c  **** 						(data_u8r,
 21320              		.loc 1 10810 0
 21321 008a 8DF80600 		strb	r0, [sp, #6]
10815:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21322              		.loc 1 10815 0
 21323 008e 0DF10602 		add	r2, sp, #6
 21324 0092 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21325 0094 0821     		movs	r1, #8
 21326 0096 0123     		movs	r3, #1
 21327 0098 A047     		blx	r4
 21328              	.LVL2690:
 21329 009a 0446     		mov	r4, r0
 21330              	.LVL2691:
 21331 009c C2E7     		b	.L2248
 21332              	.LVL2692:
 21333              	.L2253:
10786:Src/bno055.c  **** } else {
 21334              		.loc 1 10786 0
 21335 009e 8120     		movs	r0, #129
 21336              	.LVL2693:
 21337 00a0 C4E7     		b	.L2246
 21338              	.L2263:
 21339 00a2 00BF     		.align	2
 21340              	.L2262:
 21341 00a4 00000000 		.word	.LANCHOR0
 21342              		.cfi_endproc
 21343              	.LFE180:
 21345              		.section	.text.bno055_get_mag_data_output_rate,"ax",%progbits
 21346              		.align	2
 21347              		.global	bno055_get_mag_data_output_rate
 21348              		.thumb
 21349              		.thumb_func
 21351              	bno055_get_mag_data_output_rate:
 21352              	.LFB181:
10841:Src/bno055.c  **** /*!
10842:Src/bno055.c  ****  *	@brief This API used to read the mag output data rate
10843:Src/bno055.c  ****  *	from page one register from 0x09 bit 0 to 2
10844:Src/bno055.c  ****  *
10845:Src/bno055.c  ****  *	@param mag_data_output_rate_u8 : The value of mag output data rate
10846:Src/bno055.c  ****  *
10847:Src/bno055.c  ****  *  mag_data_output_rate_u8 |   result
10848:Src/bno055.c  ****  *  ----------------------    |----------------------
10849:Src/bno055.c  ****  *     0x00                   | MAG_DATA_OUTPUT_RATE_2HZ
10850:Src/bno055.c  ****  *     0x01                   | MAG_DATA_OUTPUT_RATE_6HZ
10851:Src/bno055.c  ****  *     0x02                   | MAG_DATA_OUTPUT_RATE_8HZ
10852:Src/bno055.c  ****  *     0x03                   | MAG_DATA_OUTPUT_RATE_10HZ
10853:Src/bno055.c  ****  *     0x04                   | MAG_DATA_OUTPUT_RATE_15HZ
10854:Src/bno055.c  ****  *     0x05                   | MAG_DATA_OUTPUT_RATE_20HZ
10855:Src/bno055.c  ****  *     0x06                   | MAG_DATA_OUTPUT_RATE_25HZ
10856:Src/bno055.c  ****  *     0x07                   | MAG_DATA_OUTPUT_RATE_30HZ
10857:Src/bno055.c  ****  *
10858:Src/bno055.c  ****  *	@return results of bus communication function
10859:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
ARM GAS  /tmp/ccVWLGiI.s 			page 609


10860:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10861:Src/bno055.c  ****  *
10862:Src/bno055.c  ****  *
10863:Src/bno055.c  ****  */
10864:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_mag_data_output_rate(
10865:Src/bno055.c  **** u8 *mag_data_output_rate_u8)
10866:Src/bno055.c  **** {
 21353              		.loc 1 10866 0
 21354              		.cfi_startproc
 21355              		@ args = 0, pretend = 0, frame = 8
 21356              		@ frame_needed = 0, uses_anonymous_args = 0
 21357              	.LVL2694:
 21358 0000 30B5     		push	{r4, r5, lr}
 21359              	.LCFI844:
 21360              		.cfi_def_cfa_offset 12
 21361              		.cfi_offset 4, -12
 21362              		.cfi_offset 5, -8
 21363              		.cfi_offset 14, -4
10867:Src/bno055.c  **** 	/* Variable used to return value of
10868:Src/bno055.c  **** 	communication routine*/
10869:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10870:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
10871:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
10872:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
10873:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 21364              		.loc 1 10873 0
 21365 0002 144C     		ldr	r4, .L2276
10866:Src/bno055.c  **** 	/* Variable used to return value of
 21366              		.loc 1 10866 0
 21367 0004 83B0     		sub	sp, sp, #12
 21368              	.LCFI845:
 21369              		.cfi_def_cfa_offset 24
 21370              		.loc 1 10873 0
 21371 0006 2368     		ldr	r3, [r4]
10870:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 21372              		.loc 1 10870 0
 21373 0008 0022     		movs	r2, #0
 21374 000a 8DF80720 		strb	r2, [sp, #7]
 21375              	.LVL2695:
 21376              		.loc 1 10873 0
 21377 000e FBB1     		cbz	r3, .L2268
10874:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
10875:Src/bno055.c  **** 		} else {
10876:Src/bno055.c  **** 		/*condition check for page, output data rate
10877:Src/bno055.c  **** 		available in the page one*/
10878:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 21378              		.loc 1 10878 0
 21379 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21380 0012 0546     		mov	r5, r0
 21381 0014 012A     		cmp	r2, #1
 21382 0016 04D0     		beq	.L2266
10879:Src/bno055.c  **** 			/* Write page as one */
10880:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 21383              		.loc 1 10880 0
 21384 0018 0120     		movs	r0, #1
 21385              	.LVL2696:
 21386 001a FFF7FEFF 		bl	bno055_write_page_id
ARM GAS  /tmp/ccVWLGiI.s 			page 610


 21387              	.LVL2697:
 21388 001e 2368     		ldr	r3, [r4]
10881:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 21389              		.loc 1 10881 0
 21390 0020 70B9     		cbnz	r0, .L2275
 21391              	.LVL2698:
 21392              	.L2266:
10882:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
10883:Src/bno055.c  **** 			/* Read the mag output data rate*/
10884:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 21393              		.loc 1 10884 0
 21394 0022 1C69     		ldr	r4, [r3, #16]
 21395 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21396 0026 0921     		movs	r1, #9
 21397 0028 0123     		movs	r3, #1
 21398 002a 0DF10702 		add	r2, sp, #7
 21399 002e A047     		blx	r4
 21400              	.LVL2699:
10885:Src/bno055.c  **** 			(p_bno055->dev_addr,
10886:Src/bno055.c  **** 			BNO055_MAG_DATA_OUTPUT_RATE_REG,
10887:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
10888:Src/bno055.c  **** 			*mag_data_output_rate_u8 =
 21401              		.loc 1 10888 0
 21402 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21403 0034 03F00703 		and	r3, r3, #7
 21404 0038 2B70     		strb	r3, [r5]
 21405              	.LVL2700:
 21406              	.L2265:
10889:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
10890:Src/bno055.c  **** 			BNO055_MAG_DATA_OUTPUT_RATE);
10891:Src/bno055.c  **** 		} else {
10892:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10893:Src/bno055.c  **** 		}
10894:Src/bno055.c  **** 	}
10895:Src/bno055.c  **** 	return com_rslt;
10896:Src/bno055.c  **** }
 21407              		.loc 1 10896 0
 21408 003a 40B2     		sxtb	r0, r0
 21409 003c 03B0     		add	sp, sp, #12
 21410              	.LCFI846:
 21411              		.cfi_remember_state
 21412              		.cfi_def_cfa_offset 12
 21413              		@ sp needed
 21414 003e 30BD     		pop	{r4, r5, pc}
 21415              	.LVL2701:
 21416              	.L2275:
 21417              	.LCFI847:
 21418              		.cfi_restore_state
10881:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21419              		.loc 1 10881 0 discriminator 1
 21420 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21421 0042 012A     		cmp	r2, #1
10892:Src/bno055.c  **** 		}
 21422              		.loc 1 10892 0 discriminator 1
 21423 0044 18BF     		it	ne
 21424 0046 FF20     		movne	r0, #255
10881:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 611


 21425              		.loc 1 10881 0 discriminator 1
 21426 0048 EBD0     		beq	.L2266
 21427              		.loc 1 10896 0
 21428 004a 40B2     		sxtb	r0, r0
 21429 004c 03B0     		add	sp, sp, #12
 21430              	.LCFI848:
 21431              		.cfi_remember_state
 21432              		.cfi_def_cfa_offset 12
 21433              		@ sp needed
 21434 004e 30BD     		pop	{r4, r5, pc}
 21435              	.LVL2702:
 21436              	.L2268:
 21437              	.LCFI849:
 21438              		.cfi_restore_state
10874:Src/bno055.c  **** 		} else {
 21439              		.loc 1 10874 0
 21440 0050 8120     		movs	r0, #129
 21441              	.LVL2703:
 21442 0052 F2E7     		b	.L2265
 21443              	.L2277:
 21444              		.align	2
 21445              	.L2276:
 21446 0054 00000000 		.word	.LANCHOR0
 21447              		.cfi_endproc
 21448              	.LFE181:
 21450              		.section	.text.bno055_set_mag_data_output_rate,"ax",%progbits
 21451              		.align	2
 21452              		.global	bno055_set_mag_data_output_rate
 21453              		.thumb
 21454              		.thumb_func
 21456              	bno055_set_mag_data_output_rate:
 21457              	.LFB182:
10897:Src/bno055.c  **** /*!
10898:Src/bno055.c  ****  *	@brief This API used to write the mag output data rate
10899:Src/bno055.c  ****  *	from page one register from 0x09 bit 0 to 2
10900:Src/bno055.c  ****  *
10901:Src/bno055.c  ****  *	@param mag_data_output_rate_u8 : The value of mag output data rate
10902:Src/bno055.c  ****  *
10903:Src/bno055.c  ****  *  mag_data_output_rate_u8 |   result
10904:Src/bno055.c  ****  *  ----------------------    |----------------------
10905:Src/bno055.c  ****  *     0x00                   | MAG_DATA_OUTPUT_RATE_2HZ
10906:Src/bno055.c  ****  *     0x01                   | MAG_DATA_OUTPUT_RATE_6HZ
10907:Src/bno055.c  ****  *     0x02                   | MAG_DATA_OUTPUT_RATE_8HZ
10908:Src/bno055.c  ****  *     0x03                   | MAG_DATA_OUTPUT_RATE_10HZ
10909:Src/bno055.c  ****  *     0x04                   | MAG_DATA_OUTPUT_RATE_15HZ
10910:Src/bno055.c  ****  *     0x05                   | MAG_DATA_OUTPUT_RATE_20HZ
10911:Src/bno055.c  ****  *     0x06                   | MAG_DATA_OUTPUT_RATE_25HZ
10912:Src/bno055.c  ****  *     0x07                   | MAG_DATA_OUTPUT_RATE_30HZ
10913:Src/bno055.c  ****  *
10914:Src/bno055.c  ****  *	@return results of bus communication function
10915:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
10916:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
10917:Src/bno055.c  ****  *
10918:Src/bno055.c  ****  *
10919:Src/bno055.c  ****  */
10920:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_mag_data_output_rate(
10921:Src/bno055.c  **** u8 mag_data_output_rate_u8)
ARM GAS  /tmp/ccVWLGiI.s 			page 612


10922:Src/bno055.c  **** {
 21458              		.loc 1 10922 0
 21459              		.cfi_startproc
 21460              		@ args = 0, pretend = 0, frame = 8
 21461              		@ frame_needed = 0, uses_anonymous_args = 0
 21462              	.LVL2704:
 21463 0000 30B5     		push	{r4, r5, lr}
 21464              	.LCFI850:
 21465              		.cfi_def_cfa_offset 12
 21466              		.cfi_offset 4, -12
 21467              		.cfi_offset 5, -8
 21468              		.cfi_offset 14, -4
10923:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
10924:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
10925:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
10926:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
10927:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
10928:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
10929:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 21469              		.loc 1 10929 0
 21470 0002 274C     		ldr	r4, .L2295
10922:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 21471              		.loc 1 10922 0
 21472 0004 83B0     		sub	sp, sp, #12
 21473              	.LCFI851:
 21474              		.cfi_def_cfa_offset 24
 21475              		.loc 1 10929 0
 21476 0006 2268     		ldr	r2, [r4]
10924:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 21477              		.loc 1 10924 0
 21478 0008 0023     		movs	r3, #0
 21479 000a 8DF80630 		strb	r3, [sp, #6]
 21480              	.LVL2705:
10927:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 21481              		.loc 1 10927 0
 21482 000e 8DF80730 		strb	r3, [sp, #7]
 21483              		.loc 1 10929 0
 21484 0012 002A     		cmp	r2, #0
 21485 0014 42D0     		beq	.L2286
 21486 0016 0546     		mov	r5, r0
10930:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
10931:Src/bno055.c  **** } else {
10932:Src/bno055.c  **** /* The write operation effective only if the operation
10933:Src/bno055.c  **** mode is in config mode, this part of code is checking the
10934:Src/bno055.c  **** current operation mode and set the config mode */
10935:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 21487              		.loc 1 10935 0
 21488 0018 0DF10700 		add	r0, sp, #7
 21489              	.LVL2706:
 21490 001c FFF7FEFF 		bl	bno055_get_operation_mode
 21491              	.LVL2707:
10936:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 21492              		.loc 1 10936 0
 21493 0020 38B1     		cbz	r0, .L2280
 21494              	.LVL2708:
 21495              	.L2284:
10937:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
ARM GAS  /tmp/ccVWLGiI.s 			page 613


10938:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
10939:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
10940:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
10941:Src/bno055.c  **** 		/* Write page as one */
10942:Src/bno055.c  **** 		pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
10943:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
10944:Src/bno055.c  **** 			if (mag_data_output_rate_u8
10945:Src/bno055.c  **** 				< BNO055_MAG_OUTPUT_RANGE) {
10946:Src/bno055.c  **** 				/* Write the value of
10947:Src/bno055.c  **** 				mag output data rate*/
10948:Src/bno055.c  **** 				com_rslt =
10949:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
10950:Src/bno055.c  **** 				(p_bno055->dev_addr,
10951:Src/bno055.c  **** 				BNO055_MAG_DATA_OUTPUT_RATE_REG,
10952:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
10953:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
10954:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
10955:Src/bno055.c  **** 					(data_u8r,
10956:Src/bno055.c  **** 					BNO055_MAG_DATA_OUTPUT_RATE,
10957:Src/bno055.c  **** 					mag_data_output_rate_u8);
10958:Src/bno055.c  **** 					com_rslt +=
10959:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
10960:Src/bno055.c  **** 					(p_bno055->dev_addr,
10961:Src/bno055.c  **** 					BNO055_MAG_DATA_OUTPUT_RATE_REG,
10962:Src/bno055.c  **** 					&data_u8r,
10963:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
10964:Src/bno055.c  **** 				}
10965:Src/bno055.c  **** 			} else {
10966:Src/bno055.c  **** 			com_rslt = BNO055_OUT_OF_RANGE;
10967:Src/bno055.c  **** 			}
10968:Src/bno055.c  **** 		} else {
10969:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
10970:Src/bno055.c  **** 		}
10971:Src/bno055.c  **** 	} else {
10972:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
10973:Src/bno055.c  **** 	}
10974:Src/bno055.c  **** } else {
10975:Src/bno055.c  **** com_rslt = BNO055_ERROR;
 21496              		.loc 1 10975 0
 21497 0022 FF24     		movs	r4, #255
 21498              	.LVL2709:
 21499              	.L2281:
10976:Src/bno055.c  **** }
10977:Src/bno055.c  **** }
10978:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 21500              		.loc 1 10978 0
 21501 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 21502 0028 78B9     		cbnz	r0, .L2293
 21503 002a 2046     		mov	r0, r4
 21504              	.LVL2710:
 21505              	.L2279:
10979:Src/bno055.c  **** 	/* set the operation mode of
10980:Src/bno055.c  **** 	previous operation mode*/
10981:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
10982:Src/bno055.c  **** 	(prev_opmode_u8);
10983:Src/bno055.c  **** return com_rslt;
10984:Src/bno055.c  **** }
ARM GAS  /tmp/ccVWLGiI.s 			page 614


 21506              		.loc 1 10984 0
 21507 002c 40B2     		sxtb	r0, r0
 21508 002e 03B0     		add	sp, sp, #12
 21509              	.LCFI852:
 21510              		.cfi_remember_state
 21511              		.cfi_def_cfa_offset 12
 21512              		@ sp needed
 21513 0030 30BD     		pop	{r4, r5, pc}
 21514              	.LVL2711:
 21515              	.L2280:
 21516              	.LCFI853:
 21517              		.cfi_restore_state
10937:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 21518              		.loc 1 10937 0
 21519 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21520 0036 7BB9     		cbnz	r3, .L2282
 21521              	.L2285:
 21522              	.LVL2712:
10942:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
 21523              		.loc 1 10942 0
 21524 0038 0120     		movs	r0, #1
 21525 003a FFF7FEFF 		bl	bno055_write_page_id
 21526              	.LVL2713:
10943:Src/bno055.c  **** 			if (mag_data_output_rate_u8
 21527              		.loc 1 10943 0
 21528 003e 0028     		cmp	r0, #0
 21529 0040 EFD1     		bne	.L2284
10944:Src/bno055.c  **** 				< BNO055_MAG_OUTPUT_RANGE) {
 21530              		.loc 1 10944 0
 21531 0042 072D     		cmp	r5, #7
 21532 0044 0DD9     		bls	.L2294
10966:Src/bno055.c  **** 			}
 21533              		.loc 1 10966 0
 21534 0046 FE24     		movs	r4, #254
 21535 0048 ECE7     		b	.L2281
 21536              	.LVL2714:
 21537              	.L2293:
10981:Src/bno055.c  **** 	(prev_opmode_u8);
 21538              		.loc 1 10981 0
 21539 004a FFF7FEFF 		bl	bno055_set_operation_mode
 21540              	.LVL2715:
 21541 004e 2044     		add	r0, r0, r4
 21542 0050 C0B2     		uxtb	r0, r0
 21543              	.LVL2716:
 21544              		.loc 1 10984 0
 21545 0052 40B2     		sxtb	r0, r0
 21546 0054 03B0     		add	sp, sp, #12
 21547              	.LCFI854:
 21548              		.cfi_remember_state
 21549              		.cfi_def_cfa_offset 12
 21550              		@ sp needed
 21551 0056 30BD     		pop	{r4, r5, pc}
 21552              	.LVL2717:
 21553              	.L2282:
 21554              	.LCFI855:
 21555              		.cfi_restore_state
10938:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
ARM GAS  /tmp/ccVWLGiI.s 			page 615


 21556              		.loc 1 10938 0
 21557 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 21558              	.LVL2718:
10940:Src/bno055.c  **** 		/* Write page as one */
 21559              		.loc 1 10940 0
 21560 005c 0028     		cmp	r0, #0
 21561 005e E0D1     		bne	.L2284
 21562 0060 EAE7     		b	.L2285
 21563              	.LVL2719:
 21564              	.L2294:
10949:Src/bno055.c  **** 				(p_bno055->dev_addr,
 21565              		.loc 1 10949 0
 21566 0062 2368     		ldr	r3, [r4]
10948:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 21567              		.loc 1 10948 0
 21568 0064 0DF10602 		add	r2, sp, #6
 21569 0068 1C69     		ldr	r4, [r3, #16]
 21570 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21571              	.LVL2720:
 21572 006c 0921     		movs	r1, #9
 21573 006e 0123     		movs	r3, #1
 21574 0070 A047     		blx	r4
 21575              	.LVL2721:
10949:Src/bno055.c  **** 				(p_bno055->dev_addr,
 21576              		.loc 1 10949 0
 21577 0072 0B4B     		ldr	r3, .L2295
10953:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 21578              		.loc 1 10953 0
 21579 0074 0446     		mov	r4, r0
 21580 0076 0028     		cmp	r0, #0
 21581 0078 D4D1     		bne	.L2281
10954:Src/bno055.c  **** 					(data_u8r,
 21582              		.loc 1 10954 0
 21583 007a 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 21584              	.LVL2722:
10959:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21585              		.loc 1 10959 0
 21586 007e 1B68     		ldr	r3, [r3]
10954:Src/bno055.c  **** 					(data_u8r,
 21587              		.loc 1 10954 0
 21588 0080 20F00700 		bic	r0, r0, #7
 21589 0084 2843     		orrs	r0, r0, r5
10959:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21590              		.loc 1 10959 0
 21591 0086 DC68     		ldr	r4, [r3, #12]
10954:Src/bno055.c  **** 					(data_u8r,
 21592              		.loc 1 10954 0
 21593 0088 8DF80600 		strb	r0, [sp, #6]
10959:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21594              		.loc 1 10959 0
 21595 008c 0DF10602 		add	r2, sp, #6
 21596 0090 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21597 0092 0921     		movs	r1, #9
 21598 0094 0123     		movs	r3, #1
 21599 0096 A047     		blx	r4
 21600              	.LVL2723:
 21601 0098 0446     		mov	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 616


 21602              	.LVL2724:
 21603 009a C3E7     		b	.L2281
 21604              	.LVL2725:
 21605              	.L2286:
10930:Src/bno055.c  **** } else {
 21606              		.loc 1 10930 0
 21607 009c 8120     		movs	r0, #129
 21608              	.LVL2726:
 21609 009e C5E7     		b	.L2279
 21610              	.L2296:
 21611              		.align	2
 21612              	.L2295:
 21613 00a0 00000000 		.word	.LANCHOR0
 21614              		.cfi_endproc
 21615              	.LFE182:
 21617              		.section	.text.bno055_get_mag_operation_mode,"ax",%progbits
 21618              		.align	2
 21619              		.global	bno055_get_mag_operation_mode
 21620              		.thumb
 21621              		.thumb_func
 21623              	bno055_get_mag_operation_mode:
 21624              	.LFB183:
10985:Src/bno055.c  **** /*!
10986:Src/bno055.c  ****  *	@brief This API used to read the mag operation mode
10987:Src/bno055.c  ****  *	from page one register from 0x09 bit 3 to 4
10988:Src/bno055.c  ****  *
10989:Src/bno055.c  ****  *	@param mag_operation_mode_u8 : The value of mag operation mode
10990:Src/bno055.c  ****  *
10991:Src/bno055.c  ****  *  mag_operation_mode_u8  |      result
10992:Src/bno055.c  ****  * ------------------------- |--------------------------
10993:Src/bno055.c  ****  *     0x00                  | MAG_OPR_MODE_LOWPOWER
10994:Src/bno055.c  ****  *     0x01                  | MAG_OPR_MODE_REGULAR
10995:Src/bno055.c  ****  *     0x02                  | MAG_OPR_MODE_ENHANCED_REGULAR
10996:Src/bno055.c  ****  *     0x03                  | MAG_OPR_MODE_HIGH_ACCURACY
10997:Src/bno055.c  ****  *
10998:Src/bno055.c  ****  *	@return results of bus communication function
10999:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11000:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11001:Src/bno055.c  ****  *
11002:Src/bno055.c  ****  *
11003:Src/bno055.c  ****  */
11004:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_mag_operation_mode(
11005:Src/bno055.c  **** u8 *mag_operation_mode_u8)
11006:Src/bno055.c  **** {
 21625              		.loc 1 11006 0
 21626              		.cfi_startproc
 21627              		@ args = 0, pretend = 0, frame = 8
 21628              		@ frame_needed = 0, uses_anonymous_args = 0
 21629              	.LVL2727:
 21630 0000 30B5     		push	{r4, r5, lr}
 21631              	.LCFI856:
 21632              		.cfi_def_cfa_offset 12
 21633              		.cfi_offset 4, -12
 21634              		.cfi_offset 5, -8
 21635              		.cfi_offset 14, -4
11007:Src/bno055.c  **** 	/* Variable used to return value of
11008:Src/bno055.c  **** 	communication routine*/
ARM GAS  /tmp/ccVWLGiI.s 			page 617


11009:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11010:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
11011:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11012:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11013:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 21636              		.loc 1 11013 0
 21637 0002 144C     		ldr	r4, .L2309
11006:Src/bno055.c  **** 	/* Variable used to return value of
 21638              		.loc 1 11006 0
 21639 0004 83B0     		sub	sp, sp, #12
 21640              	.LCFI857:
 21641              		.cfi_def_cfa_offset 24
 21642              		.loc 1 11013 0
 21643 0006 2368     		ldr	r3, [r4]
11010:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 21644              		.loc 1 11010 0
 21645 0008 0022     		movs	r2, #0
 21646 000a 8DF80720 		strb	r2, [sp, #7]
 21647              	.LVL2728:
 21648              		.loc 1 11013 0
 21649 000e FBB1     		cbz	r3, .L2301
11014:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11015:Src/bno055.c  **** 		} else {
11016:Src/bno055.c  **** 		/*condition check for page, mag operation mode is
11017:Src/bno055.c  **** 		available in the page one*/
11018:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 21650              		.loc 1 11018 0
 21651 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21652 0012 0546     		mov	r5, r0
 21653 0014 012A     		cmp	r2, #1
 21654 0016 04D0     		beq	.L2299
11019:Src/bno055.c  **** 			/* Write page as one */
11020:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 21655              		.loc 1 11020 0
 21656 0018 0120     		movs	r0, #1
 21657              	.LVL2729:
 21658 001a FFF7FEFF 		bl	bno055_write_page_id
 21659              	.LVL2730:
 21660 001e 2368     		ldr	r3, [r4]
11021:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 21661              		.loc 1 11021 0
 21662 0020 70B9     		cbnz	r0, .L2308
 21663              	.LVL2731:
 21664              	.L2299:
11022:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11023:Src/bno055.c  **** 			/* Read the value of mag operation mode*/
11024:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 21665              		.loc 1 11024 0
 21666 0022 1C69     		ldr	r4, [r3, #16]
 21667 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21668 0026 0921     		movs	r1, #9
 21669 0028 0123     		movs	r3, #1
 21670 002a 0DF10702 		add	r2, sp, #7
 21671 002e A047     		blx	r4
 21672              	.LVL2732:
11025:Src/bno055.c  **** 			(p_bno055->dev_addr,
11026:Src/bno055.c  **** 			BNO055_MAG_OPERATION_MODE_REG,
ARM GAS  /tmp/ccVWLGiI.s 			page 618


11027:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11028:Src/bno055.c  **** 			*mag_operation_mode_u8 =
11029:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 21673              		.loc 1 11029 0
 21674 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21675 0034 C3F3C103 		ubfx	r3, r3, #3, #2
11028:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 21676              		.loc 1 11028 0
 21677 0038 2B70     		strb	r3, [r5]
 21678              	.LVL2733:
 21679              	.L2298:
11030:Src/bno055.c  **** 			BNO055_MAG_OPERATION_MODE);
11031:Src/bno055.c  **** 		} else {
11032:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11033:Src/bno055.c  **** 		}
11034:Src/bno055.c  **** 	}
11035:Src/bno055.c  **** 	return com_rslt;
11036:Src/bno055.c  **** }
 21680              		.loc 1 11036 0
 21681 003a 40B2     		sxtb	r0, r0
 21682 003c 03B0     		add	sp, sp, #12
 21683              	.LCFI858:
 21684              		.cfi_remember_state
 21685              		.cfi_def_cfa_offset 12
 21686              		@ sp needed
 21687 003e 30BD     		pop	{r4, r5, pc}
 21688              	.LVL2734:
 21689              	.L2308:
 21690              	.LCFI859:
 21691              		.cfi_restore_state
11021:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21692              		.loc 1 11021 0 discriminator 1
 21693 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21694 0042 012A     		cmp	r2, #1
11032:Src/bno055.c  **** 		}
 21695              		.loc 1 11032 0 discriminator 1
 21696 0044 18BF     		it	ne
 21697 0046 FF20     		movne	r0, #255
11021:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21698              		.loc 1 11021 0 discriminator 1
 21699 0048 EBD0     		beq	.L2299
 21700              		.loc 1 11036 0
 21701 004a 40B2     		sxtb	r0, r0
 21702 004c 03B0     		add	sp, sp, #12
 21703              	.LCFI860:
 21704              		.cfi_remember_state
 21705              		.cfi_def_cfa_offset 12
 21706              		@ sp needed
 21707 004e 30BD     		pop	{r4, r5, pc}
 21708              	.LVL2735:
 21709              	.L2301:
 21710              	.LCFI861:
 21711              		.cfi_restore_state
11014:Src/bno055.c  **** 		} else {
 21712              		.loc 1 11014 0
 21713 0050 8120     		movs	r0, #129
 21714              	.LVL2736:
ARM GAS  /tmp/ccVWLGiI.s 			page 619


 21715 0052 F2E7     		b	.L2298
 21716              	.L2310:
 21717              		.align	2
 21718              	.L2309:
 21719 0054 00000000 		.word	.LANCHOR0
 21720              		.cfi_endproc
 21721              	.LFE183:
 21723              		.section	.text.bno055_set_mag_operation_mode,"ax",%progbits
 21724              		.align	2
 21725              		.global	bno055_set_mag_operation_mode
 21726              		.thumb
 21727              		.thumb_func
 21729              	bno055_set_mag_operation_mode:
 21730              	.LFB184:
11037:Src/bno055.c  **** /*!
11038:Src/bno055.c  ****  *	@brief This API used to write the mag operation mode
11039:Src/bno055.c  ****  *	from page one register from 0x09 bit 3 to 4
11040:Src/bno055.c  ****  *
11041:Src/bno055.c  ****  *	@param mag_operation_mode_u8 : The value of mag operation mode
11042:Src/bno055.c  ****  *
11043:Src/bno055.c  ****  *  mag_operation_mode_u8  |      result
11044:Src/bno055.c  ****  * ------------------------- |--------------------------
11045:Src/bno055.c  ****  *     0x00                  | MAG_OPR_MODE_LOWPOWER
11046:Src/bno055.c  ****  *     0x01                  | MAG_OPR_MODE_REGULAR
11047:Src/bno055.c  ****  *     0x02                  | MAG_OPR_MODE_ENHANCED_REGULAR
11048:Src/bno055.c  ****  *     0x03                  | MAG_OPR_MODE_HIGH_ACCURACY
11049:Src/bno055.c  ****  *
11050:Src/bno055.c  ****  *	@return results of bus communication function
11051:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11052:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11053:Src/bno055.c  ****  *
11054:Src/bno055.c  ****  *
11055:Src/bno055.c  ****  */
11056:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_mag_operation_mode(
11057:Src/bno055.c  **** u8 mag_operation_mode_u8)
11058:Src/bno055.c  **** {
 21731              		.loc 1 11058 0
 21732              		.cfi_startproc
 21733              		@ args = 0, pretend = 0, frame = 8
 21734              		@ frame_needed = 0, uses_anonymous_args = 0
 21735              	.LVL2737:
 21736 0000 30B5     		push	{r4, r5, lr}
 21737              	.LCFI862:
 21738              		.cfi_def_cfa_offset 12
 21739              		.cfi_offset 4, -12
 21740              		.cfi_offset 5, -8
 21741              		.cfi_offset 14, -4
11059:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11060:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11061:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11062:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11063:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11064:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11065:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 21742              		.loc 1 11065 0
 21743 0002 294C     		ldr	r4, .L2328
11058:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 620


 21744              		.loc 1 11058 0
 21745 0004 83B0     		sub	sp, sp, #12
 21746              	.LCFI863:
 21747              		.cfi_def_cfa_offset 24
 21748              		.loc 1 11065 0
 21749 0006 2268     		ldr	r2, [r4]
11060:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 21750              		.loc 1 11060 0
 21751 0008 0023     		movs	r3, #0
 21752 000a 8DF80630 		strb	r3, [sp, #6]
 21753              	.LVL2738:
11063:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 21754              		.loc 1 11063 0
 21755 000e 8DF80730 		strb	r3, [sp, #7]
 21756              		.loc 1 11065 0
 21757 0012 002A     		cmp	r2, #0
 21758 0014 45D0     		beq	.L2319
 21759 0016 0546     		mov	r5, r0
11066:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
11067:Src/bno055.c  **** } else {
11068:Src/bno055.c  **** /* The write operation effective only if the operation
11069:Src/bno055.c  **** mode is in config mode, this part of code is checking the
11070:Src/bno055.c  **** current operation mode and set the config mode */
11071:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 21760              		.loc 1 11071 0
 21761 0018 0DF10700 		add	r0, sp, #7
 21762              	.LVL2739:
 21763 001c FFF7FEFF 		bl	bno055_get_operation_mode
 21764              	.LVL2740:
11072:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 21765              		.loc 1 11072 0
 21766 0020 38B1     		cbz	r0, .L2313
 21767              	.LVL2741:
 21768              	.L2317:
11073:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11074:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
11075:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
11076:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
11077:Src/bno055.c  **** 			/* Write page as one */
11078:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
11079:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
11080:Src/bno055.c  **** 				if (mag_operation_mode_u8
11081:Src/bno055.c  **** 					< BNO055_MAG_OPR_MODE_RANGE) {
11082:Src/bno055.c  **** 					/* Write the value
11083:Src/bno055.c  **** 					of mag operation mode*/
11084:Src/bno055.c  **** 					com_rslt =
11085:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
11086:Src/bno055.c  **** 					(p_bno055->dev_addr,
11087:Src/bno055.c  **** 					BNO055_MAG_OPERATION_MODE_REG,
11088:Src/bno055.c  **** 					&data_u8r,
11089:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
11090:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
11091:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
11092:Src/bno055.c  **** 						(data_u8r,
11093:Src/bno055.c  **** 						BNO055_MAG_OPERATION_MODE,
11094:Src/bno055.c  **** 						mag_operation_mode_u8);
11095:Src/bno055.c  **** 						com_rslt +=
ARM GAS  /tmp/ccVWLGiI.s 			page 621


11096:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
11097:Src/bno055.c  **** 						(p_bno055->dev_addr,
11098:Src/bno055.c  **** 						BNO055_MAG_OPERATION_MODE_REG,
11099:Src/bno055.c  **** 						&data_u8r,
11100:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
11101:Src/bno055.c  **** 					}
11102:Src/bno055.c  **** 				} else {
11103:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
11104:Src/bno055.c  **** 				}
11105:Src/bno055.c  **** 			} else {
11106:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
11107:Src/bno055.c  **** 			}
11108:Src/bno055.c  **** 		} else {
11109:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11110:Src/bno055.c  **** 		}
11111:Src/bno055.c  **** 	} else {
11112:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 21769              		.loc 1 11112 0
 21770 0022 FF24     		movs	r4, #255
 21771              	.LVL2742:
 21772              	.L2314:
11113:Src/bno055.c  **** 	}
11114:Src/bno055.c  **** }
11115:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 21773              		.loc 1 11115 0
 21774 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 21775 0028 78B9     		cbnz	r0, .L2326
 21776 002a 2046     		mov	r0, r4
 21777              	.LVL2743:
 21778              	.L2312:
11116:Src/bno055.c  **** 	/* set the operation mode of
11117:Src/bno055.c  **** 	previous operation mode*/
11118:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
11119:Src/bno055.c  **** 	(prev_opmode_u8);
11120:Src/bno055.c  **** return com_rslt;
11121:Src/bno055.c  **** }
 21779              		.loc 1 11121 0
 21780 002c 40B2     		sxtb	r0, r0
 21781 002e 03B0     		add	sp, sp, #12
 21782              	.LCFI864:
 21783              		.cfi_remember_state
 21784              		.cfi_def_cfa_offset 12
 21785              		@ sp needed
 21786 0030 30BD     		pop	{r4, r5, pc}
 21787              	.LVL2744:
 21788              	.L2313:
 21789              	.LCFI865:
 21790              		.cfi_restore_state
11073:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 21791              		.loc 1 11073 0
 21792 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21793 0036 7BB9     		cbnz	r3, .L2315
 21794              	.L2318:
 21795              	.LVL2745:
11078:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 21796              		.loc 1 11078 0
 21797 0038 0120     		movs	r0, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 622


 21798 003a FFF7FEFF 		bl	bno055_write_page_id
 21799              	.LVL2746:
11079:Src/bno055.c  **** 				if (mag_operation_mode_u8
 21800              		.loc 1 11079 0
 21801 003e 0028     		cmp	r0, #0
 21802 0040 EFD1     		bne	.L2317
11080:Src/bno055.c  **** 					< BNO055_MAG_OPR_MODE_RANGE) {
 21803              		.loc 1 11080 0
 21804 0042 042D     		cmp	r5, #4
 21805 0044 0DD9     		bls	.L2327
11103:Src/bno055.c  **** 				}
 21806              		.loc 1 11103 0
 21807 0046 FE24     		movs	r4, #254
 21808 0048 ECE7     		b	.L2314
 21809              	.LVL2747:
 21810              	.L2326:
11118:Src/bno055.c  **** 	(prev_opmode_u8);
 21811              		.loc 1 11118 0
 21812 004a FFF7FEFF 		bl	bno055_set_operation_mode
 21813              	.LVL2748:
 21814 004e 2044     		add	r0, r0, r4
 21815 0050 C0B2     		uxtb	r0, r0
 21816              	.LVL2749:
 21817              		.loc 1 11121 0
 21818 0052 40B2     		sxtb	r0, r0
 21819 0054 03B0     		add	sp, sp, #12
 21820              	.LCFI866:
 21821              		.cfi_remember_state
 21822              		.cfi_def_cfa_offset 12
 21823              		@ sp needed
 21824 0056 30BD     		pop	{r4, r5, pc}
 21825              	.LVL2750:
 21826              	.L2315:
 21827              	.LCFI867:
 21828              		.cfi_restore_state
11074:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 21829              		.loc 1 11074 0
 21830 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 21831              	.LVL2751:
11076:Src/bno055.c  **** 			/* Write page as one */
 21832              		.loc 1 11076 0
 21833 005c 0028     		cmp	r0, #0
 21834 005e E0D1     		bne	.L2317
 21835 0060 EAE7     		b	.L2318
 21836              	.LVL2752:
 21837              	.L2327:
11085:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21838              		.loc 1 11085 0
 21839 0062 2368     		ldr	r3, [r4]
11084:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 21840              		.loc 1 11084 0
 21841 0064 0921     		movs	r1, #9
 21842 0066 1C69     		ldr	r4, [r3, #16]
 21843 0068 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21844              	.LVL2753:
 21845 006a 0DF10602 		add	r2, sp, #6
 21846 006e 0123     		movs	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 623


 21847 0070 A047     		blx	r4
 21848              	.LVL2754:
11085:Src/bno055.c  **** 					(p_bno055->dev_addr,
 21849              		.loc 1 11085 0
 21850 0072 0D49     		ldr	r1, .L2328
11090:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 21851              		.loc 1 11090 0
 21852 0074 0446     		mov	r4, r0
 21853 0076 0028     		cmp	r0, #0
 21854 0078 D4D1     		bne	.L2314
11091:Src/bno055.c  **** 						(data_u8r,
 21855              		.loc 1 11091 0
 21856 007a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 21857 007e EB00     		lsls	r3, r5, #3
11096:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21858              		.loc 1 11096 0
 21859 0080 0968     		ldr	r1, [r1]
11091:Src/bno055.c  **** 						(data_u8r,
 21860              		.loc 1 11091 0
 21861 0082 22F01802 		bic	r2, r2, #24
 21862 0086 03F01803 		and	r3, r3, #24
 21863 008a 1343     		orrs	r3, r3, r2
11096:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21864              		.loc 1 11096 0
 21865 008c CC68     		ldr	r4, [r1, #12]
11091:Src/bno055.c  **** 						(data_u8r,
 21866              		.loc 1 11091 0
 21867 008e 8DF80630 		strb	r3, [sp, #6]
11096:Src/bno055.c  **** 						(p_bno055->dev_addr,
 21868              		.loc 1 11096 0
 21869 0092 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 21870              	.LVL2755:
 21871 0094 0DF10602 		add	r2, sp, #6
 21872 0098 0921     		movs	r1, #9
 21873 009a 0123     		movs	r3, #1
 21874 009c A047     		blx	r4
 21875              	.LVL2756:
 21876 009e 0446     		mov	r4, r0
 21877              	.LVL2757:
 21878 00a0 C0E7     		b	.L2314
 21879              	.LVL2758:
 21880              	.L2319:
11066:Src/bno055.c  **** } else {
 21881              		.loc 1 11066 0
 21882 00a2 8120     		movs	r0, #129
 21883              	.LVL2759:
 21884 00a4 C2E7     		b	.L2312
 21885              	.L2329:
 21886 00a6 00BF     		.align	2
 21887              	.L2328:
 21888 00a8 00000000 		.word	.LANCHOR0
 21889              		.cfi_endproc
 21890              	.LFE184:
 21892              		.section	.text.bno055_get_mag_power_mode,"ax",%progbits
 21893              		.align	2
 21894              		.global	bno055_get_mag_power_mode
 21895              		.thumb
ARM GAS  /tmp/ccVWLGiI.s 			page 624


 21896              		.thumb_func
 21898              	bno055_get_mag_power_mode:
 21899              	.LFB185:
11122:Src/bno055.c  **** /*!
11123:Src/bno055.c  ****  *	@brief This API used to read the mag power mode
11124:Src/bno055.c  ****  *	from page one register from 0x09 bit 4 to 6
11125:Src/bno055.c  ****  *
11126:Src/bno055.c  ****  *	@param mag_power_mode_u8 : The value of mag power mode
11127:Src/bno055.c  ****  *
11128:Src/bno055.c  ****  * mag_power_mode_u8 |   result
11129:Src/bno055.c  ****  * --------------------|-----------------
11130:Src/bno055.c  ****  *     0x00            | BNO055_MAG_POWER_MODE_NORMAL
11131:Src/bno055.c  ****  *     0x01            | BNO055_MAG_POWER_MODE_SLEEP
11132:Src/bno055.c  ****  *     0x02            | BNO055_MAG_POWER_MODE_SUSPEND
11133:Src/bno055.c  ****  *     0x03            | BNO055_MAG_POWER_MODE_FORCE_MODE
11134:Src/bno055.c  ****  *
11135:Src/bno055.c  ****  *	@return results of bus communication function
11136:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11137:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11138:Src/bno055.c  ****  *
11139:Src/bno055.c  ****  *
11140:Src/bno055.c  ****  */
11141:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_mag_power_mode(
11142:Src/bno055.c  **** u8 *mag_power_mode_u8)
11143:Src/bno055.c  **** {
 21900              		.loc 1 11143 0
 21901              		.cfi_startproc
 21902              		@ args = 0, pretend = 0, frame = 8
 21903              		@ frame_needed = 0, uses_anonymous_args = 0
 21904              	.LVL2760:
 21905 0000 30B5     		push	{r4, r5, lr}
 21906              	.LCFI868:
 21907              		.cfi_def_cfa_offset 12
 21908              		.cfi_offset 4, -12
 21909              		.cfi_offset 5, -8
 21910              		.cfi_offset 14, -4
11144:Src/bno055.c  **** 	/* Variable used to return value of
11145:Src/bno055.c  **** 	communication routine*/
11146:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11147:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
11148:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11149:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11150:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 21911              		.loc 1 11150 0
 21912 0002 144C     		ldr	r4, .L2342
11143:Src/bno055.c  **** 	/* Variable used to return value of
 21913              		.loc 1 11143 0
 21914 0004 83B0     		sub	sp, sp, #12
 21915              	.LCFI869:
 21916              		.cfi_def_cfa_offset 24
 21917              		.loc 1 11150 0
 21918 0006 2368     		ldr	r3, [r4]
11147:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 21919              		.loc 1 11147 0
 21920 0008 0022     		movs	r2, #0
 21921 000a 8DF80720 		strb	r2, [sp, #7]
 21922              	.LVL2761:
ARM GAS  /tmp/ccVWLGiI.s 			page 625


 21923              		.loc 1 11150 0
 21924 000e FBB1     		cbz	r3, .L2334
11151:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11152:Src/bno055.c  **** 		} else {
11153:Src/bno055.c  **** 		/*condition check for page, mag power mode is
11154:Src/bno055.c  **** 		available in the page one*/
11155:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 21925              		.loc 1 11155 0
 21926 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21927 0012 0546     		mov	r5, r0
 21928 0014 012A     		cmp	r2, #1
 21929 0016 04D0     		beq	.L2332
11156:Src/bno055.c  **** 			/* Write page as one */
11157:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 21930              		.loc 1 11157 0
 21931 0018 0120     		movs	r0, #1
 21932              	.LVL2762:
 21933 001a FFF7FEFF 		bl	bno055_write_page_id
 21934              	.LVL2763:
 21935 001e 2368     		ldr	r3, [r4]
11158:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 21936              		.loc 1 11158 0
 21937 0020 70B9     		cbnz	r0, .L2341
 21938              	.LVL2764:
 21939              	.L2332:
11159:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11160:Src/bno055.c  **** 			/* Read the value of mag power mode */
11161:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 21940              		.loc 1 11161 0
 21941 0022 1C69     		ldr	r4, [r3, #16]
 21942 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 21943 0026 0921     		movs	r1, #9
 21944 0028 0123     		movs	r3, #1
 21945 002a 0DF10702 		add	r2, sp, #7
 21946 002e A047     		blx	r4
 21947              	.LVL2765:
11162:Src/bno055.c  **** 			(p_bno055->dev_addr,
11163:Src/bno055.c  **** 			BNO055_MAG_POWER_MODE_REG,
11164:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11165:Src/bno055.c  **** 			*mag_power_mode_u8 =
11166:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 21948              		.loc 1 11166 0
 21949 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 21950 0034 C3F34113 		ubfx	r3, r3, #5, #2
11165:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 21951              		.loc 1 11165 0
 21952 0038 2B70     		strb	r3, [r5]
 21953              	.LVL2766:
 21954              	.L2331:
11167:Src/bno055.c  **** 			BNO055_MAG_POWER_MODE);
11168:Src/bno055.c  **** 		} else {
11169:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11170:Src/bno055.c  **** 		}
11171:Src/bno055.c  **** 	}
11172:Src/bno055.c  **** 	return com_rslt;
11173:Src/bno055.c  **** }
 21955              		.loc 1 11173 0
ARM GAS  /tmp/ccVWLGiI.s 			page 626


 21956 003a 40B2     		sxtb	r0, r0
 21957 003c 03B0     		add	sp, sp, #12
 21958              	.LCFI870:
 21959              		.cfi_remember_state
 21960              		.cfi_def_cfa_offset 12
 21961              		@ sp needed
 21962 003e 30BD     		pop	{r4, r5, pc}
 21963              	.LVL2767:
 21964              	.L2341:
 21965              	.LCFI871:
 21966              		.cfi_restore_state
11158:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21967              		.loc 1 11158 0 discriminator 1
 21968 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 21969 0042 012A     		cmp	r2, #1
11169:Src/bno055.c  **** 		}
 21970              		.loc 1 11169 0 discriminator 1
 21971 0044 18BF     		it	ne
 21972 0046 FF20     		movne	r0, #255
11158:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 21973              		.loc 1 11158 0 discriminator 1
 21974 0048 EBD0     		beq	.L2332
 21975              		.loc 1 11173 0
 21976 004a 40B2     		sxtb	r0, r0
 21977 004c 03B0     		add	sp, sp, #12
 21978              	.LCFI872:
 21979              		.cfi_remember_state
 21980              		.cfi_def_cfa_offset 12
 21981              		@ sp needed
 21982 004e 30BD     		pop	{r4, r5, pc}
 21983              	.LVL2768:
 21984              	.L2334:
 21985              	.LCFI873:
 21986              		.cfi_restore_state
11151:Src/bno055.c  **** 		} else {
 21987              		.loc 1 11151 0
 21988 0050 8120     		movs	r0, #129
 21989              	.LVL2769:
 21990 0052 F2E7     		b	.L2331
 21991              	.L2343:
 21992              		.align	2
 21993              	.L2342:
 21994 0054 00000000 		.word	.LANCHOR0
 21995              		.cfi_endproc
 21996              	.LFE185:
 21998              		.section	.text.bno055_set_mag_power_mode,"ax",%progbits
 21999              		.align	2
 22000              		.global	bno055_set_mag_power_mode
 22001              		.thumb
 22002              		.thumb_func
 22004              	bno055_set_mag_power_mode:
 22005              	.LFB186:
11174:Src/bno055.c  **** /*!
11175:Src/bno055.c  ****  *	@brief This API used to write the mag power mode
11176:Src/bno055.c  ****  *	from page one register from 0x09 bit 4 to 6
11177:Src/bno055.c  ****  *
11178:Src/bno055.c  ****  *	@param mag_power_mode_u8 : The value of mag power mode
ARM GAS  /tmp/ccVWLGiI.s 			page 627


11179:Src/bno055.c  ****  *
11180:Src/bno055.c  ****  * mag_power_mode_u8 |   result
11181:Src/bno055.c  ****  * --------------------|-----------------
11182:Src/bno055.c  ****  *     0x00            | BNO055_MAG_POWER_MODE_NORMAL
11183:Src/bno055.c  ****  *     0x01            | BNO055_MAG_POWER_MODE_SLEEP
11184:Src/bno055.c  ****  *     0x02            | BNO055_MAG_POWER_MODE_SUSPEND
11185:Src/bno055.c  ****  *     0x03            | BNO055_MAG_POWER_MODE_FORCE_MODE
11186:Src/bno055.c  ****  *
11187:Src/bno055.c  ****  *	@return results of bus communication function
11188:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11189:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11190:Src/bno055.c  ****  *
11191:Src/bno055.c  ****  *
11192:Src/bno055.c  ****  */
11193:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_mag_power_mode(
11194:Src/bno055.c  **** u8 mag_power_mode_u8)
11195:Src/bno055.c  **** {
 22006              		.loc 1 11195 0
 22007              		.cfi_startproc
 22008              		@ args = 0, pretend = 0, frame = 8
 22009              		@ frame_needed = 0, uses_anonymous_args = 0
 22010              	.LVL2770:
 22011 0000 30B5     		push	{r4, r5, lr}
 22012              	.LCFI874:
 22013              		.cfi_def_cfa_offset 12
 22014              		.cfi_offset 4, -12
 22015              		.cfi_offset 5, -8
 22016              		.cfi_offset 14, -4
11196:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11197:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11198:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11199:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11200:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11201:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11202:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 22017              		.loc 1 11202 0
 22018 0002 294C     		ldr	r4, .L2361
11195:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 22019              		.loc 1 11195 0
 22020 0004 83B0     		sub	sp, sp, #12
 22021              	.LCFI875:
 22022              		.cfi_def_cfa_offset 24
 22023              		.loc 1 11202 0
 22024 0006 2268     		ldr	r2, [r4]
11197:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 22025              		.loc 1 11197 0
 22026 0008 0023     		movs	r3, #0
 22027 000a 8DF80630 		strb	r3, [sp, #6]
 22028              	.LVL2771:
11200:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 22029              		.loc 1 11200 0
 22030 000e 8DF80730 		strb	r3, [sp, #7]
 22031              		.loc 1 11202 0
 22032 0012 002A     		cmp	r2, #0
 22033 0014 45D0     		beq	.L2352
 22034 0016 0546     		mov	r5, r0
11203:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
ARM GAS  /tmp/ccVWLGiI.s 			page 628


11204:Src/bno055.c  **** } else {
11205:Src/bno055.c  **** /* The write operation effective only if the operation
11206:Src/bno055.c  **** mode is in config mode, this part of code is checking the
11207:Src/bno055.c  **** current operation mode and set the config mode */
11208:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 22035              		.loc 1 11208 0
 22036 0018 0DF10700 		add	r0, sp, #7
 22037              	.LVL2772:
 22038 001c FFF7FEFF 		bl	bno055_get_operation_mode
 22039              	.LVL2773:
11209:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 22040              		.loc 1 11209 0
 22041 0020 38B1     		cbz	r0, .L2346
 22042              	.LVL2774:
 22043              	.L2350:
11210:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11211:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode(
11212:Src/bno055.c  **** 		BNO055_OPERATION_MODE_CONFIG);
11213:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
11214:Src/bno055.c  **** 		/* Write page as one */
11215:Src/bno055.c  **** 		pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
11216:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
11217:Src/bno055.c  **** 			if (mag_power_mode_u8 <
11218:Src/bno055.c  **** 			BNO055_MAG_POWER_MODE_RANGE) {
11219:Src/bno055.c  **** 				/* Write the value of mag power mode*/
11220:Src/bno055.c  **** 				com_rslt =
11221:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
11222:Src/bno055.c  **** 				(p_bno055->dev_addr,
11223:Src/bno055.c  **** 				BNO055_MAG_POWER_MODE_REG,
11224:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11225:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
11226:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
11227:Src/bno055.c  **** 					(data_u8r,
11228:Src/bno055.c  **** 					BNO055_MAG_POWER_MODE,
11229:Src/bno055.c  **** 					mag_power_mode_u8);
11230:Src/bno055.c  **** 					com_rslt +=
11231:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
11232:Src/bno055.c  **** 					(p_bno055->dev_addr,
11233:Src/bno055.c  **** 					BNO055_MAG_POWER_MODE_REG,
11234:Src/bno055.c  **** 					&data_u8r,
11235:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
11236:Src/bno055.c  **** 				}
11237:Src/bno055.c  **** 			} else {
11238:Src/bno055.c  **** 			com_rslt = BNO055_OUT_OF_RANGE;
11239:Src/bno055.c  **** 			}
11240:Src/bno055.c  **** 		} else {
11241:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11242:Src/bno055.c  **** 		}
11243:Src/bno055.c  **** 	} else {
11244:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
11245:Src/bno055.c  **** 	}
11246:Src/bno055.c  **** } else {
11247:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 22044              		.loc 1 11247 0
 22045 0022 FF24     		movs	r4, #255
 22046              	.LVL2775:
 22047              	.L2347:
ARM GAS  /tmp/ccVWLGiI.s 			page 629


11248:Src/bno055.c  **** }
11249:Src/bno055.c  **** }
11250:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 22048              		.loc 1 11250 0
 22049 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 22050 0028 78B9     		cbnz	r0, .L2359
 22051 002a 2046     		mov	r0, r4
 22052              	.LVL2776:
 22053              	.L2345:
11251:Src/bno055.c  **** 	/* set the operation mode of
11252:Src/bno055.c  **** 	previous operation mode*/
11253:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
11254:Src/bno055.c  **** 	(prev_opmode_u8);
11255:Src/bno055.c  **** return com_rslt;
11256:Src/bno055.c  **** }
 22054              		.loc 1 11256 0
 22055 002c 40B2     		sxtb	r0, r0
 22056 002e 03B0     		add	sp, sp, #12
 22057              	.LCFI876:
 22058              		.cfi_remember_state
 22059              		.cfi_def_cfa_offset 12
 22060              		@ sp needed
 22061 0030 30BD     		pop	{r4, r5, pc}
 22062              	.LVL2777:
 22063              	.L2346:
 22064              	.LCFI877:
 22065              		.cfi_restore_state
11210:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode(
 22066              		.loc 1 11210 0
 22067 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22068 0036 7BB9     		cbnz	r3, .L2348
 22069              	.L2351:
 22070              	.LVL2778:
11215:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
 22071              		.loc 1 11215 0
 22072 0038 0120     		movs	r0, #1
 22073 003a FFF7FEFF 		bl	bno055_write_page_id
 22074              	.LVL2779:
11216:Src/bno055.c  **** 			if (mag_power_mode_u8 <
 22075              		.loc 1 11216 0
 22076 003e 0028     		cmp	r0, #0
 22077 0040 EFD1     		bne	.L2350
11217:Src/bno055.c  **** 			BNO055_MAG_POWER_MODE_RANGE) {
 22078              		.loc 1 11217 0
 22079 0042 032D     		cmp	r5, #3
 22080 0044 0DD9     		bls	.L2360
11238:Src/bno055.c  **** 			}
 22081              		.loc 1 11238 0
 22082 0046 FE24     		movs	r4, #254
 22083 0048 ECE7     		b	.L2347
 22084              	.LVL2780:
 22085              	.L2359:
11253:Src/bno055.c  **** 	(prev_opmode_u8);
 22086              		.loc 1 11253 0
 22087 004a FFF7FEFF 		bl	bno055_set_operation_mode
 22088              	.LVL2781:
 22089 004e 2044     		add	r0, r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 630


 22090 0050 C0B2     		uxtb	r0, r0
 22091              	.LVL2782:
 22092              		.loc 1 11256 0
 22093 0052 40B2     		sxtb	r0, r0
 22094 0054 03B0     		add	sp, sp, #12
 22095              	.LCFI878:
 22096              		.cfi_remember_state
 22097              		.cfi_def_cfa_offset 12
 22098              		@ sp needed
 22099 0056 30BD     		pop	{r4, r5, pc}
 22100              	.LVL2783:
 22101              	.L2348:
 22102              	.LCFI879:
 22103              		.cfi_restore_state
11211:Src/bno055.c  **** 		BNO055_OPERATION_MODE_CONFIG);
 22104              		.loc 1 11211 0
 22105 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 22106              	.LVL2784:
11213:Src/bno055.c  **** 		/* Write page as one */
 22107              		.loc 1 11213 0
 22108 005c 0028     		cmp	r0, #0
 22109 005e E0D1     		bne	.L2350
 22110 0060 EAE7     		b	.L2351
 22111              	.LVL2785:
 22112              	.L2360:
11221:Src/bno055.c  **** 				(p_bno055->dev_addr,
 22113              		.loc 1 11221 0
 22114 0062 2368     		ldr	r3, [r4]
11220:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 22115              		.loc 1 11220 0
 22116 0064 0921     		movs	r1, #9
 22117 0066 1C69     		ldr	r4, [r3, #16]
 22118 0068 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22119              	.LVL2786:
 22120 006a 0DF10602 		add	r2, sp, #6
 22121 006e 0123     		movs	r3, #1
 22122 0070 A047     		blx	r4
 22123              	.LVL2787:
11221:Src/bno055.c  **** 				(p_bno055->dev_addr,
 22124              		.loc 1 11221 0
 22125 0072 0D49     		ldr	r1, .L2361
11225:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 22126              		.loc 1 11225 0
 22127 0074 0446     		mov	r4, r0
 22128 0076 0028     		cmp	r0, #0
 22129 0078 D4D1     		bne	.L2347
11226:Src/bno055.c  **** 					(data_u8r,
 22130              		.loc 1 11226 0
 22131 007a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 22132 007e 6B01     		lsls	r3, r5, #5
11231:Src/bno055.c  **** 					(p_bno055->dev_addr,
 22133              		.loc 1 11231 0
 22134 0080 0968     		ldr	r1, [r1]
11226:Src/bno055.c  **** 					(data_u8r,
 22135              		.loc 1 11226 0
 22136 0082 22F06002 		bic	r2, r2, #96
 22137 0086 03F06003 		and	r3, r3, #96
ARM GAS  /tmp/ccVWLGiI.s 			page 631


 22138 008a 1343     		orrs	r3, r3, r2
11231:Src/bno055.c  **** 					(p_bno055->dev_addr,
 22139              		.loc 1 11231 0
 22140 008c CC68     		ldr	r4, [r1, #12]
11226:Src/bno055.c  **** 					(data_u8r,
 22141              		.loc 1 11226 0
 22142 008e 8DF80630 		strb	r3, [sp, #6]
11231:Src/bno055.c  **** 					(p_bno055->dev_addr,
 22143              		.loc 1 11231 0
 22144 0092 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 22145              	.LVL2788:
 22146 0094 0DF10602 		add	r2, sp, #6
 22147 0098 0921     		movs	r1, #9
 22148 009a 0123     		movs	r3, #1
 22149 009c A047     		blx	r4
 22150              	.LVL2789:
 22151 009e 0446     		mov	r4, r0
 22152              	.LVL2790:
 22153 00a0 C0E7     		b	.L2347
 22154              	.LVL2791:
 22155              	.L2352:
11203:Src/bno055.c  **** } else {
 22156              		.loc 1 11203 0
 22157 00a2 8120     		movs	r0, #129
 22158              	.LVL2792:
 22159 00a4 C2E7     		b	.L2345
 22160              	.L2362:
 22161 00a6 00BF     		.align	2
 22162              	.L2361:
 22163 00a8 00000000 		.word	.LANCHOR0
 22164              		.cfi_endproc
 22165              	.LFE186:
 22167              		.section	.text.bno055_get_gyro_range,"ax",%progbits
 22168              		.align	2
 22169              		.global	bno055_get_gyro_range
 22170              		.thumb
 22171              		.thumb_func
 22173              	bno055_get_gyro_range:
 22174              	.LFB187:
11257:Src/bno055.c  **** /*!
11258:Src/bno055.c  ****  *	@brief This API used to read the gyro range
11259:Src/bno055.c  ****  *	from page one register from 0x0A bit 0 to 3
11260:Src/bno055.c  ****  *
11261:Src/bno055.c  ****  *	@param gyro_range_u8 : The value of gyro range
11262:Src/bno055.c  ****  *
11263:Src/bno055.c  ****  *     gyro_range_u8 |   result
11264:Src/bno055.c  ****  * --------------------|-----------------
11265:Src/bno055.c  ****  *     0x00            | BNO055_GYRO_RANGE_2000DPS
11266:Src/bno055.c  ****  *     0x01            | BNO055_GYRO_RANGE_1000DPS
11267:Src/bno055.c  ****  *     0x02            | BNO055_GYRO_RANGE_500DPS
11268:Src/bno055.c  ****  *     0x03            | BNO055_GYRO_RANGE_250DPS
11269:Src/bno055.c  ****  *     0x04            | BNO055_GYRO_RANGE_125DPS
11270:Src/bno055.c  ****  *
11271:Src/bno055.c  ****  *	@return results of bus communication function
11272:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11273:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11274:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 632


11275:Src/bno055.c  ****  *
11276:Src/bno055.c  ****  */
11277:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_range(
11278:Src/bno055.c  **** u8 *gyro_range_u8)
11279:Src/bno055.c  **** {
 22175              		.loc 1 11279 0
 22176              		.cfi_startproc
 22177              		@ args = 0, pretend = 0, frame = 8
 22178              		@ frame_needed = 0, uses_anonymous_args = 0
 22179              	.LVL2793:
 22180 0000 30B5     		push	{r4, r5, lr}
 22181              	.LCFI880:
 22182              		.cfi_def_cfa_offset 12
 22183              		.cfi_offset 4, -12
 22184              		.cfi_offset 5, -8
 22185              		.cfi_offset 14, -4
11280:Src/bno055.c  **** 	/* Variable used to return value of
11281:Src/bno055.c  **** 	communication routine*/
11282:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11283:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
11284:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11285:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11286:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 22186              		.loc 1 11286 0
 22187 0002 144C     		ldr	r4, .L2375
11279:Src/bno055.c  **** 	/* Variable used to return value of
 22188              		.loc 1 11279 0
 22189 0004 83B0     		sub	sp, sp, #12
 22190              	.LCFI881:
 22191              		.cfi_def_cfa_offset 24
 22192              		.loc 1 11286 0
 22193 0006 2368     		ldr	r3, [r4]
11283:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 22194              		.loc 1 11283 0
 22195 0008 0022     		movs	r2, #0
 22196 000a 8DF80720 		strb	r2, [sp, #7]
 22197              	.LVL2794:
 22198              		.loc 1 11286 0
 22199 000e FBB1     		cbz	r3, .L2367
11287:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11288:Src/bno055.c  **** 		} else {
11289:Src/bno055.c  **** 		/*condition check for page, gyro range is
11290:Src/bno055.c  **** 		available in the page one*/
11291:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 22200              		.loc 1 11291 0
 22201 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22202 0012 0546     		mov	r5, r0
 22203 0014 012A     		cmp	r2, #1
 22204 0016 04D0     		beq	.L2365
11292:Src/bno055.c  **** 			/* Write page as one */
11293:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 22205              		.loc 1 11293 0
 22206 0018 0120     		movs	r0, #1
 22207              	.LVL2795:
 22208 001a FFF7FEFF 		bl	bno055_write_page_id
 22209              	.LVL2796:
 22210 001e 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 633


11294:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 22211              		.loc 1 11294 0
 22212 0020 70B9     		cbnz	r0, .L2374
 22213              	.LVL2797:
 22214              	.L2365:
11295:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11296:Src/bno055.c  **** 			/* Read the value of gyro range */
11297:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 22215              		.loc 1 11297 0
 22216 0022 1C69     		ldr	r4, [r3, #16]
 22217 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22218 0026 0A21     		movs	r1, #10
 22219 0028 0123     		movs	r3, #1
 22220 002a 0DF10702 		add	r2, sp, #7
 22221 002e A047     		blx	r4
 22222              	.LVL2798:
11298:Src/bno055.c  **** 			(p_bno055->dev_addr,
11299:Src/bno055.c  **** 			BNO055_GYRO_RANGE_REG,
11300:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11301:Src/bno055.c  **** 			*gyro_range_u8 =
 22223              		.loc 1 11301 0
 22224 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22225 0034 03F00703 		and	r3, r3, #7
 22226 0038 2B70     		strb	r3, [r5]
 22227              	.LVL2799:
 22228              	.L2364:
11302:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
11303:Src/bno055.c  **** 			BNO055_GYRO_RANGE);
11304:Src/bno055.c  **** 		} else {
11305:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11306:Src/bno055.c  **** 		}
11307:Src/bno055.c  **** 	}
11308:Src/bno055.c  **** 	return com_rslt;
11309:Src/bno055.c  **** }
 22229              		.loc 1 11309 0
 22230 003a 40B2     		sxtb	r0, r0
 22231 003c 03B0     		add	sp, sp, #12
 22232              	.LCFI882:
 22233              		.cfi_remember_state
 22234              		.cfi_def_cfa_offset 12
 22235              		@ sp needed
 22236 003e 30BD     		pop	{r4, r5, pc}
 22237              	.LVL2800:
 22238              	.L2374:
 22239              	.LCFI883:
 22240              		.cfi_restore_state
11294:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22241              		.loc 1 11294 0 discriminator 1
 22242 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22243 0042 012A     		cmp	r2, #1
11305:Src/bno055.c  **** 		}
 22244              		.loc 1 11305 0 discriminator 1
 22245 0044 18BF     		it	ne
 22246 0046 FF20     		movne	r0, #255
11294:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22247              		.loc 1 11294 0 discriminator 1
 22248 0048 EBD0     		beq	.L2365
ARM GAS  /tmp/ccVWLGiI.s 			page 634


 22249              		.loc 1 11309 0
 22250 004a 40B2     		sxtb	r0, r0
 22251 004c 03B0     		add	sp, sp, #12
 22252              	.LCFI884:
 22253              		.cfi_remember_state
 22254              		.cfi_def_cfa_offset 12
 22255              		@ sp needed
 22256 004e 30BD     		pop	{r4, r5, pc}
 22257              	.LVL2801:
 22258              	.L2367:
 22259              	.LCFI885:
 22260              		.cfi_restore_state
11287:Src/bno055.c  **** 		} else {
 22261              		.loc 1 11287 0
 22262 0050 8120     		movs	r0, #129
 22263              	.LVL2802:
 22264 0052 F2E7     		b	.L2364
 22265              	.L2376:
 22266              		.align	2
 22267              	.L2375:
 22268 0054 00000000 		.word	.LANCHOR0
 22269              		.cfi_endproc
 22270              	.LFE187:
 22272              		.section	.text.bno055_set_gyro_range,"ax",%progbits
 22273              		.align	2
 22274              		.global	bno055_set_gyro_range
 22275              		.thumb
 22276              		.thumb_func
 22278              	bno055_set_gyro_range:
 22279              	.LFB188:
11310:Src/bno055.c  **** /*!
11311:Src/bno055.c  ****  *	@brief This API used to write the gyro range
11312:Src/bno055.c  ****  *	from page one register from 0x0A bit 0 to 3
11313:Src/bno055.c  ****  *
11314:Src/bno055.c  ****  *	@param gyro_range_u8 : The value of gyro range
11315:Src/bno055.c  ****  *
11316:Src/bno055.c  ****  *     gyro_range_u8 |   result
11317:Src/bno055.c  ****  * --------------------|-----------------
11318:Src/bno055.c  ****  *     0x00            | BNO055_GYRO_RANGE_2000DPS
11319:Src/bno055.c  ****  *     0x01            | BNO055_GYRO_RANGE_1000DPS
11320:Src/bno055.c  ****  *     0x02            | BNO055_GYRO_RANGE_500DPS
11321:Src/bno055.c  ****  *     0x03            | BNO055_GYRO_RANGE_250DPS
11322:Src/bno055.c  ****  *     0x04            | BNO055_GYRO_RANGE_125DPS
11323:Src/bno055.c  ****  *
11324:Src/bno055.c  ****  *	@return results of bus communication function
11325:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11326:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11327:Src/bno055.c  ****  *
11328:Src/bno055.c  ****  *
11329:Src/bno055.c  ****  */
11330:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_range(
11331:Src/bno055.c  **** u8 gyro_range_u8)
11332:Src/bno055.c  **** {
 22280              		.loc 1 11332 0
 22281              		.cfi_startproc
 22282              		@ args = 0, pretend = 0, frame = 8
 22283              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccVWLGiI.s 			page 635


 22284              	.LVL2803:
 22285 0000 30B5     		push	{r4, r5, lr}
 22286              	.LCFI886:
 22287              		.cfi_def_cfa_offset 12
 22288              		.cfi_offset 4, -12
 22289              		.cfi_offset 5, -8
 22290              		.cfi_offset 14, -4
11333:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11334:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11335:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11336:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11337:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11338:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11339:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 22291              		.loc 1 11339 0
 22292 0002 274C     		ldr	r4, .L2394
11332:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 22293              		.loc 1 11332 0
 22294 0004 83B0     		sub	sp, sp, #12
 22295              	.LCFI887:
 22296              		.cfi_def_cfa_offset 24
 22297              		.loc 1 11339 0
 22298 0006 2268     		ldr	r2, [r4]
11334:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 22299              		.loc 1 11334 0
 22300 0008 0023     		movs	r3, #0
 22301 000a 8DF80630 		strb	r3, [sp, #6]
 22302              	.LVL2804:
11337:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 22303              		.loc 1 11337 0
 22304 000e 8DF80730 		strb	r3, [sp, #7]
 22305              		.loc 1 11339 0
 22306 0012 002A     		cmp	r2, #0
 22307 0014 42D0     		beq	.L2385
 22308 0016 0546     		mov	r5, r0
11340:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
11341:Src/bno055.c  **** } else {
11342:Src/bno055.c  **** /* The write operation effective only if the operation
11343:Src/bno055.c  **** mode is in config mode, this part of code is checking the
11344:Src/bno055.c  **** current operation mode and set the config mode */
11345:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 22309              		.loc 1 11345 0
 22310 0018 0DF10700 		add	r0, sp, #7
 22311              	.LVL2805:
 22312 001c FFF7FEFF 		bl	bno055_get_operation_mode
 22313              	.LVL2806:
11346:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 22314              		.loc 1 11346 0
 22315 0020 38B1     		cbz	r0, .L2379
 22316              	.LVL2807:
 22317              	.L2383:
11347:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11348:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
11349:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
11350:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
11351:Src/bno055.c  **** 			/* Write page as one */
11352:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
ARM GAS  /tmp/ccVWLGiI.s 			page 636


11353:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
11354:Src/bno055.c  **** 				if (gyro_range_u8 < BNO055_GYRO_RANGE) {
11355:Src/bno055.c  **** 					/* Write the value of gyro range*/
11356:Src/bno055.c  **** 					com_rslt =
11357:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
11358:Src/bno055.c  **** 					(p_bno055->dev_addr,
11359:Src/bno055.c  **** 					BNO055_GYRO_RANGE_REG,
11360:Src/bno055.c  **** 					&data_u8r,
11361:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
11362:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
11363:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
11364:Src/bno055.c  **** 						(data_u8r,
11365:Src/bno055.c  **** 						BNO055_GYRO_RANGE,
11366:Src/bno055.c  **** 						gyro_range_u8);
11367:Src/bno055.c  **** 						com_rslt +=
11368:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
11369:Src/bno055.c  **** 						(p_bno055->dev_addr,
11370:Src/bno055.c  **** 						BNO055_GYRO_RANGE_REG,
11371:Src/bno055.c  **** 						&data_u8r,
11372:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
11373:Src/bno055.c  **** 					}
11374:Src/bno055.c  **** 				} else {
11375:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
11376:Src/bno055.c  **** 				}
11377:Src/bno055.c  **** 			} else {
11378:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
11379:Src/bno055.c  **** 			}
11380:Src/bno055.c  **** 		} else {
11381:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11382:Src/bno055.c  **** 		}
11383:Src/bno055.c  **** 	} else {
11384:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 22318              		.loc 1 11384 0
 22319 0022 FF24     		movs	r4, #255
 22320              	.LVL2808:
 22321              	.L2380:
11385:Src/bno055.c  **** 	}
11386:Src/bno055.c  **** }
11387:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 22322              		.loc 1 11387 0
 22323 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 22324 0028 78B9     		cbnz	r0, .L2392
 22325 002a 2046     		mov	r0, r4
 22326              	.LVL2809:
 22327              	.L2378:
11388:Src/bno055.c  **** 	/* set the operation mode of
11389:Src/bno055.c  **** 	previous operation mode*/
11390:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
11391:Src/bno055.c  **** 	(prev_opmode_u8);
11392:Src/bno055.c  **** return com_rslt;
11393:Src/bno055.c  **** }
 22328              		.loc 1 11393 0
 22329 002c 40B2     		sxtb	r0, r0
 22330 002e 03B0     		add	sp, sp, #12
 22331              	.LCFI888:
 22332              		.cfi_remember_state
 22333              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 637


 22334              		@ sp needed
 22335 0030 30BD     		pop	{r4, r5, pc}
 22336              	.LVL2810:
 22337              	.L2379:
 22338              	.LCFI889:
 22339              		.cfi_restore_state
11347:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 22340              		.loc 1 11347 0
 22341 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22342 0036 7BB9     		cbnz	r3, .L2381
 22343              	.L2384:
 22344              	.LVL2811:
11352:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 22345              		.loc 1 11352 0
 22346 0038 0120     		movs	r0, #1
 22347 003a FFF7FEFF 		bl	bno055_write_page_id
 22348              	.LVL2812:
11353:Src/bno055.c  **** 				if (gyro_range_u8 < BNO055_GYRO_RANGE) {
 22349              		.loc 1 11353 0
 22350 003e 0028     		cmp	r0, #0
 22351 0040 EFD1     		bne	.L2383
11354:Src/bno055.c  **** 					/* Write the value of gyro range*/
 22352              		.loc 1 11354 0
 22353 0042 042D     		cmp	r5, #4
 22354 0044 0DD9     		bls	.L2393
11375:Src/bno055.c  **** 				}
 22355              		.loc 1 11375 0
 22356 0046 FE24     		movs	r4, #254
 22357 0048 ECE7     		b	.L2380
 22358              	.LVL2813:
 22359              	.L2392:
11390:Src/bno055.c  **** 	(prev_opmode_u8);
 22360              		.loc 1 11390 0
 22361 004a FFF7FEFF 		bl	bno055_set_operation_mode
 22362              	.LVL2814:
 22363 004e 2044     		add	r0, r0, r4
 22364 0050 C0B2     		uxtb	r0, r0
 22365              	.LVL2815:
 22366              		.loc 1 11393 0
 22367 0052 40B2     		sxtb	r0, r0
 22368 0054 03B0     		add	sp, sp, #12
 22369              	.LCFI890:
 22370              		.cfi_remember_state
 22371              		.cfi_def_cfa_offset 12
 22372              		@ sp needed
 22373 0056 30BD     		pop	{r4, r5, pc}
 22374              	.LVL2816:
 22375              	.L2381:
 22376              	.LCFI891:
 22377              		.cfi_restore_state
11348:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 22378              		.loc 1 11348 0
 22379 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 22380              	.LVL2817:
11350:Src/bno055.c  **** 			/* Write page as one */
 22381              		.loc 1 11350 0
 22382 005c 0028     		cmp	r0, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 638


 22383 005e E0D1     		bne	.L2383
 22384 0060 EAE7     		b	.L2384
 22385              	.LVL2818:
 22386              	.L2393:
11357:Src/bno055.c  **** 					(p_bno055->dev_addr,
 22387              		.loc 1 11357 0
 22388 0062 2368     		ldr	r3, [r4]
11356:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 22389              		.loc 1 11356 0
 22390 0064 0DF10602 		add	r2, sp, #6
 22391 0068 1C69     		ldr	r4, [r3, #16]
 22392 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22393              	.LVL2819:
 22394 006c 0A21     		movs	r1, #10
 22395 006e 0123     		movs	r3, #1
 22396 0070 A047     		blx	r4
 22397              	.LVL2820:
11357:Src/bno055.c  **** 					(p_bno055->dev_addr,
 22398              		.loc 1 11357 0
 22399 0072 0B4B     		ldr	r3, .L2394
11362:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 22400              		.loc 1 11362 0
 22401 0074 0446     		mov	r4, r0
 22402 0076 0028     		cmp	r0, #0
 22403 0078 D4D1     		bne	.L2380
11363:Src/bno055.c  **** 						(data_u8r,
 22404              		.loc 1 11363 0
 22405 007a 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 22406              	.LVL2821:
11368:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22407              		.loc 1 11368 0
 22408 007e 1B68     		ldr	r3, [r3]
11363:Src/bno055.c  **** 						(data_u8r,
 22409              		.loc 1 11363 0
 22410 0080 20F00700 		bic	r0, r0, #7
 22411 0084 2843     		orrs	r0, r0, r5
11368:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22412              		.loc 1 11368 0
 22413 0086 DC68     		ldr	r4, [r3, #12]
11363:Src/bno055.c  **** 						(data_u8r,
 22414              		.loc 1 11363 0
 22415 0088 8DF80600 		strb	r0, [sp, #6]
11368:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22416              		.loc 1 11368 0
 22417 008c 0DF10602 		add	r2, sp, #6
 22418 0090 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22419 0092 0A21     		movs	r1, #10
 22420 0094 0123     		movs	r3, #1
 22421 0096 A047     		blx	r4
 22422              	.LVL2822:
 22423 0098 0446     		mov	r4, r0
 22424              	.LVL2823:
 22425 009a C3E7     		b	.L2380
 22426              	.LVL2824:
 22427              	.L2385:
11340:Src/bno055.c  **** } else {
 22428              		.loc 1 11340 0
ARM GAS  /tmp/ccVWLGiI.s 			page 639


 22429 009c 8120     		movs	r0, #129
 22430              	.LVL2825:
 22431 009e C5E7     		b	.L2378
 22432              	.L2395:
 22433              		.align	2
 22434              	.L2394:
 22435 00a0 00000000 		.word	.LANCHOR0
 22436              		.cfi_endproc
 22437              	.LFE188:
 22439              		.section	.text.bno055_get_gyro_bw,"ax",%progbits
 22440              		.align	2
 22441              		.global	bno055_get_gyro_bw
 22442              		.thumb
 22443              		.thumb_func
 22445              	bno055_get_gyro_bw:
 22446              	.LFB189:
11394:Src/bno055.c  **** /*!
11395:Src/bno055.c  ****  *	@brief This API used to read the gyro bandwidth
11396:Src/bno055.c  ****  *	from page one register from 0x0A bit 3 to 5
11397:Src/bno055.c  ****  *
11398:Src/bno055.c  ****  *	@param gyro_bw_u8 : The value of gyro bandwidth
11399:Src/bno055.c  ****  *
11400:Src/bno055.c  ****  *     gyro_bw_u8    |   result
11401:Src/bno055.c  ****  * --------------------|-----------------
11402:Src/bno055.c  ****  *     0x00            | BNO055_GYRO_BW_523HZ
11403:Src/bno055.c  ****  *     0x01            | BNO055_GYRO_BW_230HZ
11404:Src/bno055.c  ****  *     0x02            | BNO055_GYRO_BW_116HZ
11405:Src/bno055.c  ****  *     0x03            | BNO055_GYRO_BW_47HZ
11406:Src/bno055.c  ****  *     0x04            | BNO055_GYRO_BW_23HZ
11407:Src/bno055.c  ****  *     0x05            | BNO055_GYRO_BW_12HZ
11408:Src/bno055.c  ****  *     0x06            | BNO055_GYRO_BW_64HZ
11409:Src/bno055.c  ****  *     0x07            | BNO055_GYRO_BW_32HZ
11410:Src/bno055.c  ****  *
11411:Src/bno055.c  ****  *	@return results of bus communication function
11412:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11413:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11414:Src/bno055.c  ****  *
11415:Src/bno055.c  ****  *
11416:Src/bno055.c  ****  */
11417:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_bw(
11418:Src/bno055.c  **** u8 *gyro_bw_u8)
11419:Src/bno055.c  **** {
 22447              		.loc 1 11419 0
 22448              		.cfi_startproc
 22449              		@ args = 0, pretend = 0, frame = 8
 22450              		@ frame_needed = 0, uses_anonymous_args = 0
 22451              	.LVL2826:
 22452 0000 30B5     		push	{r4, r5, lr}
 22453              	.LCFI892:
 22454              		.cfi_def_cfa_offset 12
 22455              		.cfi_offset 4, -12
 22456              		.cfi_offset 5, -8
 22457              		.cfi_offset 14, -4
11420:Src/bno055.c  **** 	/* Variable used to return value of
11421:Src/bno055.c  **** 	communication routine*/
11422:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11423:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
ARM GAS  /tmp/ccVWLGiI.s 			page 640


11424:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11425:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11426:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 22458              		.loc 1 11426 0
 22459 0002 144C     		ldr	r4, .L2408
11419:Src/bno055.c  **** 	/* Variable used to return value of
 22460              		.loc 1 11419 0
 22461 0004 83B0     		sub	sp, sp, #12
 22462              	.LCFI893:
 22463              		.cfi_def_cfa_offset 24
 22464              		.loc 1 11426 0
 22465 0006 2368     		ldr	r3, [r4]
11423:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 22466              		.loc 1 11423 0
 22467 0008 0022     		movs	r2, #0
 22468 000a 8DF80720 		strb	r2, [sp, #7]
 22469              	.LVL2827:
 22470              		.loc 1 11426 0
 22471 000e FBB1     		cbz	r3, .L2400
11427:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11428:Src/bno055.c  **** 		} else {
11429:Src/bno055.c  **** 		/*condition check for page, gyro bandwidth is
11430:Src/bno055.c  **** 		available in the page one*/
11431:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 22472              		.loc 1 11431 0
 22473 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22474 0012 0546     		mov	r5, r0
 22475 0014 012A     		cmp	r2, #1
 22476 0016 04D0     		beq	.L2398
11432:Src/bno055.c  **** 			/* Write page as one */
11433:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 22477              		.loc 1 11433 0
 22478 0018 0120     		movs	r0, #1
 22479              	.LVL2828:
 22480 001a FFF7FEFF 		bl	bno055_write_page_id
 22481              	.LVL2829:
 22482 001e 2368     		ldr	r3, [r4]
11434:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 22483              		.loc 1 11434 0
 22484 0020 70B9     		cbnz	r0, .L2407
 22485              	.LVL2830:
 22486              	.L2398:
11435:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11436:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 22487              		.loc 1 11436 0
 22488 0022 1C69     		ldr	r4, [r3, #16]
 22489 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22490 0026 0A21     		movs	r1, #10
 22491 0028 0123     		movs	r3, #1
 22492 002a 0DF10702 		add	r2, sp, #7
 22493 002e A047     		blx	r4
 22494              	.LVL2831:
11437:Src/bno055.c  **** 			(p_bno055->dev_addr,
11438:Src/bno055.c  **** 			BNO055_GYRO_BW_REG,
11439:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11440:Src/bno055.c  **** 			*gyro_bw_u8 =
11441:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 641


 22495              		.loc 1 11441 0
 22496 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22497 0034 C3F3C203 		ubfx	r3, r3, #3, #3
11440:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 22498              		.loc 1 11440 0
 22499 0038 2B70     		strb	r3, [r5]
 22500              	.LVL2832:
 22501              	.L2397:
11442:Src/bno055.c  **** 			BNO055_GYRO_BW);
11443:Src/bno055.c  **** 		} else {
11444:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11445:Src/bno055.c  **** 		}
11446:Src/bno055.c  **** 	}
11447:Src/bno055.c  **** 	return com_rslt;
11448:Src/bno055.c  **** }
 22502              		.loc 1 11448 0
 22503 003a 40B2     		sxtb	r0, r0
 22504 003c 03B0     		add	sp, sp, #12
 22505              	.LCFI894:
 22506              		.cfi_remember_state
 22507              		.cfi_def_cfa_offset 12
 22508              		@ sp needed
 22509 003e 30BD     		pop	{r4, r5, pc}
 22510              	.LVL2833:
 22511              	.L2407:
 22512              	.LCFI895:
 22513              		.cfi_restore_state
11434:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22514              		.loc 1 11434 0 discriminator 1
 22515 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22516 0042 012A     		cmp	r2, #1
11444:Src/bno055.c  **** 		}
 22517              		.loc 1 11444 0 discriminator 1
 22518 0044 18BF     		it	ne
 22519 0046 FF20     		movne	r0, #255
11434:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22520              		.loc 1 11434 0 discriminator 1
 22521 0048 EBD0     		beq	.L2398
 22522              		.loc 1 11448 0
 22523 004a 40B2     		sxtb	r0, r0
 22524 004c 03B0     		add	sp, sp, #12
 22525              	.LCFI896:
 22526              		.cfi_remember_state
 22527              		.cfi_def_cfa_offset 12
 22528              		@ sp needed
 22529 004e 30BD     		pop	{r4, r5, pc}
 22530              	.LVL2834:
 22531              	.L2400:
 22532              	.LCFI897:
 22533              		.cfi_restore_state
11427:Src/bno055.c  **** 		} else {
 22534              		.loc 1 11427 0
 22535 0050 8120     		movs	r0, #129
 22536              	.LVL2835:
 22537 0052 F2E7     		b	.L2397
 22538              	.L2409:
 22539              		.align	2
ARM GAS  /tmp/ccVWLGiI.s 			page 642


 22540              	.L2408:
 22541 0054 00000000 		.word	.LANCHOR0
 22542              		.cfi_endproc
 22543              	.LFE189:
 22545              		.section	.text.bno055_get_gyro_power_mode,"ax",%progbits
 22546              		.align	2
 22547              		.global	bno055_get_gyro_power_mode
 22548              		.thumb
 22549              		.thumb_func
 22551              	bno055_get_gyro_power_mode:
 22552              	.LFB191:
11449:Src/bno055.c  **** /*!
11450:Src/bno055.c  ****  *	@brief This API used to write the gyro bandwidth
11451:Src/bno055.c  ****  *	from page one register from 0x0A bit 3 to 5
11452:Src/bno055.c  ****  *
11453:Src/bno055.c  ****  *	@param gyro_bw_u8 : The value of gyro bandwidth
11454:Src/bno055.c  ****  *
11455:Src/bno055.c  ****  *     gyro_bw_u8    |   result
11456:Src/bno055.c  ****  * --------------------|-----------------
11457:Src/bno055.c  ****  *     0x00            | BNO055_GYRO_BW_523HZ
11458:Src/bno055.c  ****  *     0x01            | BNO055_GYRO_BW_230HZ
11459:Src/bno055.c  ****  *     0x02            | BNO055_GYRO_BW_116HZ
11460:Src/bno055.c  ****  *     0x03            | BNO055_GYRO_BW_47HZ
11461:Src/bno055.c  ****  *     0x04            | BNO055_GYRO_BW_23HZ
11462:Src/bno055.c  ****  *     0x05            | BNO055_GYRO_BW_12HZ
11463:Src/bno055.c  ****  *     0x06            | BNO055_GYRO_BW_64HZ
11464:Src/bno055.c  ****  *     0x07            | BNO055_GYRO_BW_32HZ
11465:Src/bno055.c  ****  *
11466:Src/bno055.c  ****  *	@return results of bus communication function
11467:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11468:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11469:Src/bno055.c  ****  *
11470:Src/bno055.c  ****  *
11471:Src/bno055.c  ****  */
11472:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_bw(
11473:Src/bno055.c  **** u8 gyro_bw_u8)
11474:Src/bno055.c  **** {
11475:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11476:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11477:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11478:Src/bno055.c  **** u8 gyro_opmode = BNO055_INIT_VALUE;
11479:Src/bno055.c  **** u8 gyro_auto_sleep_durn = BNO055_INIT_VALUE;
11480:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11481:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11482:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11483:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
11484:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
11485:Src/bno055.c  **** } else {
11486:Src/bno055.c  **** /* The write operation effective only if the operation
11487:Src/bno055.c  **** mode is in config mode, this part of code is checking the
11488:Src/bno055.c  **** current operation mode and set the config mode */
11489:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
11490:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
11491:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11492:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
11493:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
11494:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 643


11495:Src/bno055.c  **** 		/* Write page as one */
11496:Src/bno055.c  **** 		pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
11497:Src/bno055.c  **** 	if (pg_stat_s8 == BNO055_SUCCESS) {
11498:Src/bno055.c  **** 		/* Write the value of gyro bandwidth */
11499:Src/bno055.c  **** 		if ((gyro_bw_u8 == BNO055_INIT_VALUE ||
11500:Src/bno055.c  **** 			gyro_bw_u8 > BNO055_INIT_VALUE) &&
11501:Src/bno055.c  **** 			gyro_bw_u8 < BNO055_ACCEL_GYRO_BW_RANGE) {
11502:Src/bno055.c  **** 			switch (gyro_bw_u8) {
11503:Src/bno055.c  **** 			case BNO055_GYRO_BW_523HZ:
11504:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_523HZ;
11505:Src/bno055.c  **** 			break;
11506:Src/bno055.c  **** 			case BNO055_GYRO_BW_230HZ:
11507:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_230HZ;
11508:Src/bno055.c  **** 			break;
11509:Src/bno055.c  **** 			case BNO055_GYRO_BW_116HZ:
11510:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_116HZ;
11511:Src/bno055.c  **** 			break;
11512:Src/bno055.c  **** 			case BNO055_GYRO_BW_47HZ:
11513:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_47HZ;
11514:Src/bno055.c  **** 			break;
11515:Src/bno055.c  **** 			case BNO055_GYRO_BW_23HZ:
11516:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_23HZ;
11517:Src/bno055.c  **** 			break;
11518:Src/bno055.c  **** 			case BNO055_GYRO_BW_12HZ:
11519:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_12HZ;
11520:Src/bno055.c  **** 			break;
11521:Src/bno055.c  **** 			case BNO055_GYRO_BW_64HZ:
11522:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_64HZ;
11523:Src/bno055.c  **** 			break;
11524:Src/bno055.c  **** 			case BNO055_GYRO_BW_32HZ:
11525:Src/bno055.c  **** 			gyro_bw_u8 = BNO055_GYRO_BW_32HZ;
11526:Src/bno055.c  **** 			break;
11527:Src/bno055.c  **** 			default:
11528:Src/bno055.c  **** 			break;
11529:Src/bno055.c  **** 			}
11530:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
11531:Src/bno055.c  **** 			(p_bno055->dev_addr,
11532:Src/bno055.c  **** 			BNO055_GYRO_BW_REG,
11533:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11534:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
11535:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
11536:Src/bno055.c  **** 				(data_u8r,
11537:Src/bno055.c  **** 				BNO055_GYRO_BW,
11538:Src/bno055.c  **** 				gyro_bw_u8);
11539:Src/bno055.c  **** 				com_rslt +=
11540:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
11541:Src/bno055.c  **** 				(p_bno055->dev_addr,
11542:Src/bno055.c  **** 				BNO055_GYRO_BW_REG,
11543:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11544:Src/bno055.c  **** 			}
11545:Src/bno055.c  **** 			com_rslt = bno055_get_gyro_power_mode
11546:Src/bno055.c  **** 			(&gyro_opmode);
11547:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
11548:Src/bno055.c  **** 				if (gyro_opmode ==
11549:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_ADVANCE_POWERSAVE) {
11550:Src/bno055.c  **** 					com_rslt +=
11551:Src/bno055.c  **** 					bno055_get_gyro_auto_sleep_durn
ARM GAS  /tmp/ccVWLGiI.s 			page 644


11552:Src/bno055.c  **** 					(&gyro_auto_sleep_durn);
11553:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
11554:Src/bno055.c  **** 						com_rslt +=
11555:Src/bno055.c  **** 						bno055_gyro_set_auto_sleep_durn
11556:Src/bno055.c  **** 						(gyro_auto_sleep_durn,
11557:Src/bno055.c  **** 						gyro_bw_u8);
11558:Src/bno055.c  **** 					}
11559:Src/bno055.c  **** 				}
11560:Src/bno055.c  **** 			}
11561:Src/bno055.c  **** 		} else {
11562:Src/bno055.c  **** 		com_rslt = BNO055_OUT_OF_RANGE;
11563:Src/bno055.c  **** 		}
11564:Src/bno055.c  **** 	} else {
11565:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
11566:Src/bno055.c  **** 	}
11567:Src/bno055.c  **** } else {
11568:Src/bno055.c  **** com_rslt = BNO055_ERROR;
11569:Src/bno055.c  **** }
11570:Src/bno055.c  **** } else {
11571:Src/bno055.c  **** com_rslt = BNO055_ERROR;
11572:Src/bno055.c  **** }
11573:Src/bno055.c  **** }
11574:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11575:Src/bno055.c  **** 	/* set the operation mode of
11576:Src/bno055.c  **** 	previous operation mode*/
11577:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
11578:Src/bno055.c  **** 	(prev_opmode_u8);
11579:Src/bno055.c  **** return com_rslt;
11580:Src/bno055.c  **** }
11581:Src/bno055.c  **** /*!
11582:Src/bno055.c  ****  *	@brief This API used to read the gyro power mode
11583:Src/bno055.c  ****  *	from page one register from 0x0B bit 0 to 2
11584:Src/bno055.c  ****  *
11585:Src/bno055.c  ****  *	@param gyro_power_mode_u8 : The value of gyro power mode
11586:Src/bno055.c  ****  *
11587:Src/bno055.c  ****  *  gyro_power_mode_u8 |          result
11588:Src/bno055.c  ****  * ----------------------|----------------------------
11589:Src/bno055.c  ****  *     0x00              | GYRO_OPR_MODE_NORMAL
11590:Src/bno055.c  ****  *     0x01              | GYRO_OPR_MODE_FASTPOWERUP
11591:Src/bno055.c  ****  *     0x02              | GYRO_OPR_MODE_DEEPSUSPEND
11592:Src/bno055.c  ****  *     0x03              | GYRO_OPR_MODE_SUSPEND
11593:Src/bno055.c  ****  *     0x04              | GYRO_OPR_MODE_ADVANCE_POWERSAVE
11594:Src/bno055.c  ****  *
11595:Src/bno055.c  ****  *	@return results of bus communication function
11596:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11597:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11598:Src/bno055.c  ****  *
11599:Src/bno055.c  ****  *
11600:Src/bno055.c  ****  */
11601:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_power_mode(
11602:Src/bno055.c  **** u8 *gyro_power_mode_u8)
11603:Src/bno055.c  **** {
 22553              		.loc 1 11603 0
 22554              		.cfi_startproc
 22555              		@ args = 0, pretend = 0, frame = 8
 22556              		@ frame_needed = 0, uses_anonymous_args = 0
 22557              	.LVL2836:
ARM GAS  /tmp/ccVWLGiI.s 			page 645


 22558 0000 30B5     		push	{r4, r5, lr}
 22559              	.LCFI898:
 22560              		.cfi_def_cfa_offset 12
 22561              		.cfi_offset 4, -12
 22562              		.cfi_offset 5, -8
 22563              		.cfi_offset 14, -4
11604:Src/bno055.c  **** 	/* Variable used to return value of
11605:Src/bno055.c  **** 	communication routine*/
11606:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11607:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
11608:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11609:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11610:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 22564              		.loc 1 11610 0
 22565 0002 144C     		ldr	r4, .L2422
11603:Src/bno055.c  **** 	/* Variable used to return value of
 22566              		.loc 1 11603 0
 22567 0004 83B0     		sub	sp, sp, #12
 22568              	.LCFI899:
 22569              		.cfi_def_cfa_offset 24
 22570              		.loc 1 11610 0
 22571 0006 2368     		ldr	r3, [r4]
11607:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 22572              		.loc 1 11607 0
 22573 0008 0022     		movs	r2, #0
 22574 000a 8DF80720 		strb	r2, [sp, #7]
 22575              	.LVL2837:
 22576              		.loc 1 11610 0
 22577 000e FBB1     		cbz	r3, .L2414
11611:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11612:Src/bno055.c  **** 		} else {
11613:Src/bno055.c  **** 		/*condition check for page, gyro power mode is
11614:Src/bno055.c  **** 		available in the page one*/
11615:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 22578              		.loc 1 11615 0
 22579 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22580 0012 0546     		mov	r5, r0
 22581 0014 012A     		cmp	r2, #1
 22582 0016 04D0     		beq	.L2412
11616:Src/bno055.c  **** 			/* Write page as one */
11617:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 22583              		.loc 1 11617 0
 22584 0018 0120     		movs	r0, #1
 22585              	.LVL2838:
 22586 001a FFF7FEFF 		bl	bno055_write_page_id
 22587              	.LVL2839:
 22588 001e 2368     		ldr	r3, [r4]
11618:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 22589              		.loc 1 11618 0
 22590 0020 70B9     		cbnz	r0, .L2421
 22591              	.LVL2840:
 22592              	.L2412:
11619:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11620:Src/bno055.c  **** 			/* Write the value of gyro power mode*/
11621:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 22593              		.loc 1 11621 0
 22594 0022 1C69     		ldr	r4, [r3, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 646


 22595 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22596 0026 0B21     		movs	r1, #11
 22597 0028 0123     		movs	r3, #1
 22598 002a 0DF10702 		add	r2, sp, #7
 22599 002e A047     		blx	r4
 22600              	.LVL2841:
11622:Src/bno055.c  **** 			(p_bno055->dev_addr,
11623:Src/bno055.c  **** 			BNO055_GYRO_POWER_MODE_REG,
11624:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11625:Src/bno055.c  **** 			*gyro_power_mode_u8 =
 22601              		.loc 1 11625 0
 22602 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22603 0034 03F00703 		and	r3, r3, #7
 22604 0038 2B70     		strb	r3, [r5]
 22605              	.LVL2842:
 22606              	.L2411:
11626:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
11627:Src/bno055.c  **** 			BNO055_GYRO_POWER_MODE);
11628:Src/bno055.c  **** 		} else {
11629:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11630:Src/bno055.c  **** 		}
11631:Src/bno055.c  **** 	}
11632:Src/bno055.c  **** 	return com_rslt;
11633:Src/bno055.c  **** }
 22607              		.loc 1 11633 0
 22608 003a 40B2     		sxtb	r0, r0
 22609 003c 03B0     		add	sp, sp, #12
 22610              	.LCFI900:
 22611              		.cfi_remember_state
 22612              		.cfi_def_cfa_offset 12
 22613              		@ sp needed
 22614 003e 30BD     		pop	{r4, r5, pc}
 22615              	.LVL2843:
 22616              	.L2421:
 22617              	.LCFI901:
 22618              		.cfi_restore_state
11618:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22619              		.loc 1 11618 0 discriminator 1
 22620 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22621 0042 012A     		cmp	r2, #1
11629:Src/bno055.c  **** 		}
 22622              		.loc 1 11629 0 discriminator 1
 22623 0044 18BF     		it	ne
 22624 0046 FF20     		movne	r0, #255
11618:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22625              		.loc 1 11618 0 discriminator 1
 22626 0048 EBD0     		beq	.L2412
 22627              		.loc 1 11633 0
 22628 004a 40B2     		sxtb	r0, r0
 22629 004c 03B0     		add	sp, sp, #12
 22630              	.LCFI902:
 22631              		.cfi_remember_state
 22632              		.cfi_def_cfa_offset 12
 22633              		@ sp needed
 22634 004e 30BD     		pop	{r4, r5, pc}
 22635              	.LVL2844:
 22636              	.L2414:
ARM GAS  /tmp/ccVWLGiI.s 			page 647


 22637              	.LCFI903:
 22638              		.cfi_restore_state
11611:Src/bno055.c  **** 		} else {
 22639              		.loc 1 11611 0
 22640 0050 8120     		movs	r0, #129
 22641              	.LVL2845:
 22642 0052 F2E7     		b	.L2411
 22643              	.L2423:
 22644              		.align	2
 22645              	.L2422:
 22646 0054 00000000 		.word	.LANCHOR0
 22647              		.cfi_endproc
 22648              	.LFE191:
 22650              		.section	.text.bno055_get_accel_sleep_tmr_mode,"ax",%progbits
 22651              		.align	2
 22652              		.global	bno055_get_accel_sleep_tmr_mode
 22653              		.thumb
 22654              		.thumb_func
 22656              	bno055_get_accel_sleep_tmr_mode:
 22657              	.LFB193:
11634:Src/bno055.c  **** /*!
11635:Src/bno055.c  ****  *	@brief This API used to write the gyro power mode
11636:Src/bno055.c  ****  *	from page one register from 0x0B bit 0 to 2
11637:Src/bno055.c  ****  *
11638:Src/bno055.c  ****  *	@param gyro_power_mode_u8 : The value of gyro power mode
11639:Src/bno055.c  ****  *
11640:Src/bno055.c  ****  *  gyro_power_mode_u8 |          result
11641:Src/bno055.c  ****  * ----------------------|----------------------------
11642:Src/bno055.c  ****  *     0x00              | GYRO_OPR_MODE_NORMAL
11643:Src/bno055.c  ****  *     0x01              | GYRO_OPR_MODE_FASTPOWERUP
11644:Src/bno055.c  ****  *     0x02              | GYRO_OPR_MODE_DEEPSUSPEND
11645:Src/bno055.c  ****  *     0x03              | GYRO_OPR_MODE_SUSPEND
11646:Src/bno055.c  ****  *     0x04              | GYRO_OPR_MODE_ADVANCE_POWERSAVE
11647:Src/bno055.c  ****  *
11648:Src/bno055.c  ****  *	@return results of bus communication function
11649:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11650:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11651:Src/bno055.c  ****  *
11652:Src/bno055.c  ****  *
11653:Src/bno055.c  ****  */
11654:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_power_mode(
11655:Src/bno055.c  **** u8 gyro_power_mode_u8)
11656:Src/bno055.c  **** {
11657:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11658:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11659:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11660:Src/bno055.c  **** u8 gyro_auto_sleep_durn = BNO055_INIT_VALUE;
11661:Src/bno055.c  **** u8 gyro_bw_u8 = BNO055_INIT_VALUE;
11662:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11663:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11664:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11665:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
11666:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
11667:Src/bno055.c  **** } else {
11668:Src/bno055.c  **** /* The write operation effective only if the operation
11669:Src/bno055.c  **** mode is in config mode, this part of code is checking the
11670:Src/bno055.c  **** current operation mode and set the config mode */
ARM GAS  /tmp/ccVWLGiI.s 			page 648


11671:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
11672:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
11673:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11674:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
11675:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
11676:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
11677:Src/bno055.c  **** 		/* Write page as one */
11678:Src/bno055.c  **** 		pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
11679:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
11680:Src/bno055.c  **** 			/* Write the value of power mode*/
11681:Src/bno055.c  **** 			if ((gyro_power_mode_u8 == BNO055_INIT_VALUE ||
11682:Src/bno055.c  **** 			gyro_power_mode_u8 > BNO055_INIT_VALUE) &&
11683:Src/bno055.c  **** 			gyro_power_mode_u8 < BNO055_GYRO_RANGE) {
11684:Src/bno055.c  **** 				switch (gyro_power_mode_u8) {
11685:Src/bno055.c  **** 				case BNO055_GYRO_POWER_MODE_NORMAL:
11686:Src/bno055.c  **** 				gyro_power_mode_u8 =
11687:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_NORMAL;
11688:Src/bno055.c  **** 				break;
11689:Src/bno055.c  **** 				case BNO055_GYRO_POWER_MODE_FASTPOWERUP:
11690:Src/bno055.c  **** 				gyro_power_mode_u8 =
11691:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_FASTPOWERUP;
11692:Src/bno055.c  **** 				break;
11693:Src/bno055.c  **** 				case BNO055_GYRO_POWER_MODE_DEEPSUSPEND:
11694:Src/bno055.c  **** 				gyro_power_mode_u8 =
11695:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_DEEPSUSPEND;
11696:Src/bno055.c  **** 				break;
11697:Src/bno055.c  **** 				case BNO055_GYRO_POWER_MODE_SUSPEND:
11698:Src/bno055.c  **** 				gyro_power_mode_u8 =
11699:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_SUSPEND;
11700:Src/bno055.c  **** 				break;
11701:Src/bno055.c  **** 				case BNO055_GYRO_POWER_MODE_ADVANCE_POWERSAVE:
11702:Src/bno055.c  **** 				com_rslt = bno055_get_gyro_bw
11703:Src/bno055.c  **** 				(&gyro_bw_u8);
11704:Src/bno055.c  **** 				com_rslt += bno055_get_gyro_auto_sleep_durn
11705:Src/bno055.c  **** 				(&gyro_auto_sleep_durn);
11706:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS)
11707:Src/bno055.c  **** 					bno055_gyro_set_auto_sleep_durn
11708:Src/bno055.c  **** 					(gyro_auto_sleep_durn,
11709:Src/bno055.c  **** 					gyro_bw_u8);
11710:Src/bno055.c  **** 				com_rslt +=
11711:Src/bno055.c  **** 				bno055_write_page_id(BNO055_PAGE_ONE);
11712:Src/bno055.c  **** 				gyro_power_mode_u8 =
11713:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_ADVANCE_POWERSAVE;
11714:Src/bno055.c  **** 				break;
11715:Src/bno055.c  **** 				default:
11716:Src/bno055.c  **** 				break;
11717:Src/bno055.c  **** 				}
11718:Src/bno055.c  **** 				com_rslt =
11719:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
11720:Src/bno055.c  **** 				(p_bno055->dev_addr,
11721:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_REG,
11722:Src/bno055.c  **** 				&data_u8r,
11723:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
11724:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
11725:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
11726:Src/bno055.c  **** 					(data_u8r,
11727:Src/bno055.c  **** 					BNO055_GYRO_POWER_MODE,
ARM GAS  /tmp/ccVWLGiI.s 			page 649


11728:Src/bno055.c  **** 					gyro_power_mode_u8);
11729:Src/bno055.c  **** 					com_rslt +=
11730:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
11731:Src/bno055.c  **** 					(p_bno055->dev_addr,
11732:Src/bno055.c  **** 					BNO055_GYRO_POWER_MODE_REG,
11733:Src/bno055.c  **** 					&data_u8r,
11734:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
11735:Src/bno055.c  **** 				}
11736:Src/bno055.c  **** 			} else {
11737:Src/bno055.c  **** 			com_rslt = BNO055_OUT_OF_RANGE;
11738:Src/bno055.c  **** 			}
11739:Src/bno055.c  **** 		} else {
11740:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11741:Src/bno055.c  **** 		}
11742:Src/bno055.c  **** 	} else {
11743:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
11744:Src/bno055.c  **** 	}
11745:Src/bno055.c  **** } else {
11746:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
11747:Src/bno055.c  **** }
11748:Src/bno055.c  **** }
11749:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11750:Src/bno055.c  **** 	/* set the operation mode of
11751:Src/bno055.c  **** 	previous operation mode*/
11752:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
11753:Src/bno055.c  **** 	(prev_opmode_u8);
11754:Src/bno055.c  **** return com_rslt;
11755:Src/bno055.c  **** }
11756:Src/bno055.c  **** /*!
11757:Src/bno055.c  ****  *	@brief This API used to read the accel sleep mode
11758:Src/bno055.c  ****  *	from page one register from 0x0C bit 0
11759:Src/bno055.c  ****  *
11760:Src/bno055.c  ****  *	@param sleep_tmr_u8 : The value of accel sleep mode
11761:Src/bno055.c  ****  *
11762:Src/bno055.c  ****  *  sleep_tmr_u8   |   result
11763:Src/bno055.c  ****  * ----------------- |------------------------------------
11764:Src/bno055.c  ****  *     0x00          | enable EventDrivenSampling(EDT)
11765:Src/bno055.c  ****  *     0x01          | enable Equidistant sampling mode(EST)
11766:Src/bno055.c  ****  *
11767:Src/bno055.c  ****  *	@return results of bus communication function
11768:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11769:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11770:Src/bno055.c  ****  *
11771:Src/bno055.c  ****  *
11772:Src/bno055.c  ****  */
11773:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_sleep_tmr_mode(
11774:Src/bno055.c  **** u8 *sleep_tmr_u8)
11775:Src/bno055.c  **** {
 22658              		.loc 1 11775 0
 22659              		.cfi_startproc
 22660              		@ args = 0, pretend = 0, frame = 8
 22661              		@ frame_needed = 0, uses_anonymous_args = 0
 22662              	.LVL2846:
 22663 0000 30B5     		push	{r4, r5, lr}
 22664              	.LCFI904:
 22665              		.cfi_def_cfa_offset 12
 22666              		.cfi_offset 4, -12
ARM GAS  /tmp/ccVWLGiI.s 			page 650


 22667              		.cfi_offset 5, -8
 22668              		.cfi_offset 14, -4
11776:Src/bno055.c  **** 	/* Variable used to return value of
11777:Src/bno055.c  **** 	communication routine*/
11778:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11779:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
11780:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11781:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11782:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 22669              		.loc 1 11782 0
 22670 0002 144C     		ldr	r4, .L2436
11775:Src/bno055.c  **** 	/* Variable used to return value of
 22671              		.loc 1 11775 0
 22672 0004 83B0     		sub	sp, sp, #12
 22673              	.LCFI905:
 22674              		.cfi_def_cfa_offset 24
 22675              		.loc 1 11782 0
 22676 0006 2368     		ldr	r3, [r4]
11779:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 22677              		.loc 1 11779 0
 22678 0008 0022     		movs	r2, #0
 22679 000a 8DF80720 		strb	r2, [sp, #7]
 22680              	.LVL2847:
 22681              		.loc 1 11782 0
 22682 000e FBB1     		cbz	r3, .L2428
11783:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11784:Src/bno055.c  **** 		} else {
11785:Src/bno055.c  **** 		/*condition check for page, accel sleep mode is
11786:Src/bno055.c  **** 		available in the page one*/
11787:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 22683              		.loc 1 11787 0
 22684 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22685 0012 0546     		mov	r5, r0
 22686 0014 012A     		cmp	r2, #1
 22687 0016 04D0     		beq	.L2426
11788:Src/bno055.c  **** 			/* Write page as one */
11789:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 22688              		.loc 1 11789 0
 22689 0018 0120     		movs	r0, #1
 22690              	.LVL2848:
 22691 001a FFF7FEFF 		bl	bno055_write_page_id
 22692              	.LVL2849:
 22693 001e 2368     		ldr	r3, [r4]
11790:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 22694              		.loc 1 11790 0
 22695 0020 70B9     		cbnz	r0, .L2435
 22696              	.LVL2850:
 22697              	.L2426:
11791:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11792:Src/bno055.c  **** 			/* read the value of accel sleep mode */
11793:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 22698              		.loc 1 11793 0
 22699 0022 1C69     		ldr	r4, [r3, #16]
 22700 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22701 0026 0C21     		movs	r1, #12
 22702 0028 0123     		movs	r3, #1
 22703 002a 0DF10702 		add	r2, sp, #7
ARM GAS  /tmp/ccVWLGiI.s 			page 651


 22704 002e A047     		blx	r4
 22705              	.LVL2851:
11794:Src/bno055.c  **** 			(p_bno055->dev_addr,
11795:Src/bno055.c  **** 			BNO055_ACCEL_SLEEP_MODE_REG,
11796:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11797:Src/bno055.c  **** 			*sleep_tmr_u8 =
 22706              		.loc 1 11797 0
 22707 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22708 0034 03F00103 		and	r3, r3, #1
 22709 0038 2B70     		strb	r3, [r5]
 22710              	.LVL2852:
 22711              	.L2425:
11798:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
11799:Src/bno055.c  **** 			BNO055_ACCEL_SLEEP_MODE);
11800:Src/bno055.c  **** 		} else {
11801:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11802:Src/bno055.c  **** 		}
11803:Src/bno055.c  **** 	}
11804:Src/bno055.c  **** 	return com_rslt;
11805:Src/bno055.c  **** }
 22712              		.loc 1 11805 0
 22713 003a 40B2     		sxtb	r0, r0
 22714 003c 03B0     		add	sp, sp, #12
 22715              	.LCFI906:
 22716              		.cfi_remember_state
 22717              		.cfi_def_cfa_offset 12
 22718              		@ sp needed
 22719 003e 30BD     		pop	{r4, r5, pc}
 22720              	.LVL2853:
 22721              	.L2435:
 22722              	.LCFI907:
 22723              		.cfi_restore_state
11790:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22724              		.loc 1 11790 0 discriminator 1
 22725 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22726 0042 012A     		cmp	r2, #1
11801:Src/bno055.c  **** 		}
 22727              		.loc 1 11801 0 discriminator 1
 22728 0044 18BF     		it	ne
 22729 0046 FF20     		movne	r0, #255
11790:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22730              		.loc 1 11790 0 discriminator 1
 22731 0048 EBD0     		beq	.L2426
 22732              		.loc 1 11805 0
 22733 004a 40B2     		sxtb	r0, r0
 22734 004c 03B0     		add	sp, sp, #12
 22735              	.LCFI908:
 22736              		.cfi_remember_state
 22737              		.cfi_def_cfa_offset 12
 22738              		@ sp needed
 22739 004e 30BD     		pop	{r4, r5, pc}
 22740              	.LVL2854:
 22741              	.L2428:
 22742              	.LCFI909:
 22743              		.cfi_restore_state
11783:Src/bno055.c  **** 		} else {
 22744              		.loc 1 11783 0
ARM GAS  /tmp/ccVWLGiI.s 			page 652


 22745 0050 8120     		movs	r0, #129
 22746              	.LVL2855:
 22747 0052 F2E7     		b	.L2425
 22748              	.L2437:
 22749              		.align	2
 22750              	.L2436:
 22751 0054 00000000 		.word	.LANCHOR0
 22752              		.cfi_endproc
 22753              	.LFE193:
 22755              		.section	.text.bno055_set_accel_sleep_tmr_mode,"ax",%progbits
 22756              		.align	2
 22757              		.global	bno055_set_accel_sleep_tmr_mode
 22758              		.thumb
 22759              		.thumb_func
 22761              	bno055_set_accel_sleep_tmr_mode:
 22762              	.LFB194:
11806:Src/bno055.c  **** /*!
11807:Src/bno055.c  ****  *	@brief This API used to write the accel sleep mode
11808:Src/bno055.c  ****  *	from page one register from 0x0C bit 0
11809:Src/bno055.c  ****  *
11810:Src/bno055.c  ****  *	@param sleep_tmr_u8 : The value of accel sleep mode
11811:Src/bno055.c  ****  *
11812:Src/bno055.c  ****  *  sleep_tmr_u8   |   result
11813:Src/bno055.c  ****  * ----------------- |------------------------------------
11814:Src/bno055.c  ****  *     0x00          | enable EventDrivenSampling(EDT)
11815:Src/bno055.c  ****  *     0x01          | enable Equidistant sampling mode(EST)
11816:Src/bno055.c  ****  *
11817:Src/bno055.c  ****  *	@return results of bus communication function
11818:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11819:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11820:Src/bno055.c  ****  *
11821:Src/bno055.c  ****  *
11822:Src/bno055.c  ****  */
11823:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_sleep_tmr_mode(
11824:Src/bno055.c  **** u8 sleep_tmr_u8)
11825:Src/bno055.c  **** {
 22763              		.loc 1 11825 0
 22764              		.cfi_startproc
 22765              		@ args = 0, pretend = 0, frame = 8
 22766              		@ frame_needed = 0, uses_anonymous_args = 0
 22767              	.LVL2856:
 22768 0000 30B5     		push	{r4, r5, lr}
 22769              	.LCFI910:
 22770              		.cfi_def_cfa_offset 12
 22771              		.cfi_offset 4, -12
 22772              		.cfi_offset 5, -8
 22773              		.cfi_offset 14, -4
11826:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11827:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11828:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11829:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11830:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11831:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11832:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 22774              		.loc 1 11832 0
 22775 0002 274C     		ldr	r4, .L2455
11825:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 653


 22776              		.loc 1 11825 0
 22777 0004 83B0     		sub	sp, sp, #12
 22778              	.LCFI911:
 22779              		.cfi_def_cfa_offset 24
 22780              		.loc 1 11832 0
 22781 0006 2268     		ldr	r2, [r4]
11827:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 22782              		.loc 1 11827 0
 22783 0008 0023     		movs	r3, #0
 22784 000a 8DF80630 		strb	r3, [sp, #6]
 22785              	.LVL2857:
11829:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 22786              		.loc 1 11829 0
 22787 000e 8DF80730 		strb	r3, [sp, #7]
 22788              	.LVL2858:
 22789              		.loc 1 11832 0
 22790 0012 2AB3     		cbz	r2, .L2446
 22791 0014 0546     		mov	r5, r0
11833:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
11834:Src/bno055.c  **** } else {
11835:Src/bno055.c  **** 	/* The write operation effective only if the operation
11836:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
11837:Src/bno055.c  **** 	current operation mode and set the config mode */
11838:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 22792              		.loc 1 11838 0
 22793 0016 0DF10700 		add	r0, sp, #7
 22794              	.LVL2859:
 22795 001a FFF7FEFF 		bl	bno055_get_operation_mode
 22796              	.LVL2860:
11839:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 22797              		.loc 1 11839 0
 22798 001e 38B1     		cbz	r0, .L2440
 22799              	.LVL2861:
 22800              	.L2444:
11840:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11841:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
11842:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
11843:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
11844:Src/bno055.c  **** 				/* Write page as one */
11845:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
11846:Src/bno055.c  **** 					BNO055_PAGE_ONE);
11847:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
11848:Src/bno055.c  **** 					if (sleep_tmr_u8 <
11849:Src/bno055.c  **** 					BNO055_ACCEL_SLEEP_MODE_RANGE) {
11850:Src/bno055.c  **** 						/*Write the value
11851:Src/bno055.c  **** 						of accel sleep mode*/
11852:Src/bno055.c  **** 						com_rslt =
11853:Src/bno055.c  **** 						p_bno055->BNO055_BUS_READ_FUNC
11854:Src/bno055.c  **** 						(p_bno055->dev_addr,
11855:Src/bno055.c  **** 						BNO055_ACCEL_SLEEP_MODE_REG,
11856:Src/bno055.c  **** 						&data_u8r,
11857:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
11858:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
11859:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
11860:Src/bno055.c  **** 						(data_u8r,
11861:Src/bno055.c  **** 						BNO055_ACCEL_SLEEP_MODE,
11862:Src/bno055.c  **** 						sleep_tmr_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 654


11863:Src/bno055.c  **** 						com_rslt +=
11864:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
11865:Src/bno055.c  **** 						(p_bno055->dev_addr,
11866:Src/bno055.c  **** 						BNO055_ACCEL_SLEEP_MODE_REG,
11867:Src/bno055.c  **** 						&data_u8r,
11868:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
11869:Src/bno055.c  **** 					}
11870:Src/bno055.c  **** 					} else {
11871:Src/bno055.c  **** 					com_rslt = BNO055_OUT_OF_RANGE;
11872:Src/bno055.c  **** 					}
11873:Src/bno055.c  **** 				} else {
11874:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
11875:Src/bno055.c  **** 				}
11876:Src/bno055.c  **** 			} else {
11877:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
11878:Src/bno055.c  **** 			}
11879:Src/bno055.c  **** 		} else {
11880:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 22801              		.loc 1 11880 0
 22802 0020 FF24     		movs	r4, #255
 22803              	.LVL2862:
 22804              	.L2441:
11881:Src/bno055.c  **** 		}
11882:Src/bno055.c  **** }
11883:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 22805              		.loc 1 11883 0
 22806 0022 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 22807 0026 78B9     		cbnz	r0, .L2453
 22808 0028 2046     		mov	r0, r4
 22809              	.LVL2863:
 22810              	.L2439:
11884:Src/bno055.c  **** 	/* set the operation mode of
11885:Src/bno055.c  **** 	previous operation mode*/
11886:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
11887:Src/bno055.c  **** 	(prev_opmode_u8);
11888:Src/bno055.c  **** return com_rslt;
11889:Src/bno055.c  **** }
 22811              		.loc 1 11889 0
 22812 002a 40B2     		sxtb	r0, r0
 22813 002c 03B0     		add	sp, sp, #12
 22814              	.LCFI912:
 22815              		.cfi_remember_state
 22816              		.cfi_def_cfa_offset 12
 22817              		@ sp needed
 22818 002e 30BD     		pop	{r4, r5, pc}
 22819              	.LVL2864:
 22820              	.L2440:
 22821              	.LCFI913:
 22822              		.cfi_restore_state
11840:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 22823              		.loc 1 11840 0
 22824 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22825 0034 7BB9     		cbnz	r3, .L2442
 22826              	.L2445:
 22827              	.LVL2865:
11845:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 22828              		.loc 1 11845 0
ARM GAS  /tmp/ccVWLGiI.s 			page 655


 22829 0036 0120     		movs	r0, #1
 22830 0038 FFF7FEFF 		bl	bno055_write_page_id
 22831              	.LVL2866:
11847:Src/bno055.c  **** 					if (sleep_tmr_u8 <
 22832              		.loc 1 11847 0
 22833 003c 0028     		cmp	r0, #0
 22834 003e EFD1     		bne	.L2444
11848:Src/bno055.c  **** 					BNO055_ACCEL_SLEEP_MODE_RANGE) {
 22835              		.loc 1 11848 0
 22836 0040 012D     		cmp	r5, #1
 22837 0042 0FD9     		bls	.L2454
11871:Src/bno055.c  **** 					}
 22838              		.loc 1 11871 0
 22839 0044 FE24     		movs	r4, #254
 22840 0046 ECE7     		b	.L2441
 22841              	.LVL2867:
 22842              	.L2453:
11886:Src/bno055.c  **** 	(prev_opmode_u8);
 22843              		.loc 1 11886 0
 22844 0048 FFF7FEFF 		bl	bno055_set_operation_mode
 22845              	.LVL2868:
 22846 004c 2044     		add	r0, r0, r4
 22847 004e C0B2     		uxtb	r0, r0
 22848              	.LVL2869:
 22849              		.loc 1 11889 0
 22850 0050 40B2     		sxtb	r0, r0
 22851 0052 03B0     		add	sp, sp, #12
 22852              	.LCFI914:
 22853              		.cfi_remember_state
 22854              		.cfi_def_cfa_offset 12
 22855              		@ sp needed
 22856 0054 30BD     		pop	{r4, r5, pc}
 22857              	.LVL2870:
 22858              	.L2442:
 22859              	.LCFI915:
 22860              		.cfi_restore_state
11841:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 22861              		.loc 1 11841 0
 22862 0056 FFF7FEFF 		bl	bno055_set_operation_mode
 22863              	.LVL2871:
11843:Src/bno055.c  **** 				/* Write page as one */
 22864              		.loc 1 11843 0
 22865 005a 0028     		cmp	r0, #0
 22866 005c E0D1     		bne	.L2444
 22867 005e EAE7     		b	.L2445
 22868              	.LVL2872:
 22869              	.L2446:
11833:Src/bno055.c  **** } else {
 22870              		.loc 1 11833 0
 22871 0060 8120     		movs	r0, #129
 22872              	.LVL2873:
 22873 0062 E2E7     		b	.L2439
 22874              	.LVL2874:
 22875              	.L2454:
11853:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22876              		.loc 1 11853 0
 22877 0064 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 656


11852:Src/bno055.c  **** 						p_bno055->BNO055_BUS_READ_FUNC
 22878              		.loc 1 11852 0
 22879 0066 0DF10602 		add	r2, sp, #6
 22880 006a 1C69     		ldr	r4, [r3, #16]
 22881 006c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22882              	.LVL2875:
 22883 006e 0C21     		movs	r1, #12
 22884 0070 0123     		movs	r3, #1
 22885 0072 A047     		blx	r4
 22886              	.LVL2876:
11853:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22887              		.loc 1 11853 0
 22888 0074 0A4B     		ldr	r3, .L2455
11858:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 22889              		.loc 1 11858 0
 22890 0076 0446     		mov	r4, r0
 22891 0078 0028     		cmp	r0, #0
 22892 007a D2D1     		bne	.L2441
11859:Src/bno055.c  **** 						(data_u8r,
 22893              		.loc 1 11859 0
 22894 007c 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 22895              	.LVL2877:
11864:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22896              		.loc 1 11864 0
 22897 0080 1B68     		ldr	r3, [r3]
11859:Src/bno055.c  **** 						(data_u8r,
 22898              		.loc 1 11859 0
 22899 0082 20F00100 		bic	r0, r0, #1
 22900 0086 2843     		orrs	r0, r0, r5
11864:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22901              		.loc 1 11864 0
 22902 0088 DC68     		ldr	r4, [r3, #12]
11859:Src/bno055.c  **** 						(data_u8r,
 22903              		.loc 1 11859 0
 22904 008a 8DF80600 		strb	r0, [sp, #6]
11864:Src/bno055.c  **** 						(p_bno055->dev_addr,
 22905              		.loc 1 11864 0
 22906 008e 0DF10602 		add	r2, sp, #6
 22907 0092 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22908 0094 0C21     		movs	r1, #12
 22909 0096 0123     		movs	r3, #1
 22910 0098 A047     		blx	r4
 22911              	.LVL2878:
 22912 009a 0446     		mov	r4, r0
 22913              	.LVL2879:
 22914 009c C1E7     		b	.L2441
 22915              	.L2456:
 22916 009e 00BF     		.align	2
 22917              	.L2455:
 22918 00a0 00000000 		.word	.LANCHOR0
 22919              		.cfi_endproc
 22920              	.LFE194:
 22922              		.section	.text.bno055_get_accel_sleep_durn,"ax",%progbits
 22923              		.align	2
 22924              		.global	bno055_get_accel_sleep_durn
 22925              		.thumb
 22926              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 657


 22928              	bno055_get_accel_sleep_durn:
 22929              	.LFB195:
11890:Src/bno055.c  **** /*!
11891:Src/bno055.c  ****  *	@brief This API used to read the accel sleep duration
11892:Src/bno055.c  ****  *	from page one register from 0x0C bit 1 to 4
11893:Src/bno055.c  ****  *
11894:Src/bno055.c  ****  *	@param sleep_durn_u8 : The value of accel sleep duration
11895:Src/bno055.c  ****  *
11896:Src/bno055.c  ****  * sleep_durn_u8  |      result
11897:Src/bno055.c  ****  * ---------------- |-----------------------------
11898:Src/bno055.c  ****  *     0x05         | BNO055_ACCEL_SLEEP_DURN_0_5MS
11899:Src/bno055.c  ****  *     0x06         | BNO055_ACCEL_SLEEP_DURN_1MS
11900:Src/bno055.c  ****  *     0x07         | BNO055_ACCEL_SLEEP_DURN_2MS
11901:Src/bno055.c  ****  *     0x08         | BNO055_ACCEL_SLEEP_DURN_4MS
11902:Src/bno055.c  ****  *     0x09         | BNO055_ACCEL_SLEEP_DURN_6MS
11903:Src/bno055.c  ****  *     0x0A         | BNO055_ACCEL_SLEEP_DURN_10MS
11904:Src/bno055.c  ****  *     0x0B         | BNO055_ACCEL_SLEEP_DURN_25MS
11905:Src/bno055.c  ****  *     0x0C         | BNO055_ACCEL_SLEEP_DURN_50MS
11906:Src/bno055.c  ****  *     0x0D         | BNO055_ACCEL_SLEEP_DURN_100MS
11907:Src/bno055.c  ****  *     0x0E         | BNO055_ACCEL_SLEEP_DURN_500MS
11908:Src/bno055.c  ****  *     0x0F         | BNO055_ACCEL_SLEEP_DURN_1S
11909:Src/bno055.c  ****  *
11910:Src/bno055.c  ****  *	@return results of bus communication function
11911:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11912:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11913:Src/bno055.c  ****  *
11914:Src/bno055.c  ****  *
11915:Src/bno055.c  ****  */
11916:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_sleep_durn(
11917:Src/bno055.c  **** u8 *sleep_durn_u8)
11918:Src/bno055.c  **** {
 22930              		.loc 1 11918 0
 22931              		.cfi_startproc
 22932              		@ args = 0, pretend = 0, frame = 8
 22933              		@ frame_needed = 0, uses_anonymous_args = 0
 22934              	.LVL2880:
 22935 0000 30B5     		push	{r4, r5, lr}
 22936              	.LCFI916:
 22937              		.cfi_def_cfa_offset 12
 22938              		.cfi_offset 4, -12
 22939              		.cfi_offset 5, -8
 22940              		.cfi_offset 14, -4
11919:Src/bno055.c  **** 	/* Variable used to return value of
11920:Src/bno055.c  **** 	communication routine*/
11921:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11922:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
11923:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
11924:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
11925:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 22941              		.loc 1 11925 0
 22942 0002 144C     		ldr	r4, .L2469
11918:Src/bno055.c  **** 	/* Variable used to return value of
 22943              		.loc 1 11918 0
 22944 0004 83B0     		sub	sp, sp, #12
 22945              	.LCFI917:
 22946              		.cfi_def_cfa_offset 24
 22947              		.loc 1 11925 0
ARM GAS  /tmp/ccVWLGiI.s 			page 658


 22948 0006 2368     		ldr	r3, [r4]
11922:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 22949              		.loc 1 11922 0
 22950 0008 0022     		movs	r2, #0
 22951 000a 8DF80720 		strb	r2, [sp, #7]
 22952              	.LVL2881:
 22953              		.loc 1 11925 0
 22954 000e FBB1     		cbz	r3, .L2461
11926:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
11927:Src/bno055.c  **** 		} else {
11928:Src/bno055.c  **** 		/*condition check for page, accel sleep duration
11929:Src/bno055.c  **** 		available in the page one*/
11930:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 22955              		.loc 1 11930 0
 22956 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22957 0012 0546     		mov	r5, r0
 22958 0014 012A     		cmp	r2, #1
 22959 0016 04D0     		beq	.L2459
11931:Src/bno055.c  **** 			/* Write page as one */
11932:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 22960              		.loc 1 11932 0
 22961 0018 0120     		movs	r0, #1
 22962              	.LVL2882:
 22963 001a FFF7FEFF 		bl	bno055_write_page_id
 22964              	.LVL2883:
 22965 001e 2368     		ldr	r3, [r4]
11933:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 22966              		.loc 1 11933 0
 22967 0020 70B9     		cbnz	r0, .L2468
 22968              	.LVL2884:
 22969              	.L2459:
11934:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
11935:Src/bno055.c  **** 			/* Read the value of accel sleep duration */
11936:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 22970              		.loc 1 11936 0
 22971 0022 1C69     		ldr	r4, [r3, #16]
 22972 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 22973 0026 0C21     		movs	r1, #12
 22974 0028 0123     		movs	r3, #1
 22975 002a 0DF10702 		add	r2, sp, #7
 22976 002e A047     		blx	r4
 22977              	.LVL2885:
11937:Src/bno055.c  **** 			(p_bno055->dev_addr,
11938:Src/bno055.c  **** 			BNO055_ACCEL_SLEEP_DURN_REG,
11939:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
11940:Src/bno055.c  **** 			*sleep_durn_u8 =
11941:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 22978              		.loc 1 11941 0
 22979 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 22980 0034 C3F34303 		ubfx	r3, r3, #1, #4
11940:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 22981              		.loc 1 11940 0
 22982 0038 2B70     		strb	r3, [r5]
 22983              	.LVL2886:
 22984              	.L2458:
11942:Src/bno055.c  **** 			BNO055_ACCEL_SLEEP_DURN);
11943:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 659


11944:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
11945:Src/bno055.c  **** 		}
11946:Src/bno055.c  **** 	}
11947:Src/bno055.c  **** 	return com_rslt;
11948:Src/bno055.c  **** }
 22985              		.loc 1 11948 0
 22986 003a 40B2     		sxtb	r0, r0
 22987 003c 03B0     		add	sp, sp, #12
 22988              	.LCFI918:
 22989              		.cfi_remember_state
 22990              		.cfi_def_cfa_offset 12
 22991              		@ sp needed
 22992 003e 30BD     		pop	{r4, r5, pc}
 22993              	.LVL2887:
 22994              	.L2468:
 22995              	.LCFI919:
 22996              		.cfi_restore_state
11933:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 22997              		.loc 1 11933 0 discriminator 1
 22998 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 22999 0042 012A     		cmp	r2, #1
11944:Src/bno055.c  **** 		}
 23000              		.loc 1 11944 0 discriminator 1
 23001 0044 18BF     		it	ne
 23002 0046 FF20     		movne	r0, #255
11933:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 23003              		.loc 1 11933 0 discriminator 1
 23004 0048 EBD0     		beq	.L2459
 23005              		.loc 1 11948 0
 23006 004a 40B2     		sxtb	r0, r0
 23007 004c 03B0     		add	sp, sp, #12
 23008              	.LCFI920:
 23009              		.cfi_remember_state
 23010              		.cfi_def_cfa_offset 12
 23011              		@ sp needed
 23012 004e 30BD     		pop	{r4, r5, pc}
 23013              	.LVL2888:
 23014              	.L2461:
 23015              	.LCFI921:
 23016              		.cfi_restore_state
11926:Src/bno055.c  **** 		} else {
 23017              		.loc 1 11926 0
 23018 0050 8120     		movs	r0, #129
 23019              	.LVL2889:
 23020 0052 F2E7     		b	.L2458
 23021              	.L2470:
 23022              		.align	2
 23023              	.L2469:
 23024 0054 00000000 		.word	.LANCHOR0
 23025              		.cfi_endproc
 23026              	.LFE195:
 23028              		.section	.text.bno055_set_accel_sleep_durn,"ax",%progbits
 23029              		.align	2
 23030              		.global	bno055_set_accel_sleep_durn
 23031              		.thumb
 23032              		.thumb_func
 23034              	bno055_set_accel_sleep_durn:
ARM GAS  /tmp/ccVWLGiI.s 			page 660


 23035              	.LFB196:
11949:Src/bno055.c  **** /*!
11950:Src/bno055.c  ****  *	@brief This API used to write the accel sleep duration
11951:Src/bno055.c  ****  *	from page one register from 0x0C bit 1 to 4
11952:Src/bno055.c  ****  *
11953:Src/bno055.c  ****  *	@param sleep_durn_u8 : The value of accel sleep duration
11954:Src/bno055.c  ****  *
11955:Src/bno055.c  ****  * sleep_durn_u8  |      result
11956:Src/bno055.c  ****  * ---------------|-----------------------------
11957:Src/bno055.c  ****  *     0x05       | BNO055_ACCEL_SLEEP_DURN_0_5MS
11958:Src/bno055.c  ****  *     0x06       | BNO055_ACCEL_SLEEP_DURN_1MS
11959:Src/bno055.c  ****  *     0x07       | BNO055_ACCEL_SLEEP_DURN_2MS
11960:Src/bno055.c  ****  *     0x08       | BNO055_ACCEL_SLEEP_DURN_4MS
11961:Src/bno055.c  ****  *     0x09       | BNO055_ACCEL_SLEEP_DURN_6MS
11962:Src/bno055.c  ****  *     0x0A       | BNO055_ACCEL_SLEEP_DURN_10MS
11963:Src/bno055.c  ****  *     0x0B       | BNO055_ACCEL_SLEEP_DURN_25MS
11964:Src/bno055.c  ****  *     0x0C       | BNO055_ACCEL_SLEEP_DURN_50MS
11965:Src/bno055.c  ****  *     0x0D       | BNO055_ACCEL_SLEEP_DURN_100MS
11966:Src/bno055.c  ****  *     0x0E       | BNO055_ACCEL_SLEEP_DURN_500MS
11967:Src/bno055.c  ****  *     0x0F       | BNO055_ACCEL_SLEEP_DURN_1S
11968:Src/bno055.c  ****  *
11969:Src/bno055.c  ****  *	@return results of bus communication function
11970:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
11971:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
11972:Src/bno055.c  ****  *
11973:Src/bno055.c  ****  *
11974:Src/bno055.c  ****  */
11975:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_sleep_durn(
11976:Src/bno055.c  **** u8 sleep_durn_u8)
11977:Src/bno055.c  **** {
 23036              		.loc 1 11977 0
 23037              		.cfi_startproc
 23038              		@ args = 0, pretend = 0, frame = 8
 23039              		@ frame_needed = 0, uses_anonymous_args = 0
 23040              	.LVL2890:
 23041 0000 30B5     		push	{r4, r5, lr}
 23042              	.LCFI922:
 23043              		.cfi_def_cfa_offset 12
 23044              		.cfi_offset 4, -12
 23045              		.cfi_offset 5, -8
 23046              		.cfi_offset 14, -4
11978:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
11979:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
11980:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
11981:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
11982:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
11983:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
11984:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 23047              		.loc 1 11984 0
 23048 0002 294C     		ldr	r4, .L2488
11977:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 23049              		.loc 1 11977 0
 23050 0004 83B0     		sub	sp, sp, #12
 23051              	.LCFI923:
 23052              		.cfi_def_cfa_offset 24
 23053              		.loc 1 11984 0
 23054 0006 2268     		ldr	r2, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 661


11979:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 23055              		.loc 1 11979 0
 23056 0008 0023     		movs	r3, #0
 23057 000a 8DF80630 		strb	r3, [sp, #6]
 23058              	.LVL2891:
11981:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 23059              		.loc 1 11981 0
 23060 000e 8DF80730 		strb	r3, [sp, #7]
 23061              	.LVL2892:
 23062              		.loc 1 11984 0
 23063 0012 002A     		cmp	r2, #0
 23064 0014 45D0     		beq	.L2479
 23065 0016 0546     		mov	r5, r0
11985:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
11986:Src/bno055.c  **** } else {
11987:Src/bno055.c  **** 	/* The write operation effective only if the operation
11988:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
11989:Src/bno055.c  **** 	current operation mode and set the config mode */
11990:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 23066              		.loc 1 11990 0
 23067 0018 0DF10700 		add	r0, sp, #7
 23068              	.LVL2893:
 23069 001c FFF7FEFF 		bl	bno055_get_operation_mode
 23070              	.LVL2894:
11991:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 23071              		.loc 1 11991 0
 23072 0020 38B1     		cbz	r0, .L2473
 23073              	.LVL2895:
 23074              	.L2477:
11992:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
11993:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
11994:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
11995:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
11996:Src/bno055.c  **** 				/* Write page as one */
11997:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
11998:Src/bno055.c  **** 					BNO055_PAGE_ONE);
11999:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
12000:Src/bno055.c  **** 					if (sleep_durn_u8 <
12001:Src/bno055.c  **** 					BNO055_ACCEL_SLEEP_DURATION_RANGE) {
12002:Src/bno055.c  **** 						/* Write the accel
12003:Src/bno055.c  **** 						sleep duration*/
12004:Src/bno055.c  **** 						com_rslt =
12005:Src/bno055.c  **** 						p_bno055->BNO055_BUS_READ_FUNC
12006:Src/bno055.c  **** 						(p_bno055->dev_addr,
12007:Src/bno055.c  **** 						BNO055_ACCEL_SLEEP_DURN_REG,
12008:Src/bno055.c  **** 						&data_u8r,
12009:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
12010:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
12011:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
12012:Src/bno055.c  **** 						(data_u8r,
12013:Src/bno055.c  **** 						BNO055_ACCEL_SLEEP_DURN,
12014:Src/bno055.c  **** 						sleep_durn_u8);
12015:Src/bno055.c  **** 						com_rslt +=
12016:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
12017:Src/bno055.c  **** 						(p_bno055->dev_addr,
12018:Src/bno055.c  **** 						BNO055_ACCEL_SLEEP_DURN_REG,
12019:Src/bno055.c  **** 						&data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 662


12020:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
12021:Src/bno055.c  **** 					}
12022:Src/bno055.c  **** 					} else {
12023:Src/bno055.c  **** 					com_rslt = BNO055_OUT_OF_RANGE;
12024:Src/bno055.c  **** 					}
12025:Src/bno055.c  **** 				} else {
12026:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
12027:Src/bno055.c  **** 				}
12028:Src/bno055.c  **** 			} else {
12029:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
12030:Src/bno055.c  **** 			}
12031:Src/bno055.c  **** 		} else {
12032:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 23075              		.loc 1 12032 0
 23076 0022 FF24     		movs	r4, #255
 23077              	.LVL2896:
 23078              	.L2474:
12033:Src/bno055.c  **** 		}
12034:Src/bno055.c  **** 	}
12035:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 23079              		.loc 1 12035 0
 23080 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 23081 0028 78B9     		cbnz	r0, .L2486
 23082 002a 2046     		mov	r0, r4
 23083              	.LVL2897:
 23084              	.L2472:
12036:Src/bno055.c  **** 		/* set the operation mode of
12037:Src/bno055.c  **** 		previous operation mode*/
12038:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
12039:Src/bno055.c  **** 		(prev_opmode_u8);
12040:Src/bno055.c  **** 	return com_rslt;
12041:Src/bno055.c  **** }
 23085              		.loc 1 12041 0
 23086 002c 40B2     		sxtb	r0, r0
 23087 002e 03B0     		add	sp, sp, #12
 23088              	.LCFI924:
 23089              		.cfi_remember_state
 23090              		.cfi_def_cfa_offset 12
 23091              		@ sp needed
 23092 0030 30BD     		pop	{r4, r5, pc}
 23093              	.LVL2898:
 23094              	.L2473:
 23095              	.LCFI925:
 23096              		.cfi_restore_state
11992:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 23097              		.loc 1 11992 0
 23098 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 23099 0036 7BB9     		cbnz	r3, .L2475
 23100              	.L2478:
 23101              	.LVL2899:
11997:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 23102              		.loc 1 11997 0
 23103 0038 0120     		movs	r0, #1
 23104 003a FFF7FEFF 		bl	bno055_write_page_id
 23105              	.LVL2900:
11999:Src/bno055.c  **** 					if (sleep_durn_u8 <
 23106              		.loc 1 11999 0
ARM GAS  /tmp/ccVWLGiI.s 			page 663


 23107 003e 0028     		cmp	r0, #0
 23108 0040 EFD1     		bne	.L2477
12000:Src/bno055.c  **** 					BNO055_ACCEL_SLEEP_DURATION_RANGE) {
 23109              		.loc 1 12000 0
 23110 0042 0F2D     		cmp	r5, #15
 23111 0044 0DD9     		bls	.L2487
12023:Src/bno055.c  **** 					}
 23112              		.loc 1 12023 0
 23113 0046 FE24     		movs	r4, #254
 23114 0048 ECE7     		b	.L2474
 23115              	.LVL2901:
 23116              	.L2486:
12038:Src/bno055.c  **** 		(prev_opmode_u8);
 23117              		.loc 1 12038 0
 23118 004a FFF7FEFF 		bl	bno055_set_operation_mode
 23119              	.LVL2902:
 23120 004e 2044     		add	r0, r0, r4
 23121 0050 C0B2     		uxtb	r0, r0
 23122              	.LVL2903:
 23123              		.loc 1 12041 0
 23124 0052 40B2     		sxtb	r0, r0
 23125 0054 03B0     		add	sp, sp, #12
 23126              	.LCFI926:
 23127              		.cfi_remember_state
 23128              		.cfi_def_cfa_offset 12
 23129              		@ sp needed
 23130 0056 30BD     		pop	{r4, r5, pc}
 23131              	.LVL2904:
 23132              	.L2475:
 23133              	.LCFI927:
 23134              		.cfi_restore_state
11993:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 23135              		.loc 1 11993 0
 23136 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 23137              	.LVL2905:
11995:Src/bno055.c  **** 				/* Write page as one */
 23138              		.loc 1 11995 0
 23139 005c 0028     		cmp	r0, #0
 23140 005e E0D1     		bne	.L2477
 23141 0060 EAE7     		b	.L2478
 23142              	.LVL2906:
 23143              	.L2487:
12005:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23144              		.loc 1 12005 0
 23145 0062 2368     		ldr	r3, [r4]
12004:Src/bno055.c  **** 						p_bno055->BNO055_BUS_READ_FUNC
 23146              		.loc 1 12004 0
 23147 0064 0C21     		movs	r1, #12
 23148 0066 1C69     		ldr	r4, [r3, #16]
 23149 0068 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23150              	.LVL2907:
 23151 006a 0DF10602 		add	r2, sp, #6
 23152 006e 0123     		movs	r3, #1
 23153 0070 A047     		blx	r4
 23154              	.LVL2908:
12005:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23155              		.loc 1 12005 0
ARM GAS  /tmp/ccVWLGiI.s 			page 664


 23156 0072 0D49     		ldr	r1, .L2488
12010:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
 23157              		.loc 1 12010 0
 23158 0074 0446     		mov	r4, r0
 23159 0076 0028     		cmp	r0, #0
 23160 0078 D4D1     		bne	.L2474
12011:Src/bno055.c  **** 						(data_u8r,
 23161              		.loc 1 12011 0
 23162 007a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 23163 007e 6B00     		lsls	r3, r5, #1
12016:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23164              		.loc 1 12016 0
 23165 0080 0968     		ldr	r1, [r1]
12011:Src/bno055.c  **** 						(data_u8r,
 23166              		.loc 1 12011 0
 23167 0082 22F01E02 		bic	r2, r2, #30
 23168 0086 03F01E03 		and	r3, r3, #30
 23169 008a 1343     		orrs	r3, r3, r2
12016:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23170              		.loc 1 12016 0
 23171 008c CC68     		ldr	r4, [r1, #12]
12011:Src/bno055.c  **** 						(data_u8r,
 23172              		.loc 1 12011 0
 23173 008e 8DF80630 		strb	r3, [sp, #6]
12016:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23174              		.loc 1 12016 0
 23175 0092 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 23176              	.LVL2909:
 23177 0094 0DF10602 		add	r2, sp, #6
 23178 0098 0C21     		movs	r1, #12
 23179 009a 0123     		movs	r3, #1
 23180 009c A047     		blx	r4
 23181              	.LVL2910:
 23182 009e 0446     		mov	r4, r0
 23183              	.LVL2911:
 23184 00a0 C0E7     		b	.L2474
 23185              	.LVL2912:
 23186              	.L2479:
11985:Src/bno055.c  **** } else {
 23187              		.loc 1 11985 0
 23188 00a2 8120     		movs	r0, #129
 23189              	.LVL2913:
 23190 00a4 C2E7     		b	.L2472
 23191              	.L2489:
 23192 00a6 00BF     		.align	2
 23193              	.L2488:
 23194 00a8 00000000 		.word	.LANCHOR0
 23195              		.cfi_endproc
 23196              	.LFE196:
 23198              		.section	.text.bno055_get_gyro_sleep_durn,"ax",%progbits
 23199              		.align	2
 23200              		.global	bno055_get_gyro_sleep_durn
 23201              		.thumb
 23202              		.thumb_func
 23204              	bno055_get_gyro_sleep_durn:
 23205              	.LFB197:
12042:Src/bno055.c  **** /*!
ARM GAS  /tmp/ccVWLGiI.s 			page 665


12043:Src/bno055.c  ****  *	@brief This API used to write the gyro sleep duration
12044:Src/bno055.c  ****  *	from page one register from 0x0D bit 0 to 2
12045:Src/bno055.c  ****  *
12046:Src/bno055.c  ****  *	@param sleep_durn_u8 : The value of gyro sleep duration
12047:Src/bno055.c  ****  *
12048:Src/bno055.c  ****  *	@return results of bus communication function
12049:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12050:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12051:Src/bno055.c  ****  *
12052:Src/bno055.c  ****  *
12053:Src/bno055.c  ****  */
12054:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_sleep_durn(u8 *sleep_durn_u8)
12055:Src/bno055.c  **** {
 23206              		.loc 1 12055 0
 23207              		.cfi_startproc
 23208              		@ args = 0, pretend = 0, frame = 8
 23209              		@ frame_needed = 0, uses_anonymous_args = 0
 23210              	.LVL2914:
 23211 0000 30B5     		push	{r4, r5, lr}
 23212              	.LCFI928:
 23213              		.cfi_def_cfa_offset 12
 23214              		.cfi_offset 4, -12
 23215              		.cfi_offset 5, -8
 23216              		.cfi_offset 14, -4
12056:Src/bno055.c  **** 	/* Variable used to return value of
12057:Src/bno055.c  **** 	communication routine*/
12058:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12059:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12060:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12061:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12062:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 23217              		.loc 1 12062 0
 23218 0002 144C     		ldr	r4, .L2502
12055:Src/bno055.c  **** 	/* Variable used to return value of
 23219              		.loc 1 12055 0
 23220 0004 83B0     		sub	sp, sp, #12
 23221              	.LCFI929:
 23222              		.cfi_def_cfa_offset 24
 23223              		.loc 1 12062 0
 23224 0006 2368     		ldr	r3, [r4]
12059:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 23225              		.loc 1 12059 0
 23226 0008 0022     		movs	r2, #0
 23227 000a 8DF80720 		strb	r2, [sp, #7]
 23228              	.LVL2915:
 23229              		.loc 1 12062 0
 23230 000e FBB1     		cbz	r3, .L2494
12063:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12064:Src/bno055.c  **** 		} else {
12065:Src/bno055.c  **** 		/*condition check for page, accel range is
12066:Src/bno055.c  **** 		available in the page one*/
12067:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 23231              		.loc 1 12067 0
 23232 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 23233 0012 0546     		mov	r5, r0
 23234 0014 012A     		cmp	r2, #1
 23235 0016 04D0     		beq	.L2492
ARM GAS  /tmp/ccVWLGiI.s 			page 666


12068:Src/bno055.c  **** 			/* Write page as one */
12069:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 23236              		.loc 1 12069 0
 23237 0018 0120     		movs	r0, #1
 23238              	.LVL2916:
 23239 001a FFF7FEFF 		bl	bno055_write_page_id
 23240              	.LVL2917:
 23241 001e 2368     		ldr	r3, [r4]
12070:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 23242              		.loc 1 12070 0
 23243 0020 70B9     		cbnz	r0, .L2501
 23244              	.LVL2918:
 23245              	.L2492:
12071:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12072:Src/bno055.c  **** 			/* Read the gyro sleep duration */
12073:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 23246              		.loc 1 12073 0
 23247 0022 1C69     		ldr	r4, [r3, #16]
 23248 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23249 0026 0D21     		movs	r1, #13
 23250 0028 0123     		movs	r3, #1
 23251 002a 0DF10702 		add	r2, sp, #7
 23252 002e A047     		blx	r4
 23253              	.LVL2919:
12074:Src/bno055.c  **** 			(p_bno055->dev_addr,
12075:Src/bno055.c  **** 			BNO055_GYRO_SLEEP_DURN_REG,
12076:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12077:Src/bno055.c  **** 			*sleep_durn_u8 =
 23254              		.loc 1 12077 0
 23255 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 23256 0034 03F00703 		and	r3, r3, #7
 23257 0038 2B70     		strb	r3, [r5]
 23258              	.LVL2920:
 23259              	.L2491:
12078:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
12079:Src/bno055.c  **** 			BNO055_GYRO_SLEEP_DURN);
12080:Src/bno055.c  **** 		} else {
12081:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12082:Src/bno055.c  **** 		}
12083:Src/bno055.c  **** 	}
12084:Src/bno055.c  **** 	return com_rslt;
12085:Src/bno055.c  **** }
 23260              		.loc 1 12085 0
 23261 003a 40B2     		sxtb	r0, r0
 23262 003c 03B0     		add	sp, sp, #12
 23263              	.LCFI930:
 23264              		.cfi_remember_state
 23265              		.cfi_def_cfa_offset 12
 23266              		@ sp needed
 23267 003e 30BD     		pop	{r4, r5, pc}
 23268              	.LVL2921:
 23269              	.L2501:
 23270              	.LCFI931:
 23271              		.cfi_restore_state
12070:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 23272              		.loc 1 12070 0 discriminator 1
 23273 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 667


 23274 0042 012A     		cmp	r2, #1
12081:Src/bno055.c  **** 		}
 23275              		.loc 1 12081 0 discriminator 1
 23276 0044 18BF     		it	ne
 23277 0046 FF20     		movne	r0, #255
12070:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 23278              		.loc 1 12070 0 discriminator 1
 23279 0048 EBD0     		beq	.L2492
 23280              		.loc 1 12085 0
 23281 004a 40B2     		sxtb	r0, r0
 23282 004c 03B0     		add	sp, sp, #12
 23283              	.LCFI932:
 23284              		.cfi_remember_state
 23285              		.cfi_def_cfa_offset 12
 23286              		@ sp needed
 23287 004e 30BD     		pop	{r4, r5, pc}
 23288              	.LVL2922:
 23289              	.L2494:
 23290              	.LCFI933:
 23291              		.cfi_restore_state
12063:Src/bno055.c  **** 		} else {
 23292              		.loc 1 12063 0
 23293 0050 8120     		movs	r0, #129
 23294              	.LVL2923:
 23295 0052 F2E7     		b	.L2491
 23296              	.L2503:
 23297              		.align	2
 23298              	.L2502:
 23299 0054 00000000 		.word	.LANCHOR0
 23300              		.cfi_endproc
 23301              	.LFE197:
 23303              		.section	.text.bno055_set_gyro_sleep_durn,"ax",%progbits
 23304              		.align	2
 23305              		.global	bno055_set_gyro_sleep_durn
 23306              		.thumb
 23307              		.thumb_func
 23309              	bno055_set_gyro_sleep_durn:
 23310              	.LFB198:
12086:Src/bno055.c  **** /*!
12087:Src/bno055.c  ****  *	@brief This API used to write the gyro sleep duration
12088:Src/bno055.c  ****  *	from page one register from 0x0D bit 0 to 2
12089:Src/bno055.c  ****  *
12090:Src/bno055.c  ****  *	@param sleep_durn_u8 : The value of gyro sleep duration
12091:Src/bno055.c  ****  *
12092:Src/bno055.c  ****  *	@return results of bus communication function
12093:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12094:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12095:Src/bno055.c  ****  *
12096:Src/bno055.c  ****  *
12097:Src/bno055.c  ****  */
12098:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_sleep_durn(u8 sleep_durn_u8)
12099:Src/bno055.c  **** {
 23311              		.loc 1 12099 0
 23312              		.cfi_startproc
 23313              		@ args = 0, pretend = 0, frame = 8
 23314              		@ frame_needed = 0, uses_anonymous_args = 0
 23315              	.LVL2924:
ARM GAS  /tmp/ccVWLGiI.s 			page 668


 23316 0000 30B5     		push	{r4, r5, lr}
 23317              	.LCFI934:
 23318              		.cfi_def_cfa_offset 12
 23319              		.cfi_offset 4, -12
 23320              		.cfi_offset 5, -8
 23321              		.cfi_offset 14, -4
12100:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12101:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
12102:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
12103:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
12104:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
12105:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
12106:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 23322              		.loc 1 12106 0
 23323 0002 274C     		ldr	r4, .L2521
12099:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 23324              		.loc 1 12099 0
 23325 0004 83B0     		sub	sp, sp, #12
 23326              	.LCFI935:
 23327              		.cfi_def_cfa_offset 24
 23328              		.loc 1 12106 0
 23329 0006 2268     		ldr	r2, [r4]
12101:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 23330              		.loc 1 12101 0
 23331 0008 0023     		movs	r3, #0
 23332 000a 8DF80630 		strb	r3, [sp, #6]
 23333              	.LVL2925:
12104:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 23334              		.loc 1 12104 0
 23335 000e 8DF80730 		strb	r3, [sp, #7]
 23336              		.loc 1 12106 0
 23337 0012 002A     		cmp	r2, #0
 23338 0014 42D0     		beq	.L2512
 23339 0016 0546     		mov	r5, r0
12107:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
12108:Src/bno055.c  **** } else {
12109:Src/bno055.c  **** /* The write operation effective only if the operation
12110:Src/bno055.c  **** mode is in config mode, this part of code is checking the
12111:Src/bno055.c  **** current operation mode and set the config mode */
12112:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 23340              		.loc 1 12112 0
 23341 0018 0DF10700 		add	r0, sp, #7
 23342              	.LVL2926:
 23343 001c FFF7FEFF 		bl	bno055_get_operation_mode
 23344              	.LVL2927:
12113:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 23345              		.loc 1 12113 0
 23346 0020 38B1     		cbz	r0, .L2506
 23347              	.LVL2928:
 23348              	.L2510:
12114:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
12115:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
12116:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
12117:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
12118:Src/bno055.c  **** 			/* Write page as one */
12119:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
12120:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 669


12121:Src/bno055.c  **** 				if (sleep_durn_u8 <
12122:Src/bno055.c  **** 				BNO055_GYRO_AUTO_SLEEP_DURATION_RANGE) {
12123:Src/bno055.c  **** 					com_rslt =
12124:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
12125:Src/bno055.c  **** 					(p_bno055->dev_addr,
12126:Src/bno055.c  **** 					BNO055_GYRO_SLEEP_DURN_REG,
12127:Src/bno055.c  **** 					&data_u8r,
12128:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
12129:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
12130:Src/bno055.c  **** 						/* Write the gyro
12131:Src/bno055.c  **** 						sleep duration */
12132:Src/bno055.c  **** 						data_u8r = BNO055_SET_BITSLICE
12133:Src/bno055.c  **** 						(data_u8r,
12134:Src/bno055.c  **** 						BNO055_GYRO_SLEEP_DURN,
12135:Src/bno055.c  **** 						sleep_durn_u8);
12136:Src/bno055.c  **** 						com_rslt +=
12137:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
12138:Src/bno055.c  **** 						(p_bno055->dev_addr,
12139:Src/bno055.c  **** 						BNO055_GYRO_SLEEP_DURN_REG,
12140:Src/bno055.c  **** 						&data_u8r,
12141:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
12142:Src/bno055.c  **** 					}
12143:Src/bno055.c  **** 				} else {
12144:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
12145:Src/bno055.c  **** 				}
12146:Src/bno055.c  **** 			} else {
12147:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
12148:Src/bno055.c  **** 			}
12149:Src/bno055.c  **** 		} else {
12150:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12151:Src/bno055.c  **** 		}
12152:Src/bno055.c  **** 	} else {
12153:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 23349              		.loc 1 12153 0
 23350 0022 FF24     		movs	r4, #255
 23351              	.LVL2929:
 23352              	.L2507:
12154:Src/bno055.c  **** 	}
12155:Src/bno055.c  **** }
12156:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 23353              		.loc 1 12156 0
 23354 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 23355 0028 78B9     		cbnz	r0, .L2519
 23356 002a 2046     		mov	r0, r4
 23357              	.LVL2930:
 23358              	.L2505:
12157:Src/bno055.c  **** 	/* set the operation mode of
12158:Src/bno055.c  **** 	previous operation mode*/
12159:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
12160:Src/bno055.c  **** 	(prev_opmode_u8);
12161:Src/bno055.c  **** return com_rslt;
12162:Src/bno055.c  **** }
 23359              		.loc 1 12162 0
 23360 002c 40B2     		sxtb	r0, r0
 23361 002e 03B0     		add	sp, sp, #12
 23362              	.LCFI936:
 23363              		.cfi_remember_state
ARM GAS  /tmp/ccVWLGiI.s 			page 670


 23364              		.cfi_def_cfa_offset 12
 23365              		@ sp needed
 23366 0030 30BD     		pop	{r4, r5, pc}
 23367              	.LVL2931:
 23368              	.L2506:
 23369              	.LCFI937:
 23370              		.cfi_restore_state
12114:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 23371              		.loc 1 12114 0
 23372 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 23373 0036 7BB9     		cbnz	r3, .L2508
 23374              	.L2511:
 23375              	.LVL2932:
12119:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 23376              		.loc 1 12119 0
 23377 0038 0120     		movs	r0, #1
 23378 003a FFF7FEFF 		bl	bno055_write_page_id
 23379              	.LVL2933:
12120:Src/bno055.c  **** 				if (sleep_durn_u8 <
 23380              		.loc 1 12120 0
 23381 003e 0028     		cmp	r0, #0
 23382 0040 EFD1     		bne	.L2510
12121:Src/bno055.c  **** 				BNO055_GYRO_AUTO_SLEEP_DURATION_RANGE) {
 23383              		.loc 1 12121 0
 23384 0042 072D     		cmp	r5, #7
 23385 0044 0DD9     		bls	.L2520
12144:Src/bno055.c  **** 				}
 23386              		.loc 1 12144 0
 23387 0046 FE24     		movs	r4, #254
 23388 0048 ECE7     		b	.L2507
 23389              	.LVL2934:
 23390              	.L2519:
12159:Src/bno055.c  **** 	(prev_opmode_u8);
 23391              		.loc 1 12159 0
 23392 004a FFF7FEFF 		bl	bno055_set_operation_mode
 23393              	.LVL2935:
 23394 004e 2044     		add	r0, r0, r4
 23395 0050 C0B2     		uxtb	r0, r0
 23396              	.LVL2936:
 23397              		.loc 1 12162 0
 23398 0052 40B2     		sxtb	r0, r0
 23399 0054 03B0     		add	sp, sp, #12
 23400              	.LCFI938:
 23401              		.cfi_remember_state
 23402              		.cfi_def_cfa_offset 12
 23403              		@ sp needed
 23404 0056 30BD     		pop	{r4, r5, pc}
 23405              	.LVL2937:
 23406              	.L2508:
 23407              	.LCFI939:
 23408              		.cfi_restore_state
12115:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 23409              		.loc 1 12115 0
 23410 0058 FFF7FEFF 		bl	bno055_set_operation_mode
 23411              	.LVL2938:
12117:Src/bno055.c  **** 			/* Write page as one */
 23412              		.loc 1 12117 0
ARM GAS  /tmp/ccVWLGiI.s 			page 671


 23413 005c 0028     		cmp	r0, #0
 23414 005e E0D1     		bne	.L2510
 23415 0060 EAE7     		b	.L2511
 23416              	.LVL2939:
 23417              	.L2520:
12124:Src/bno055.c  **** 					(p_bno055->dev_addr,
 23418              		.loc 1 12124 0
 23419 0062 2368     		ldr	r3, [r4]
12123:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 23420              		.loc 1 12123 0
 23421 0064 0DF10602 		add	r2, sp, #6
 23422 0068 1C69     		ldr	r4, [r3, #16]
 23423 006a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23424              	.LVL2940:
 23425 006c 0D21     		movs	r1, #13
 23426 006e 0123     		movs	r3, #1
 23427 0070 A047     		blx	r4
 23428              	.LVL2941:
12124:Src/bno055.c  **** 					(p_bno055->dev_addr,
 23429              		.loc 1 12124 0
 23430 0072 0B4B     		ldr	r3, .L2521
12129:Src/bno055.c  **** 						/* Write the gyro
 23431              		.loc 1 12129 0
 23432 0074 0446     		mov	r4, r0
 23433 0076 0028     		cmp	r0, #0
 23434 0078 D4D1     		bne	.L2507
12132:Src/bno055.c  **** 						(data_u8r,
 23435              		.loc 1 12132 0
 23436 007a 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 23437              	.LVL2942:
12137:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23438              		.loc 1 12137 0
 23439 007e 1B68     		ldr	r3, [r3]
12132:Src/bno055.c  **** 						(data_u8r,
 23440              		.loc 1 12132 0
 23441 0080 20F00700 		bic	r0, r0, #7
 23442 0084 2843     		orrs	r0, r0, r5
12137:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23443              		.loc 1 12137 0
 23444 0086 DC68     		ldr	r4, [r3, #12]
12132:Src/bno055.c  **** 						(data_u8r,
 23445              		.loc 1 12132 0
 23446 0088 8DF80600 		strb	r0, [sp, #6]
12137:Src/bno055.c  **** 						(p_bno055->dev_addr,
 23447              		.loc 1 12137 0
 23448 008c 0DF10602 		add	r2, sp, #6
 23449 0090 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23450 0092 0D21     		movs	r1, #13
 23451 0094 0123     		movs	r3, #1
 23452 0096 A047     		blx	r4
 23453              	.LVL2943:
 23454 0098 0446     		mov	r4, r0
 23455              	.LVL2944:
 23456 009a C3E7     		b	.L2507
 23457              	.LVL2945:
 23458              	.L2512:
12107:Src/bno055.c  **** } else {
ARM GAS  /tmp/ccVWLGiI.s 			page 672


 23459              		.loc 1 12107 0
 23460 009c 8120     		movs	r0, #129
 23461              	.LVL2946:
 23462 009e C5E7     		b	.L2505
 23463              	.L2522:
 23464              		.align	2
 23465              	.L2521:
 23466 00a0 00000000 		.word	.LANCHOR0
 23467              		.cfi_endproc
 23468              	.LFE198:
 23470              		.section	.text.bno055_get_gyro_auto_sleep_durn,"ax",%progbits
 23471              		.align	2
 23472              		.global	bno055_get_gyro_auto_sleep_durn
 23473              		.thumb
 23474              		.thumb_func
 23476              	bno055_get_gyro_auto_sleep_durn:
 23477              	.LFB199:
12163:Src/bno055.c  **** /*!
12164:Src/bno055.c  ****  *	@brief This API used to read the gyro auto sleep duration
12165:Src/bno055.c  ****  *	from page one register from 0x0D bit 3 to 5
12166:Src/bno055.c  ****  *
12167:Src/bno055.c  ****  *	@param auto_sleep_durn_u8 : The value of gyro auto sleep duration
12168:Src/bno055.c  ****  *
12169:Src/bno055.c  ****  *	@return results of bus communication function
12170:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12171:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12172:Src/bno055.c  ****  *
12173:Src/bno055.c  ****  *
12174:Src/bno055.c  ****  */
12175:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_auto_sleep_durn(
12176:Src/bno055.c  **** u8 *auto_sleep_durn_u8)
12177:Src/bno055.c  **** {
 23478              		.loc 1 12177 0
 23479              		.cfi_startproc
 23480              		@ args = 0, pretend = 0, frame = 8
 23481              		@ frame_needed = 0, uses_anonymous_args = 0
 23482              	.LVL2947:
 23483 0000 30B5     		push	{r4, r5, lr}
 23484              	.LCFI940:
 23485              		.cfi_def_cfa_offset 12
 23486              		.cfi_offset 4, -12
 23487              		.cfi_offset 5, -8
 23488              		.cfi_offset 14, -4
12178:Src/bno055.c  **** 	/* Variable used to return value of
12179:Src/bno055.c  **** 	communication routine*/
12180:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12181:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12182:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12183:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12184:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 23489              		.loc 1 12184 0
 23490 0002 144C     		ldr	r4, .L2535
12177:Src/bno055.c  **** 	/* Variable used to return value of
 23491              		.loc 1 12177 0
 23492 0004 83B0     		sub	sp, sp, #12
 23493              	.LCFI941:
 23494              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccVWLGiI.s 			page 673


 23495              		.loc 1 12184 0
 23496 0006 2368     		ldr	r3, [r4]
12181:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 23497              		.loc 1 12181 0
 23498 0008 0022     		movs	r2, #0
 23499 000a 8DF80720 		strb	r2, [sp, #7]
 23500              	.LVL2948:
 23501              		.loc 1 12184 0
 23502 000e FBB1     		cbz	r3, .L2527
12185:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12186:Src/bno055.c  **** 		} else {
12187:Src/bno055.c  **** 		/*condition check for page, accel range is
12188:Src/bno055.c  **** 		available in the page one*/
12189:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 23503              		.loc 1 12189 0
 23504 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 23505 0012 0546     		mov	r5, r0
 23506 0014 012A     		cmp	r2, #1
 23507 0016 04D0     		beq	.L2525
12190:Src/bno055.c  **** 			/* Write page as one */
12191:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 23508              		.loc 1 12191 0
 23509 0018 0120     		movs	r0, #1
 23510              	.LVL2949:
 23511 001a FFF7FEFF 		bl	bno055_write_page_id
 23512              	.LVL2950:
 23513 001e 2368     		ldr	r3, [r4]
12192:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 23514              		.loc 1 12192 0
 23515 0020 70B9     		cbnz	r0, .L2534
 23516              	.LVL2951:
 23517              	.L2525:
12193:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12194:Src/bno055.c  **** 			/* Read the value of gyro auto sleep duration */
12195:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 23518              		.loc 1 12195 0
 23519 0022 1C69     		ldr	r4, [r3, #16]
 23520 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23521 0026 0D21     		movs	r1, #13
 23522 0028 0123     		movs	r3, #1
 23523 002a 0DF10702 		add	r2, sp, #7
 23524 002e A047     		blx	r4
 23525              	.LVL2952:
12196:Src/bno055.c  **** 			(p_bno055->dev_addr,
12197:Src/bno055.c  **** 			BNO055_GYRO_AUTO_SLEEP_DURN_REG,
12198:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12199:Src/bno055.c  **** 			*auto_sleep_durn_u8 =
12200:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 23526              		.loc 1 12200 0
 23527 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 23528 0034 C3F3C203 		ubfx	r3, r3, #3, #3
12199:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 23529              		.loc 1 12199 0
 23530 0038 2B70     		strb	r3, [r5]
 23531              	.LVL2953:
 23532              	.L2524:
12201:Src/bno055.c  **** 			BNO055_GYRO_AUTO_SLEEP_DURN);
ARM GAS  /tmp/ccVWLGiI.s 			page 674


12202:Src/bno055.c  **** 		} else {
12203:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12204:Src/bno055.c  **** 		}
12205:Src/bno055.c  **** 	}
12206:Src/bno055.c  **** 	return com_rslt;
12207:Src/bno055.c  **** }
 23533              		.loc 1 12207 0
 23534 003a 40B2     		sxtb	r0, r0
 23535 003c 03B0     		add	sp, sp, #12
 23536              	.LCFI942:
 23537              		.cfi_remember_state
 23538              		.cfi_def_cfa_offset 12
 23539              		@ sp needed
 23540 003e 30BD     		pop	{r4, r5, pc}
 23541              	.LVL2954:
 23542              	.L2534:
 23543              	.LCFI943:
 23544              		.cfi_restore_state
12192:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 23545              		.loc 1 12192 0 discriminator 1
 23546 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 23547 0042 012A     		cmp	r2, #1
12203:Src/bno055.c  **** 		}
 23548              		.loc 1 12203 0 discriminator 1
 23549 0044 18BF     		it	ne
 23550 0046 FF20     		movne	r0, #255
12192:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 23551              		.loc 1 12192 0 discriminator 1
 23552 0048 EBD0     		beq	.L2525
 23553              		.loc 1 12207 0
 23554 004a 40B2     		sxtb	r0, r0
 23555 004c 03B0     		add	sp, sp, #12
 23556              	.LCFI944:
 23557              		.cfi_remember_state
 23558              		.cfi_def_cfa_offset 12
 23559              		@ sp needed
 23560 004e 30BD     		pop	{r4, r5, pc}
 23561              	.LVL2955:
 23562              	.L2527:
 23563              	.LCFI945:
 23564              		.cfi_restore_state
12185:Src/bno055.c  **** 		} else {
 23565              		.loc 1 12185 0
 23566 0050 8120     		movs	r0, #129
 23567              	.LVL2956:
 23568 0052 F2E7     		b	.L2524
 23569              	.L2536:
 23570              		.align	2
 23571              	.L2535:
 23572 0054 00000000 		.word	.LANCHOR0
 23573              		.cfi_endproc
 23574              	.LFE199:
 23576              		.section	.text.bno055_gyro_set_auto_sleep_durn,"ax",%progbits
 23577              		.align	2
 23578              		.global	bno055_gyro_set_auto_sleep_durn
 23579              		.thumb
 23580              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 675


 23582              	bno055_gyro_set_auto_sleep_durn:
 23583              	.LFB200:
12208:Src/bno055.c  **** /*!
12209:Src/bno055.c  ****  *	@brief This API used to write the gyro auto sleep duration
12210:Src/bno055.c  ****  *	from page one register from 0x0D bit 3 to 5
12211:Src/bno055.c  ****  *
12212:Src/bno055.c  ****  *	@param auto_sleep_durn_u8 : The value of gyro auto sleep duration
12213:Src/bno055.c  ****  *	@param bw : The value of gyro bandwidth
12214:Src/bno055.c  ****  *
12215:Src/bno055.c  ****  *	@return results of bus communication function
12216:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12217:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12218:Src/bno055.c  ****  *
12219:Src/bno055.c  ****  *
12220:Src/bno055.c  ****  */
12221:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_gyro_set_auto_sleep_durn(
12222:Src/bno055.c  **** u8 auto_sleep_durn_u8, u8 bw)
12223:Src/bno055.c  **** {
 23584              		.loc 1 12223 0
 23585              		.cfi_startproc
 23586              		@ args = 0, pretend = 0, frame = 8
 23587              		@ frame_needed = 0, uses_anonymous_args = 0
 23588              	.LVL2957:
 23589 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 23590              	.LCFI946:
 23591              		.cfi_def_cfa_offset 20
 23592              		.cfi_offset 4, -20
 23593              		.cfi_offset 5, -16
 23594              		.cfi_offset 6, -12
 23595              		.cfi_offset 7, -8
 23596              		.cfi_offset 14, -4
12224:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12225:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
12226:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
12227:Src/bno055.c  **** u8 auto_sleep_durn_u8r;
12228:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
12229:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
12230:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
12231:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 23597              		.loc 1 12231 0
 23598 0002 364D     		ldr	r5, .L2567
12223:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 23599              		.loc 1 12223 0
 23600 0004 83B0     		sub	sp, sp, #12
 23601              	.LCFI947:
 23602              		.cfi_def_cfa_offset 32
 23603              		.loc 1 12231 0
 23604 0006 2A68     		ldr	r2, [r5]
12225:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 23605              		.loc 1 12225 0
 23606 0008 0023     		movs	r3, #0
 23607 000a 8DF80630 		strb	r3, [sp, #6]
 23608              	.LVL2958:
12228:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 23609              		.loc 1 12228 0
 23610 000e 8DF80730 		strb	r3, [sp, #7]
 23611              	.LVL2959:
ARM GAS  /tmp/ccVWLGiI.s 			page 676


 23612              		.loc 1 12231 0
 23613 0012 002A     		cmp	r2, #0
 23614 0014 5FD0     		beq	.L2556
 23615 0016 0646     		mov	r6, r0
12232:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
12233:Src/bno055.c  **** } else {
12234:Src/bno055.c  **** /* The write operation effective only if the operation
12235:Src/bno055.c  **** mode is in config mode, this part of code is checking the
12236:Src/bno055.c  **** current operation mode and set the config mode */
12237:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 23616              		.loc 1 12237 0
 23617 0018 0DF10700 		add	r0, sp, #7
 23618              	.LVL2960:
 23619 001c 0F46     		mov	r7, r1
 23620 001e FFF7FEFF 		bl	bno055_get_operation_mode
 23621              	.LVL2961:
12238:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 23622              		.loc 1 12238 0
 23623 0022 38B1     		cbz	r0, .L2539
 23624              	.LVL2962:
 23625              	.L2543:
12239:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
12240:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
12241:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
12242:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
12243:Src/bno055.c  **** 		/* Write page as one */
12244:Src/bno055.c  **** 		pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
12245:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
12246:Src/bno055.c  **** 			/* Write the value of gyro sleep duration */
12247:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
12248:Src/bno055.c  **** 			(p_bno055->dev_addr,
12249:Src/bno055.c  **** 			BNO055_GYRO_AUTO_SLEEP_DURN_REG,
12250:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12251:Src/bno055.c  **** 			if (auto_sleep_durn_u8 <
12252:Src/bno055.c  **** 			BNO055_GYRO_AUTO_SLEEP_DURATION_RANGE) {
12253:Src/bno055.c  **** 				switch (bw) {
12254:Src/bno055.c  **** 				case BNO055_GYRO_BW_523HZ:
12255:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12256:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR)
12257:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12258:Src/bno055.c  **** 					auto_sleep_durn_u8;
12259:Src/bno055.c  **** 				else
12260:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12261:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR;
12262:Src/bno055.c  **** 				break;
12263:Src/bno055.c  **** 				case BNO055_GYRO_BW_230HZ:
12264:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12265:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR)
12266:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12267:Src/bno055.c  **** 					auto_sleep_durn_u8;
12268:Src/bno055.c  **** 				else
12269:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12270:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR;
12271:Src/bno055.c  **** 				break;
12272:Src/bno055.c  **** 				case BNO055_GYRO_BW_116HZ:
12273:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12274:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR)
ARM GAS  /tmp/ccVWLGiI.s 			page 677


12275:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12276:Src/bno055.c  **** 					auto_sleep_durn_u8;
12277:Src/bno055.c  **** 				else
12278:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12279:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR;
12280:Src/bno055.c  **** 				break;
12281:Src/bno055.c  **** 				case BNO055_GYRO_BW_47HZ:
12282:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12283:Src/bno055.c  **** 					BNO055_GYRO_5MS_AUTOSLPDUR)
12284:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12285:Src/bno055.c  **** 					auto_sleep_durn_u8;
12286:Src/bno055.c  **** 				else
12287:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12288:Src/bno055.c  **** 					BNO055_GYRO_5MS_AUTOSLPDUR;
12289:Src/bno055.c  **** 				break;
12290:Src/bno055.c  **** 				case BNO055_GYRO_BW_23HZ:
12291:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12292:Src/bno055.c  **** 					BNO055_GYRO_10MS_AUTOSLPDUR)
12293:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12294:Src/bno055.c  **** 					auto_sleep_durn_u8;
12295:Src/bno055.c  **** 				else
12296:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12297:Src/bno055.c  **** 					BNO055_GYRO_10MS_AUTOSLPDUR;
12298:Src/bno055.c  **** 				break;
12299:Src/bno055.c  **** 				case BNO055_GYRO_BW_12HZ:
12300:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12301:Src/bno055.c  **** 					BNO055_GYRO_20MS_AUTOSLPDUR)
12302:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12303:Src/bno055.c  **** 					auto_sleep_durn_u8;
12304:Src/bno055.c  **** 				else
12305:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12306:Src/bno055.c  **** 					BNO055_GYRO_20MS_AUTOSLPDUR;
12307:Src/bno055.c  **** 				break;
12308:Src/bno055.c  **** 				case BNO055_GYRO_BW_64HZ:
12309:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12310:Src/bno055.c  **** 					BNO055_GYRO_10MS_AUTOSLPDUR)
12311:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12312:Src/bno055.c  **** 					auto_sleep_durn_u8;
12313:Src/bno055.c  **** 				else
12314:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12315:Src/bno055.c  **** 					BNO055_GYRO_10MS_AUTOSLPDUR;
12316:Src/bno055.c  **** 				break;
12317:Src/bno055.c  **** 				case BNO055_GYRO_BW_32HZ:
12318:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12319:Src/bno055.c  **** 					BNO055_GYRO_20MS_AUTOSLPDUR)
12320:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12321:Src/bno055.c  **** 					auto_sleep_durn_u8;
12322:Src/bno055.c  **** 				else
12323:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12324:Src/bno055.c  **** 					BNO055_GYRO_20MS_AUTOSLPDUR;
12325:Src/bno055.c  **** 				break;
12326:Src/bno055.c  **** 				default:
12327:Src/bno055.c  **** 				if (auto_sleep_durn_u8 >
12328:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR)
12329:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12330:Src/bno055.c  **** 					auto_sleep_durn_u8;
12331:Src/bno055.c  **** 				else
ARM GAS  /tmp/ccVWLGiI.s 			page 678


12332:Src/bno055.c  **** 					auto_sleep_durn_u8r =
12333:Src/bno055.c  **** 					BNO055_GYRO_4MS_AUTOSLPDUR;
12334:Src/bno055.c  **** 				break;
12335:Src/bno055.c  **** 				}
12336:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
12337:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
12338:Src/bno055.c  **** 					(data_u8r,
12339:Src/bno055.c  **** 					BNO055_GYRO_AUTO_SLEEP_DURN,
12340:Src/bno055.c  **** 					auto_sleep_durn_u8r);
12341:Src/bno055.c  **** 					com_rslt +=
12342:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
12343:Src/bno055.c  **** 					(p_bno055->dev_addr,
12344:Src/bno055.c  **** 					BNO055_GYRO_AUTO_SLEEP_DURN_REG,
12345:Src/bno055.c  **** 					&data_u8r,
12346:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
12347:Src/bno055.c  **** 				}
12348:Src/bno055.c  **** 			} else {
12349:Src/bno055.c  **** 			com_rslt = BNO055_OUT_OF_RANGE;
12350:Src/bno055.c  **** 			}
12351:Src/bno055.c  **** 		} else {
12352:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12353:Src/bno055.c  **** 		}
12354:Src/bno055.c  **** 	} else {
12355:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
12356:Src/bno055.c  **** 	}
12357:Src/bno055.c  **** } else {
12358:Src/bno055.c  **** com_rslt = BNO055_ERROR;
 23626              		.loc 1 12358 0
 23627 0024 FF24     		movs	r4, #255
 23628              	.LVL2963:
 23629              	.L2540:
12359:Src/bno055.c  **** }
12360:Src/bno055.c  **** }
12361:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 23630              		.loc 1 12361 0
 23631 0026 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 23632 002a F0B9     		cbnz	r0, .L2566
 23633 002c 2046     		mov	r0, r4
 23634              	.LVL2964:
 23635              	.L2538:
12362:Src/bno055.c  **** 	/* set the operation mode of
12363:Src/bno055.c  **** 	previous operation mode*/
12364:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
12365:Src/bno055.c  **** 	(prev_opmode_u8);
12366:Src/bno055.c  **** return com_rslt;
12367:Src/bno055.c  **** }
 23636              		.loc 1 12367 0
 23637 002e 40B2     		sxtb	r0, r0
 23638 0030 03B0     		add	sp, sp, #12
 23639              	.LCFI948:
 23640              		.cfi_remember_state
 23641              		.cfi_def_cfa_offset 20
 23642              		@ sp needed
 23643 0032 F0BD     		pop	{r4, r5, r6, r7, pc}
 23644              	.LVL2965:
 23645              	.L2539:
 23646              	.LCFI949:
ARM GAS  /tmp/ccVWLGiI.s 			page 679


 23647              		.cfi_restore_state
12239:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 23648              		.loc 1 12239 0
 23649 0034 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 23650 0038 F3B9     		cbnz	r3, .L2541
 23651              	.L2544:
 23652              	.LVL2966:
12244:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
 23653              		.loc 1 12244 0
 23654 003a 0120     		movs	r0, #1
 23655 003c FFF7FEFF 		bl	bno055_write_page_id
 23656              	.LVL2967:
12245:Src/bno055.c  **** 			/* Write the value of gyro sleep duration */
 23657              		.loc 1 12245 0
 23658 0040 0028     		cmp	r0, #0
 23659 0042 EFD1     		bne	.L2543
12247:Src/bno055.c  **** 			(p_bno055->dev_addr,
 23660              		.loc 1 12247 0
 23661 0044 2B68     		ldr	r3, [r5]
 23662 0046 0DF10602 		add	r2, sp, #6
 23663 004a 1C69     		ldr	r4, [r3, #16]
 23664 004c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23665              	.LVL2968:
 23666 004e 0D21     		movs	r1, #13
 23667 0050 0123     		movs	r3, #1
 23668 0052 A047     		blx	r4
 23669              	.LVL2969:
12251:Src/bno055.c  **** 			BNO055_GYRO_AUTO_SLEEP_DURATION_RANGE) {
 23670              		.loc 1 12251 0
 23671 0054 072E     		cmp	r6, #7
12247:Src/bno055.c  **** 			(p_bno055->dev_addr,
 23672              		.loc 1 12247 0
 23673 0056 0446     		mov	r4, r0
 23674              	.LVL2970:
12251:Src/bno055.c  **** 			BNO055_GYRO_AUTO_SLEEP_DURATION_RANGE) {
 23675              		.loc 1 12251 0
 23676 0058 3BD8     		bhi	.L2557
12253:Src/bno055.c  **** 				case BNO055_GYRO_BW_523HZ:
 23677              		.loc 1 12253 0
 23678 005a 072F     		cmp	r7, #7
 23679 005c 11D8     		bhi	.L2545
 23680 005e DFE807F0 		tbb	[pc, r7]
 23681              	.L2547:
 23682 0062 10       		.byte	(.L2545-.L2547)/2
 23683 0063 10       		.byte	(.L2545-.L2547)/2
 23684 0064 10       		.byte	(.L2545-.L2547)/2
 23685 0065 33       		.byte	(.L2550-.L2547)/2
 23686 0066 2A       		.byte	(.L2553-.L2547)/2
 23687 0067 2F       		.byte	(.L2554-.L2547)/2
 23688 0068 2A       		.byte	(.L2553-.L2547)/2
 23689 0069 2F       		.byte	(.L2554-.L2547)/2
 23690              		.p2align 1
 23691              	.L2566:
12364:Src/bno055.c  **** 	(prev_opmode_u8);
 23692              		.loc 1 12364 0
 23693 006a FFF7FEFF 		bl	bno055_set_operation_mode
 23694              	.LVL2971:
ARM GAS  /tmp/ccVWLGiI.s 			page 680


 23695 006e 2044     		add	r0, r0, r4
 23696 0070 C0B2     		uxtb	r0, r0
 23697              	.LVL2972:
 23698              		.loc 1 12367 0
 23699 0072 40B2     		sxtb	r0, r0
 23700 0074 03B0     		add	sp, sp, #12
 23701              	.LCFI950:
 23702              		.cfi_remember_state
 23703              		.cfi_def_cfa_offset 20
 23704              		@ sp needed
 23705 0076 F0BD     		pop	{r4, r5, r6, r7, pc}
 23706              	.LVL2973:
 23707              	.L2541:
 23708              	.LCFI951:
 23709              		.cfi_restore_state
12240:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 23710              		.loc 1 12240 0
 23711 0078 FFF7FEFF 		bl	bno055_set_operation_mode
 23712              	.LVL2974:
12242:Src/bno055.c  **** 		/* Write page as one */
 23713              		.loc 1 12242 0
 23714 007c 0028     		cmp	r0, #0
 23715 007e D1D1     		bne	.L2543
 23716 0080 DBE7     		b	.L2544
 23717              	.LVL2975:
 23718              	.L2545:
 23719 0082 012E     		cmp	r6, #1
 23720 0084 38BF     		it	cc
 23721 0086 0126     		movcc	r6, #1
 23722 0088 F6B2     		uxtb	r6, r6
 23723              	.L2555:
 23724              	.LVL2976:
12336:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 23725              		.loc 1 12336 0
 23726 008a 002C     		cmp	r4, #0
 23727 008c CBD1     		bne	.L2540
12337:Src/bno055.c  **** 					(data_u8r,
 23728              		.loc 1 12337 0
 23729 008e 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 23730 0092 F300     		lsls	r3, r6, #3
12342:Src/bno055.c  **** 					(p_bno055->dev_addr,
 23731              		.loc 1 12342 0
 23732 0094 2968     		ldr	r1, [r5]
12337:Src/bno055.c  **** 					(data_u8r,
 23733              		.loc 1 12337 0
 23734 0096 22F03802 		bic	r2, r2, #56
 23735 009a 03F03803 		and	r3, r3, #56
 23736 009e 1343     		orrs	r3, r3, r2
12342:Src/bno055.c  **** 					(p_bno055->dev_addr,
 23737              		.loc 1 12342 0
 23738 00a0 CC68     		ldr	r4, [r1, #12]
 23739              	.LVL2977:
12337:Src/bno055.c  **** 					(data_u8r,
 23740              		.loc 1 12337 0
 23741 00a2 8DF80630 		strb	r3, [sp, #6]
12342:Src/bno055.c  **** 					(p_bno055->dev_addr,
 23742              		.loc 1 12342 0
ARM GAS  /tmp/ccVWLGiI.s 			page 681


 23743 00a6 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 23744 00a8 0DF10602 		add	r2, sp, #6
 23745 00ac 0D21     		movs	r1, #13
 23746 00ae 0123     		movs	r3, #1
 23747 00b0 A047     		blx	r4
 23748              	.LVL2978:
 23749 00b2 0446     		mov	r4, r0
 23750              	.LVL2979:
 23751 00b4 B7E7     		b	.L2540
 23752              	.LVL2980:
 23753              	.L2553:
 23754 00b6 042E     		cmp	r6, #4
 23755 00b8 38BF     		it	cc
 23756 00ba 0426     		movcc	r6, #4
 23757 00bc F6B2     		uxtb	r6, r6
 23758 00be E4E7     		b	.L2555
 23759              	.L2554:
12305:Src/bno055.c  **** 					BNO055_GYRO_20MS_AUTOSLPDUR;
 23760              		.loc 1 12305 0
 23761 00c0 072E     		cmp	r6, #7
 23762 00c2 18BF     		it	ne
 23763 00c4 0626     		movne	r6, #6
 23764 00c6 E0E7     		b	.L2555
 23765              	.L2550:
 23766 00c8 022E     		cmp	r6, #2
 23767 00ca 38BF     		it	cc
 23768 00cc 0226     		movcc	r6, #2
 23769 00ce F6B2     		uxtb	r6, r6
 23770 00d0 DBE7     		b	.L2555
 23771              	.L2557:
12349:Src/bno055.c  **** 			}
 23772              		.loc 1 12349 0
 23773 00d2 FE24     		movs	r4, #254
 23774              	.LVL2981:
 23775 00d4 A7E7     		b	.L2540
 23776              	.LVL2982:
 23777              	.L2556:
12232:Src/bno055.c  **** } else {
 23778              		.loc 1 12232 0
 23779 00d6 8120     		movs	r0, #129
 23780              	.LVL2983:
 23781 00d8 A9E7     		b	.L2538
 23782              	.L2568:
 23783 00da 00BF     		.align	2
 23784              	.L2567:
 23785 00dc 00000000 		.word	.LANCHOR0
 23786              		.cfi_endproc
 23787              	.LFE200:
 23789              		.section	.text.bno055_set_gyro_bw,"ax",%progbits
 23790              		.align	2
 23791              		.global	bno055_set_gyro_bw
 23792              		.thumb
 23793              		.thumb_func
 23795              	bno055_set_gyro_bw:
 23796              	.LFB190:
11474:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 23797              		.loc 1 11474 0
ARM GAS  /tmp/ccVWLGiI.s 			page 682


 23798              		.cfi_startproc
 23799              		@ args = 0, pretend = 0, frame = 8
 23800              		@ frame_needed = 0, uses_anonymous_args = 0
 23801              	.LVL2984:
 23802 0000 70B5     		push	{r4, r5, r6, lr}
 23803              	.LCFI952:
 23804              		.cfi_def_cfa_offset 16
 23805              		.cfi_offset 4, -16
 23806              		.cfi_offset 5, -12
 23807              		.cfi_offset 6, -8
 23808              		.cfi_offset 14, -4
11483:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 23809              		.loc 1 11483 0
 23810 0002 3A4C     		ldr	r4, .L2597
11474:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 23811              		.loc 1 11474 0
 23812 0004 82B0     		sub	sp, sp, #8
 23813              	.LCFI953:
 23814              		.cfi_def_cfa_offset 24
11483:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 23815              		.loc 1 11483 0
 23816 0006 2268     		ldr	r2, [r4]
11476:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 23817              		.loc 1 11476 0
 23818 0008 0023     		movs	r3, #0
 23819 000a 8DF80430 		strb	r3, [sp, #4]
 23820              	.LVL2985:
11478:Src/bno055.c  **** u8 gyro_auto_sleep_durn = BNO055_INIT_VALUE;
 23821              		.loc 1 11478 0
 23822 000e 8DF80530 		strb	r3, [sp, #5]
11479:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 23823              		.loc 1 11479 0
 23824 0012 8DF80630 		strb	r3, [sp, #6]
 23825              	.LVL2986:
11481:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 23826              		.loc 1 11481 0
 23827 0016 8DF80730 		strb	r3, [sp, #7]
11483:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 23828              		.loc 1 11483 0
 23829 001a 002A     		cmp	r2, #0
 23830 001c 51D0     		beq	.L2587
 23831 001e 0546     		mov	r5, r0
11489:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 23832              		.loc 1 11489 0
 23833 0020 0DF10700 		add	r0, sp, #7
 23834              	.LVL2987:
 23835 0024 FFF7FEFF 		bl	bno055_get_operation_mode
 23836              	.LVL2988:
11490:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 23837              		.loc 1 11490 0
 23838 0028 38B1     		cbz	r0, .L2571
 23839              	.LVL2989:
 23840              	.L2575:
11571:Src/bno055.c  **** }
 23841              		.loc 1 11571 0
 23842 002a FF24     		movs	r4, #255
 23843              	.LVL2990:
ARM GAS  /tmp/ccVWLGiI.s 			page 683


 23844              	.L2572:
11574:Src/bno055.c  **** 	/* set the operation mode of
 23845              		.loc 1 11574 0
 23846 002c 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 23847 0030 B0B9     		cbnz	r0, .L2595
 23848 0032 2046     		mov	r0, r4
 23849              	.LVL2991:
 23850              	.L2570:
11580:Src/bno055.c  **** /*!
 23851              		.loc 1 11580 0
 23852 0034 40B2     		sxtb	r0, r0
 23853 0036 02B0     		add	sp, sp, #8
 23854              	.LCFI954:
 23855              		.cfi_remember_state
 23856              		.cfi_def_cfa_offset 16
 23857              		@ sp needed
 23858 0038 70BD     		pop	{r4, r5, r6, pc}
 23859              	.LVL2992:
 23860              	.L2571:
 23861              	.LCFI955:
 23862              		.cfi_restore_state
11491:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 23863              		.loc 1 11491 0
 23864 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 23865 003e B3B9     		cbnz	r3, .L2573
 23866              	.L2576:
 23867              	.LVL2993:
11496:Src/bno055.c  **** 	if (pg_stat_s8 == BNO055_SUCCESS) {
 23868              		.loc 1 11496 0
 23869 0040 0120     		movs	r0, #1
 23870 0042 FFF7FEFF 		bl	bno055_write_page_id
 23871              	.LVL2994:
11497:Src/bno055.c  **** 		/* Write the value of gyro bandwidth */
 23872              		.loc 1 11497 0
 23873 0046 0028     		cmp	r0, #0
 23874 0048 EFD1     		bne	.L2575
11499:Src/bno055.c  **** 			gyro_bw_u8 > BNO055_INIT_VALUE) &&
 23875              		.loc 1 11499 0
 23876 004a 072D     		cmp	r5, #7
 23877 004c 14D8     		bhi	.L2588
11502:Src/bno055.c  **** 			case BNO055_GYRO_BW_523HZ:
 23878              		.loc 1 11502 0
 23879 004e 6B1E     		subs	r3, r5, #1
 23880 0050 062B     		cmp	r3, #6
 23881 0052 13D8     		bhi	.L2589
 23882 0054 DFE803F0 		tbb	[pc, r3]
 23883              	.L2579:
 23884 0058 13       		.byte	(.L2577-.L2579)/2
 23885 0059 13       		.byte	(.L2577-.L2579)/2
 23886 005a 13       		.byte	(.L2577-.L2579)/2
 23887 005b 13       		.byte	(.L2577-.L2579)/2
 23888 005c 13       		.byte	(.L2577-.L2579)/2
 23889 005d 13       		.byte	(.L2577-.L2579)/2
 23890 005e 13       		.byte	(.L2577-.L2579)/2
 23891              	.LVL2995:
 23892 005f 00       		.p2align 1
 23893              	.L2595:
ARM GAS  /tmp/ccVWLGiI.s 			page 684


11577:Src/bno055.c  **** 	(prev_opmode_u8);
 23894              		.loc 1 11577 0
 23895 0060 FFF7FEFF 		bl	bno055_set_operation_mode
 23896              	.LVL2996:
 23897 0064 2044     		add	r0, r0, r4
 23898 0066 C0B2     		uxtb	r0, r0
 23899              	.LVL2997:
11580:Src/bno055.c  **** /*!
 23900              		.loc 1 11580 0
 23901 0068 40B2     		sxtb	r0, r0
 23902 006a 02B0     		add	sp, sp, #8
 23903              	.LCFI956:
 23904              		.cfi_remember_state
 23905              		.cfi_def_cfa_offset 16
 23906              		@ sp needed
 23907 006c 70BD     		pop	{r4, r5, r6, pc}
 23908              	.LVL2998:
 23909              	.L2573:
 23910              	.LCFI957:
 23911              		.cfi_restore_state
11492:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 23912              		.loc 1 11492 0
 23913 006e FFF7FEFF 		bl	bno055_set_operation_mode
 23914              	.LVL2999:
11494:Src/bno055.c  **** 		/* Write page as one */
 23915              		.loc 1 11494 0
 23916 0072 0028     		cmp	r0, #0
 23917 0074 D9D1     		bne	.L2575
 23918 0076 E3E7     		b	.L2576
 23919              	.LVL3000:
 23920              	.L2588:
11562:Src/bno055.c  **** 		}
 23921              		.loc 1 11562 0
 23922 0078 FE24     		movs	r4, #254
 23923 007a D7E7     		b	.L2572
 23924              	.L2589:
11504:Src/bno055.c  **** 			break;
 23925              		.loc 1 11504 0
 23926 007c 0025     		movs	r5, #0
 23927              	.L2577:
 23928              	.LVL3001:
11530:Src/bno055.c  **** 			(p_bno055->dev_addr,
 23929              		.loc 1 11530 0
 23930 007e 2368     		ldr	r3, [r4]
 23931 0080 01AA     		add	r2, sp, #4
 23932 0082 1C69     		ldr	r4, [r3, #16]
 23933 0084 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 23934              	.LVL3002:
 23935 0086 0A21     		movs	r1, #10
 23936 0088 0123     		movs	r3, #1
 23937 008a 184E     		ldr	r6, .L2597
 23938 008c A047     		blx	r4
 23939              	.LVL3003:
11534:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
 23940              		.loc 1 11534 0
 23941 008e D0B1     		cbz	r0, .L2596
 23942              	.LVL3004:
ARM GAS  /tmp/ccVWLGiI.s 			page 685


 23943              	.L2586:
11545:Src/bno055.c  **** 			(&gyro_opmode);
 23944              		.loc 1 11545 0
 23945 0090 0DF10500 		add	r0, sp, #5
 23946 0094 FFF7FEFF 		bl	bno055_get_gyro_power_mode
 23947              	.LVL3005:
11547:Src/bno055.c  **** 				if (gyro_opmode ==
 23948              		.loc 1 11547 0
 23949 0098 0446     		mov	r4, r0
 23950 009a 0028     		cmp	r0, #0
 23951 009c C6D1     		bne	.L2572
11548:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_ADVANCE_POWERSAVE) {
 23952              		.loc 1 11548 0
 23953 009e 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 23954 00a2 042B     		cmp	r3, #4
 23955 00a4 C2D1     		bne	.L2572
11551:Src/bno055.c  **** 					(&gyro_auto_sleep_durn);
 23956              		.loc 1 11551 0
 23957 00a6 0DF10600 		add	r0, sp, #6
 23958              	.LVL3006:
 23959 00aa FFF7FEFF 		bl	bno055_get_gyro_auto_sleep_durn
 23960              	.LVL3007:
11553:Src/bno055.c  **** 						com_rslt +=
 23961              		.loc 1 11553 0
 23962 00ae 0446     		mov	r4, r0
 23963 00b0 0028     		cmp	r0, #0
 23964 00b2 BBD1     		bne	.L2572
11555:Src/bno055.c  **** 						(gyro_auto_sleep_durn,
 23965              		.loc 1 11555 0
 23966 00b4 2946     		mov	r1, r5
 23967 00b6 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 23968              	.LVL3008:
 23969 00ba FFF7FEFF 		bl	bno055_gyro_set_auto_sleep_durn
 23970              	.LVL3009:
11554:Src/bno055.c  **** 						bno055_gyro_set_auto_sleep_durn
 23971              		.loc 1 11554 0
 23972 00be C4B2     		uxtb	r4, r0
 23973              	.LVL3010:
 23974 00c0 B4E7     		b	.L2572
 23975              	.LVL3011:
 23976              	.L2587:
11484:Src/bno055.c  **** } else {
 23977              		.loc 1 11484 0
 23978 00c2 8120     		movs	r0, #129
 23979              	.LVL3012:
 23980 00c4 B6E7     		b	.L2570
 23981              	.LVL3013:
 23982              	.L2596:
11535:Src/bno055.c  **** 				(data_u8r,
 23983              		.loc 1 11535 0
 23984 00c6 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 23985 00ca EA00     		lsls	r2, r5, #3
11540:Src/bno055.c  **** 				(p_bno055->dev_addr,
 23986              		.loc 1 11540 0
 23987 00cc 3168     		ldr	r1, [r6]
11535:Src/bno055.c  **** 				(data_u8r,
 23988              		.loc 1 11535 0
ARM GAS  /tmp/ccVWLGiI.s 			page 686


 23989 00ce 02F03802 		and	r2, r2, #56
 23990 00d2 23F03803 		bic	r3, r3, #56
 23991 00d6 1343     		orrs	r3, r3, r2
 23992 00d8 8DF80430 		strb	r3, [sp, #4]
11540:Src/bno055.c  **** 				(p_bno055->dev_addr,
 23993              		.loc 1 11540 0
 23994 00dc CC68     		ldr	r4, [r1, #12]
 23995 00de 01AA     		add	r2, sp, #4
 23996 00e0 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 23997              	.LVL3014:
 23998 00e2 0123     		movs	r3, #1
 23999 00e4 0A21     		movs	r1, #10
 24000 00e6 A047     		blx	r4
 24001              	.LVL3015:
 24002 00e8 D2E7     		b	.L2586
 24003              	.L2598:
 24004 00ea 00BF     		.align	2
 24005              	.L2597:
 24006 00ec 00000000 		.word	.LANCHOR0
 24007              		.cfi_endproc
 24008              	.LFE190:
 24010              		.section	.text.bno055_set_gyro_power_mode,"ax",%progbits
 24011              		.align	2
 24012              		.global	bno055_set_gyro_power_mode
 24013              		.thumb
 24014              		.thumb_func
 24016              	bno055_set_gyro_power_mode:
 24017              	.LFB192:
11656:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 24018              		.loc 1 11656 0
 24019              		.cfi_startproc
 24020              		@ args = 0, pretend = 0, frame = 8
 24021              		@ frame_needed = 0, uses_anonymous_args = 0
 24022              	.LVL3016:
 24023 0000 70B5     		push	{r4, r5, r6, lr}
 24024              	.LCFI958:
 24025              		.cfi_def_cfa_offset 16
 24026              		.cfi_offset 4, -16
 24027              		.cfi_offset 5, -12
 24028              		.cfi_offset 6, -8
 24029              		.cfi_offset 14, -4
11665:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 24030              		.loc 1 11665 0
 24031 0002 384C     		ldr	r4, .L2624
11656:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 24032              		.loc 1 11656 0
 24033 0004 82B0     		sub	sp, sp, #8
 24034              	.LCFI959:
 24035              		.cfi_def_cfa_offset 24
11665:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 24036              		.loc 1 11665 0
 24037 0006 2268     		ldr	r2, [r4]
11658:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 24038              		.loc 1 11658 0
 24039 0008 0023     		movs	r3, #0
 24040 000a 8DF80430 		strb	r3, [sp, #4]
 24041              	.LVL3017:
ARM GAS  /tmp/ccVWLGiI.s 			page 687


11660:Src/bno055.c  **** u8 gyro_bw_u8 = BNO055_INIT_VALUE;
 24042              		.loc 1 11660 0
 24043 000e 8DF80530 		strb	r3, [sp, #5]
11661:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 24044              		.loc 1 11661 0
 24045 0012 8DF80630 		strb	r3, [sp, #6]
 24046              	.LVL3018:
11663:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 24047              		.loc 1 11663 0
 24048 0016 8DF80730 		strb	r3, [sp, #7]
11665:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
 24049              		.loc 1 11665 0
 24050 001a 002A     		cmp	r2, #0
 24051 001c 59D0     		beq	.L2614
 24052 001e 0546     		mov	r5, r0
11671:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 24053              		.loc 1 11671 0
 24054 0020 0DF10700 		add	r0, sp, #7
 24055              	.LVL3019:
 24056 0024 FFF7FEFF 		bl	bno055_get_operation_mode
 24057              	.LVL3020:
11672:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 24058              		.loc 1 11672 0
 24059 0028 38B1     		cbz	r0, .L2601
 24060              	.LVL3021:
 24061              	.L2605:
11746:Src/bno055.c  **** }
 24062              		.loc 1 11746 0
 24063 002a FF24     		movs	r4, #255
 24064              	.LVL3022:
 24065              	.L2602:
11749:Src/bno055.c  **** 	/* set the operation mode of
 24066              		.loc 1 11749 0
 24067 002c 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 24068 0030 A0B9     		cbnz	r0, .L2622
 24069 0032 2046     		mov	r0, r4
 24070              	.LVL3023:
 24071              	.L2600:
11755:Src/bno055.c  **** /*!
 24072              		.loc 1 11755 0
 24073 0034 40B2     		sxtb	r0, r0
 24074 0036 02B0     		add	sp, sp, #8
 24075              	.LCFI960:
 24076              		.cfi_remember_state
 24077              		.cfi_def_cfa_offset 16
 24078              		@ sp needed
 24079 0038 70BD     		pop	{r4, r5, r6, pc}
 24080              	.LVL3024:
 24081              	.L2601:
 24082              	.LCFI961:
 24083              		.cfi_restore_state
11673:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 24084              		.loc 1 11673 0
 24085 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 24086 003e A3B9     		cbnz	r3, .L2603
 24087              	.L2606:
 24088              	.LVL3025:
ARM GAS  /tmp/ccVWLGiI.s 			page 688


11678:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
 24089              		.loc 1 11678 0
 24090 0040 0120     		movs	r0, #1
 24091 0042 FFF7FEFF 		bl	bno055_write_page_id
 24092              	.LVL3026:
11679:Src/bno055.c  **** 			/* Write the value of power mode*/
 24093              		.loc 1 11679 0
 24094 0046 0028     		cmp	r0, #0
 24095 0048 EFD1     		bne	.L2605
11681:Src/bno055.c  **** 			gyro_power_mode_u8 > BNO055_INIT_VALUE) &&
 24096              		.loc 1 11681 0
 24097 004a 042D     		cmp	r5, #4
 24098 004c 12D8     		bhi	.L2615
11684:Src/bno055.c  **** 				case BNO055_GYRO_POWER_MODE_NORMAL:
 24099              		.loc 1 11684 0
 24100 004e 6B1E     		subs	r3, r5, #1
 24101 0050 032B     		cmp	r3, #3
 24102 0052 3CD8     		bhi	.L2616
 24103 0054 DFE803F0 		tbb	[pc, r3]
 24104              	.L2609:
 24105 0058 20       		.byte	(.L2607-.L2609)/2
 24106 0059 20       		.byte	(.L2607-.L2609)/2
 24107 005a 20       		.byte	(.L2607-.L2609)/2
 24108 005b 10       		.byte	(.L2612-.L2609)/2
 24109              	.LVL3027:
 24110              		.p2align 1
 24111              	.L2622:
11752:Src/bno055.c  **** 	(prev_opmode_u8);
 24112              		.loc 1 11752 0
 24113 005c FFF7FEFF 		bl	bno055_set_operation_mode
 24114              	.LVL3028:
 24115 0060 2044     		add	r0, r0, r4
 24116 0062 C0B2     		uxtb	r0, r0
 24117              	.LVL3029:
11755:Src/bno055.c  **** /*!
 24118              		.loc 1 11755 0
 24119 0064 40B2     		sxtb	r0, r0
 24120 0066 02B0     		add	sp, sp, #8
 24121              	.LCFI962:
 24122              		.cfi_remember_state
 24123              		.cfi_def_cfa_offset 16
 24124              		@ sp needed
 24125 0068 70BD     		pop	{r4, r5, r6, pc}
 24126              	.LVL3030:
 24127              	.L2603:
 24128              	.LCFI963:
 24129              		.cfi_restore_state
11674:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 24130              		.loc 1 11674 0
 24131 006a FFF7FEFF 		bl	bno055_set_operation_mode
 24132              	.LVL3031:
11676:Src/bno055.c  **** 		/* Write page as one */
 24133              		.loc 1 11676 0
 24134 006e 0028     		cmp	r0, #0
 24135 0070 DBD1     		bne	.L2605
 24136 0072 E5E7     		b	.L2606
 24137              	.LVL3032:
ARM GAS  /tmp/ccVWLGiI.s 			page 689


 24138              	.L2615:
11737:Src/bno055.c  **** 			}
 24139              		.loc 1 11737 0
 24140 0074 FE24     		movs	r4, #254
 24141 0076 D9E7     		b	.L2602
 24142              	.L2612:
11702:Src/bno055.c  **** 				(&gyro_bw_u8);
 24143              		.loc 1 11702 0
 24144 0078 0DF10600 		add	r0, sp, #6
 24145              	.LVL3033:
 24146 007c FFF7FEFF 		bl	bno055_get_gyro_bw
 24147              	.LVL3034:
 24148 0080 0646     		mov	r6, r0
 24149              	.LVL3035:
11704:Src/bno055.c  **** 				(&gyro_auto_sleep_durn);
 24150              		.loc 1 11704 0
 24151 0082 0DF10500 		add	r0, sp, #5
 24152 0086 FFF7FEFF 		bl	bno055_get_gyro_auto_sleep_durn
 24153              	.LVL3036:
 24154 008a 3044     		add	r0, r0, r6
 24155              	.LVL3037:
11706:Src/bno055.c  **** 					bno055_gyro_set_auto_sleep_durn
 24156              		.loc 1 11706 0
 24157 008c 10F0FF0F 		tst	r0, #255
 24158 0090 21D0     		beq	.L2623
 24159              	.L2613:
11711:Src/bno055.c  **** 				gyro_power_mode_u8 =
 24160              		.loc 1 11711 0
 24161 0092 0120     		movs	r0, #1
 24162 0094 FFF7FEFF 		bl	bno055_write_page_id
 24163              	.LVL3038:
 24164              	.L2607:
11719:Src/bno055.c  **** 				(p_bno055->dev_addr,
 24165              		.loc 1 11719 0
 24166 0098 2368     		ldr	r3, [r4]
11718:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 24167              		.loc 1 11718 0
 24168 009a 01AA     		add	r2, sp, #4
 24169 009c 1C69     		ldr	r4, [r3, #16]
 24170 009e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24171 00a0 0B21     		movs	r1, #11
 24172 00a2 0123     		movs	r3, #1
 24173 00a4 A047     		blx	r4
 24174              	.LVL3039:
11719:Src/bno055.c  **** 				(p_bno055->dev_addr,
 24175              		.loc 1 11719 0
 24176 00a6 0F4A     		ldr	r2, .L2624
11724:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 24177              		.loc 1 11724 0
 24178 00a8 0446     		mov	r4, r0
 24179 00aa 0028     		cmp	r0, #0
 24180 00ac BED1     		bne	.L2602
11725:Src/bno055.c  **** 					(data_u8r,
 24181              		.loc 1 11725 0
 24182 00ae 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
11730:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24183              		.loc 1 11730 0
ARM GAS  /tmp/ccVWLGiI.s 			page 690


 24184 00b2 1168     		ldr	r1, [r2]
11725:Src/bno055.c  **** 					(data_u8r,
 24185              		.loc 1 11725 0
 24186 00b4 23F00703 		bic	r3, r3, #7
 24187 00b8 1D43     		orrs	r5, r5, r3
 24188              	.LVL3040:
11730:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24189              		.loc 1 11730 0
 24190 00ba CC68     		ldr	r4, [r1, #12]
 24191 00bc 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 24192              	.LVL3041:
 24193 00be 01AA     		add	r2, sp, #4
11725:Src/bno055.c  **** 					(data_u8r,
 24194              		.loc 1 11725 0
 24195 00c0 8DF80450 		strb	r5, [sp, #4]
11730:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24196              		.loc 1 11730 0
 24197 00c4 0B21     		movs	r1, #11
 24198 00c6 0123     		movs	r3, #1
 24199 00c8 A047     		blx	r4
 24200              	.LVL3042:
 24201 00ca 0446     		mov	r4, r0
 24202              	.LVL3043:
 24203 00cc AEE7     		b	.L2602
 24204              	.LVL3044:
 24205              	.L2616:
11686:Src/bno055.c  **** 				BNO055_GYRO_POWER_MODE_NORMAL;
 24206              		.loc 1 11686 0
 24207 00ce 0025     		movs	r5, #0
 24208 00d0 E2E7     		b	.L2607
 24209              	.LVL3045:
 24210              	.L2614:
11666:Src/bno055.c  **** } else {
 24211              		.loc 1 11666 0
 24212 00d2 8120     		movs	r0, #129
 24213              	.LVL3046:
 24214 00d4 AEE7     		b	.L2600
 24215              	.LVL3047:
 24216              	.L2623:
11707:Src/bno055.c  **** 					(gyro_auto_sleep_durn,
 24217              		.loc 1 11707 0
 24218 00d6 9DF80500 		ldrb	r0, [sp, #5]	@ zero_extendqisi2
 24219 00da 9DF80610 		ldrb	r1, [sp, #6]	@ zero_extendqisi2
 24220 00de FFF7FEFF 		bl	bno055_gyro_set_auto_sleep_durn
 24221              	.LVL3048:
 24222 00e2 D6E7     		b	.L2613
 24223              	.L2625:
 24224              		.align	2
 24225              	.L2624:
 24226 00e4 00000000 		.word	.LANCHOR0
 24227              		.cfi_endproc
 24228              	.LFE192:
 24230              		.section	.text.bno055_get_mag_sleep_mode,"ax",%progbits
 24231              		.align	2
 24232              		.global	bno055_get_mag_sleep_mode
 24233              		.thumb
 24234              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 691


 24236              	bno055_get_mag_sleep_mode:
 24237              	.LFB201:
12368:Src/bno055.c  **** /*!
12369:Src/bno055.c  ****  *	@brief This API used to read the mag sleep mode
12370:Src/bno055.c  ****  *	from page one register from 0x0E bit 0
12371:Src/bno055.c  ****  *
12372:Src/bno055.c  ****  *	@param sleep_mode_u8 : The value of mag sleep mode
12373:Src/bno055.c  ****  *
12374:Src/bno055.c  ****  *	@return results of bus communication function
12375:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12376:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12377:Src/bno055.c  ****  *
12378:Src/bno055.c  ****  *
12379:Src/bno055.c  ****  */
12380:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_mag_sleep_mode(
12381:Src/bno055.c  **** u8 *sleep_mode_u8)
12382:Src/bno055.c  **** {
 24238              		.loc 1 12382 0
 24239              		.cfi_startproc
 24240              		@ args = 0, pretend = 0, frame = 8
 24241              		@ frame_needed = 0, uses_anonymous_args = 0
 24242              	.LVL3049:
 24243 0000 30B5     		push	{r4, r5, lr}
 24244              	.LCFI964:
 24245              		.cfi_def_cfa_offset 12
 24246              		.cfi_offset 4, -12
 24247              		.cfi_offset 5, -8
 24248              		.cfi_offset 14, -4
12383:Src/bno055.c  **** 	/* Variable used to return value of
12384:Src/bno055.c  **** 	communication routine*/
12385:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12386:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12387:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12388:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12389:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 24249              		.loc 1 12389 0
 24250 0002 144C     		ldr	r4, .L2638
12382:Src/bno055.c  **** 	/* Variable used to return value of
 24251              		.loc 1 12382 0
 24252 0004 83B0     		sub	sp, sp, #12
 24253              	.LCFI965:
 24254              		.cfi_def_cfa_offset 24
 24255              		.loc 1 12389 0
 24256 0006 2368     		ldr	r3, [r4]
12386:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 24257              		.loc 1 12386 0
 24258 0008 0022     		movs	r2, #0
 24259 000a 8DF80720 		strb	r2, [sp, #7]
 24260              	.LVL3050:
 24261              		.loc 1 12389 0
 24262 000e FBB1     		cbz	r3, .L2630
12390:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12391:Src/bno055.c  **** 		} else {
12392:Src/bno055.c  **** 		/*condition check for page,mag sleep mode is
12393:Src/bno055.c  **** 		available in the page one*/
12394:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 24263              		.loc 1 12394 0
ARM GAS  /tmp/ccVWLGiI.s 			page 692


 24264 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24265 0012 0546     		mov	r5, r0
 24266 0014 012A     		cmp	r2, #1
 24267 0016 04D0     		beq	.L2628
12395:Src/bno055.c  **** 			/* Write page as one */
12396:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 24268              		.loc 1 12396 0
 24269 0018 0120     		movs	r0, #1
 24270              	.LVL3051:
 24271 001a FFF7FEFF 		bl	bno055_write_page_id
 24272              	.LVL3052:
 24273 001e 2368     		ldr	r3, [r4]
12397:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 24274              		.loc 1 12397 0
 24275 0020 70B9     		cbnz	r0, .L2637
 24276              	.LVL3053:
 24277              	.L2628:
12398:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12399:Src/bno055.c  **** 			/* Read the value of mag sleep mode*/
12400:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 24278              		.loc 1 12400 0
 24279 0022 1C69     		ldr	r4, [r3, #16]
 24280 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24281 0026 0E21     		movs	r1, #14
 24282 0028 0123     		movs	r3, #1
 24283 002a 0DF10702 		add	r2, sp, #7
 24284 002e A047     		blx	r4
 24285              	.LVL3054:
12401:Src/bno055.c  **** 			(p_bno055->dev_addr,
12402:Src/bno055.c  **** 			BNO055_MAG_SLEEP_MODE_REG,
12403:Src/bno055.c  **** 			&data_u8r,
12404:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
12405:Src/bno055.c  **** 			*sleep_mode_u8 =
 24286              		.loc 1 12405 0
 24287 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 24288 0034 03F00103 		and	r3, r3, #1
 24289 0038 2B70     		strb	r3, [r5]
 24290              	.LVL3055:
 24291              	.L2627:
12406:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
12407:Src/bno055.c  **** 			BNO055_MAG_SLEEP_MODE);
12408:Src/bno055.c  **** 		} else {
12409:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12410:Src/bno055.c  **** 		}
12411:Src/bno055.c  **** 	}
12412:Src/bno055.c  **** 	return com_rslt;
12413:Src/bno055.c  **** }
 24292              		.loc 1 12413 0
 24293 003a 40B2     		sxtb	r0, r0
 24294 003c 03B0     		add	sp, sp, #12
 24295              	.LCFI966:
 24296              		.cfi_remember_state
 24297              		.cfi_def_cfa_offset 12
 24298              		@ sp needed
 24299 003e 30BD     		pop	{r4, r5, pc}
 24300              	.LVL3056:
 24301              	.L2637:
ARM GAS  /tmp/ccVWLGiI.s 			page 693


 24302              	.LCFI967:
 24303              		.cfi_restore_state
12397:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24304              		.loc 1 12397 0 discriminator 1
 24305 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24306 0042 012A     		cmp	r2, #1
12409:Src/bno055.c  **** 		}
 24307              		.loc 1 12409 0 discriminator 1
 24308 0044 18BF     		it	ne
 24309 0046 FF20     		movne	r0, #255
12397:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24310              		.loc 1 12397 0 discriminator 1
 24311 0048 EBD0     		beq	.L2628
 24312              		.loc 1 12413 0
 24313 004a 40B2     		sxtb	r0, r0
 24314 004c 03B0     		add	sp, sp, #12
 24315              	.LCFI968:
 24316              		.cfi_remember_state
 24317              		.cfi_def_cfa_offset 12
 24318              		@ sp needed
 24319 004e 30BD     		pop	{r4, r5, pc}
 24320              	.LVL3057:
 24321              	.L2630:
 24322              	.LCFI969:
 24323              		.cfi_restore_state
12390:Src/bno055.c  **** 		} else {
 24324              		.loc 1 12390 0
 24325 0050 8120     		movs	r0, #129
 24326              	.LVL3058:
 24327 0052 F2E7     		b	.L2627
 24328              	.L2639:
 24329              		.align	2
 24330              	.L2638:
 24331 0054 00000000 		.word	.LANCHOR0
 24332              		.cfi_endproc
 24333              	.LFE201:
 24335              		.section	.text.bno055_set_mag_sleep_mode,"ax",%progbits
 24336              		.align	2
 24337              		.global	bno055_set_mag_sleep_mode
 24338              		.thumb
 24339              		.thumb_func
 24341              	bno055_set_mag_sleep_mode:
 24342              	.LFB202:
12414:Src/bno055.c  **** /*!
12415:Src/bno055.c  ****  *	@brief This API used to write the mag sleep mode
12416:Src/bno055.c  ****  *	from page one register from 0x0E bit 0
12417:Src/bno055.c  ****  *
12418:Src/bno055.c  ****  *	@param sleep_mode_u8 : The value of mag sleep mode
12419:Src/bno055.c  ****  *
12420:Src/bno055.c  ****  *	@return results of bus communication function
12421:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12422:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12423:Src/bno055.c  ****  *
12424:Src/bno055.c  ****  *
12425:Src/bno055.c  ****  */
12426:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_mag_sleep_mode(
12427:Src/bno055.c  **** u8 sleep_mode_u8)
ARM GAS  /tmp/ccVWLGiI.s 			page 694


12428:Src/bno055.c  **** {
 24343              		.loc 1 12428 0
 24344              		.cfi_startproc
 24345              		@ args = 0, pretend = 0, frame = 8
 24346              		@ frame_needed = 0, uses_anonymous_args = 0
 24347              	.LVL3059:
 24348 0000 30B5     		push	{r4, r5, lr}
 24349              	.LCFI970:
 24350              		.cfi_def_cfa_offset 12
 24351              		.cfi_offset 4, -12
 24352              		.cfi_offset 5, -8
 24353              		.cfi_offset 14, -4
12429:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12430:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
12431:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
12432:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
12433:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
12434:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
12435:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 24354              		.loc 1 12435 0
 24355 0002 264C     		ldr	r4, .L2656
12428:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 24356              		.loc 1 12428 0
 24357 0004 83B0     		sub	sp, sp, #12
 24358              	.LCFI971:
 24359              		.cfi_def_cfa_offset 24
 24360              		.loc 1 12435 0
 24361 0006 2268     		ldr	r2, [r4]
12430:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 24362              		.loc 1 12430 0
 24363 0008 0023     		movs	r3, #0
 24364 000a 8DF80630 		strb	r3, [sp, #6]
 24365              	.LVL3060:
12433:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 24366              		.loc 1 12433 0
 24367 000e 8DF80730 		strb	r3, [sp, #7]
 24368              		.loc 1 12435 0
 24369 0012 002A     		cmp	r2, #0
 24370 0014 40D0     		beq	.L2648
 24371 0016 0546     		mov	r5, r0
12436:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
12437:Src/bno055.c  **** } else {
12438:Src/bno055.c  **** 	/* The write operation effective only if the operation
12439:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
12440:Src/bno055.c  **** 	current operation mode and set the config mode */
12441:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 24372              		.loc 1 12441 0
 24373 0018 0DF10700 		add	r0, sp, #7
 24374              	.LVL3061:
 24375 001c FFF7FEFF 		bl	bno055_get_operation_mode
 24376              	.LVL3062:
12442:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 24377              		.loc 1 12442 0
 24378 0020 38B1     		cbz	r0, .L2642
 24379              	.LVL3063:
 24380              	.L2646:
12443:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
ARM GAS  /tmp/ccVWLGiI.s 			page 695


12444:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
12445:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
12446:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
12447:Src/bno055.c  **** 				/* Write page as one */
12448:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
12449:Src/bno055.c  **** 					BNO055_PAGE_ONE);
12450:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
12451:Src/bno055.c  **** 					com_rslt =
12452:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
12453:Src/bno055.c  **** 					(p_bno055->dev_addr,
12454:Src/bno055.c  **** 					BNO055_MAG_SLEEP_MODE_REG,
12455:Src/bno055.c  **** 					&data_u8r,
12456:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
12457:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
12458:Src/bno055.c  **** 						/* Write the value
12459:Src/bno055.c  **** 						of mag sleep mode*/
12460:Src/bno055.c  **** 						data_u8r =
12461:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
12462:Src/bno055.c  **** 						BNO055_MAG_SLEEP_MODE,
12463:Src/bno055.c  **** 						sleep_mode_u8);
12464:Src/bno055.c  **** 						com_rslt +=
12465:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
12466:Src/bno055.c  **** 						(p_bno055->dev_addr,
12467:Src/bno055.c  **** 						BNO055_MAG_SLEEP_MODE_REG,
12468:Src/bno055.c  **** 						&data_u8r,
12469:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
12470:Src/bno055.c  **** 					}
12471:Src/bno055.c  **** 				} else {
12472:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
12473:Src/bno055.c  **** 				}
12474:Src/bno055.c  **** 			} else {
12475:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
12476:Src/bno055.c  **** 			}
12477:Src/bno055.c  **** 		} else {
12478:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 24381              		.loc 1 12478 0
 24382 0022 FF24     		movs	r4, #255
 24383              	.LVL3064:
 24384              	.L2643:
12479:Src/bno055.c  **** 		}
12480:Src/bno055.c  **** 	}
12481:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 24385              		.loc 1 12481 0
 24386 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 24387 0028 50BB     		cbnz	r0, .L2655
 24388 002a 2046     		mov	r0, r4
 24389              	.LVL3065:
 24390              	.L2641:
12482:Src/bno055.c  **** 		/* set the operation mode of
12483:Src/bno055.c  **** 		previous operation mode*/
12484:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
12485:Src/bno055.c  **** 		(prev_opmode_u8);
12486:Src/bno055.c  **** 	return com_rslt;
12487:Src/bno055.c  **** }
 24391              		.loc 1 12487 0
 24392 002c 40B2     		sxtb	r0, r0
 24393 002e 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 696


 24394              	.LCFI972:
 24395              		.cfi_remember_state
 24396              		.cfi_def_cfa_offset 12
 24397              		@ sp needed
 24398 0030 30BD     		pop	{r4, r5, pc}
 24399              	.LVL3066:
 24400              	.L2642:
 24401              	.LCFI973:
 24402              		.cfi_restore_state
12443:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 24403              		.loc 1 12443 0
 24404 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 24405 0036 53BB     		cbnz	r3, .L2644
 24406              	.L2647:
 24407              	.LVL3067:
12448:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 24408              		.loc 1 12448 0
 24409 0038 0120     		movs	r0, #1
 24410 003a FFF7FEFF 		bl	bno055_write_page_id
 24411              	.LVL3068:
12450:Src/bno055.c  **** 					com_rslt =
 24412              		.loc 1 12450 0
 24413 003e 0028     		cmp	r0, #0
 24414 0040 EFD1     		bne	.L2646
12452:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24415              		.loc 1 12452 0
 24416 0042 2368     		ldr	r3, [r4]
12451:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 24417              		.loc 1 12451 0
 24418 0044 0DF10602 		add	r2, sp, #6
 24419 0048 1C69     		ldr	r4, [r3, #16]
 24420 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24421              	.LVL3069:
 24422 004c 0E21     		movs	r1, #14
 24423 004e 0123     		movs	r3, #1
 24424 0050 A047     		blx	r4
 24425              	.LVL3070:
12452:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24426              		.loc 1 12452 0
 24427 0052 124A     		ldr	r2, .L2656
12457:Src/bno055.c  **** 						/* Write the value
 24428              		.loc 1 12457 0
 24429 0054 0446     		mov	r4, r0
 24430 0056 0028     		cmp	r0, #0
 24431 0058 E4D1     		bne	.L2643
12460:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 24432              		.loc 1 12460 0
 24433 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
12465:Src/bno055.c  **** 						(p_bno055->dev_addr,
 24434              		.loc 1 12465 0
 24435 005e 1168     		ldr	r1, [r2]
12460:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 24436              		.loc 1 12460 0
 24437 0060 23F00103 		bic	r3, r3, #1
 24438 0064 05F00100 		and	r0, r5, #1
 24439              	.LVL3071:
 24440 0068 1843     		orrs	r0, r0, r3
ARM GAS  /tmp/ccVWLGiI.s 			page 697


12465:Src/bno055.c  **** 						(p_bno055->dev_addr,
 24441              		.loc 1 12465 0
 24442 006a CC68     		ldr	r4, [r1, #12]
12460:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 24443              		.loc 1 12460 0
 24444 006c 8DF80600 		strb	r0, [sp, #6]
12465:Src/bno055.c  **** 						(p_bno055->dev_addr,
 24445              		.loc 1 12465 0
 24446 0070 0DF10602 		add	r2, sp, #6
 24447 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 24448 0076 0123     		movs	r3, #1
 24449 0078 0E21     		movs	r1, #14
 24450 007a A047     		blx	r4
 24451              	.LVL3072:
 24452 007c 0446     		mov	r4, r0
 24453              	.LVL3073:
 24454 007e D1E7     		b	.L2643
 24455              	.L2655:
12484:Src/bno055.c  **** 		(prev_opmode_u8);
 24456              		.loc 1 12484 0
 24457 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 24458              	.LVL3074:
 24459 0084 2044     		add	r0, r0, r4
 24460 0086 C0B2     		uxtb	r0, r0
 24461              	.LVL3075:
 24462              		.loc 1 12487 0
 24463 0088 40B2     		sxtb	r0, r0
 24464 008a 03B0     		add	sp, sp, #12
 24465              	.LCFI974:
 24466              		.cfi_remember_state
 24467              		.cfi_def_cfa_offset 12
 24468              		@ sp needed
 24469 008c 30BD     		pop	{r4, r5, pc}
 24470              	.LVL3076:
 24471              	.L2644:
 24472              	.LCFI975:
 24473              		.cfi_restore_state
12444:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 24474              		.loc 1 12444 0
 24475 008e FFF7FEFF 		bl	bno055_set_operation_mode
 24476              	.LVL3077:
12446:Src/bno055.c  **** 				/* Write page as one */
 24477              		.loc 1 12446 0
 24478 0092 0028     		cmp	r0, #0
 24479 0094 C5D1     		bne	.L2646
 24480 0096 CFE7     		b	.L2647
 24481              	.LVL3078:
 24482              	.L2648:
12436:Src/bno055.c  **** } else {
 24483              		.loc 1 12436 0
 24484 0098 8120     		movs	r0, #129
 24485              	.LVL3079:
 24486 009a C7E7     		b	.L2641
 24487              	.L2657:
 24488              		.align	2
 24489              	.L2656:
 24490 009c 00000000 		.word	.LANCHOR0
ARM GAS  /tmp/ccVWLGiI.s 			page 698


 24491              		.cfi_endproc
 24492              	.LFE202:
 24494              		.section	.text.bno055_get_mag_sleep_durn,"ax",%progbits
 24495              		.align	2
 24496              		.global	bno055_get_mag_sleep_durn
 24497              		.thumb
 24498              		.thumb_func
 24500              	bno055_get_mag_sleep_durn:
 24501              	.LFB203:
12488:Src/bno055.c  **** /*!
12489:Src/bno055.c  ****  *	@brief This API used to read the mag sleep duration
12490:Src/bno055.c  ****  *	from page one register from 0x0E bit 1 to 4
12491:Src/bno055.c  ****  *
12492:Src/bno055.c  ****  *	@param sleep_durn_u8 : The value of mag sleep duration
12493:Src/bno055.c  ****  *
12494:Src/bno055.c  ****  *	@return results of bus communication function
12495:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12496:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12497:Src/bno055.c  ****  *
12498:Src/bno055.c  ****  *
12499:Src/bno055.c  ****  */
12500:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_mag_sleep_durn(
12501:Src/bno055.c  **** u8 *sleep_durn_u8)
12502:Src/bno055.c  **** {
 24502              		.loc 1 12502 0
 24503              		.cfi_startproc
 24504              		@ args = 0, pretend = 0, frame = 8
 24505              		@ frame_needed = 0, uses_anonymous_args = 0
 24506              	.LVL3080:
 24507 0000 30B5     		push	{r4, r5, lr}
 24508              	.LCFI976:
 24509              		.cfi_def_cfa_offset 12
 24510              		.cfi_offset 4, -12
 24511              		.cfi_offset 5, -8
 24512              		.cfi_offset 14, -4
12503:Src/bno055.c  **** 	/* Variable used to return value of
12504:Src/bno055.c  **** 	communication routine*/
12505:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12506:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12507:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12508:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12509:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 24513              		.loc 1 12509 0
 24514 0002 144C     		ldr	r4, .L2670
12502:Src/bno055.c  **** 	/* Variable used to return value of
 24515              		.loc 1 12502 0
 24516 0004 83B0     		sub	sp, sp, #12
 24517              	.LCFI977:
 24518              		.cfi_def_cfa_offset 24
 24519              		.loc 1 12509 0
 24520 0006 2368     		ldr	r3, [r4]
12506:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 24521              		.loc 1 12506 0
 24522 0008 0022     		movs	r2, #0
 24523 000a 8DF80720 		strb	r2, [sp, #7]
 24524              	.LVL3081:
 24525              		.loc 1 12509 0
ARM GAS  /tmp/ccVWLGiI.s 			page 699


 24526 000e FBB1     		cbz	r3, .L2662
12510:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12511:Src/bno055.c  **** 		} else {
12512:Src/bno055.c  **** 		/*condition check for page,mag sleep duration is
12513:Src/bno055.c  **** 		available in the page one*/
12514:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 24527              		.loc 1 12514 0
 24528 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24529 0012 0546     		mov	r5, r0
 24530 0014 012A     		cmp	r2, #1
 24531 0016 04D0     		beq	.L2660
12515:Src/bno055.c  **** 			/* Write page as one */
12516:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 24532              		.loc 1 12516 0
 24533 0018 0120     		movs	r0, #1
 24534              	.LVL3082:
 24535 001a FFF7FEFF 		bl	bno055_write_page_id
 24536              	.LVL3083:
 24537 001e 2368     		ldr	r3, [r4]
12517:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 24538              		.loc 1 12517 0
 24539 0020 70B9     		cbnz	r0, .L2669
 24540              	.LVL3084:
 24541              	.L2660:
12518:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12519:Src/bno055.c  **** 			/* Read the value of mag sleep duration*/
12520:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 24542              		.loc 1 12520 0
 24543 0022 1C69     		ldr	r4, [r3, #16]
 24544 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24545 0026 0E21     		movs	r1, #14
 24546 0028 0123     		movs	r3, #1
 24547 002a 0DF10702 		add	r2, sp, #7
 24548 002e A047     		blx	r4
 24549              	.LVL3085:
12521:Src/bno055.c  **** 			(p_bno055->dev_addr,
12522:Src/bno055.c  **** 			BNO055_MAG_SLEEP_DURN_REG,
12523:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12524:Src/bno055.c  **** 			*sleep_durn_u8 =
12525:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 24550              		.loc 1 12525 0
 24551 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 24552 0034 C3F34303 		ubfx	r3, r3, #1, #4
12524:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 24553              		.loc 1 12524 0
 24554 0038 2B70     		strb	r3, [r5]
 24555              	.LVL3086:
 24556              	.L2659:
12526:Src/bno055.c  **** 			BNO055_MAG_SLEEP_DURN);
12527:Src/bno055.c  **** 		} else {
12528:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12529:Src/bno055.c  **** 		}
12530:Src/bno055.c  **** 	}
12531:Src/bno055.c  **** 	return com_rslt;
12532:Src/bno055.c  **** }
 24557              		.loc 1 12532 0
 24558 003a 40B2     		sxtb	r0, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 700


 24559 003c 03B0     		add	sp, sp, #12
 24560              	.LCFI978:
 24561              		.cfi_remember_state
 24562              		.cfi_def_cfa_offset 12
 24563              		@ sp needed
 24564 003e 30BD     		pop	{r4, r5, pc}
 24565              	.LVL3087:
 24566              	.L2669:
 24567              	.LCFI979:
 24568              		.cfi_restore_state
12517:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24569              		.loc 1 12517 0 discriminator 1
 24570 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24571 0042 012A     		cmp	r2, #1
12528:Src/bno055.c  **** 		}
 24572              		.loc 1 12528 0 discriminator 1
 24573 0044 18BF     		it	ne
 24574 0046 FF20     		movne	r0, #255
12517:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24575              		.loc 1 12517 0 discriminator 1
 24576 0048 EBD0     		beq	.L2660
 24577              		.loc 1 12532 0
 24578 004a 40B2     		sxtb	r0, r0
 24579 004c 03B0     		add	sp, sp, #12
 24580              	.LCFI980:
 24581              		.cfi_remember_state
 24582              		.cfi_def_cfa_offset 12
 24583              		@ sp needed
 24584 004e 30BD     		pop	{r4, r5, pc}
 24585              	.LVL3088:
 24586              	.L2662:
 24587              	.LCFI981:
 24588              		.cfi_restore_state
12510:Src/bno055.c  **** 		} else {
 24589              		.loc 1 12510 0
 24590 0050 8120     		movs	r0, #129
 24591              	.LVL3089:
 24592 0052 F2E7     		b	.L2659
 24593              	.L2671:
 24594              		.align	2
 24595              	.L2670:
 24596 0054 00000000 		.word	.LANCHOR0
 24597              		.cfi_endproc
 24598              	.LFE203:
 24600              		.section	.text.bno055_set_mag_sleep_durn,"ax",%progbits
 24601              		.align	2
 24602              		.global	bno055_set_mag_sleep_durn
 24603              		.thumb
 24604              		.thumb_func
 24606              	bno055_set_mag_sleep_durn:
 24607              	.LFB204:
12533:Src/bno055.c  **** /*!
12534:Src/bno055.c  ****  *	@brief This API used to write the mag sleep duration
12535:Src/bno055.c  ****  *	from page one register from 0x0E bit 1 to 4
12536:Src/bno055.c  ****  *
12537:Src/bno055.c  ****  *	@param sleep_durn_u8 : The value of mag sleep duration
12538:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 701


12539:Src/bno055.c  ****  *	@return results of bus communication function
12540:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12541:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12542:Src/bno055.c  ****  *
12543:Src/bno055.c  ****  *
12544:Src/bno055.c  ****  */
12545:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_mag_sleep_durn(
12546:Src/bno055.c  **** u8 sleep_durn_u8)
12547:Src/bno055.c  **** {
 24608              		.loc 1 12547 0
 24609              		.cfi_startproc
 24610              		@ args = 0, pretend = 0, frame = 8
 24611              		@ frame_needed = 0, uses_anonymous_args = 0
 24612              	.LVL3090:
 24613 0000 30B5     		push	{r4, r5, lr}
 24614              	.LCFI982:
 24615              		.cfi_def_cfa_offset 12
 24616              		.cfi_offset 4, -12
 24617              		.cfi_offset 5, -8
 24618              		.cfi_offset 14, -4
12548:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12549:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
12550:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
12551:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
12552:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
12553:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
12554:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 24619              		.loc 1 12554 0
 24620 0002 274C     		ldr	r4, .L2688
12547:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 24621              		.loc 1 12547 0
 24622 0004 83B0     		sub	sp, sp, #12
 24623              	.LCFI983:
 24624              		.cfi_def_cfa_offset 24
 24625              		.loc 1 12554 0
 24626 0006 2268     		ldr	r2, [r4]
12549:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 24627              		.loc 1 12549 0
 24628 0008 0023     		movs	r3, #0
 24629 000a 8DF80630 		strb	r3, [sp, #6]
 24630              	.LVL3091:
12552:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 24631              		.loc 1 12552 0
 24632 000e 8DF80730 		strb	r3, [sp, #7]
 24633              		.loc 1 12554 0
 24634 0012 002A     		cmp	r2, #0
 24635 0014 41D0     		beq	.L2680
 24636 0016 0546     		mov	r5, r0
12555:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
12556:Src/bno055.c  **** } else {
12557:Src/bno055.c  **** 	/* The write operation effective only if the operation
12558:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
12559:Src/bno055.c  **** 	current operation mode and set the config mode */
12560:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 24637              		.loc 1 12560 0
 24638 0018 0DF10700 		add	r0, sp, #7
 24639              	.LVL3092:
ARM GAS  /tmp/ccVWLGiI.s 			page 702


 24640 001c FFF7FEFF 		bl	bno055_get_operation_mode
 24641              	.LVL3093:
12561:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 24642              		.loc 1 12561 0
 24643 0020 38B1     		cbz	r0, .L2674
 24644              	.LVL3094:
 24645              	.L2678:
12562:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
12563:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
12564:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
12565:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
12566:Src/bno055.c  **** 				/* Write page as one */
12567:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
12568:Src/bno055.c  **** 					BNO055_PAGE_ONE);
12569:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
12570:Src/bno055.c  **** 					com_rslt =
12571:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
12572:Src/bno055.c  **** 					(p_bno055->dev_addr,
12573:Src/bno055.c  **** 					BNO055_MAG_SLEEP_DURN_REG,
12574:Src/bno055.c  **** 					&data_u8r,
12575:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
12576:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
12577:Src/bno055.c  **** 						/* Write the value of
12578:Src/bno055.c  **** 						mag sleep duration */
12579:Src/bno055.c  **** 						data_u8r =
12580:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
12581:Src/bno055.c  **** 						BNO055_MAG_SLEEP_DURN,
12582:Src/bno055.c  **** 						sleep_durn_u8);
12583:Src/bno055.c  **** 						com_rslt +=
12584:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
12585:Src/bno055.c  **** 						(p_bno055->dev_addr,
12586:Src/bno055.c  **** 						BNO055_MAG_SLEEP_DURN_REG,
12587:Src/bno055.c  **** 						&data_u8r,
12588:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
12589:Src/bno055.c  **** 					}
12590:Src/bno055.c  **** 				} else {
12591:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
12592:Src/bno055.c  **** 				}
12593:Src/bno055.c  **** 			} else {
12594:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
12595:Src/bno055.c  **** 			}
12596:Src/bno055.c  **** 		} else {
12597:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 24646              		.loc 1 12597 0
 24647 0022 FF24     		movs	r4, #255
 24648              	.LVL3095:
 24649              	.L2675:
12598:Src/bno055.c  **** 		}
12599:Src/bno055.c  **** 	}
12600:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 24650              		.loc 1 12600 0
 24651 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 24652 0028 58BB     		cbnz	r0, .L2687
 24653 002a 2046     		mov	r0, r4
 24654              	.LVL3096:
 24655              	.L2673:
12601:Src/bno055.c  **** 		/* set the operation mode of
ARM GAS  /tmp/ccVWLGiI.s 			page 703


12602:Src/bno055.c  **** 		previous operation mode*/
12603:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
12604:Src/bno055.c  **** 		(prev_opmode_u8);
12605:Src/bno055.c  **** 	return com_rslt;
12606:Src/bno055.c  **** }
 24656              		.loc 1 12606 0
 24657 002c 40B2     		sxtb	r0, r0
 24658 002e 03B0     		add	sp, sp, #12
 24659              	.LCFI984:
 24660              		.cfi_remember_state
 24661              		.cfi_def_cfa_offset 12
 24662              		@ sp needed
 24663 0030 30BD     		pop	{r4, r5, pc}
 24664              	.LVL3097:
 24665              	.L2674:
 24666              	.LCFI985:
 24667              		.cfi_restore_state
12562:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 24668              		.loc 1 12562 0
 24669 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 24670 0036 5BBB     		cbnz	r3, .L2676
 24671              	.L2679:
 24672              	.LVL3098:
12567:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 24673              		.loc 1 12567 0
 24674 0038 0120     		movs	r0, #1
 24675 003a FFF7FEFF 		bl	bno055_write_page_id
 24676              	.LVL3099:
12569:Src/bno055.c  **** 					com_rslt =
 24677              		.loc 1 12569 0
 24678 003e 0028     		cmp	r0, #0
 24679 0040 EFD1     		bne	.L2678
12571:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24680              		.loc 1 12571 0
 24681 0042 2368     		ldr	r3, [r4]
12570:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 24682              		.loc 1 12570 0
 24683 0044 0E21     		movs	r1, #14
 24684 0046 1C69     		ldr	r4, [r3, #16]
 24685 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24686              	.LVL3100:
 24687 004a 0DF10602 		add	r2, sp, #6
 24688 004e 0123     		movs	r3, #1
 24689 0050 A047     		blx	r4
 24690              	.LVL3101:
12571:Src/bno055.c  **** 					(p_bno055->dev_addr,
 24691              		.loc 1 12571 0
 24692 0052 1349     		ldr	r1, .L2688
12576:Src/bno055.c  **** 						/* Write the value of
 24693              		.loc 1 12576 0
 24694 0054 0446     		mov	r4, r0
 24695 0056 0028     		cmp	r0, #0
 24696 0058 E4D1     		bne	.L2675
12579:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 24697              		.loc 1 12579 0
 24698 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
12580:Src/bno055.c  **** 						BNO055_MAG_SLEEP_DURN,
ARM GAS  /tmp/ccVWLGiI.s 			page 704


 24699              		.loc 1 12580 0
 24700 005e 6B00     		lsls	r3, r5, #1
12584:Src/bno055.c  **** 						(p_bno055->dev_addr,
 24701              		.loc 1 12584 0
 24702 0060 0968     		ldr	r1, [r1]
12579:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 24703              		.loc 1 12579 0
 24704 0062 22F01E02 		bic	r2, r2, #30
 24705 0066 03F01E03 		and	r3, r3, #30
 24706 006a 1343     		orrs	r3, r3, r2
12584:Src/bno055.c  **** 						(p_bno055->dev_addr,
 24707              		.loc 1 12584 0
 24708 006c CC68     		ldr	r4, [r1, #12]
12579:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 24709              		.loc 1 12579 0
 24710 006e 8DF80630 		strb	r3, [sp, #6]
12584:Src/bno055.c  **** 						(p_bno055->dev_addr,
 24711              		.loc 1 12584 0
 24712 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 24713              	.LVL3102:
 24714 0074 0DF10602 		add	r2, sp, #6
 24715 0078 0E21     		movs	r1, #14
 24716 007a 0123     		movs	r3, #1
 24717 007c A047     		blx	r4
 24718              	.LVL3103:
 24719 007e 0446     		mov	r4, r0
 24720              	.LVL3104:
 24721 0080 D0E7     		b	.L2675
 24722              	.L2687:
12603:Src/bno055.c  **** 		(prev_opmode_u8);
 24723              		.loc 1 12603 0
 24724 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 24725              	.LVL3105:
 24726 0086 2044     		add	r0, r0, r4
 24727 0088 C0B2     		uxtb	r0, r0
 24728              	.LVL3106:
 24729              		.loc 1 12606 0
 24730 008a 40B2     		sxtb	r0, r0
 24731 008c 03B0     		add	sp, sp, #12
 24732              	.LCFI986:
 24733              		.cfi_remember_state
 24734              		.cfi_def_cfa_offset 12
 24735              		@ sp needed
 24736 008e 30BD     		pop	{r4, r5, pc}
 24737              	.LVL3107:
 24738              	.L2676:
 24739              	.LCFI987:
 24740              		.cfi_restore_state
12563:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 24741              		.loc 1 12563 0
 24742 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 24743              	.LVL3108:
12565:Src/bno055.c  **** 				/* Write page as one */
 24744              		.loc 1 12565 0
 24745 0094 0028     		cmp	r0, #0
 24746 0096 C4D1     		bne	.L2678
 24747 0098 CEE7     		b	.L2679
ARM GAS  /tmp/ccVWLGiI.s 			page 705


 24748              	.LVL3109:
 24749              	.L2680:
12555:Src/bno055.c  **** } else {
 24750              		.loc 1 12555 0
 24751 009a 8120     		movs	r0, #129
 24752              	.LVL3110:
 24753 009c C6E7     		b	.L2673
 24754              	.L2689:
 24755 009e 00BF     		.align	2
 24756              	.L2688:
 24757 00a0 00000000 		.word	.LANCHOR0
 24758              		.cfi_endproc
 24759              	.LFE204:
 24761              		.section	.text.bno055_get_intr_mask_gyro_any_motion,"ax",%progbits
 24762              		.align	2
 24763              		.global	bno055_get_intr_mask_gyro_any_motion
 24764              		.thumb
 24765              		.thumb_func
 24767              	bno055_get_intr_mask_gyro_any_motion:
 24768              	.LFB205:
12607:Src/bno055.c  **** /*!
12608:Src/bno055.c  ****  *	@brief This API used to read the gyro anymotion interrupt mask
12609:Src/bno055.c  ****  *	from page one register from 0x0F bit 2
12610:Src/bno055.c  ****  *
12611:Src/bno055.c  ****  *	@param gyro_any_motion_u8 : The value of gyro anymotion interrupt mask
12612:Src/bno055.c  ****  *		gyro_any_motion_u8 |   result
12613:Src/bno055.c  ****  *     --------------------  |------------
12614:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
12615:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
12616:Src/bno055.c  ****  *
12617:Src/bno055.c  ****  *	@return results of bus communication function
12618:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12619:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12620:Src/bno055.c  ****  *
12621:Src/bno055.c  ****  *	@note While enabling the gyro anymotion interrupt
12622:Src/bno055.c  ****  *	configure the following settings
12623:Src/bno055.c  ****  *
12624:Src/bno055.c  ****  *	Axis:
12625:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_axis_enable()
12626:Src/bno055.c  ****  *
12627:Src/bno055.c  ****  *	Filter setting:
12628:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_filter()
12629:Src/bno055.c  ****  *
12630:Src/bno055.c  ****  *	Threshold :
12631:Src/bno055.c  ****  *
12632:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_thres()
12633:Src/bno055.c  ****  *
12634:Src/bno055.c  ****  *	Slope samples :
12635:Src/bno055.c  ****  *
12636:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_slope_samples()
12637:Src/bno055.c  ****  *
12638:Src/bno055.c  ****  *	Awake duration :
12639:Src/bno055.c  ****  *
12640:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_awake_durn()
12641:Src/bno055.c  ****  *
12642:Src/bno055.c  ****  */
12643:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_mask_gyro_any_motion(
ARM GAS  /tmp/ccVWLGiI.s 			page 706


12644:Src/bno055.c  **** u8 *gyro_any_motion_u8)
12645:Src/bno055.c  **** {
 24769              		.loc 1 12645 0
 24770              		.cfi_startproc
 24771              		@ args = 0, pretend = 0, frame = 8
 24772              		@ frame_needed = 0, uses_anonymous_args = 0
 24773              	.LVL3111:
 24774 0000 30B5     		push	{r4, r5, lr}
 24775              	.LCFI988:
 24776              		.cfi_def_cfa_offset 12
 24777              		.cfi_offset 4, -12
 24778              		.cfi_offset 5, -8
 24779              		.cfi_offset 14, -4
12646:Src/bno055.c  **** 	/* Variable used to return value of
12647:Src/bno055.c  **** 	communication routine*/
12648:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12649:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12650:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12651:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12652:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 24780              		.loc 1 12652 0
 24781 0002 144C     		ldr	r4, .L2702
12645:Src/bno055.c  **** 	/* Variable used to return value of
 24782              		.loc 1 12645 0
 24783 0004 83B0     		sub	sp, sp, #12
 24784              	.LCFI989:
 24785              		.cfi_def_cfa_offset 24
 24786              		.loc 1 12652 0
 24787 0006 2368     		ldr	r3, [r4]
12649:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 24788              		.loc 1 12649 0
 24789 0008 0022     		movs	r2, #0
 24790 000a 8DF80720 		strb	r2, [sp, #7]
 24791              	.LVL3112:
 24792              		.loc 1 12652 0
 24793 000e FBB1     		cbz	r3, .L2694
12653:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12654:Src/bno055.c  **** 		} else {
12655:Src/bno055.c  **** 		/*condition check for page, gyro anymotion interrupt mask is
12656:Src/bno055.c  **** 		available in the page one*/
12657:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 24794              		.loc 1 12657 0
 24795 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24796 0012 0546     		mov	r5, r0
 24797 0014 012A     		cmp	r2, #1
 24798 0016 04D0     		beq	.L2692
12658:Src/bno055.c  **** 			/* Write page as one */
12659:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 24799              		.loc 1 12659 0
 24800 0018 0120     		movs	r0, #1
 24801              	.LVL3113:
 24802 001a FFF7FEFF 		bl	bno055_write_page_id
 24803              	.LVL3114:
 24804 001e 2368     		ldr	r3, [r4]
12660:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 24805              		.loc 1 12660 0
 24806 0020 70B9     		cbnz	r0, .L2701
ARM GAS  /tmp/ccVWLGiI.s 			page 707


 24807              	.LVL3115:
 24808              	.L2692:
12661:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12662:Src/bno055.c  **** 			/* Read the value of gyro anymotion interrupt mask*/
12663:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 24809              		.loc 1 12663 0
 24810 0022 1C69     		ldr	r4, [r3, #16]
 24811 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24812 0026 0F21     		movs	r1, #15
 24813 0028 0123     		movs	r3, #1
 24814 002a 0DF10702 		add	r2, sp, #7
 24815 002e A047     		blx	r4
 24816              	.LVL3116:
12664:Src/bno055.c  **** 			(p_bno055->dev_addr,
12665:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR_MASK_REG,
12666:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12667:Src/bno055.c  **** 			*gyro_any_motion_u8 =
12668:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 24817              		.loc 1 12668 0
 24818 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 24819 0034 C3F38003 		ubfx	r3, r3, #2, #1
12667:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 24820              		.loc 1 12667 0
 24821 0038 2B70     		strb	r3, [r5]
 24822              	.LVL3117:
 24823              	.L2691:
12669:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR_MASK);
12670:Src/bno055.c  **** 		} else {
12671:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12672:Src/bno055.c  **** 		}
12673:Src/bno055.c  **** 	}
12674:Src/bno055.c  **** 	return com_rslt;
12675:Src/bno055.c  **** }
 24824              		.loc 1 12675 0
 24825 003a 40B2     		sxtb	r0, r0
 24826 003c 03B0     		add	sp, sp, #12
 24827              	.LCFI990:
 24828              		.cfi_remember_state
 24829              		.cfi_def_cfa_offset 12
 24830              		@ sp needed
 24831 003e 30BD     		pop	{r4, r5, pc}
 24832              	.LVL3118:
 24833              	.L2701:
 24834              	.LCFI991:
 24835              		.cfi_restore_state
12660:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24836              		.loc 1 12660 0 discriminator 1
 24837 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24838 0042 012A     		cmp	r2, #1
12671:Src/bno055.c  **** 		}
 24839              		.loc 1 12671 0 discriminator 1
 24840 0044 18BF     		it	ne
 24841 0046 FF20     		movne	r0, #255
12660:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24842              		.loc 1 12660 0 discriminator 1
 24843 0048 EBD0     		beq	.L2692
 24844              		.loc 1 12675 0
ARM GAS  /tmp/ccVWLGiI.s 			page 708


 24845 004a 40B2     		sxtb	r0, r0
 24846 004c 03B0     		add	sp, sp, #12
 24847              	.LCFI992:
 24848              		.cfi_remember_state
 24849              		.cfi_def_cfa_offset 12
 24850              		@ sp needed
 24851 004e 30BD     		pop	{r4, r5, pc}
 24852              	.LVL3119:
 24853              	.L2694:
 24854              	.LCFI993:
 24855              		.cfi_restore_state
12653:Src/bno055.c  **** 		} else {
 24856              		.loc 1 12653 0
 24857 0050 8120     		movs	r0, #129
 24858              	.LVL3120:
 24859 0052 F2E7     		b	.L2691
 24860              	.L2703:
 24861              		.align	2
 24862              	.L2702:
 24863 0054 00000000 		.word	.LANCHOR0
 24864              		.cfi_endproc
 24865              	.LFE205:
 24867              		.section	.text.bno055_set_intr_mask_gyro_any_motion,"ax",%progbits
 24868              		.align	2
 24869              		.global	bno055_set_intr_mask_gyro_any_motion
 24870              		.thumb
 24871              		.thumb_func
 24873              	bno055_set_intr_mask_gyro_any_motion:
 24874              	.LFB206:
12676:Src/bno055.c  **** /*!
12677:Src/bno055.c  ****  *	@brief This API used to write the gyro anymotion interrupt mask
12678:Src/bno055.c  ****  *	from page one register from 0x0F bit 2
12679:Src/bno055.c  ****  *
12680:Src/bno055.c  ****  *	@param gyro_any_motion_u8 : The value of gyro anymotion interrupt mask
12681:Src/bno055.c  ****  *		gyro_any_motion_u8 |   result
12682:Src/bno055.c  ****  *     --------------------  |------------
12683:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
12684:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
12685:Src/bno055.c  ****  *
12686:Src/bno055.c  ****  *	@return results of bus communication function
12687:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12688:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12689:Src/bno055.c  ****  *
12690:Src/bno055.c  ****  *	@note While enabling the gyro anymotion interrupt
12691:Src/bno055.c  ****  *	configure the following settings
12692:Src/bno055.c  ****  *
12693:Src/bno055.c  ****  *	Axis:
12694:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_axis_enable()
12695:Src/bno055.c  ****  *
12696:Src/bno055.c  ****  *	Filter setting:
12697:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_filter()
12698:Src/bno055.c  ****  *
12699:Src/bno055.c  ****  *	Threshold :
12700:Src/bno055.c  ****  *
12701:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_thres()
12702:Src/bno055.c  ****  *
12703:Src/bno055.c  ****  *	Slope samples :
ARM GAS  /tmp/ccVWLGiI.s 			page 709


12704:Src/bno055.c  ****  *
12705:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_slope_samples()
12706:Src/bno055.c  ****  *
12707:Src/bno055.c  ****  *	Awake duration :
12708:Src/bno055.c  ****  *
12709:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_awake_durn()
12710:Src/bno055.c  ****  *
12711:Src/bno055.c  ****  */
12712:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_mask_gyro_any_motion(
12713:Src/bno055.c  **** u8 gyro_any_motion_u8)
12714:Src/bno055.c  **** {
 24875              		.loc 1 12714 0
 24876              		.cfi_startproc
 24877              		@ args = 0, pretend = 0, frame = 8
 24878              		@ frame_needed = 0, uses_anonymous_args = 0
 24879              	.LVL3121:
 24880 0000 70B5     		push	{r4, r5, r6, lr}
 24881              	.LCFI994:
 24882              		.cfi_def_cfa_offset 16
 24883              		.cfi_offset 4, -16
 24884              		.cfi_offset 5, -12
 24885              		.cfi_offset 6, -8
 24886              		.cfi_offset 14, -4
12715:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12716:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12717:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12718:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12719:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 24887              		.loc 1 12719 0
 24888 0002 1D4D     		ldr	r5, .L2718
12714:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 24889              		.loc 1 12714 0
 24890 0004 82B0     		sub	sp, sp, #8
 24891              	.LCFI995:
 24892              		.cfi_def_cfa_offset 24
 24893              		.loc 1 12719 0
 24894 0006 2B68     		ldr	r3, [r5]
12716:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 24895              		.loc 1 12716 0
 24896 0008 0022     		movs	r2, #0
 24897 000a 8DF80720 		strb	r2, [sp, #7]
 24898              	.LVL3122:
 24899              		.loc 1 12719 0
 24900 000e 002B     		cmp	r3, #0
 24901 0010 30D0     		beq	.L2708
12720:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12721:Src/bno055.c  **** 		} else {
12722:Src/bno055.c  **** 		/*condition check for page, accel range is
12723:Src/bno055.c  **** 		available in the page one*/
12724:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 24902              		.loc 1 12724 0
 24903 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24904 0014 0446     		mov	r4, r0
 24905 0016 012A     		cmp	r2, #1
 24906 0018 04D0     		beq	.L2706
12725:Src/bno055.c  **** 			/* Write page as one */
12726:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
ARM GAS  /tmp/ccVWLGiI.s 			page 710


 24907              		.loc 1 12726 0
 24908 001a 0120     		movs	r0, #1
 24909              	.LVL3123:
 24910 001c FFF7FEFF 		bl	bno055_write_page_id
 24911              	.LVL3124:
 24912 0020 2B68     		ldr	r3, [r5]
12727:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 24913              		.loc 1 12727 0
 24914 0022 50B9     		cbnz	r0, .L2716
 24915              	.LVL3125:
 24916              	.L2706:
12728:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12729:Src/bno055.c  **** 			/* Write the value of gyro anymotion interrupt mask*/
12730:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 24917              		.loc 1 12730 0
 24918 0024 1E69     		ldr	r6, [r3, #16]
 24919 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 24920 0028 0DF10702 		add	r2, sp, #7
 24921 002c 0F21     		movs	r1, #15
 24922 002e 0123     		movs	r3, #1
 24923 0030 B047     		blx	r6
 24924              	.LVL3126:
12731:Src/bno055.c  **** 			(p_bno055->dev_addr,
12732:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR_MASK_REG,
12733:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12734:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 24925              		.loc 1 12734 0
 24926 0032 50B1     		cbz	r0, .L2717
 24927              	.LVL3127:
 24928              	.L2705:
12735:Src/bno055.c  **** 				data_u8r =
12736:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
12737:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_INTR_MASK,
12738:Src/bno055.c  **** 				gyro_any_motion_u8);
12739:Src/bno055.c  **** 				com_rslt +=
12740:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
12741:Src/bno055.c  **** 				(p_bno055->dev_addr,
12742:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_INTR_MASK_REG,
12743:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12744:Src/bno055.c  **** 			}
12745:Src/bno055.c  **** 		} else {
12746:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12747:Src/bno055.c  **** 		}
12748:Src/bno055.c  **** 	}
12749:Src/bno055.c  **** 	return com_rslt;
12750:Src/bno055.c  **** }
 24929              		.loc 1 12750 0
 24930 0034 40B2     		sxtb	r0, r0
 24931 0036 02B0     		add	sp, sp, #8
 24932              	.LCFI996:
 24933              		.cfi_remember_state
 24934              		.cfi_def_cfa_offset 16
 24935              		@ sp needed
 24936 0038 70BD     		pop	{r4, r5, r6, pc}
 24937              	.LVL3128:
 24938              	.L2716:
 24939              	.LCFI997:
ARM GAS  /tmp/ccVWLGiI.s 			page 711


 24940              		.cfi_restore_state
12727:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24941              		.loc 1 12727 0 discriminator 1
 24942 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 24943 003c 012A     		cmp	r2, #1
12746:Src/bno055.c  **** 		}
 24944              		.loc 1 12746 0 discriminator 1
 24945 003e 18BF     		it	ne
 24946 0040 FF20     		movne	r0, #255
12727:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 24947              		.loc 1 12727 0 discriminator 1
 24948 0042 EFD0     		beq	.L2706
 24949              		.loc 1 12750 0
 24950 0044 40B2     		sxtb	r0, r0
 24951 0046 02B0     		add	sp, sp, #8
 24952              	.LCFI998:
 24953              		.cfi_remember_state
 24954              		.cfi_def_cfa_offset 16
 24955              		@ sp needed
 24956 0048 70BD     		pop	{r4, r5, r6, pc}
 24957              	.LVL3129:
 24958              	.L2717:
 24959              	.LCFI999:
 24960              		.cfi_restore_state
12735:Src/bno055.c  **** 				data_u8r =
 24961              		.loc 1 12735 0
 24962 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
12736:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_INTR_MASK,
 24963              		.loc 1 12736 0
 24964 004e A000     		lsls	r0, r4, #2
 24965              	.LVL3130:
12740:Src/bno055.c  **** 				(p_bno055->dev_addr,
 24966              		.loc 1 12740 0
 24967 0050 2968     		ldr	r1, [r5]
12735:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 24968              		.loc 1 12735 0
 24969 0052 23F00404 		bic	r4, r3, #4
 24970 0056 00F00400 		and	r0, r0, #4
 24971 005a 2043     		orrs	r0, r0, r4
 24972 005c 8DF80700 		strb	r0, [sp, #7]
12740:Src/bno055.c  **** 				(p_bno055->dev_addr,
 24973              		.loc 1 12740 0
 24974 0060 CC68     		ldr	r4, [r1, #12]
 24975 0062 0DF10702 		add	r2, sp, #7
 24976 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 24977 0068 0123     		movs	r3, #1
 24978 006a 0F21     		movs	r1, #15
 24979 006c A047     		blx	r4
 24980              	.LVL3131:
 24981              		.loc 1 12750 0
 24982 006e 40B2     		sxtb	r0, r0
 24983 0070 02B0     		add	sp, sp, #8
 24984              	.LCFI1000:
 24985              		.cfi_remember_state
 24986              		.cfi_def_cfa_offset 16
 24987              		@ sp needed
 24988 0072 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  /tmp/ccVWLGiI.s 			page 712


 24989              	.LVL3132:
 24990              	.L2708:
 24991              	.LCFI1001:
 24992              		.cfi_restore_state
12720:Src/bno055.c  **** 		} else {
 24993              		.loc 1 12720 0
 24994 0074 8120     		movs	r0, #129
 24995              	.LVL3133:
 24996 0076 DDE7     		b	.L2705
 24997              	.L2719:
 24998              		.align	2
 24999              	.L2718:
 25000 0078 00000000 		.word	.LANCHOR0
 25001              		.cfi_endproc
 25002              	.LFE206:
 25004              		.section	.text.bno055_get_intr_mask_gyro_highrate,"ax",%progbits
 25005              		.align	2
 25006              		.global	bno055_get_intr_mask_gyro_highrate
 25007              		.thumb
 25008              		.thumb_func
 25010              	bno055_get_intr_mask_gyro_highrate:
 25011              	.LFB207:
12751:Src/bno055.c  **** /*!
12752:Src/bno055.c  ****  *	@brief This API used to read the gyro highrate interrupt mask
12753:Src/bno055.c  ****  *	from page one register from 0x0F bit 3
12754:Src/bno055.c  ****  *
12755:Src/bno055.c  ****  *	@param gyro_highrate_u8 : The value of gyro highrate interrupt mask
12756:Src/bno055.c  ****  *		  gyro_highrate_u8 |  result
12757:Src/bno055.c  ****  *     --------------------  |------------
12758:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
12759:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
12760:Src/bno055.c  ****  *
12761:Src/bno055.c  ****  *	@return results of bus communication function
12762:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12763:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12764:Src/bno055.c  ****  *
12765:Src/bno055.c  ****  *	@note While enabling the gyro highrate interrupt
12766:Src/bno055.c  ****  *	configure the below settings by using
12767:Src/bno055.c  ****  *	the following API
12768:Src/bno055.c  ****  *
12769:Src/bno055.c  ****  *	Axis :
12770:Src/bno055.c  ****  *
12771:Src/bno055.c  ****  *	bno055_set_gyro_highrate_axis_enable()
12772:Src/bno055.c  ****  *
12773:Src/bno055.c  ****  *	Filter :
12774:Src/bno055.c  ****  *
12775:Src/bno055.c  ****  *	bno055_set_gyro_highrate_filter()
12776:Src/bno055.c  ****  *
12777:Src/bno055.c  ****  *	Threshold :
12778:Src/bno055.c  ****  *
12779:Src/bno055.c  ****  *	bno055_get_gyro_highrate_x_thres()
12780:Src/bno055.c  ****  *
12781:Src/bno055.c  ****  *	bno055_get_gyro_highrate_y_thres()
12782:Src/bno055.c  ****  *
12783:Src/bno055.c  ****  *	bno055_get_gyro_highrate_z_thres()
12784:Src/bno055.c  ****  *
12785:Src/bno055.c  ****  *	Hysteresis :
ARM GAS  /tmp/ccVWLGiI.s 			page 713


12786:Src/bno055.c  ****  *
12787:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_hyst()
12788:Src/bno055.c  ****  *
12789:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_hyst()
12790:Src/bno055.c  ****  *
12791:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_hyst()
12792:Src/bno055.c  ****  *
12793:Src/bno055.c  ****  *	Duration :
12794:Src/bno055.c  ****  *
12795:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_durn()
12796:Src/bno055.c  ****  *
12797:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_durn()
12798:Src/bno055.c  ****  *
12799:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_durn()
12800:Src/bno055.c  ****  *
12801:Src/bno055.c  ****  */
12802:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_mask_gyro_highrate(
12803:Src/bno055.c  **** u8 *gyro_highrate_u8)
12804:Src/bno055.c  **** {
 25012              		.loc 1 12804 0
 25013              		.cfi_startproc
 25014              		@ args = 0, pretend = 0, frame = 8
 25015              		@ frame_needed = 0, uses_anonymous_args = 0
 25016              	.LVL3134:
 25017 0000 30B5     		push	{r4, r5, lr}
 25018              	.LCFI1002:
 25019              		.cfi_def_cfa_offset 12
 25020              		.cfi_offset 4, -12
 25021              		.cfi_offset 5, -8
 25022              		.cfi_offset 14, -4
12805:Src/bno055.c  **** 	/* Variable used to return value of
12806:Src/bno055.c  **** 	communication routine*/
12807:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12808:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12809:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12810:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12811:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25023              		.loc 1 12811 0
 25024 0002 144C     		ldr	r4, .L2732
12804:Src/bno055.c  **** 	/* Variable used to return value of
 25025              		.loc 1 12804 0
 25026 0004 83B0     		sub	sp, sp, #12
 25027              	.LCFI1003:
 25028              		.cfi_def_cfa_offset 24
 25029              		.loc 1 12811 0
 25030 0006 2368     		ldr	r3, [r4]
12808:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25031              		.loc 1 12808 0
 25032 0008 0022     		movs	r2, #0
 25033 000a 8DF80720 		strb	r2, [sp, #7]
 25034              	.LVL3135:
 25035              		.loc 1 12811 0
 25036 000e FBB1     		cbz	r3, .L2724
12812:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12813:Src/bno055.c  **** 		} else {
12814:Src/bno055.c  **** 		/*condition check for page, gyro highrate interrupt mask is
12815:Src/bno055.c  **** 		available in the page one*/
ARM GAS  /tmp/ccVWLGiI.s 			page 714


12816:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25037              		.loc 1 12816 0
 25038 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25039 0012 0546     		mov	r5, r0
 25040 0014 012A     		cmp	r2, #1
 25041 0016 04D0     		beq	.L2722
12817:Src/bno055.c  **** 			/* Write page as one */
12818:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25042              		.loc 1 12818 0
 25043 0018 0120     		movs	r0, #1
 25044              	.LVL3136:
 25045 001a FFF7FEFF 		bl	bno055_write_page_id
 25046              	.LVL3137:
 25047 001e 2368     		ldr	r3, [r4]
12819:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25048              		.loc 1 12819 0
 25049 0020 70B9     		cbnz	r0, .L2731
 25050              	.LVL3138:
 25051              	.L2722:
12820:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12821:Src/bno055.c  **** 			/* Read the value of gyro highrate interrupt mask*/
12822:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25052              		.loc 1 12822 0
 25053 0022 1C69     		ldr	r4, [r3, #16]
 25054 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25055 0026 0F21     		movs	r1, #15
 25056 0028 0123     		movs	r3, #1
 25057 002a 0DF10702 		add	r2, sp, #7
 25058 002e A047     		blx	r4
 25059              	.LVL3139:
12823:Src/bno055.c  **** 			(p_bno055->dev_addr,
12824:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_INTR_MASK_REG,
12825:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12826:Src/bno055.c  **** 			*gyro_highrate_u8 =
12827:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25060              		.loc 1 12827 0
 25061 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 25062 0034 C3F3C003 		ubfx	r3, r3, #3, #1
12826:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25063              		.loc 1 12826 0
 25064 0038 2B70     		strb	r3, [r5]
 25065              	.LVL3140:
 25066              	.L2721:
12828:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_INTR_MASK);
12829:Src/bno055.c  **** 		} else {
12830:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12831:Src/bno055.c  **** 		}
12832:Src/bno055.c  **** 	}
12833:Src/bno055.c  **** 	return com_rslt;
12834:Src/bno055.c  **** }
 25067              		.loc 1 12834 0
 25068 003a 40B2     		sxtb	r0, r0
 25069 003c 03B0     		add	sp, sp, #12
 25070              	.LCFI1004:
 25071              		.cfi_remember_state
 25072              		.cfi_def_cfa_offset 12
 25073              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 715


 25074 003e 30BD     		pop	{r4, r5, pc}
 25075              	.LVL3141:
 25076              	.L2731:
 25077              	.LCFI1005:
 25078              		.cfi_restore_state
12819:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25079              		.loc 1 12819 0 discriminator 1
 25080 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25081 0042 012A     		cmp	r2, #1
12830:Src/bno055.c  **** 		}
 25082              		.loc 1 12830 0 discriminator 1
 25083 0044 18BF     		it	ne
 25084 0046 FF20     		movne	r0, #255
12819:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25085              		.loc 1 12819 0 discriminator 1
 25086 0048 EBD0     		beq	.L2722
 25087              		.loc 1 12834 0
 25088 004a 40B2     		sxtb	r0, r0
 25089 004c 03B0     		add	sp, sp, #12
 25090              	.LCFI1006:
 25091              		.cfi_remember_state
 25092              		.cfi_def_cfa_offset 12
 25093              		@ sp needed
 25094 004e 30BD     		pop	{r4, r5, pc}
 25095              	.LVL3142:
 25096              	.L2724:
 25097              	.LCFI1007:
 25098              		.cfi_restore_state
12812:Src/bno055.c  **** 		} else {
 25099              		.loc 1 12812 0
 25100 0050 8120     		movs	r0, #129
 25101              	.LVL3143:
 25102 0052 F2E7     		b	.L2721
 25103              	.L2733:
 25104              		.align	2
 25105              	.L2732:
 25106 0054 00000000 		.word	.LANCHOR0
 25107              		.cfi_endproc
 25108              	.LFE207:
 25110              		.section	.text.bno055_set_intr_mask_gyro_highrate,"ax",%progbits
 25111              		.align	2
 25112              		.global	bno055_set_intr_mask_gyro_highrate
 25113              		.thumb
 25114              		.thumb_func
 25116              	bno055_set_intr_mask_gyro_highrate:
 25117              	.LFB208:
12835:Src/bno055.c  **** /*!
12836:Src/bno055.c  ****  *	@brief This API used to write the gyro highrate interrupt mask
12837:Src/bno055.c  ****  *	from page one register from 0x0F bit 3
12838:Src/bno055.c  ****  *
12839:Src/bno055.c  ****  *	@param gyro_highrate_u8 : The value of gyro highrate interrupt mask
12840:Src/bno055.c  ****  *		  gyro_highrate_u8 |  result
12841:Src/bno055.c  ****  *     --------------------  |------------
12842:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
12843:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
12844:Src/bno055.c  ****  *
12845:Src/bno055.c  ****  *	@return results of bus communication function
ARM GAS  /tmp/ccVWLGiI.s 			page 716


12846:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12847:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12848:Src/bno055.c  ****  *
12849:Src/bno055.c  ****  *	@note While enabling the gyro highrate interrupt
12850:Src/bno055.c  ****  *	configure the below settings by using
12851:Src/bno055.c  ****  *	the following APIs
12852:Src/bno055.c  ****  *
12853:Src/bno055.c  ****  *	Axis :
12854:Src/bno055.c  ****  *
12855:Src/bno055.c  ****  *	bno055_set_gyro_highrate_axis_enable()
12856:Src/bno055.c  ****  *
12857:Src/bno055.c  ****  *	Filter :
12858:Src/bno055.c  ****  *
12859:Src/bno055.c  ****  *	bno055_set_gyro_highrate_filter()
12860:Src/bno055.c  ****  *
12861:Src/bno055.c  ****  *	Threshold :
12862:Src/bno055.c  ****  *
12863:Src/bno055.c  ****  *	bno055_get_gyro_highrate_x_thres()
12864:Src/bno055.c  ****  *
12865:Src/bno055.c  ****  *	bno055_get_gyro_highrate_y_thres()
12866:Src/bno055.c  ****  *
12867:Src/bno055.c  ****  *	bno055_get_gyro_highrate_z_thres()
12868:Src/bno055.c  ****  *
12869:Src/bno055.c  ****  *	Hysteresis :
12870:Src/bno055.c  ****  *
12871:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_hyst()
12872:Src/bno055.c  ****  *
12873:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_hyst()
12874:Src/bno055.c  ****  *
12875:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_hyst()
12876:Src/bno055.c  ****  *
12877:Src/bno055.c  ****  *	Duration :
12878:Src/bno055.c  ****  *
12879:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_durn()
12880:Src/bno055.c  ****  *
12881:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_durn()
12882:Src/bno055.c  ****  *
12883:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_durn()
12884:Src/bno055.c  ****  *
12885:Src/bno055.c  ****  */
12886:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_mask_gyro_highrate(
12887:Src/bno055.c  **** u8 gyro_highrate_u8)
12888:Src/bno055.c  **** {
 25118              		.loc 1 12888 0
 25119              		.cfi_startproc
 25120              		@ args = 0, pretend = 0, frame = 8
 25121              		@ frame_needed = 0, uses_anonymous_args = 0
 25122              	.LVL3144:
 25123 0000 70B5     		push	{r4, r5, r6, lr}
 25124              	.LCFI1008:
 25125              		.cfi_def_cfa_offset 16
 25126              		.cfi_offset 4, -16
 25127              		.cfi_offset 5, -12
 25128              		.cfi_offset 6, -8
 25129              		.cfi_offset 14, -4
12889:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12890:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
ARM GAS  /tmp/ccVWLGiI.s 			page 717


12891:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12892:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12893:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25130              		.loc 1 12893 0
 25131 0002 1D4D     		ldr	r5, .L2748
12888:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 25132              		.loc 1 12888 0
 25133 0004 82B0     		sub	sp, sp, #8
 25134              	.LCFI1009:
 25135              		.cfi_def_cfa_offset 24
 25136              		.loc 1 12893 0
 25137 0006 2B68     		ldr	r3, [r5]
12890:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25138              		.loc 1 12890 0
 25139 0008 0022     		movs	r2, #0
 25140 000a 8DF80720 		strb	r2, [sp, #7]
 25141              	.LVL3145:
 25142              		.loc 1 12893 0
 25143 000e 002B     		cmp	r3, #0
 25144 0010 30D0     		beq	.L2738
12894:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12895:Src/bno055.c  **** 		} else {
12896:Src/bno055.c  **** 		/*condition check for page, gyro highrate interrupt mask is
12897:Src/bno055.c  **** 		available in the page one*/
12898:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25145              		.loc 1 12898 0
 25146 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25147 0014 0446     		mov	r4, r0
 25148 0016 012A     		cmp	r2, #1
 25149 0018 04D0     		beq	.L2736
12899:Src/bno055.c  **** 			/* Write page as one */
12900:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25150              		.loc 1 12900 0
 25151 001a 0120     		movs	r0, #1
 25152              	.LVL3146:
 25153 001c FFF7FEFF 		bl	bno055_write_page_id
 25154              	.LVL3147:
 25155 0020 2B68     		ldr	r3, [r5]
12901:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25156              		.loc 1 12901 0
 25157 0022 50B9     		cbnz	r0, .L2746
 25158              	.LVL3148:
 25159              	.L2736:
12902:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12903:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25160              		.loc 1 12903 0
 25161 0024 1E69     		ldr	r6, [r3, #16]
 25162 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25163 0028 0DF10702 		add	r2, sp, #7
 25164 002c 0F21     		movs	r1, #15
 25165 002e 0123     		movs	r3, #1
 25166 0030 B047     		blx	r6
 25167              	.LVL3149:
12904:Src/bno055.c  **** 			(p_bno055->dev_addr,
12905:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_INTR_MASK_REG,
12906:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12907:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 718


 25168              		.loc 1 12907 0
 25169 0032 50B1     		cbz	r0, .L2747
 25170              	.LVL3150:
 25171              	.L2735:
12908:Src/bno055.c  **** 				/* Write the value of gyro
12909:Src/bno055.c  **** 				highrate interrupt mask*/
12910:Src/bno055.c  **** 				data_u8r =
12911:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
12912:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_INTR_MASK,
12913:Src/bno055.c  **** 				gyro_highrate_u8);
12914:Src/bno055.c  **** 				com_rslt +=
12915:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
12916:Src/bno055.c  **** 				(p_bno055->dev_addr,
12917:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_INTR_MASK_REG,
12918:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12919:Src/bno055.c  **** 			}
12920:Src/bno055.c  **** 		} else {
12921:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12922:Src/bno055.c  **** 		}
12923:Src/bno055.c  **** 	}
12924:Src/bno055.c  **** 	return com_rslt;
12925:Src/bno055.c  **** }
 25172              		.loc 1 12925 0
 25173 0034 40B2     		sxtb	r0, r0
 25174 0036 02B0     		add	sp, sp, #8
 25175              	.LCFI1010:
 25176              		.cfi_remember_state
 25177              		.cfi_def_cfa_offset 16
 25178              		@ sp needed
 25179 0038 70BD     		pop	{r4, r5, r6, pc}
 25180              	.LVL3151:
 25181              	.L2746:
 25182              	.LCFI1011:
 25183              		.cfi_restore_state
12901:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25184              		.loc 1 12901 0 discriminator 1
 25185 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25186 003c 012A     		cmp	r2, #1
12921:Src/bno055.c  **** 		}
 25187              		.loc 1 12921 0 discriminator 1
 25188 003e 18BF     		it	ne
 25189 0040 FF20     		movne	r0, #255
12901:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25190              		.loc 1 12901 0 discriminator 1
 25191 0042 EFD0     		beq	.L2736
 25192              		.loc 1 12925 0
 25193 0044 40B2     		sxtb	r0, r0
 25194 0046 02B0     		add	sp, sp, #8
 25195              	.LCFI1012:
 25196              		.cfi_remember_state
 25197              		.cfi_def_cfa_offset 16
 25198              		@ sp needed
 25199 0048 70BD     		pop	{r4, r5, r6, pc}
 25200              	.LVL3152:
 25201              	.L2747:
 25202              	.LCFI1013:
 25203              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 719


12910:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25204              		.loc 1 12910 0
 25205 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
12911:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_INTR_MASK,
 25206              		.loc 1 12911 0
 25207 004e E000     		lsls	r0, r4, #3
 25208              	.LVL3153:
12915:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25209              		.loc 1 12915 0
 25210 0050 2968     		ldr	r1, [r5]
12910:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25211              		.loc 1 12910 0
 25212 0052 23F00804 		bic	r4, r3, #8
 25213 0056 00F00800 		and	r0, r0, #8
 25214 005a 2043     		orrs	r0, r0, r4
 25215 005c 8DF80700 		strb	r0, [sp, #7]
12915:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25216              		.loc 1 12915 0
 25217 0060 CC68     		ldr	r4, [r1, #12]
 25218 0062 0DF10702 		add	r2, sp, #7
 25219 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 25220 0068 0123     		movs	r3, #1
 25221 006a 0F21     		movs	r1, #15
 25222 006c A047     		blx	r4
 25223              	.LVL3154:
 25224              		.loc 1 12925 0
 25225 006e 40B2     		sxtb	r0, r0
 25226 0070 02B0     		add	sp, sp, #8
 25227              	.LCFI1014:
 25228              		.cfi_remember_state
 25229              		.cfi_def_cfa_offset 16
 25230              		@ sp needed
 25231 0072 70BD     		pop	{r4, r5, r6, pc}
 25232              	.LVL3155:
 25233              	.L2738:
 25234              	.LCFI1015:
 25235              		.cfi_restore_state
12894:Src/bno055.c  **** 		} else {
 25236              		.loc 1 12894 0
 25237 0074 8120     		movs	r0, #129
 25238              	.LVL3156:
 25239 0076 DDE7     		b	.L2735
 25240              	.L2749:
 25241              		.align	2
 25242              	.L2748:
 25243 0078 00000000 		.word	.LANCHOR0
 25244              		.cfi_endproc
 25245              	.LFE208:
 25247              		.section	.text.bno055_get_intr_mask_accel_high_g,"ax",%progbits
 25248              		.align	2
 25249              		.global	bno055_get_intr_mask_accel_high_g
 25250              		.thumb
 25251              		.thumb_func
 25253              	bno055_get_intr_mask_accel_high_g:
 25254              	.LFB209:
12926:Src/bno055.c  **** /*!
12927:Src/bno055.c  ****  *	@brief This API used to read the accel highg interrupt mask
ARM GAS  /tmp/ccVWLGiI.s 			page 720


12928:Src/bno055.c  ****  *	from page one register from 0x0F bit 5
12929:Src/bno055.c  ****  *
12930:Src/bno055.c  ****  *	@param accel_high_g_u8 : The value of accel highg interrupt mask
12931:Src/bno055.c  ****  *		   accel_high_g_u8 |   result
12932:Src/bno055.c  ****  *     --------------------  |------------
12933:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
12934:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
12935:Src/bno055.c  ****  *
12936:Src/bno055.c  ****  *	@return results of bus communication function
12937:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
12938:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
12939:Src/bno055.c  ****  *
12940:Src/bno055.c  ****  *	@note While enabling the accel highg interrupt
12941:Src/bno055.c  ****  *	configure the below settings by using
12942:Src/bno055.c  ****  *	the following APIs
12943:Src/bno055.c  ****  *
12944:Src/bno055.c  ****  *	Axis :
12945:Src/bno055.c  ****  *
12946:Src/bno055.c  ****  *	bno055_set_accel_high_g_axis_enable()
12947:Src/bno055.c  ****  *
12948:Src/bno055.c  ****  *	Threshold :
12949:Src/bno055.c  ****  *
12950:Src/bno055.c  ****  *	bno055_set_accel_high_g_thres()
12951:Src/bno055.c  ****  *
12952:Src/bno055.c  ****  *	Duration :
12953:Src/bno055.c  ****  *
12954:Src/bno055.c  ****  *	bno055_set_accel_high_g_durn()
12955:Src/bno055.c  ****  *
12956:Src/bno055.c  ****  */
12957:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_mask_accel_high_g(
12958:Src/bno055.c  **** u8 *accel_high_g_u8)
12959:Src/bno055.c  **** {
 25255              		.loc 1 12959 0
 25256              		.cfi_startproc
 25257              		@ args = 0, pretend = 0, frame = 8
 25258              		@ frame_needed = 0, uses_anonymous_args = 0
 25259              	.LVL3157:
 25260 0000 30B5     		push	{r4, r5, lr}
 25261              	.LCFI1016:
 25262              		.cfi_def_cfa_offset 12
 25263              		.cfi_offset 4, -12
 25264              		.cfi_offset 5, -8
 25265              		.cfi_offset 14, -4
12960:Src/bno055.c  **** 	/* Variable used to return value of
12961:Src/bno055.c  **** 	communication routine*/
12962:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
12963:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
12964:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
12965:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
12966:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25266              		.loc 1 12966 0
 25267 0002 144C     		ldr	r4, .L2762
12959:Src/bno055.c  **** 	/* Variable used to return value of
 25268              		.loc 1 12959 0
 25269 0004 83B0     		sub	sp, sp, #12
 25270              	.LCFI1017:
 25271              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccVWLGiI.s 			page 721


 25272              		.loc 1 12966 0
 25273 0006 2368     		ldr	r3, [r4]
12963:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25274              		.loc 1 12963 0
 25275 0008 0022     		movs	r2, #0
 25276 000a 8DF80720 		strb	r2, [sp, #7]
 25277              	.LVL3158:
 25278              		.loc 1 12966 0
 25279 000e FBB1     		cbz	r3, .L2754
12967:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
12968:Src/bno055.c  **** 		} else {
12969:Src/bno055.c  **** 		/*condition check for page, accel highg interrupt mask is
12970:Src/bno055.c  **** 		available in the page one*/
12971:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25280              		.loc 1 12971 0
 25281 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25282 0012 0546     		mov	r5, r0
 25283 0014 012A     		cmp	r2, #1
 25284 0016 04D0     		beq	.L2752
12972:Src/bno055.c  **** 			/* Write page as one */
12973:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25285              		.loc 1 12973 0
 25286 0018 0120     		movs	r0, #1
 25287              	.LVL3159:
 25288 001a FFF7FEFF 		bl	bno055_write_page_id
 25289              	.LVL3160:
 25290 001e 2368     		ldr	r3, [r4]
12974:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25291              		.loc 1 12974 0
 25292 0020 70B9     		cbnz	r0, .L2761
 25293              	.LVL3161:
 25294              	.L2752:
12975:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
12976:Src/bno055.c  **** 			/* Read the value of accel highg interrupt mask*/
12977:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25295              		.loc 1 12977 0
 25296 0022 1C69     		ldr	r4, [r3, #16]
 25297 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25298 0026 0F21     		movs	r1, #15
 25299 0028 0123     		movs	r3, #1
 25300 002a 0DF10702 		add	r2, sp, #7
 25301 002e A047     		blx	r4
 25302              	.LVL3162:
12978:Src/bno055.c  **** 			(p_bno055->dev_addr,
12979:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_INTR_MASK_REG,
12980:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
12981:Src/bno055.c  **** 			*accel_high_g_u8 =
12982:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25303              		.loc 1 12982 0
 25304 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 25305 0034 C3F34013 		ubfx	r3, r3, #5, #1
12981:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25306              		.loc 1 12981 0
 25307 0038 2B70     		strb	r3, [r5]
 25308              	.LVL3163:
 25309              	.L2751:
12983:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_INTR_MASK);
ARM GAS  /tmp/ccVWLGiI.s 			page 722


12984:Src/bno055.c  **** 		} else {
12985:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
12986:Src/bno055.c  **** 		}
12987:Src/bno055.c  **** 	}
12988:Src/bno055.c  **** 	return com_rslt;
12989:Src/bno055.c  **** }
 25310              		.loc 1 12989 0
 25311 003a 40B2     		sxtb	r0, r0
 25312 003c 03B0     		add	sp, sp, #12
 25313              	.LCFI1018:
 25314              		.cfi_remember_state
 25315              		.cfi_def_cfa_offset 12
 25316              		@ sp needed
 25317 003e 30BD     		pop	{r4, r5, pc}
 25318              	.LVL3164:
 25319              	.L2761:
 25320              	.LCFI1019:
 25321              		.cfi_restore_state
12974:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25322              		.loc 1 12974 0 discriminator 1
 25323 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25324 0042 012A     		cmp	r2, #1
12985:Src/bno055.c  **** 		}
 25325              		.loc 1 12985 0 discriminator 1
 25326 0044 18BF     		it	ne
 25327 0046 FF20     		movne	r0, #255
12974:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25328              		.loc 1 12974 0 discriminator 1
 25329 0048 EBD0     		beq	.L2752
 25330              		.loc 1 12989 0
 25331 004a 40B2     		sxtb	r0, r0
 25332 004c 03B0     		add	sp, sp, #12
 25333              	.LCFI1020:
 25334              		.cfi_remember_state
 25335              		.cfi_def_cfa_offset 12
 25336              		@ sp needed
 25337 004e 30BD     		pop	{r4, r5, pc}
 25338              	.LVL3165:
 25339              	.L2754:
 25340              	.LCFI1021:
 25341              		.cfi_restore_state
12967:Src/bno055.c  **** 		} else {
 25342              		.loc 1 12967 0
 25343 0050 8120     		movs	r0, #129
 25344              	.LVL3166:
 25345 0052 F2E7     		b	.L2751
 25346              	.L2763:
 25347              		.align	2
 25348              	.L2762:
 25349 0054 00000000 		.word	.LANCHOR0
 25350              		.cfi_endproc
 25351              	.LFE209:
 25353              		.section	.text.bno055_set_intr_mask_accel_high_g,"ax",%progbits
 25354              		.align	2
 25355              		.global	bno055_set_intr_mask_accel_high_g
 25356              		.thumb
 25357              		.thumb_func
ARM GAS  /tmp/ccVWLGiI.s 			page 723


 25359              	bno055_set_intr_mask_accel_high_g:
 25360              	.LFB210:
12990:Src/bno055.c  **** /*!
12991:Src/bno055.c  ****  *	@brief This API used to write the accel highg interrupt mask
12992:Src/bno055.c  ****  *	from page one register from 0x0F bit 5
12993:Src/bno055.c  ****  *
12994:Src/bno055.c  ****  *	@param accel_high_g_u8 : The value of accel highg interrupt mask
12995:Src/bno055.c  ****  *		   accel_high_g_u8 |   result
12996:Src/bno055.c  ****  *     --------------------  |------------
12997:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
12998:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
12999:Src/bno055.c  ****  *
13000:Src/bno055.c  ****  *	@return results of bus communication function
13001:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13002:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13003:Src/bno055.c  ****  *
13004:Src/bno055.c  ****  *	@note While enabling the accel highg interrupt
13005:Src/bno055.c  ****  *	configure the below settings by using
13006:Src/bno055.c  ****  *	the following APIs
13007:Src/bno055.c  ****  *
13008:Src/bno055.c  ****  *	Axis :
13009:Src/bno055.c  ****  *
13010:Src/bno055.c  ****  *	bno055_set_accel_high_g_axis_enable()
13011:Src/bno055.c  ****  *
13012:Src/bno055.c  ****  *	Threshold :
13013:Src/bno055.c  ****  *
13014:Src/bno055.c  ****  *	bno055_set_accel_high_g_thres()
13015:Src/bno055.c  ****  *
13016:Src/bno055.c  ****  *	Duration :
13017:Src/bno055.c  ****  *
13018:Src/bno055.c  ****  *	bno055_set_accel_high_g_durn()
13019:Src/bno055.c  ****  *
13020:Src/bno055.c  ****  */
13021:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_mask_accel_high_g(
13022:Src/bno055.c  **** u8 accel_high_g_u8)
13023:Src/bno055.c  **** {
 25361              		.loc 1 13023 0
 25362              		.cfi_startproc
 25363              		@ args = 0, pretend = 0, frame = 8
 25364              		@ frame_needed = 0, uses_anonymous_args = 0
 25365              	.LVL3167:
 25366 0000 70B5     		push	{r4, r5, r6, lr}
 25367              	.LCFI1022:
 25368              		.cfi_def_cfa_offset 16
 25369              		.cfi_offset 4, -16
 25370              		.cfi_offset 5, -12
 25371              		.cfi_offset 6, -8
 25372              		.cfi_offset 14, -4
13024:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13025:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13026:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13027:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13028:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25373              		.loc 1 13028 0
 25374 0002 1D4D     		ldr	r5, .L2778
13023:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 25375              		.loc 1 13023 0
ARM GAS  /tmp/ccVWLGiI.s 			page 724


 25376 0004 82B0     		sub	sp, sp, #8
 25377              	.LCFI1023:
 25378              		.cfi_def_cfa_offset 24
 25379              		.loc 1 13028 0
 25380 0006 2B68     		ldr	r3, [r5]
13025:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25381              		.loc 1 13025 0
 25382 0008 0022     		movs	r2, #0
 25383 000a 8DF80720 		strb	r2, [sp, #7]
 25384              	.LVL3168:
 25385              		.loc 1 13028 0
 25386 000e 002B     		cmp	r3, #0
 25387 0010 30D0     		beq	.L2768
13029:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13030:Src/bno055.c  **** 		} else {
13031:Src/bno055.c  **** 		/*condition check for page, accel highg interrupt mask is
13032:Src/bno055.c  **** 		available in the page one*/
13033:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25388              		.loc 1 13033 0
 25389 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25390 0014 0446     		mov	r4, r0
 25391 0016 012A     		cmp	r2, #1
 25392 0018 04D0     		beq	.L2766
13034:Src/bno055.c  **** 			/* Write page as one */
13035:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25393              		.loc 1 13035 0
 25394 001a 0120     		movs	r0, #1
 25395              	.LVL3169:
 25396 001c FFF7FEFF 		bl	bno055_write_page_id
 25397              	.LVL3170:
 25398 0020 2B68     		ldr	r3, [r5]
13036:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25399              		.loc 1 13036 0
 25400 0022 50B9     		cbnz	r0, .L2776
 25401              	.LVL3171:
 25402              	.L2766:
13037:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13038:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25403              		.loc 1 13038 0
 25404 0024 1E69     		ldr	r6, [r3, #16]
 25405 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25406 0028 0DF10702 		add	r2, sp, #7
 25407 002c 0F21     		movs	r1, #15
 25408 002e 0123     		movs	r3, #1
 25409 0030 B047     		blx	r6
 25410              	.LVL3172:
13039:Src/bno055.c  **** 			(p_bno055->dev_addr,
13040:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_INTR_MASK_REG,
13041:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13042:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 25411              		.loc 1 13042 0
 25412 0032 50B1     		cbz	r0, .L2777
 25413              	.LVL3173:
 25414              	.L2765:
13043:Src/bno055.c  **** 				/* Write the value of accel
13044:Src/bno055.c  **** 				highg interrupt mask*/
13045:Src/bno055.c  **** 				data_u8r =
ARM GAS  /tmp/ccVWLGiI.s 			page 725


13046:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
13047:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_INTR_MASK,
13048:Src/bno055.c  **** 				accel_high_g_u8);
13049:Src/bno055.c  **** 				com_rslt +=
13050:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
13051:Src/bno055.c  **** 				(p_bno055->dev_addr,
13052:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_INTR_MASK_REG,
13053:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13054:Src/bno055.c  **** 			}
13055:Src/bno055.c  **** 		} else {
13056:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13057:Src/bno055.c  **** 		}
13058:Src/bno055.c  **** 	}
13059:Src/bno055.c  **** 	return com_rslt;
13060:Src/bno055.c  **** }
 25415              		.loc 1 13060 0
 25416 0034 40B2     		sxtb	r0, r0
 25417 0036 02B0     		add	sp, sp, #8
 25418              	.LCFI1024:
 25419              		.cfi_remember_state
 25420              		.cfi_def_cfa_offset 16
 25421              		@ sp needed
 25422 0038 70BD     		pop	{r4, r5, r6, pc}
 25423              	.LVL3174:
 25424              	.L2776:
 25425              	.LCFI1025:
 25426              		.cfi_restore_state
13036:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25427              		.loc 1 13036 0 discriminator 1
 25428 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25429 003c 012A     		cmp	r2, #1
13056:Src/bno055.c  **** 		}
 25430              		.loc 1 13056 0 discriminator 1
 25431 003e 18BF     		it	ne
 25432 0040 FF20     		movne	r0, #255
13036:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25433              		.loc 1 13036 0 discriminator 1
 25434 0042 EFD0     		beq	.L2766
 25435              		.loc 1 13060 0
 25436 0044 40B2     		sxtb	r0, r0
 25437 0046 02B0     		add	sp, sp, #8
 25438              	.LCFI1026:
 25439              		.cfi_remember_state
 25440              		.cfi_def_cfa_offset 16
 25441              		@ sp needed
 25442 0048 70BD     		pop	{r4, r5, r6, pc}
 25443              	.LVL3175:
 25444              	.L2777:
 25445              	.LCFI1027:
 25446              		.cfi_restore_state
13045:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25447              		.loc 1 13045 0
 25448 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
13046:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_INTR_MASK,
 25449              		.loc 1 13046 0
 25450 004e 6001     		lsls	r0, r4, #5
 25451              	.LVL3176:
ARM GAS  /tmp/ccVWLGiI.s 			page 726


13050:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25452              		.loc 1 13050 0
 25453 0050 2968     		ldr	r1, [r5]
13045:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25454              		.loc 1 13045 0
 25455 0052 23F02004 		bic	r4, r3, #32
 25456 0056 00F02000 		and	r0, r0, #32
 25457 005a 2043     		orrs	r0, r0, r4
 25458 005c 8DF80700 		strb	r0, [sp, #7]
13050:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25459              		.loc 1 13050 0
 25460 0060 CC68     		ldr	r4, [r1, #12]
 25461 0062 0DF10702 		add	r2, sp, #7
 25462 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 25463 0068 0123     		movs	r3, #1
 25464 006a 0F21     		movs	r1, #15
 25465 006c A047     		blx	r4
 25466              	.LVL3177:
 25467              		.loc 1 13060 0
 25468 006e 40B2     		sxtb	r0, r0
 25469 0070 02B0     		add	sp, sp, #8
 25470              	.LCFI1028:
 25471              		.cfi_remember_state
 25472              		.cfi_def_cfa_offset 16
 25473              		@ sp needed
 25474 0072 70BD     		pop	{r4, r5, r6, pc}
 25475              	.LVL3178:
 25476              	.L2768:
 25477              	.LCFI1029:
 25478              		.cfi_restore_state
13029:Src/bno055.c  **** 		} else {
 25479              		.loc 1 13029 0
 25480 0074 8120     		movs	r0, #129
 25481              	.LVL3179:
 25482 0076 DDE7     		b	.L2765
 25483              	.L2779:
 25484              		.align	2
 25485              	.L2778:
 25486 0078 00000000 		.word	.LANCHOR0
 25487              		.cfi_endproc
 25488              	.LFE210:
 25490              		.section	.text.bno055_get_intr_mask_accel_any_motion,"ax",%progbits
 25491              		.align	2
 25492              		.global	bno055_get_intr_mask_accel_any_motion
 25493              		.thumb
 25494              		.thumb_func
 25496              	bno055_get_intr_mask_accel_any_motion:
 25497              	.LFB211:
13061:Src/bno055.c  **** /*!
13062:Src/bno055.c  ****  *	@brief This API used to read the accel anymotion interrupt mask
13063:Src/bno055.c  ****  *	from page one register from 0x0F bit 6
13064:Src/bno055.c  ****  *
13065:Src/bno055.c  ****  *	@param accel_any_motion_u8 : The value of accel anymotion interrupt mask
13066:Src/bno055.c  ****  *     accel_any_motion_u8 | result
13067:Src/bno055.c  ****  *     --------------------  |------------
13068:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13069:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
ARM GAS  /tmp/ccVWLGiI.s 			page 727


13070:Src/bno055.c  ****  *
13071:Src/bno055.c  ****  *	@return results of bus communication function
13072:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13073:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13074:Src/bno055.c  ****  *
13075:Src/bno055.c  ****  *	@note While enabling the accel highg interrupt
13076:Src/bno055.c  ****  *	configure the below settings by using
13077:Src/bno055.c  ****  *	the following APIs
13078:Src/bno055.c  ****  *
13079:Src/bno055.c  ****  *	Axis :
13080:Src/bno055.c  ****  *
13081:Src/bno055.c  ****  *	bno055_set_accel_high_g_axis_enable()
13082:Src/bno055.c  ****  *
13083:Src/bno055.c  ****  *	Threshold :
13084:Src/bno055.c  ****  *
13085:Src/bno055.c  ****  *	bno055_set_accel_high_g_thres()
13086:Src/bno055.c  ****  *
13087:Src/bno055.c  ****  *	Duration :
13088:Src/bno055.c  ****  *
13089:Src/bno055.c  ****  *	bno055_set_accel_high_g_durn()
13090:Src/bno055.c  ****  *
13091:Src/bno055.c  ****  */
13092:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_mask_accel_any_motion(
13093:Src/bno055.c  **** u8 *accel_any_motion_u8)
13094:Src/bno055.c  **** {
 25498              		.loc 1 13094 0
 25499              		.cfi_startproc
 25500              		@ args = 0, pretend = 0, frame = 8
 25501              		@ frame_needed = 0, uses_anonymous_args = 0
 25502              	.LVL3180:
 25503 0000 30B5     		push	{r4, r5, lr}
 25504              	.LCFI1030:
 25505              		.cfi_def_cfa_offset 12
 25506              		.cfi_offset 4, -12
 25507              		.cfi_offset 5, -8
 25508              		.cfi_offset 14, -4
13095:Src/bno055.c  **** 	/* Variable used to return value of
13096:Src/bno055.c  **** 	communication routine*/
13097:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13098:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13099:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13100:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13101:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25509              		.loc 1 13101 0
 25510 0002 144C     		ldr	r4, .L2792
13094:Src/bno055.c  **** 	/* Variable used to return value of
 25511              		.loc 1 13094 0
 25512 0004 83B0     		sub	sp, sp, #12
 25513              	.LCFI1031:
 25514              		.cfi_def_cfa_offset 24
 25515              		.loc 1 13101 0
 25516 0006 2368     		ldr	r3, [r4]
13098:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25517              		.loc 1 13098 0
 25518 0008 0022     		movs	r2, #0
 25519 000a 8DF80720 		strb	r2, [sp, #7]
 25520              	.LVL3181:
ARM GAS  /tmp/ccVWLGiI.s 			page 728


 25521              		.loc 1 13101 0
 25522 000e FBB1     		cbz	r3, .L2784
13102:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13103:Src/bno055.c  **** 		} else {
13104:Src/bno055.c  **** 		/*condition check for page, accel anymotion interrupt mask is
13105:Src/bno055.c  **** 		available in the page one*/
13106:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25523              		.loc 1 13106 0
 25524 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25525 0012 0546     		mov	r5, r0
 25526 0014 012A     		cmp	r2, #1
 25527 0016 04D0     		beq	.L2782
13107:Src/bno055.c  **** 			/* Write page as one */
13108:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25528              		.loc 1 13108 0
 25529 0018 0120     		movs	r0, #1
 25530              	.LVL3182:
 25531 001a FFF7FEFF 		bl	bno055_write_page_id
 25532              	.LVL3183:
 25533 001e 2368     		ldr	r3, [r4]
13109:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25534              		.loc 1 13109 0
 25535 0020 70B9     		cbnz	r0, .L2791
 25536              	.LVL3184:
 25537              	.L2782:
13110:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13111:Src/bno055.c  **** 			/* The value of accel anymotion interrupt mask*/
13112:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25538              		.loc 1 13112 0
 25539 0022 1C69     		ldr	r4, [r3, #16]
 25540 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25541 0026 0F21     		movs	r1, #15
 25542 0028 0123     		movs	r3, #1
 25543 002a 0DF10702 		add	r2, sp, #7
 25544 002e A047     		blx	r4
 25545              	.LVL3185:
13113:Src/bno055.c  **** 			(p_bno055->dev_addr,
13114:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_INTR_MASK_REG,
13115:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13116:Src/bno055.c  **** 			*accel_any_motion_u8 =
13117:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25546              		.loc 1 13117 0
 25547 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 25548 0034 C3F38013 		ubfx	r3, r3, #6, #1
13116:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25549              		.loc 1 13116 0
 25550 0038 2B70     		strb	r3, [r5]
 25551              	.LVL3186:
 25552              	.L2781:
13118:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_INTR_MASK);
13119:Src/bno055.c  **** 		} else {
13120:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13121:Src/bno055.c  **** 		}
13122:Src/bno055.c  **** 	}
13123:Src/bno055.c  **** 	return com_rslt;
13124:Src/bno055.c  **** }
 25553              		.loc 1 13124 0
ARM GAS  /tmp/ccVWLGiI.s 			page 729


 25554 003a 40B2     		sxtb	r0, r0
 25555 003c 03B0     		add	sp, sp, #12
 25556              	.LCFI1032:
 25557              		.cfi_remember_state
 25558              		.cfi_def_cfa_offset 12
 25559              		@ sp needed
 25560 003e 30BD     		pop	{r4, r5, pc}
 25561              	.LVL3187:
 25562              	.L2791:
 25563              	.LCFI1033:
 25564              		.cfi_restore_state
13109:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25565              		.loc 1 13109 0 discriminator 1
 25566 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25567 0042 012A     		cmp	r2, #1
13120:Src/bno055.c  **** 		}
 25568              		.loc 1 13120 0 discriminator 1
 25569 0044 18BF     		it	ne
 25570 0046 FF20     		movne	r0, #255
13109:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25571              		.loc 1 13109 0 discriminator 1
 25572 0048 EBD0     		beq	.L2782
 25573              		.loc 1 13124 0
 25574 004a 40B2     		sxtb	r0, r0
 25575 004c 03B0     		add	sp, sp, #12
 25576              	.LCFI1034:
 25577              		.cfi_remember_state
 25578              		.cfi_def_cfa_offset 12
 25579              		@ sp needed
 25580 004e 30BD     		pop	{r4, r5, pc}
 25581              	.LVL3188:
 25582              	.L2784:
 25583              	.LCFI1035:
 25584              		.cfi_restore_state
13102:Src/bno055.c  **** 		} else {
 25585              		.loc 1 13102 0
 25586 0050 8120     		movs	r0, #129
 25587              	.LVL3189:
 25588 0052 F2E7     		b	.L2781
 25589              	.L2793:
 25590              		.align	2
 25591              	.L2792:
 25592 0054 00000000 		.word	.LANCHOR0
 25593              		.cfi_endproc
 25594              	.LFE211:
 25596              		.section	.text.bno055_set_intr_mask_accel_any_motion,"ax",%progbits
 25597              		.align	2
 25598              		.global	bno055_set_intr_mask_accel_any_motion
 25599              		.thumb
 25600              		.thumb_func
 25602              	bno055_set_intr_mask_accel_any_motion:
 25603              	.LFB212:
13125:Src/bno055.c  **** /*!
13126:Src/bno055.c  ****  *	@brief This API used to write the accel anymotion interrupt mask
13127:Src/bno055.c  ****  *	from page one register from 0x0F bit 6
13128:Src/bno055.c  ****  *
13129:Src/bno055.c  ****  *	@param accel_any_motion_u8 : The value of accel anymotion interrupt mask
ARM GAS  /tmp/ccVWLGiI.s 			page 730


13130:Src/bno055.c  ****  *     accel_any_motion_u8 | result
13131:Src/bno055.c  ****  *     --------------------  |------------
13132:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13133:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13134:Src/bno055.c  ****  *
13135:Src/bno055.c  ****  *	@return results of bus communication function
13136:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13137:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13138:Src/bno055.c  ****  *
13139:Src/bno055.c  ****  *	@note While enabling the accel anymotion interrupt
13140:Src/bno055.c  ****  *	configure the following settings
13141:Src/bno055.c  ****  *
13142:Src/bno055.c  ****  *	Axis:
13143:Src/bno055.c  ****  *
13144:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13145:Src/bno055.c  ****  *
13146:Src/bno055.c  ****  *	Duration:
13147:Src/bno055.c  ****  *
13148:Src/bno055.c  ****  *	bno055_set_accel_any_motion_durn()
13149:Src/bno055.c  ****  *
13150:Src/bno055.c  ****  * Threshold:
13151:Src/bno055.c  ****  *
13152:Src/bno055.c  ****  *	bno055_set_accel_any_motion_thres()
13153:Src/bno055.c  ****  *
13154:Src/bno055.c  ****  */
13155:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_mask_accel_any_motion(
13156:Src/bno055.c  **** u8 accel_any_motion_u8)
13157:Src/bno055.c  **** {
 25604              		.loc 1 13157 0
 25605              		.cfi_startproc
 25606              		@ args = 0, pretend = 0, frame = 8
 25607              		@ frame_needed = 0, uses_anonymous_args = 0
 25608              	.LVL3190:
 25609 0000 70B5     		push	{r4, r5, r6, lr}
 25610              	.LCFI1036:
 25611              		.cfi_def_cfa_offset 16
 25612              		.cfi_offset 4, -16
 25613              		.cfi_offset 5, -12
 25614              		.cfi_offset 6, -8
 25615              		.cfi_offset 14, -4
13158:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13159:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13160:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13161:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13162:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25616              		.loc 1 13162 0
 25617 0002 1D4D     		ldr	r5, .L2808
13157:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 25618              		.loc 1 13157 0
 25619 0004 82B0     		sub	sp, sp, #8
 25620              	.LCFI1037:
 25621              		.cfi_def_cfa_offset 24
 25622              		.loc 1 13162 0
 25623 0006 2B68     		ldr	r3, [r5]
13159:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25624              		.loc 1 13159 0
 25625 0008 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 731


 25626 000a 8DF80720 		strb	r2, [sp, #7]
 25627              	.LVL3191:
 25628              		.loc 1 13162 0
 25629 000e 002B     		cmp	r3, #0
 25630 0010 30D0     		beq	.L2798
13163:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13164:Src/bno055.c  **** 		} else {
13165:Src/bno055.c  **** 		/*condition check for page, accel anymotion interrupt mask is
13166:Src/bno055.c  **** 		available in the page one*/
13167:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25631              		.loc 1 13167 0
 25632 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25633 0014 0446     		mov	r4, r0
 25634 0016 012A     		cmp	r2, #1
 25635 0018 04D0     		beq	.L2796
13168:Src/bno055.c  **** 			/* Write page as one */
13169:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25636              		.loc 1 13169 0
 25637 001a 0120     		movs	r0, #1
 25638              	.LVL3192:
 25639 001c FFF7FEFF 		bl	bno055_write_page_id
 25640              	.LVL3193:
 25641 0020 2B68     		ldr	r3, [r5]
13170:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25642              		.loc 1 13170 0
 25643 0022 50B9     		cbnz	r0, .L2806
 25644              	.LVL3194:
 25645              	.L2796:
13171:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13172:Src/bno055.c  **** 			/* Write the value of accel anymotion interrupt mask*/
13173:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25646              		.loc 1 13173 0
 25647 0024 1E69     		ldr	r6, [r3, #16]
 25648 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25649 0028 0DF10702 		add	r2, sp, #7
 25650 002c 0F21     		movs	r1, #15
 25651 002e 0123     		movs	r3, #1
 25652 0030 B047     		blx	r6
 25653              	.LVL3195:
13174:Src/bno055.c  **** 			(p_bno055->dev_addr,
13175:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_INTR_MASK_REG,
13176:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13177:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 25654              		.loc 1 13177 0
 25655 0032 50B1     		cbz	r0, .L2807
 25656              	.LVL3196:
 25657              	.L2795:
13178:Src/bno055.c  **** 				data_u8r =
13179:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
13180:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_INTR_MASK,
13181:Src/bno055.c  **** 				accel_any_motion_u8);
13182:Src/bno055.c  **** 				com_rslt +=
13183:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
13184:Src/bno055.c  **** 				(p_bno055->dev_addr,
13185:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_INTR_MASK_REG,
13186:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13187:Src/bno055.c  **** 			}
ARM GAS  /tmp/ccVWLGiI.s 			page 732


13188:Src/bno055.c  **** 		} else {
13189:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13190:Src/bno055.c  **** 		}
13191:Src/bno055.c  **** 	}
13192:Src/bno055.c  **** 	return com_rslt;
13193:Src/bno055.c  **** }
 25658              		.loc 1 13193 0
 25659 0034 40B2     		sxtb	r0, r0
 25660 0036 02B0     		add	sp, sp, #8
 25661              	.LCFI1038:
 25662              		.cfi_remember_state
 25663              		.cfi_def_cfa_offset 16
 25664              		@ sp needed
 25665 0038 70BD     		pop	{r4, r5, r6, pc}
 25666              	.LVL3197:
 25667              	.L2806:
 25668              	.LCFI1039:
 25669              		.cfi_restore_state
13170:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25670              		.loc 1 13170 0 discriminator 1
 25671 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25672 003c 012A     		cmp	r2, #1
13189:Src/bno055.c  **** 		}
 25673              		.loc 1 13189 0 discriminator 1
 25674 003e 18BF     		it	ne
 25675 0040 FF20     		movne	r0, #255
13170:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25676              		.loc 1 13170 0 discriminator 1
 25677 0042 EFD0     		beq	.L2796
 25678              		.loc 1 13193 0
 25679 0044 40B2     		sxtb	r0, r0
 25680 0046 02B0     		add	sp, sp, #8
 25681              	.LCFI1040:
 25682              		.cfi_remember_state
 25683              		.cfi_def_cfa_offset 16
 25684              		@ sp needed
 25685 0048 70BD     		pop	{r4, r5, r6, pc}
 25686              	.LVL3198:
 25687              	.L2807:
 25688              	.LCFI1041:
 25689              		.cfi_restore_state
13178:Src/bno055.c  **** 				data_u8r =
 25690              		.loc 1 13178 0
 25691 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
13179:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_INTR_MASK,
 25692              		.loc 1 13179 0
 25693 004e A001     		lsls	r0, r4, #6
 25694              	.LVL3199:
13183:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25695              		.loc 1 13183 0
 25696 0050 2968     		ldr	r1, [r5]
13178:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25697              		.loc 1 13178 0
 25698 0052 23F04004 		bic	r4, r3, #64
 25699 0056 00F04000 		and	r0, r0, #64
 25700 005a 2043     		orrs	r0, r0, r4
 25701 005c 8DF80700 		strb	r0, [sp, #7]
ARM GAS  /tmp/ccVWLGiI.s 			page 733


13183:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25702              		.loc 1 13183 0
 25703 0060 CC68     		ldr	r4, [r1, #12]
 25704 0062 0DF10702 		add	r2, sp, #7
 25705 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 25706 0068 0123     		movs	r3, #1
 25707 006a 0F21     		movs	r1, #15
 25708 006c A047     		blx	r4
 25709              	.LVL3200:
 25710              		.loc 1 13193 0
 25711 006e 40B2     		sxtb	r0, r0
 25712 0070 02B0     		add	sp, sp, #8
 25713              	.LCFI1042:
 25714              		.cfi_remember_state
 25715              		.cfi_def_cfa_offset 16
 25716              		@ sp needed
 25717 0072 70BD     		pop	{r4, r5, r6, pc}
 25718              	.LVL3201:
 25719              	.L2798:
 25720              	.LCFI1043:
 25721              		.cfi_restore_state
13163:Src/bno055.c  **** 		} else {
 25722              		.loc 1 13163 0
 25723 0074 8120     		movs	r0, #129
 25724              	.LVL3202:
 25725 0076 DDE7     		b	.L2795
 25726              	.L2809:
 25727              		.align	2
 25728              	.L2808:
 25729 0078 00000000 		.word	.LANCHOR0
 25730              		.cfi_endproc
 25731              	.LFE212:
 25733              		.section	.text.bno055_get_intr_mask_accel_no_motion,"ax",%progbits
 25734              		.align	2
 25735              		.global	bno055_get_intr_mask_accel_no_motion
 25736              		.thumb
 25737              		.thumb_func
 25739              	bno055_get_intr_mask_accel_no_motion:
 25740              	.LFB213:
13194:Src/bno055.c  **** /*!
13195:Src/bno055.c  ****  *	@brief This API used to read the accel nomotion interrupt mask
13196:Src/bno055.c  ****  *	from page one register from 0x0F bit 7
13197:Src/bno055.c  ****  *
13198:Src/bno055.c  ****  *	@param accel_nomotion_u8 : The value of accel nomotion interrupt mask
13199:Src/bno055.c  ****  *     accel_nomotion_u8   | result
13200:Src/bno055.c  ****  *     --------------------  |------------
13201:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13202:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13203:Src/bno055.c  ****  *
13204:Src/bno055.c  ****  *	@return results of bus communication function
13205:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13206:Src/bno055.c  ****  *
13207:Src/bno055.c  ****  *	@note While enabling the accel anymotion interrupt
13208:Src/bno055.c  ****  *	configure the following settings
13209:Src/bno055.c  ****  *
13210:Src/bno055.c  ****  *	Axis:
13211:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 734


13212:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13213:Src/bno055.c  ****  *
13214:Src/bno055.c  ****  *	Duration:
13215:Src/bno055.c  ****  *
13216:Src/bno055.c  ****  *	bno055_set_accel_any_motion_durn()
13217:Src/bno055.c  ****  *
13218:Src/bno055.c  ****  * Threshold:
13219:Src/bno055.c  ****  *
13220:Src/bno055.c  ****  *	bno055_set_accel_any_motion_thres())
13221:Src/bno055.c  ****  *
13222:Src/bno055.c  ****  */
13223:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_mask_accel_no_motion(
13224:Src/bno055.c  **** u8 *accel_nomotion_u8)
13225:Src/bno055.c  **** {
 25741              		.loc 1 13225 0
 25742              		.cfi_startproc
 25743              		@ args = 0, pretend = 0, frame = 8
 25744              		@ frame_needed = 0, uses_anonymous_args = 0
 25745              	.LVL3203:
 25746 0000 30B5     		push	{r4, r5, lr}
 25747              	.LCFI1044:
 25748              		.cfi_def_cfa_offset 12
 25749              		.cfi_offset 4, -12
 25750              		.cfi_offset 5, -8
 25751              		.cfi_offset 14, -4
13226:Src/bno055.c  **** 	/* Variable used to return value of
13227:Src/bno055.c  **** 	communication routine*/
13228:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13229:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13230:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13231:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13232:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25752              		.loc 1 13232 0
 25753 0002 144C     		ldr	r4, .L2822
13225:Src/bno055.c  **** 	/* Variable used to return value of
 25754              		.loc 1 13225 0
 25755 0004 83B0     		sub	sp, sp, #12
 25756              	.LCFI1045:
 25757              		.cfi_def_cfa_offset 24
 25758              		.loc 1 13232 0
 25759 0006 2368     		ldr	r3, [r4]
13229:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25760              		.loc 1 13229 0
 25761 0008 0022     		movs	r2, #0
 25762 000a 8DF80720 		strb	r2, [sp, #7]
 25763              	.LVL3204:
 25764              		.loc 1 13232 0
 25765 000e F3B1     		cbz	r3, .L2814
13233:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13234:Src/bno055.c  **** 		} else {
13235:Src/bno055.c  **** 		/*condition check for page, accel nomotion interrupt mask is
13236:Src/bno055.c  **** 		available in the page one*/
13237:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25766              		.loc 1 13237 0
 25767 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25768 0012 0546     		mov	r5, r0
 25769 0014 012A     		cmp	r2, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 735


 25770 0016 04D0     		beq	.L2812
13238:Src/bno055.c  **** 			/* Write page as one */
13239:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25771              		.loc 1 13239 0
 25772 0018 0120     		movs	r0, #1
 25773              	.LVL3205:
 25774 001a FFF7FEFF 		bl	bno055_write_page_id
 25775              	.LVL3206:
 25776 001e 2368     		ldr	r3, [r4]
13240:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25777              		.loc 1 13240 0
 25778 0020 68B9     		cbnz	r0, .L2821
 25779              	.LVL3207:
 25780              	.L2812:
13241:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13242:Src/bno055.c  **** 			/* Read the value of accel nomotion interrupt mask*/
13243:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25781              		.loc 1 13243 0
 25782 0022 1C69     		ldr	r4, [r3, #16]
 25783 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25784 0026 0F21     		movs	r1, #15
 25785 0028 0123     		movs	r3, #1
 25786 002a 0DF10702 		add	r2, sp, #7
 25787 002e A047     		blx	r4
 25788              	.LVL3208:
13244:Src/bno055.c  **** 			(p_bno055->dev_addr,
13245:Src/bno055.c  **** 			BNO055_ACCEL_NO_MOTION_INTR_MASK_REG,
13246:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13247:Src/bno055.c  **** 			*accel_nomotion_u8 =
13248:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25789              		.loc 1 13248 0
 25790 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 25791 0034 DB09     		lsrs	r3, r3, #7
13247:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 25792              		.loc 1 13247 0
 25793 0036 2B70     		strb	r3, [r5]
 25794              	.LVL3209:
 25795              	.L2811:
13249:Src/bno055.c  **** 			BNO055_ACCEL_NO_MOTION_INTR_MASK);
13250:Src/bno055.c  **** 		} else {
13251:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13252:Src/bno055.c  **** 		}
13253:Src/bno055.c  **** 	}
13254:Src/bno055.c  **** 	return com_rslt;
13255:Src/bno055.c  **** }
 25796              		.loc 1 13255 0
 25797 0038 40B2     		sxtb	r0, r0
 25798 003a 03B0     		add	sp, sp, #12
 25799              	.LCFI1046:
 25800              		.cfi_remember_state
 25801              		.cfi_def_cfa_offset 12
 25802              		@ sp needed
 25803 003c 30BD     		pop	{r4, r5, pc}
 25804              	.LVL3210:
 25805              	.L2821:
 25806              	.LCFI1047:
 25807              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 736


13240:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25808              		.loc 1 13240 0 discriminator 1
 25809 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25810 0040 012A     		cmp	r2, #1
13251:Src/bno055.c  **** 		}
 25811              		.loc 1 13251 0 discriminator 1
 25812 0042 18BF     		it	ne
 25813 0044 FF20     		movne	r0, #255
13240:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25814              		.loc 1 13240 0 discriminator 1
 25815 0046 ECD0     		beq	.L2812
 25816              		.loc 1 13255 0
 25817 0048 40B2     		sxtb	r0, r0
 25818 004a 03B0     		add	sp, sp, #12
 25819              	.LCFI1048:
 25820              		.cfi_remember_state
 25821              		.cfi_def_cfa_offset 12
 25822              		@ sp needed
 25823 004c 30BD     		pop	{r4, r5, pc}
 25824              	.LVL3211:
 25825              	.L2814:
 25826              	.LCFI1049:
 25827              		.cfi_restore_state
13233:Src/bno055.c  **** 		} else {
 25828              		.loc 1 13233 0
 25829 004e 8120     		movs	r0, #129
 25830              	.LVL3212:
 25831 0050 F2E7     		b	.L2811
 25832              	.L2823:
 25833 0052 00BF     		.align	2
 25834              	.L2822:
 25835 0054 00000000 		.word	.LANCHOR0
 25836              		.cfi_endproc
 25837              	.LFE213:
 25839              		.section	.text.bno055_set_intr_mask_accel_no_motion,"ax",%progbits
 25840              		.align	2
 25841              		.global	bno055_set_intr_mask_accel_no_motion
 25842              		.thumb
 25843              		.thumb_func
 25845              	bno055_set_intr_mask_accel_no_motion:
 25846              	.LFB214:
13256:Src/bno055.c  **** /*!
13257:Src/bno055.c  ****  *	@brief This API used to write the accel nomotion interrupt mask
13258:Src/bno055.c  ****  *	from page one register from 0x0F bit 7
13259:Src/bno055.c  ****  *
13260:Src/bno055.c  ****  *	@param accel_nomotion_u8 : The value of accel nomotion interrupt mask
13261:Src/bno055.c  ****  *     accel_nomotion_u8   | result
13262:Src/bno055.c  ****  *     --------------------  |------------
13263:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13264:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13265:Src/bno055.c  ****  *
13266:Src/bno055.c  ****  *	@return results of bus communication function
13267:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13268:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13269:Src/bno055.c  ****  *
13270:Src/bno055.c  ****  *	@note While enabling the accel nomotion interrupt
13271:Src/bno055.c  ****  *	configure the following settings
ARM GAS  /tmp/ccVWLGiI.s 			page 737


13272:Src/bno055.c  ****  *
13273:Src/bno055.c  ****  *	Axis:
13274:Src/bno055.c  ****  *
13275:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13276:Src/bno055.c  ****  *
13277:Src/bno055.c  ****  *	Threshold :
13278:Src/bno055.c  ****  *
13279:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_thres()
13280:Src/bno055.c  ****  *
13281:Src/bno055.c  ****  *	Duration :
13282:Src/bno055.c  ****  *
13283:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_durn()
13284:Src/bno055.c  ****  *
13285:Src/bno055.c  ****  *	Slow/no motion enable:
13286:Src/bno055.c  ****  *
13287:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_enable()
13288:Src/bno055.c  ****  *
13289:Src/bno055.c  ****  */
13290:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_mask_accel_no_motion(
13291:Src/bno055.c  **** u8 accel_nomotion_u8)
13292:Src/bno055.c  **** {
 25847              		.loc 1 13292 0
 25848              		.cfi_startproc
 25849              		@ args = 0, pretend = 0, frame = 8
 25850              		@ frame_needed = 0, uses_anonymous_args = 0
 25851              	.LVL3213:
 25852 0000 70B5     		push	{r4, r5, r6, lr}
 25853              	.LCFI1050:
 25854              		.cfi_def_cfa_offset 16
 25855              		.cfi_offset 4, -16
 25856              		.cfi_offset 5, -12
 25857              		.cfi_offset 6, -8
 25858              		.cfi_offset 14, -4
13293:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13294:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13295:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13296:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13297:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25859              		.loc 1 13297 0
 25860 0002 1C4D     		ldr	r5, .L2838
13292:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 25861              		.loc 1 13292 0
 25862 0004 82B0     		sub	sp, sp, #8
 25863              	.LCFI1051:
 25864              		.cfi_def_cfa_offset 24
 25865              		.loc 1 13297 0
 25866 0006 2B68     		ldr	r3, [r5]
13294:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 25867              		.loc 1 13294 0
 25868 0008 0022     		movs	r2, #0
 25869 000a 8DF80720 		strb	r2, [sp, #7]
 25870              	.LVL3214:
 25871              		.loc 1 13297 0
 25872 000e 002B     		cmp	r3, #0
 25873 0010 2ED0     		beq	.L2828
13298:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13299:Src/bno055.c  **** 		} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 738


13300:Src/bno055.c  **** 		/*condition check for page, accel
13301:Src/bno055.c  **** 		nomotion interrupt mask is
13302:Src/bno055.c  **** 		available in the page one*/
13303:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 25874              		.loc 1 13303 0
 25875 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25876 0014 0446     		mov	r4, r0
 25877 0016 012A     		cmp	r2, #1
 25878 0018 04D0     		beq	.L2826
13304:Src/bno055.c  **** 			/* Write page as one */
13305:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 25879              		.loc 1 13305 0
 25880 001a 0120     		movs	r0, #1
 25881              	.LVL3215:
 25882 001c FFF7FEFF 		bl	bno055_write_page_id
 25883              	.LVL3216:
 25884 0020 2B68     		ldr	r3, [r5]
13306:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 25885              		.loc 1 13306 0
 25886 0022 50B9     		cbnz	r0, .L2836
 25887              	.LVL3217:
 25888              	.L2826:
13307:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13308:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 25889              		.loc 1 13308 0
 25890 0024 1E69     		ldr	r6, [r3, #16]
 25891 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25892 0028 0DF10702 		add	r2, sp, #7
 25893 002c 0F21     		movs	r1, #15
 25894 002e 0123     		movs	r3, #1
 25895 0030 B047     		blx	r6
 25896              	.LVL3218:
13309:Src/bno055.c  **** 			(p_bno055->dev_addr,
13310:Src/bno055.c  **** 			BNO055_ACCEL_NO_MOTION_INTR_MASK_REG,
13311:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13312:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 25897              		.loc 1 13312 0
 25898 0032 50B1     		cbz	r0, .L2837
 25899              	.LVL3219:
 25900              	.L2825:
13313:Src/bno055.c  **** 				/* Write the value of accel
13314:Src/bno055.c  **** 				nomotion interrupt mask*/
13315:Src/bno055.c  **** 				data_u8r =
13316:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
13317:Src/bno055.c  **** 				BNO055_ACCEL_NO_MOTION_INTR_MASK,
13318:Src/bno055.c  **** 				accel_nomotion_u8);
13319:Src/bno055.c  **** 				com_rslt +=
13320:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
13321:Src/bno055.c  **** 				(p_bno055->dev_addr,
13322:Src/bno055.c  **** 				BNO055_ACCEL_NO_MOTION_INTR_MASK_REG,
13323:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13324:Src/bno055.c  **** 			}
13325:Src/bno055.c  **** 		} else {
13326:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13327:Src/bno055.c  **** 		}
13328:Src/bno055.c  **** 	}
13329:Src/bno055.c  **** 	return com_rslt;
ARM GAS  /tmp/ccVWLGiI.s 			page 739


13330:Src/bno055.c  **** }
 25901              		.loc 1 13330 0
 25902 0034 40B2     		sxtb	r0, r0
 25903 0036 02B0     		add	sp, sp, #8
 25904              	.LCFI1052:
 25905              		.cfi_remember_state
 25906              		.cfi_def_cfa_offset 16
 25907              		@ sp needed
 25908 0038 70BD     		pop	{r4, r5, r6, pc}
 25909              	.LVL3220:
 25910              	.L2836:
 25911              	.LCFI1053:
 25912              		.cfi_restore_state
13306:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25913              		.loc 1 13306 0 discriminator 1
 25914 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 25915 003c 012A     		cmp	r2, #1
13326:Src/bno055.c  **** 		}
 25916              		.loc 1 13326 0 discriminator 1
 25917 003e 18BF     		it	ne
 25918 0040 FF20     		movne	r0, #255
13306:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 25919              		.loc 1 13306 0 discriminator 1
 25920 0042 EFD0     		beq	.L2826
 25921              		.loc 1 13330 0
 25922 0044 40B2     		sxtb	r0, r0
 25923 0046 02B0     		add	sp, sp, #8
 25924              	.LCFI1054:
 25925              		.cfi_remember_state
 25926              		.cfi_def_cfa_offset 16
 25927              		@ sp needed
 25928 0048 70BD     		pop	{r4, r5, r6, pc}
 25929              	.LVL3221:
 25930              	.L2837:
 25931              	.LCFI1055:
 25932              		.cfi_restore_state
13315:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25933              		.loc 1 13315 0
 25934 004a 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 25935              	.LVL3222:
13320:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25936              		.loc 1 13320 0
 25937 004e 2B68     		ldr	r3, [r5]
13315:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 25938              		.loc 1 13315 0
 25939 0050 00F07F00 		and	r0, r0, #127
 25940 0054 40EAC410 		orr	r0, r0, r4, lsl #7
 25941 0058 8DF80700 		strb	r0, [sp, #7]
13320:Src/bno055.c  **** 				(p_bno055->dev_addr,
 25942              		.loc 1 13320 0
 25943 005c DC68     		ldr	r4, [r3, #12]
 25944 005e 0DF10702 		add	r2, sp, #7
 25945 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 25946 0064 0F21     		movs	r1, #15
 25947 0066 0123     		movs	r3, #1
 25948 0068 A047     		blx	r4
 25949              	.LVL3223:
ARM GAS  /tmp/ccVWLGiI.s 			page 740


 25950              		.loc 1 13330 0
 25951 006a 40B2     		sxtb	r0, r0
 25952 006c 02B0     		add	sp, sp, #8
 25953              	.LCFI1056:
 25954              		.cfi_remember_state
 25955              		.cfi_def_cfa_offset 16
 25956              		@ sp needed
 25957 006e 70BD     		pop	{r4, r5, r6, pc}
 25958              	.LVL3224:
 25959              	.L2828:
 25960              	.LCFI1057:
 25961              		.cfi_restore_state
13298:Src/bno055.c  **** 		} else {
 25962              		.loc 1 13298 0
 25963 0070 8120     		movs	r0, #129
 25964              	.LVL3225:
 25965 0072 DFE7     		b	.L2825
 25966              	.L2839:
 25967              		.align	2
 25968              	.L2838:
 25969 0074 00000000 		.word	.LANCHOR0
 25970              		.cfi_endproc
 25971              	.LFE214:
 25973              		.section	.text.bno055_get_intr_gyro_any_motion,"ax",%progbits
 25974              		.align	2
 25975              		.global	bno055_get_intr_gyro_any_motion
 25976              		.thumb
 25977              		.thumb_func
 25979              	bno055_get_intr_gyro_any_motion:
 25980              	.LFB215:
13331:Src/bno055.c  **** /*!
13332:Src/bno055.c  ****  *	@brief This API used to read the gyro anymotion interrupt
13333:Src/bno055.c  ****  *	from page one register from 0x10 bit 2
13334:Src/bno055.c  ****  *
13335:Src/bno055.c  ****  *	@param gyro_any_motion_u8 : The value of gyro anymotion interrupt
13336:Src/bno055.c  ****  *		gyro_any_motion_u8 | result
13337:Src/bno055.c  ****  *     --------------------  |------------
13338:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13339:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13340:Src/bno055.c  ****  *
13341:Src/bno055.c  ****  *	@return results of bus communication function
13342:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13343:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13344:Src/bno055.c  ****  *
13345:Src/bno055.c  ****  *	@note While enabling the gyro anymotion interrupt
13346:Src/bno055.c  ****  *	configure the following settings
13347:Src/bno055.c  ****  *
13348:Src/bno055.c  ****  *	Axis:
13349:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_axis_enable()
13350:Src/bno055.c  ****  *
13351:Src/bno055.c  ****  *	Filter setting:
13352:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_filter()
13353:Src/bno055.c  ****  *
13354:Src/bno055.c  ****  *	Threshold :
13355:Src/bno055.c  ****  *
13356:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_thres()
13357:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 741


13358:Src/bno055.c  ****  *	Slope samples :
13359:Src/bno055.c  ****  *
13360:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_slope_samples()
13361:Src/bno055.c  ****  *
13362:Src/bno055.c  ****  *	Awake duration :
13363:Src/bno055.c  ****  *
13364:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_awake_durn()
13365:Src/bno055.c  ****  */
13366:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_gyro_any_motion(
13367:Src/bno055.c  **** u8 *gyro_any_motion_u8)
13368:Src/bno055.c  **** {
 25981              		.loc 1 13368 0
 25982              		.cfi_startproc
 25983              		@ args = 0, pretend = 0, frame = 8
 25984              		@ frame_needed = 0, uses_anonymous_args = 0
 25985              	.LVL3226:
 25986 0000 30B5     		push	{r4, r5, lr}
 25987              	.LCFI1058:
 25988              		.cfi_def_cfa_offset 12
 25989              		.cfi_offset 4, -12
 25990              		.cfi_offset 5, -8
 25991              		.cfi_offset 14, -4
13369:Src/bno055.c  **** 	/* Variable used to return value of
13370:Src/bno055.c  **** 	communication routine*/
13371:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13372:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13373:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13374:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13375:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 25992              		.loc 1 13375 0
 25993 0002 144C     		ldr	r4, .L2852
13368:Src/bno055.c  **** 	/* Variable used to return value of
 25994              		.loc 1 13368 0
 25995 0004 83B0     		sub	sp, sp, #12
 25996              	.LCFI1059:
 25997              		.cfi_def_cfa_offset 24
 25998              		.loc 1 13375 0
 25999 0006 2368     		ldr	r3, [r4]
13372:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26000              		.loc 1 13372 0
 26001 0008 0022     		movs	r2, #0
 26002 000a 8DF80720 		strb	r2, [sp, #7]
 26003              	.LVL3227:
 26004              		.loc 1 13375 0
 26005 000e FBB1     		cbz	r3, .L2844
13376:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13377:Src/bno055.c  **** 		} else {
13378:Src/bno055.c  **** 		/*condition check for page, gyro anymotion interrupt  is
13379:Src/bno055.c  **** 		available in the page one*/
13380:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26006              		.loc 1 13380 0
 26007 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26008 0012 0546     		mov	r5, r0
 26009 0014 012A     		cmp	r2, #1
 26010 0016 04D0     		beq	.L2842
13381:Src/bno055.c  **** 			/* Write page as one */
13382:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
ARM GAS  /tmp/ccVWLGiI.s 			page 742


 26011              		.loc 1 13382 0
 26012 0018 0120     		movs	r0, #1
 26013              	.LVL3228:
 26014 001a FFF7FEFF 		bl	bno055_write_page_id
 26015              	.LVL3229:
 26016 001e 2368     		ldr	r3, [r4]
13383:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26017              		.loc 1 13383 0
 26018 0020 70B9     		cbnz	r0, .L2851
 26019              	.LVL3230:
 26020              	.L2842:
13384:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13385:Src/bno055.c  **** 			/* Read the value of gyro anymotion interrupt */
13386:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26021              		.loc 1 13386 0
 26022 0022 1C69     		ldr	r4, [r3, #16]
 26023 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26024 0026 1021     		movs	r1, #16
 26025 0028 0123     		movs	r3, #1
 26026 002a 0DF10702 		add	r2, sp, #7
 26027 002e A047     		blx	r4
 26028              	.LVL3231:
13387:Src/bno055.c  **** 			(p_bno055->dev_addr,
13388:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR_REG,
13389:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13390:Src/bno055.c  **** 			*gyro_any_motion_u8 =
13391:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26029              		.loc 1 13391 0
 26030 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 26031 0034 C3F38003 		ubfx	r3, r3, #2, #1
13390:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26032              		.loc 1 13390 0
 26033 0038 2B70     		strb	r3, [r5]
 26034              	.LVL3232:
 26035              	.L2841:
13392:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR);
13393:Src/bno055.c  **** 		} else {
13394:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13395:Src/bno055.c  **** 		}
13396:Src/bno055.c  **** 	}
13397:Src/bno055.c  **** 	return com_rslt;
13398:Src/bno055.c  **** }
 26036              		.loc 1 13398 0
 26037 003a 40B2     		sxtb	r0, r0
 26038 003c 03B0     		add	sp, sp, #12
 26039              	.LCFI1060:
 26040              		.cfi_remember_state
 26041              		.cfi_def_cfa_offset 12
 26042              		@ sp needed
 26043 003e 30BD     		pop	{r4, r5, pc}
 26044              	.LVL3233:
 26045              	.L2851:
 26046              	.LCFI1061:
 26047              		.cfi_restore_state
13383:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26048              		.loc 1 13383 0 discriminator 1
 26049 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 743


 26050 0042 012A     		cmp	r2, #1
13394:Src/bno055.c  **** 		}
 26051              		.loc 1 13394 0 discriminator 1
 26052 0044 18BF     		it	ne
 26053 0046 FF20     		movne	r0, #255
13383:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26054              		.loc 1 13383 0 discriminator 1
 26055 0048 EBD0     		beq	.L2842
 26056              		.loc 1 13398 0
 26057 004a 40B2     		sxtb	r0, r0
 26058 004c 03B0     		add	sp, sp, #12
 26059              	.LCFI1062:
 26060              		.cfi_remember_state
 26061              		.cfi_def_cfa_offset 12
 26062              		@ sp needed
 26063 004e 30BD     		pop	{r4, r5, pc}
 26064              	.LVL3234:
 26065              	.L2844:
 26066              	.LCFI1063:
 26067              		.cfi_restore_state
13376:Src/bno055.c  **** 		} else {
 26068              		.loc 1 13376 0
 26069 0050 8120     		movs	r0, #129
 26070              	.LVL3235:
 26071 0052 F2E7     		b	.L2841
 26072              	.L2853:
 26073              		.align	2
 26074              	.L2852:
 26075 0054 00000000 		.word	.LANCHOR0
 26076              		.cfi_endproc
 26077              	.LFE215:
 26079              		.section	.text.bno055_set_intr_gyro_any_motion,"ax",%progbits
 26080              		.align	2
 26081              		.global	bno055_set_intr_gyro_any_motion
 26082              		.thumb
 26083              		.thumb_func
 26085              	bno055_set_intr_gyro_any_motion:
 26086              	.LFB216:
13399:Src/bno055.c  **** /*!
13400:Src/bno055.c  ****  *	@brief This API used to write the gyro anymotion interrupt
13401:Src/bno055.c  ****  *	from page one register from 0x10 bit 2
13402:Src/bno055.c  ****  *
13403:Src/bno055.c  ****  *	@param gyro_any_motion_u8 : The value of gyro anymotion interrupt
13404:Src/bno055.c  ****  *	  gyro_any_motion_u8   | result
13405:Src/bno055.c  ****  *     --------------------  |------------
13406:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13407:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13408:Src/bno055.c  ****  *
13409:Src/bno055.c  ****  *	@return results of bus communication function
13410:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13411:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13412:Src/bno055.c  ****  *
13413:Src/bno055.c  ****  *	@note While enabling the gyro anymotion interrupt
13414:Src/bno055.c  ****  *	configure the following settings
13415:Src/bno055.c  ****  *
13416:Src/bno055.c  ****  *	Axis:
13417:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_axis_enable()
ARM GAS  /tmp/ccVWLGiI.s 			page 744


13418:Src/bno055.c  ****  *
13419:Src/bno055.c  ****  *	Filter setting:
13420:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_filter()
13421:Src/bno055.c  ****  *
13422:Src/bno055.c  ****  *	Threshold :
13423:Src/bno055.c  ****  *
13424:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_thres()
13425:Src/bno055.c  ****  *
13426:Src/bno055.c  ****  *	Slope samples :
13427:Src/bno055.c  ****  *
13428:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_slope_samples()
13429:Src/bno055.c  ****  *
13430:Src/bno055.c  ****  *	Awake duration :
13431:Src/bno055.c  ****  *
13432:Src/bno055.c  ****  *	bno055_set_gyro_any_motion_awake_durn()
13433:Src/bno055.c  ****  */
13434:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_gyro_any_motion(
13435:Src/bno055.c  **** u8 gyro_any_motion_u8)
13436:Src/bno055.c  **** {
 26087              		.loc 1 13436 0
 26088              		.cfi_startproc
 26089              		@ args = 0, pretend = 0, frame = 8
 26090              		@ frame_needed = 0, uses_anonymous_args = 0
 26091              	.LVL3236:
 26092 0000 70B5     		push	{r4, r5, r6, lr}
 26093              	.LCFI1064:
 26094              		.cfi_def_cfa_offset 16
 26095              		.cfi_offset 4, -16
 26096              		.cfi_offset 5, -12
 26097              		.cfi_offset 6, -8
 26098              		.cfi_offset 14, -4
13437:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13438:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
13439:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
13440:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
13441:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 26099              		.loc 1 13441 0
 26100 0002 1D4D     		ldr	r5, .L2868
13436:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 26101              		.loc 1 13436 0
 26102 0004 82B0     		sub	sp, sp, #8
 26103              	.LCFI1065:
 26104              		.cfi_def_cfa_offset 24
 26105              		.loc 1 13441 0
 26106 0006 2B68     		ldr	r3, [r5]
13438:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 26107              		.loc 1 13438 0
 26108 0008 0022     		movs	r2, #0
 26109 000a 8DF80720 		strb	r2, [sp, #7]
 26110              	.LVL3237:
 26111              		.loc 1 13441 0
 26112 000e 002B     		cmp	r3, #0
 26113 0010 30D0     		beq	.L2858
13442:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
13443:Src/bno055.c  **** 	} else {
13444:Src/bno055.c  **** 	/*condition check for page, gyro anymotion interrupt  is
13445:Src/bno055.c  **** 	available in the page one*/
ARM GAS  /tmp/ccVWLGiI.s 			page 745


13446:Src/bno055.c  **** 	if (p_bno055->page_id != BNO055_PAGE_ONE)
 26114              		.loc 1 13446 0
 26115 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26116 0014 0446     		mov	r4, r0
 26117 0016 012A     		cmp	r2, #1
 26118 0018 04D0     		beq	.L2856
13447:Src/bno055.c  **** 		/* Write page as one */
13448:Src/bno055.c  **** 		stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26119              		.loc 1 13448 0
 26120 001a 0120     		movs	r0, #1
 26121              	.LVL3238:
 26122 001c FFF7FEFF 		bl	bno055_write_page_id
 26123              	.LVL3239:
 26124 0020 2B68     		ldr	r3, [r5]
13449:Src/bno055.c  **** 	if ((stat_s8 == BNO055_SUCCESS) ||
 26125              		.loc 1 13449 0
 26126 0022 50B9     		cbnz	r0, .L2866
 26127              	.LVL3240:
 26128              	.L2856:
13450:Src/bno055.c  **** 	(p_bno055->page_id == BNO055_PAGE_ONE)) {
13451:Src/bno055.c  **** 		/* Write the value of gyro anymotion interrupt */
13452:Src/bno055.c  **** 		com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26129              		.loc 1 13452 0
 26130 0024 1E69     		ldr	r6, [r3, #16]
 26131 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26132 0028 0DF10702 		add	r2, sp, #7
 26133 002c 1021     		movs	r1, #16
 26134 002e 0123     		movs	r3, #1
 26135 0030 B047     		blx	r6
 26136              	.LVL3241:
13453:Src/bno055.c  **** 		(p_bno055->dev_addr,
13454:Src/bno055.c  **** 		BNO055_GYRO_ANY_MOTION_INTR_REG,
13455:Src/bno055.c  **** 		&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13456:Src/bno055.c  **** 		if (com_rslt == BNO055_SUCCESS) {
 26137              		.loc 1 13456 0
 26138 0032 50B1     		cbz	r0, .L2867
 26139              	.LVL3242:
 26140              	.L2855:
13457:Src/bno055.c  **** 			data_u8r =
13458:Src/bno055.c  **** 			BNO055_SET_BITSLICE(data_u8r,
13459:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR,
13460:Src/bno055.c  **** 			gyro_any_motion_u8);
13461:Src/bno055.c  **** 			com_rslt +=
13462:Src/bno055.c  **** 			p_bno055->BNO055_BUS_WRITE_FUNC
13463:Src/bno055.c  **** 			(p_bno055->dev_addr,
13464:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR_REG,
13465:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13466:Src/bno055.c  **** 		}
13467:Src/bno055.c  **** 	} else {
13468:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
13469:Src/bno055.c  **** 	}
13470:Src/bno055.c  **** 	}
13471:Src/bno055.c  **** 	return com_rslt;
13472:Src/bno055.c  **** }
 26141              		.loc 1 13472 0
 26142 0034 40B2     		sxtb	r0, r0
 26143 0036 02B0     		add	sp, sp, #8
ARM GAS  /tmp/ccVWLGiI.s 			page 746


 26144              	.LCFI1066:
 26145              		.cfi_remember_state
 26146              		.cfi_def_cfa_offset 16
 26147              		@ sp needed
 26148 0038 70BD     		pop	{r4, r5, r6, pc}
 26149              	.LVL3243:
 26150              	.L2866:
 26151              	.LCFI1067:
 26152              		.cfi_restore_state
13449:Src/bno055.c  **** 	(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26153              		.loc 1 13449 0 discriminator 1
 26154 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26155 003c 012A     		cmp	r2, #1
13468:Src/bno055.c  **** 	}
 26156              		.loc 1 13468 0 discriminator 1
 26157 003e 18BF     		it	ne
 26158 0040 FF20     		movne	r0, #255
13449:Src/bno055.c  **** 	(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26159              		.loc 1 13449 0 discriminator 1
 26160 0042 EFD0     		beq	.L2856
 26161              		.loc 1 13472 0
 26162 0044 40B2     		sxtb	r0, r0
 26163 0046 02B0     		add	sp, sp, #8
 26164              	.LCFI1068:
 26165              		.cfi_remember_state
 26166              		.cfi_def_cfa_offset 16
 26167              		@ sp needed
 26168 0048 70BD     		pop	{r4, r5, r6, pc}
 26169              	.LVL3244:
 26170              	.L2867:
 26171              	.LCFI1069:
 26172              		.cfi_restore_state
13457:Src/bno055.c  **** 			data_u8r =
 26173              		.loc 1 13457 0
 26174 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
13458:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_INTR,
 26175              		.loc 1 13458 0
 26176 004e A000     		lsls	r0, r4, #2
 26177              	.LVL3245:
13462:Src/bno055.c  **** 			(p_bno055->dev_addr,
 26178              		.loc 1 13462 0
 26179 0050 2968     		ldr	r1, [r5]
13457:Src/bno055.c  **** 			BNO055_SET_BITSLICE(data_u8r,
 26180              		.loc 1 13457 0
 26181 0052 23F00404 		bic	r4, r3, #4
 26182 0056 00F00400 		and	r0, r0, #4
 26183 005a 2043     		orrs	r0, r0, r4
 26184 005c 8DF80700 		strb	r0, [sp, #7]
13462:Src/bno055.c  **** 			(p_bno055->dev_addr,
 26185              		.loc 1 13462 0
 26186 0060 CC68     		ldr	r4, [r1, #12]
 26187 0062 0DF10702 		add	r2, sp, #7
 26188 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 26189 0068 0123     		movs	r3, #1
 26190 006a 1021     		movs	r1, #16
 26191 006c A047     		blx	r4
 26192              	.LVL3246:
ARM GAS  /tmp/ccVWLGiI.s 			page 747


 26193              		.loc 1 13472 0
 26194 006e 40B2     		sxtb	r0, r0
 26195 0070 02B0     		add	sp, sp, #8
 26196              	.LCFI1070:
 26197              		.cfi_remember_state
 26198              		.cfi_def_cfa_offset 16
 26199              		@ sp needed
 26200 0072 70BD     		pop	{r4, r5, r6, pc}
 26201              	.LVL3247:
 26202              	.L2858:
 26203              	.LCFI1071:
 26204              		.cfi_restore_state
13442:Src/bno055.c  **** 	} else {
 26205              		.loc 1 13442 0
 26206 0074 8120     		movs	r0, #129
 26207              	.LVL3248:
 26208 0076 DDE7     		b	.L2855
 26209              	.L2869:
 26210              		.align	2
 26211              	.L2868:
 26212 0078 00000000 		.word	.LANCHOR0
 26213              		.cfi_endproc
 26214              	.LFE216:
 26216              		.section	.text.bno055_get_intr_gyro_highrate,"ax",%progbits
 26217              		.align	2
 26218              		.global	bno055_get_intr_gyro_highrate
 26219              		.thumb
 26220              		.thumb_func
 26222              	bno055_get_intr_gyro_highrate:
 26223              	.LFB217:
13473:Src/bno055.c  **** /*!
13474:Src/bno055.c  ****  *	@brief This API used to read the gyro highrate interrupt
13475:Src/bno055.c  ****  *	from page one register from 0x10 bit 3
13476:Src/bno055.c  ****  *
13477:Src/bno055.c  ****  *	@param gyro_highrate_u8 : The value of gyro highrate interrupt
13478:Src/bno055.c  ****  *		gyro_highrate_u8   | result
13479:Src/bno055.c  ****  *     --------------------  |------------
13480:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13481:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13482:Src/bno055.c  ****  *
13483:Src/bno055.c  ****  *	@return results of bus communication function
13484:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13485:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13486:Src/bno055.c  ****  *
13487:Src/bno055.c  ****  *	@note While enabling the gyro highrate interrupt
13488:Src/bno055.c  ****  *	configure the below settings by using
13489:Src/bno055.c  ****  *	the following APIs
13490:Src/bno055.c  ****  *
13491:Src/bno055.c  ****  *	Axis :
13492:Src/bno055.c  ****  *
13493:Src/bno055.c  ****  *	bno055_set_gyro_highrate_axis_enable()
13494:Src/bno055.c  ****  *
13495:Src/bno055.c  ****  *	Filter :
13496:Src/bno055.c  ****  *
13497:Src/bno055.c  ****  *	bno055_set_gyro_highrate_filter()
13498:Src/bno055.c  ****  *
13499:Src/bno055.c  ****  *	Threshold :
ARM GAS  /tmp/ccVWLGiI.s 			page 748


13500:Src/bno055.c  ****  *
13501:Src/bno055.c  ****  *	bno055_get_gyro_highrate_x_thres()
13502:Src/bno055.c  ****  *
13503:Src/bno055.c  ****  *	bno055_get_gyro_highrate_y_thres()
13504:Src/bno055.c  ****  *
13505:Src/bno055.c  ****  *	bno055_get_gyro_highrate_z_thres()
13506:Src/bno055.c  ****  *
13507:Src/bno055.c  ****  *	Hysteresis :
13508:Src/bno055.c  ****  *
13509:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_hyst()
13510:Src/bno055.c  ****  *
13511:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_hyst()
13512:Src/bno055.c  ****  *
13513:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_hyst()
13514:Src/bno055.c  ****  *
13515:Src/bno055.c  ****  *	Duration :
13516:Src/bno055.c  ****  *
13517:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_durn()
13518:Src/bno055.c  ****  *
13519:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_durn()
13520:Src/bno055.c  ****  *
13521:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_durn()
13522:Src/bno055.c  ****  *
13523:Src/bno055.c  ****  */
13524:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_gyro_highrate(
13525:Src/bno055.c  **** u8 *gyro_highrate_u8)
13526:Src/bno055.c  **** {
 26224              		.loc 1 13526 0
 26225              		.cfi_startproc
 26226              		@ args = 0, pretend = 0, frame = 8
 26227              		@ frame_needed = 0, uses_anonymous_args = 0
 26228              	.LVL3249:
 26229 0000 30B5     		push	{r4, r5, lr}
 26230              	.LCFI1072:
 26231              		.cfi_def_cfa_offset 12
 26232              		.cfi_offset 4, -12
 26233              		.cfi_offset 5, -8
 26234              		.cfi_offset 14, -4
13527:Src/bno055.c  **** 	/* Variable used to return value of
13528:Src/bno055.c  **** 	communication routine*/
13529:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13530:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13531:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13532:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13533:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26235              		.loc 1 13533 0
 26236 0002 144C     		ldr	r4, .L2882
13526:Src/bno055.c  **** 	/* Variable used to return value of
 26237              		.loc 1 13526 0
 26238 0004 83B0     		sub	sp, sp, #12
 26239              	.LCFI1073:
 26240              		.cfi_def_cfa_offset 24
 26241              		.loc 1 13533 0
 26242 0006 2368     		ldr	r3, [r4]
13530:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26243              		.loc 1 13530 0
 26244 0008 0022     		movs	r2, #0
ARM GAS  /tmp/ccVWLGiI.s 			page 749


 26245 000a 8DF80720 		strb	r2, [sp, #7]
 26246              	.LVL3250:
 26247              		.loc 1 13533 0
 26248 000e FBB1     		cbz	r3, .L2874
13534:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13535:Src/bno055.c  **** 		} else {
13536:Src/bno055.c  **** 		/*condition check for page, gyro highrate interrupt is
13537:Src/bno055.c  **** 		available in the page one*/
13538:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26249              		.loc 1 13538 0
 26250 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26251 0012 0546     		mov	r5, r0
 26252 0014 012A     		cmp	r2, #1
 26253 0016 04D0     		beq	.L2872
13539:Src/bno055.c  **** 			/* Write page as one */
13540:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26254              		.loc 1 13540 0
 26255 0018 0120     		movs	r0, #1
 26256              	.LVL3251:
 26257 001a FFF7FEFF 		bl	bno055_write_page_id
 26258              	.LVL3252:
 26259 001e 2368     		ldr	r3, [r4]
13541:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26260              		.loc 1 13541 0
 26261 0020 70B9     		cbnz	r0, .L2881
 26262              	.LVL3253:
 26263              	.L2872:
13542:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13543:Src/bno055.c  **** 			/* Read the value of gyro highrate interrupt */
13544:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26264              		.loc 1 13544 0
 26265 0022 1C69     		ldr	r4, [r3, #16]
 26266 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26267 0026 1021     		movs	r1, #16
 26268 0028 0123     		movs	r3, #1
 26269 002a 0DF10702 		add	r2, sp, #7
 26270 002e A047     		blx	r4
 26271              	.LVL3254:
13545:Src/bno055.c  **** 			(p_bno055->dev_addr,
13546:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_INTR_REG,
13547:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13548:Src/bno055.c  **** 			*gyro_highrate_u8 =
13549:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26272              		.loc 1 13549 0
 26273 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 26274 0034 C3F3C003 		ubfx	r3, r3, #3, #1
13548:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26275              		.loc 1 13548 0
 26276 0038 2B70     		strb	r3, [r5]
 26277              	.LVL3255:
 26278              	.L2871:
13550:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_INTR);
13551:Src/bno055.c  **** 		} else {
13552:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13553:Src/bno055.c  **** 		}
13554:Src/bno055.c  **** 	}
13555:Src/bno055.c  **** 	return com_rslt;
ARM GAS  /tmp/ccVWLGiI.s 			page 750


13556:Src/bno055.c  **** }
 26279              		.loc 1 13556 0
 26280 003a 40B2     		sxtb	r0, r0
 26281 003c 03B0     		add	sp, sp, #12
 26282              	.LCFI1074:
 26283              		.cfi_remember_state
 26284              		.cfi_def_cfa_offset 12
 26285              		@ sp needed
 26286 003e 30BD     		pop	{r4, r5, pc}
 26287              	.LVL3256:
 26288              	.L2881:
 26289              	.LCFI1075:
 26290              		.cfi_restore_state
13541:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26291              		.loc 1 13541 0 discriminator 1
 26292 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26293 0042 012A     		cmp	r2, #1
13552:Src/bno055.c  **** 		}
 26294              		.loc 1 13552 0 discriminator 1
 26295 0044 18BF     		it	ne
 26296 0046 FF20     		movne	r0, #255
13541:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26297              		.loc 1 13541 0 discriminator 1
 26298 0048 EBD0     		beq	.L2872
 26299              		.loc 1 13556 0
 26300 004a 40B2     		sxtb	r0, r0
 26301 004c 03B0     		add	sp, sp, #12
 26302              	.LCFI1076:
 26303              		.cfi_remember_state
 26304              		.cfi_def_cfa_offset 12
 26305              		@ sp needed
 26306 004e 30BD     		pop	{r4, r5, pc}
 26307              	.LVL3257:
 26308              	.L2874:
 26309              	.LCFI1077:
 26310              		.cfi_restore_state
13534:Src/bno055.c  **** 		} else {
 26311              		.loc 1 13534 0
 26312 0050 8120     		movs	r0, #129
 26313              	.LVL3258:
 26314 0052 F2E7     		b	.L2871
 26315              	.L2883:
 26316              		.align	2
 26317              	.L2882:
 26318 0054 00000000 		.word	.LANCHOR0
 26319              		.cfi_endproc
 26320              	.LFE217:
 26322              		.section	.text.bno055_set_intr_gyro_highrate,"ax",%progbits
 26323              		.align	2
 26324              		.global	bno055_set_intr_gyro_highrate
 26325              		.thumb
 26326              		.thumb_func
 26328              	bno055_set_intr_gyro_highrate:
 26329              	.LFB218:
13557:Src/bno055.c  **** /*!
13558:Src/bno055.c  ****  *	@brief This API used to write the gyro highrate interrupt
13559:Src/bno055.c  ****  *	from page one register from 0x10 bit 3
ARM GAS  /tmp/ccVWLGiI.s 			page 751


13560:Src/bno055.c  ****  *
13561:Src/bno055.c  ****  *	@param gyro_highrate_u8 : The value of gyro highrate interrupt
13562:Src/bno055.c  ****  *		gyro_highrate_u8   | result
13563:Src/bno055.c  ****  *     --------------------  |------------
13564:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13565:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13566:Src/bno055.c  ****  *
13567:Src/bno055.c  ****  *	@return results of bus communication function
13568:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13569:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13570:Src/bno055.c  ****  *
13571:Src/bno055.c  ****  *	@note While enabling the gyro highrate interrupt
13572:Src/bno055.c  ****  *	configure the below settings by using
13573:Src/bno055.c  ****  *	the following APIs
13574:Src/bno055.c  ****  *
13575:Src/bno055.c  ****  *	Axis :
13576:Src/bno055.c  ****  *
13577:Src/bno055.c  ****  *	bno055_set_gyro_highrate_axis_enable()
13578:Src/bno055.c  ****  *
13579:Src/bno055.c  ****  *	Filter :
13580:Src/bno055.c  ****  *
13581:Src/bno055.c  ****  *	bno055_set_gyro_highrate_filter()
13582:Src/bno055.c  ****  *
13583:Src/bno055.c  ****  *	Threshold :
13584:Src/bno055.c  ****  *
13585:Src/bno055.c  ****  *	bno055_get_gyro_highrate_x_thres()
13586:Src/bno055.c  ****  *
13587:Src/bno055.c  ****  *	bno055_get_gyro_highrate_y_thres()
13588:Src/bno055.c  ****  *
13589:Src/bno055.c  ****  *	bno055_get_gyro_highrate_z_thres()
13590:Src/bno055.c  ****  *
13591:Src/bno055.c  ****  *	Hysteresis :
13592:Src/bno055.c  ****  *
13593:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_hyst()
13594:Src/bno055.c  ****  *
13595:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_hyst()
13596:Src/bno055.c  ****  *
13597:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_hyst()
13598:Src/bno055.c  ****  *
13599:Src/bno055.c  ****  *	Duration :
13600:Src/bno055.c  ****  *
13601:Src/bno055.c  ****  *	bno055_set_gyro_highrate_x_durn()
13602:Src/bno055.c  ****  *
13603:Src/bno055.c  ****  *	bno055_set_gyro_highrate_y_durn()
13604:Src/bno055.c  ****  *
13605:Src/bno055.c  ****  *	bno055_set_gyro_highrate_z_durn()
13606:Src/bno055.c  ****  *
13607:Src/bno055.c  ****  */
13608:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_gyro_highrate(
13609:Src/bno055.c  **** u8 gyro_highrate_u8)
13610:Src/bno055.c  **** {
 26330              		.loc 1 13610 0
 26331              		.cfi_startproc
 26332              		@ args = 0, pretend = 0, frame = 8
 26333              		@ frame_needed = 0, uses_anonymous_args = 0
 26334              	.LVL3259:
 26335 0000 70B5     		push	{r4, r5, r6, lr}
ARM GAS  /tmp/ccVWLGiI.s 			page 752


 26336              	.LCFI1078:
 26337              		.cfi_def_cfa_offset 16
 26338              		.cfi_offset 4, -16
 26339              		.cfi_offset 5, -12
 26340              		.cfi_offset 6, -8
 26341              		.cfi_offset 14, -4
13611:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13612:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13613:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13614:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13615:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26342              		.loc 1 13615 0
 26343 0002 1D4D     		ldr	r5, .L2898
13610:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 26344              		.loc 1 13610 0
 26345 0004 82B0     		sub	sp, sp, #8
 26346              	.LCFI1079:
 26347              		.cfi_def_cfa_offset 24
 26348              		.loc 1 13615 0
 26349 0006 2B68     		ldr	r3, [r5]
13612:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26350              		.loc 1 13612 0
 26351 0008 0022     		movs	r2, #0
 26352 000a 8DF80720 		strb	r2, [sp, #7]
 26353              	.LVL3260:
 26354              		.loc 1 13615 0
 26355 000e 002B     		cmp	r3, #0
 26356 0010 30D0     		beq	.L2888
13616:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13617:Src/bno055.c  **** 		} else {
13618:Src/bno055.c  **** 		/*condition check for page, gyro highrate interrupt is
13619:Src/bno055.c  **** 		available in the page one*/
13620:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26357              		.loc 1 13620 0
 26358 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26359 0014 0446     		mov	r4, r0
 26360 0016 012A     		cmp	r2, #1
 26361 0018 04D0     		beq	.L2886
13621:Src/bno055.c  **** 			/* Write page as one */
13622:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26362              		.loc 1 13622 0
 26363 001a 0120     		movs	r0, #1
 26364              	.LVL3261:
 26365 001c FFF7FEFF 		bl	bno055_write_page_id
 26366              	.LVL3262:
 26367 0020 2B68     		ldr	r3, [r5]
13623:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26368              		.loc 1 13623 0
 26369 0022 50B9     		cbnz	r0, .L2896
 26370              	.LVL3263:
 26371              	.L2886:
13624:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13625:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26372              		.loc 1 13625 0
 26373 0024 1E69     		ldr	r6, [r3, #16]
 26374 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26375 0028 0DF10702 		add	r2, sp, #7
ARM GAS  /tmp/ccVWLGiI.s 			page 753


 26376 002c 1021     		movs	r1, #16
 26377 002e 0123     		movs	r3, #1
 26378 0030 B047     		blx	r6
 26379              	.LVL3264:
13626:Src/bno055.c  **** 			(p_bno055->dev_addr,
13627:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_INTR_REG,
13628:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13629:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 26380              		.loc 1 13629 0
 26381 0032 50B1     		cbz	r0, .L2897
 26382              	.LVL3265:
 26383              	.L2885:
13630:Src/bno055.c  **** 				/* Write the value of gyro highrate interrupt */
13631:Src/bno055.c  **** 				data_u8r =
13632:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
13633:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_INTR, gyro_highrate_u8);
13634:Src/bno055.c  **** 				com_rslt +=
13635:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
13636:Src/bno055.c  **** 				(p_bno055->dev_addr,
13637:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_INTR_REG,
13638:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13639:Src/bno055.c  **** 			}
13640:Src/bno055.c  **** 		} else {
13641:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13642:Src/bno055.c  **** 		}
13643:Src/bno055.c  **** 	}
13644:Src/bno055.c  **** 	return com_rslt;
13645:Src/bno055.c  **** }
 26384              		.loc 1 13645 0
 26385 0034 40B2     		sxtb	r0, r0
 26386 0036 02B0     		add	sp, sp, #8
 26387              	.LCFI1080:
 26388              		.cfi_remember_state
 26389              		.cfi_def_cfa_offset 16
 26390              		@ sp needed
 26391 0038 70BD     		pop	{r4, r5, r6, pc}
 26392              	.LVL3266:
 26393              	.L2896:
 26394              	.LCFI1081:
 26395              		.cfi_restore_state
13623:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26396              		.loc 1 13623 0 discriminator 1
 26397 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26398 003c 012A     		cmp	r2, #1
13641:Src/bno055.c  **** 		}
 26399              		.loc 1 13641 0 discriminator 1
 26400 003e 18BF     		it	ne
 26401 0040 FF20     		movne	r0, #255
13623:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26402              		.loc 1 13623 0 discriminator 1
 26403 0042 EFD0     		beq	.L2886
 26404              		.loc 1 13645 0
 26405 0044 40B2     		sxtb	r0, r0
 26406 0046 02B0     		add	sp, sp, #8
 26407              	.LCFI1082:
 26408              		.cfi_remember_state
 26409              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccVWLGiI.s 			page 754


 26410              		@ sp needed
 26411 0048 70BD     		pop	{r4, r5, r6, pc}
 26412              	.LVL3267:
 26413              	.L2897:
 26414              	.LCFI1083:
 26415              		.cfi_restore_state
13631:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 26416              		.loc 1 13631 0
 26417 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
13632:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_INTR, gyro_highrate_u8);
 26418              		.loc 1 13632 0
 26419 004e E000     		lsls	r0, r4, #3
 26420              	.LVL3268:
13635:Src/bno055.c  **** 				(p_bno055->dev_addr,
 26421              		.loc 1 13635 0
 26422 0050 2968     		ldr	r1, [r5]
13631:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 26423              		.loc 1 13631 0
 26424 0052 23F00804 		bic	r4, r3, #8
 26425 0056 00F00800 		and	r0, r0, #8
 26426 005a 2043     		orrs	r0, r0, r4
 26427 005c 8DF80700 		strb	r0, [sp, #7]
13635:Src/bno055.c  **** 				(p_bno055->dev_addr,
 26428              		.loc 1 13635 0
 26429 0060 CC68     		ldr	r4, [r1, #12]
 26430 0062 0DF10702 		add	r2, sp, #7
 26431 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 26432 0068 0123     		movs	r3, #1
 26433 006a 1021     		movs	r1, #16
 26434 006c A047     		blx	r4
 26435              	.LVL3269:
 26436              		.loc 1 13645 0
 26437 006e 40B2     		sxtb	r0, r0
 26438 0070 02B0     		add	sp, sp, #8
 26439              	.LCFI1084:
 26440              		.cfi_remember_state
 26441              		.cfi_def_cfa_offset 16
 26442              		@ sp needed
 26443 0072 70BD     		pop	{r4, r5, r6, pc}
 26444              	.LVL3270:
 26445              	.L2888:
 26446              	.LCFI1085:
 26447              		.cfi_restore_state
13616:Src/bno055.c  **** 		} else {
 26448              		.loc 1 13616 0
 26449 0074 8120     		movs	r0, #129
 26450              	.LVL3271:
 26451 0076 DDE7     		b	.L2885
 26452              	.L2899:
 26453              		.align	2
 26454              	.L2898:
 26455 0078 00000000 		.word	.LANCHOR0
 26456              		.cfi_endproc
 26457              	.LFE218:
 26459              		.section	.text.bno055_get_intr_accel_high_g,"ax",%progbits
 26460              		.align	2
 26461              		.global	bno055_get_intr_accel_high_g
ARM GAS  /tmp/ccVWLGiI.s 			page 755


 26462              		.thumb
 26463              		.thumb_func
 26465              	bno055_get_intr_accel_high_g:
 26466              	.LFB219:
13646:Src/bno055.c  **** /*!
13647:Src/bno055.c  ****  *	@brief This API used to read the accel highg interrupt
13648:Src/bno055.c  ****  *	from page one register from 0x10 bit 5
13649:Src/bno055.c  ****  *
13650:Src/bno055.c  ****  *	@param accel_high_g_u8 : The value of accel highg interrupt
13651:Src/bno055.c  ****  *		accel_high_g_u8    | result
13652:Src/bno055.c  ****  *     --------------------  |------------
13653:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13654:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13655:Src/bno055.c  ****  *
13656:Src/bno055.c  ****  *	@return results of bus communication function
13657:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13658:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13659:Src/bno055.c  ****  *
13660:Src/bno055.c  ****  *	@note While enabling the accel highg interrupt
13661:Src/bno055.c  ****  *	configure the below settings by using
13662:Src/bno055.c  ****  *	the following APIs
13663:Src/bno055.c  ****  *
13664:Src/bno055.c  ****  *	Axis :
13665:Src/bno055.c  ****  *
13666:Src/bno055.c  ****  *	bno055_set_accel_high_g_axis_enable()
13667:Src/bno055.c  ****  *
13668:Src/bno055.c  ****  *	Threshold :
13669:Src/bno055.c  ****  *
13670:Src/bno055.c  ****  *	bno055_set_accel_high_g_thres()
13671:Src/bno055.c  ****  *
13672:Src/bno055.c  ****  *	Duration :
13673:Src/bno055.c  ****  *
13674:Src/bno055.c  ****  *	bno055_set_accel_high_g_durn()
13675:Src/bno055.c  ****  *
13676:Src/bno055.c  ****  */
13677:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_accel_high_g(
13678:Src/bno055.c  **** u8 *accel_high_g_u8)
13679:Src/bno055.c  **** {
 26467              		.loc 1 13679 0
 26468              		.cfi_startproc
 26469              		@ args = 0, pretend = 0, frame = 8
 26470              		@ frame_needed = 0, uses_anonymous_args = 0
 26471              	.LVL3272:
 26472 0000 30B5     		push	{r4, r5, lr}
 26473              	.LCFI1086:
 26474              		.cfi_def_cfa_offset 12
 26475              		.cfi_offset 4, -12
 26476              		.cfi_offset 5, -8
 26477              		.cfi_offset 14, -4
13680:Src/bno055.c  **** 	/* Variable used to return value of
13681:Src/bno055.c  **** 	communication routine*/
13682:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13683:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13684:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13685:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13686:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26478              		.loc 1 13686 0
ARM GAS  /tmp/ccVWLGiI.s 			page 756


 26479 0002 144C     		ldr	r4, .L2912
13679:Src/bno055.c  **** 	/* Variable used to return value of
 26480              		.loc 1 13679 0
 26481 0004 83B0     		sub	sp, sp, #12
 26482              	.LCFI1087:
 26483              		.cfi_def_cfa_offset 24
 26484              		.loc 1 13686 0
 26485 0006 2368     		ldr	r3, [r4]
13683:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26486              		.loc 1 13683 0
 26487 0008 0022     		movs	r2, #0
 26488 000a 8DF80720 		strb	r2, [sp, #7]
 26489              	.LVL3273:
 26490              		.loc 1 13686 0
 26491 000e FBB1     		cbz	r3, .L2904
13687:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13688:Src/bno055.c  **** 		} else {
13689:Src/bno055.c  **** 		/*condition check for page, accel highg interrupt  is
13690:Src/bno055.c  **** 		available in the page one*/
13691:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26492              		.loc 1 13691 0
 26493 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26494 0012 0546     		mov	r5, r0
 26495 0014 012A     		cmp	r2, #1
 26496 0016 04D0     		beq	.L2902
13692:Src/bno055.c  **** 			/* Write page as one */
13693:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26497              		.loc 1 13693 0
 26498 0018 0120     		movs	r0, #1
 26499              	.LVL3274:
 26500 001a FFF7FEFF 		bl	bno055_write_page_id
 26501              	.LVL3275:
 26502 001e 2368     		ldr	r3, [r4]
13694:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26503              		.loc 1 13694 0
 26504 0020 70B9     		cbnz	r0, .L2911
 26505              	.LVL3276:
 26506              	.L2902:
13695:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13696:Src/bno055.c  **** 			/* Read the value of accel highg interrupt*/
13697:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26507              		.loc 1 13697 0
 26508 0022 1C69     		ldr	r4, [r3, #16]
 26509 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26510 0026 1021     		movs	r1, #16
 26511 0028 0123     		movs	r3, #1
 26512 002a 0DF10702 		add	r2, sp, #7
 26513 002e A047     		blx	r4
 26514              	.LVL3277:
13698:Src/bno055.c  **** 			(p_bno055->dev_addr,
13699:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_INTR_REG,
13700:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13701:Src/bno055.c  **** 			*accel_high_g_u8 =
13702:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26515              		.loc 1 13702 0
 26516 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 26517 0034 C3F34013 		ubfx	r3, r3, #5, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 757


13701:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26518              		.loc 1 13701 0
 26519 0038 2B70     		strb	r3, [r5]
 26520              	.LVL3278:
 26521              	.L2901:
13703:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_INTR);
13704:Src/bno055.c  **** 		} else {
13705:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13706:Src/bno055.c  **** 		}
13707:Src/bno055.c  **** 	}
13708:Src/bno055.c  **** 	return com_rslt;
13709:Src/bno055.c  **** }
 26522              		.loc 1 13709 0
 26523 003a 40B2     		sxtb	r0, r0
 26524 003c 03B0     		add	sp, sp, #12
 26525              	.LCFI1088:
 26526              		.cfi_remember_state
 26527              		.cfi_def_cfa_offset 12
 26528              		@ sp needed
 26529 003e 30BD     		pop	{r4, r5, pc}
 26530              	.LVL3279:
 26531              	.L2911:
 26532              	.LCFI1089:
 26533              		.cfi_restore_state
13694:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26534              		.loc 1 13694 0 discriminator 1
 26535 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26536 0042 012A     		cmp	r2, #1
13705:Src/bno055.c  **** 		}
 26537              		.loc 1 13705 0 discriminator 1
 26538 0044 18BF     		it	ne
 26539 0046 FF20     		movne	r0, #255
13694:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26540              		.loc 1 13694 0 discriminator 1
 26541 0048 EBD0     		beq	.L2902
 26542              		.loc 1 13709 0
 26543 004a 40B2     		sxtb	r0, r0
 26544 004c 03B0     		add	sp, sp, #12
 26545              	.LCFI1090:
 26546              		.cfi_remember_state
 26547              		.cfi_def_cfa_offset 12
 26548              		@ sp needed
 26549 004e 30BD     		pop	{r4, r5, pc}
 26550              	.LVL3280:
 26551              	.L2904:
 26552              	.LCFI1091:
 26553              		.cfi_restore_state
13687:Src/bno055.c  **** 		} else {
 26554              		.loc 1 13687 0
 26555 0050 8120     		movs	r0, #129
 26556              	.LVL3281:
 26557 0052 F2E7     		b	.L2901
 26558              	.L2913:
 26559              		.align	2
 26560              	.L2912:
 26561 0054 00000000 		.word	.LANCHOR0
 26562              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 758


 26563              	.LFE219:
 26565              		.section	.text.bno055_set_intr_accel_high_g,"ax",%progbits
 26566              		.align	2
 26567              		.global	bno055_set_intr_accel_high_g
 26568              		.thumb
 26569              		.thumb_func
 26571              	bno055_set_intr_accel_high_g:
 26572              	.LFB220:
13710:Src/bno055.c  **** /*!
13711:Src/bno055.c  ****  *	@brief This API used to write the accel highg interrupt
13712:Src/bno055.c  ****  *	from page one register from 0x10 bit 5
13713:Src/bno055.c  ****  *
13714:Src/bno055.c  ****  *	@param accel_high_g_u8 : The value of accel highg interrupt
13715:Src/bno055.c  ****  *		accel_high_g_u8    | result
13716:Src/bno055.c  ****  *     --------------------  |------------
13717:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13718:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13719:Src/bno055.c  ****  *
13720:Src/bno055.c  ****  *	@return results of bus communication function
13721:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13722:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13723:Src/bno055.c  ****  *
13724:Src/bno055.c  ****  *	@note While enabling the accel highg interrupt
13725:Src/bno055.c  ****  *	configure the below settings by using
13726:Src/bno055.c  ****  *	the following APIs
13727:Src/bno055.c  ****  *
13728:Src/bno055.c  ****  *	Axis :
13729:Src/bno055.c  ****  *
13730:Src/bno055.c  ****  *	bno055_set_accel_high_g_axis_enable()
13731:Src/bno055.c  ****  *
13732:Src/bno055.c  ****  *	Threshold :
13733:Src/bno055.c  ****  *
13734:Src/bno055.c  ****  *	bno055_set_accel_high_g_thres()
13735:Src/bno055.c  ****  *
13736:Src/bno055.c  ****  *	Duration :
13737:Src/bno055.c  ****  *
13738:Src/bno055.c  ****  *	bno055_set_accel_high_g_durn()
13739:Src/bno055.c  ****  *
13740:Src/bno055.c  ****  */
13741:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_accel_high_g(
13742:Src/bno055.c  **** u8 accel_high_g_u8)
13743:Src/bno055.c  **** {
 26573              		.loc 1 13743 0
 26574              		.cfi_startproc
 26575              		@ args = 0, pretend = 0, frame = 8
 26576              		@ frame_needed = 0, uses_anonymous_args = 0
 26577              	.LVL3282:
 26578 0000 70B5     		push	{r4, r5, r6, lr}
 26579              	.LCFI1092:
 26580              		.cfi_def_cfa_offset 16
 26581              		.cfi_offset 4, -16
 26582              		.cfi_offset 5, -12
 26583              		.cfi_offset 6, -8
 26584              		.cfi_offset 14, -4
13744:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13745:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13746:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 759


13747:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13748:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26585              		.loc 1 13748 0
 26586 0002 1D4D     		ldr	r5, .L2928
13743:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 26587              		.loc 1 13743 0
 26588 0004 82B0     		sub	sp, sp, #8
 26589              	.LCFI1093:
 26590              		.cfi_def_cfa_offset 24
 26591              		.loc 1 13748 0
 26592 0006 2B68     		ldr	r3, [r5]
13745:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26593              		.loc 1 13745 0
 26594 0008 0022     		movs	r2, #0
 26595 000a 8DF80720 		strb	r2, [sp, #7]
 26596              	.LVL3283:
 26597              		.loc 1 13748 0
 26598 000e 002B     		cmp	r3, #0
 26599 0010 30D0     		beq	.L2918
13749:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13750:Src/bno055.c  **** 		} else {
13751:Src/bno055.c  **** 		/*condition check for page, accel highg interrupt is
13752:Src/bno055.c  **** 		available in the page one*/
13753:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26600              		.loc 1 13753 0
 26601 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26602 0014 0446     		mov	r4, r0
 26603 0016 012A     		cmp	r2, #1
 26604 0018 04D0     		beq	.L2916
13754:Src/bno055.c  **** 			/* Write page as one */
13755:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26605              		.loc 1 13755 0
 26606 001a 0120     		movs	r0, #1
 26607              	.LVL3284:
 26608 001c FFF7FEFF 		bl	bno055_write_page_id
 26609              	.LVL3285:
 26610 0020 2B68     		ldr	r3, [r5]
13756:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26611              		.loc 1 13756 0
 26612 0022 50B9     		cbnz	r0, .L2926
 26613              	.LVL3286:
 26614              	.L2916:
13757:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13758:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26615              		.loc 1 13758 0
 26616 0024 1E69     		ldr	r6, [r3, #16]
 26617 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26618 0028 0DF10702 		add	r2, sp, #7
 26619 002c 1021     		movs	r1, #16
 26620 002e 0123     		movs	r3, #1
 26621 0030 B047     		blx	r6
 26622              	.LVL3287:
13759:Src/bno055.c  **** 			(p_bno055->dev_addr,
13760:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_INTR_REG,
13761:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13762:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 26623              		.loc 1 13762 0
ARM GAS  /tmp/ccVWLGiI.s 			page 760


 26624 0032 50B1     		cbz	r0, .L2927
 26625              	.LVL3288:
 26626              	.L2915:
13763:Src/bno055.c  **** 				/* Write the value of accel highg interrupt*/
13764:Src/bno055.c  **** 				data_u8r =
13765:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
13766:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_INTR,
13767:Src/bno055.c  **** 				accel_high_g_u8);
13768:Src/bno055.c  **** 				com_rslt +=
13769:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
13770:Src/bno055.c  **** 				(p_bno055->dev_addr,
13771:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_INTR_REG,
13772:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13773:Src/bno055.c  **** 			}
13774:Src/bno055.c  **** 		} else {
13775:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13776:Src/bno055.c  **** 		}
13777:Src/bno055.c  **** 	}
13778:Src/bno055.c  **** 	return com_rslt;
13779:Src/bno055.c  **** }
 26627              		.loc 1 13779 0
 26628 0034 40B2     		sxtb	r0, r0
 26629 0036 02B0     		add	sp, sp, #8
 26630              	.LCFI1094:
 26631              		.cfi_remember_state
 26632              		.cfi_def_cfa_offset 16
 26633              		@ sp needed
 26634 0038 70BD     		pop	{r4, r5, r6, pc}
 26635              	.LVL3289:
 26636              	.L2926:
 26637              	.LCFI1095:
 26638              		.cfi_restore_state
13756:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26639              		.loc 1 13756 0 discriminator 1
 26640 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26641 003c 012A     		cmp	r2, #1
13775:Src/bno055.c  **** 		}
 26642              		.loc 1 13775 0 discriminator 1
 26643 003e 18BF     		it	ne
 26644 0040 FF20     		movne	r0, #255
13756:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26645              		.loc 1 13756 0 discriminator 1
 26646 0042 EFD0     		beq	.L2916
 26647              		.loc 1 13779 0
 26648 0044 40B2     		sxtb	r0, r0
 26649 0046 02B0     		add	sp, sp, #8
 26650              	.LCFI1096:
 26651              		.cfi_remember_state
 26652              		.cfi_def_cfa_offset 16
 26653              		@ sp needed
 26654 0048 70BD     		pop	{r4, r5, r6, pc}
 26655              	.LVL3290:
 26656              	.L2927:
 26657              	.LCFI1097:
 26658              		.cfi_restore_state
13764:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 26659              		.loc 1 13764 0
ARM GAS  /tmp/ccVWLGiI.s 			page 761


 26660 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
13765:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_INTR,
 26661              		.loc 1 13765 0
 26662 004e 6001     		lsls	r0, r4, #5
 26663              	.LVL3291:
13769:Src/bno055.c  **** 				(p_bno055->dev_addr,
 26664              		.loc 1 13769 0
 26665 0050 2968     		ldr	r1, [r5]
13764:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 26666              		.loc 1 13764 0
 26667 0052 23F02004 		bic	r4, r3, #32
 26668 0056 00F02000 		and	r0, r0, #32
 26669 005a 2043     		orrs	r0, r0, r4
 26670 005c 8DF80700 		strb	r0, [sp, #7]
13769:Src/bno055.c  **** 				(p_bno055->dev_addr,
 26671              		.loc 1 13769 0
 26672 0060 CC68     		ldr	r4, [r1, #12]
 26673 0062 0DF10702 		add	r2, sp, #7
 26674 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 26675 0068 0123     		movs	r3, #1
 26676 006a 1021     		movs	r1, #16
 26677 006c A047     		blx	r4
 26678              	.LVL3292:
 26679              		.loc 1 13779 0
 26680 006e 40B2     		sxtb	r0, r0
 26681 0070 02B0     		add	sp, sp, #8
 26682              	.LCFI1098:
 26683              		.cfi_remember_state
 26684              		.cfi_def_cfa_offset 16
 26685              		@ sp needed
 26686 0072 70BD     		pop	{r4, r5, r6, pc}
 26687              	.LVL3293:
 26688              	.L2918:
 26689              	.LCFI1099:
 26690              		.cfi_restore_state
13749:Src/bno055.c  **** 		} else {
 26691              		.loc 1 13749 0
 26692 0074 8120     		movs	r0, #129
 26693              	.LVL3294:
 26694 0076 DDE7     		b	.L2915
 26695              	.L2929:
 26696              		.align	2
 26697              	.L2928:
 26698 0078 00000000 		.word	.LANCHOR0
 26699              		.cfi_endproc
 26700              	.LFE220:
 26702              		.section	.text.bno055_get_intr_accel_any_motion,"ax",%progbits
 26703              		.align	2
 26704              		.global	bno055_get_intr_accel_any_motion
 26705              		.thumb
 26706              		.thumb_func
 26708              	bno055_get_intr_accel_any_motion:
 26709              	.LFB221:
13780:Src/bno055.c  **** /*!
13781:Src/bno055.c  ****  *	@brief This API used to read the accel anymotion interrupt
13782:Src/bno055.c  ****  *	from page one register from 0x10 bit 6
13783:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 762


13784:Src/bno055.c  ****  *	@param accel_any_motion_u8 : The value of accel anymotion interrupt
13785:Src/bno055.c  ****  *	accel_any_motion_u8    | result
13786:Src/bno055.c  ****  *     --------------------  |------------
13787:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13788:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13789:Src/bno055.c  ****  *
13790:Src/bno055.c  ****  *	@return results of bus communication function
13791:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13792:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13793:Src/bno055.c  ****  *
13794:Src/bno055.c  ****  *	@note While enabling the accel anymotion interrupt
13795:Src/bno055.c  ****  *	configure the following settings
13796:Src/bno055.c  ****  *
13797:Src/bno055.c  ****  *	Axis:
13798:Src/bno055.c  ****  *
13799:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13800:Src/bno055.c  ****  *
13801:Src/bno055.c  ****  *	Duration:
13802:Src/bno055.c  ****  *
13803:Src/bno055.c  ****  *	bno055_set_accel_any_motion_durn()
13804:Src/bno055.c  ****  *
13805:Src/bno055.c  ****  * Threshold:
13806:Src/bno055.c  ****  *
13807:Src/bno055.c  ****  *	bno055_set_accel_any_motion_thres()
13808:Src/bno055.c  ****  *
13809:Src/bno055.c  ****  */
13810:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_accel_any_motion(
13811:Src/bno055.c  **** u8 *accel_any_motion_u8)
13812:Src/bno055.c  **** {
 26710              		.loc 1 13812 0
 26711              		.cfi_startproc
 26712              		@ args = 0, pretend = 0, frame = 8
 26713              		@ frame_needed = 0, uses_anonymous_args = 0
 26714              	.LVL3295:
 26715 0000 30B5     		push	{r4, r5, lr}
 26716              	.LCFI1100:
 26717              		.cfi_def_cfa_offset 12
 26718              		.cfi_offset 4, -12
 26719              		.cfi_offset 5, -8
 26720              		.cfi_offset 14, -4
13813:Src/bno055.c  **** 	/* Variable used to return value of
13814:Src/bno055.c  **** 	communication routine*/
13815:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13816:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13817:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13818:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13819:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26721              		.loc 1 13819 0
 26722 0002 144C     		ldr	r4, .L2942
13812:Src/bno055.c  **** 	/* Variable used to return value of
 26723              		.loc 1 13812 0
 26724 0004 83B0     		sub	sp, sp, #12
 26725              	.LCFI1101:
 26726              		.cfi_def_cfa_offset 24
 26727              		.loc 1 13819 0
 26728 0006 2368     		ldr	r3, [r4]
13816:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 763


 26729              		.loc 1 13816 0
 26730 0008 0022     		movs	r2, #0
 26731 000a 8DF80720 		strb	r2, [sp, #7]
 26732              	.LVL3296:
 26733              		.loc 1 13819 0
 26734 000e FBB1     		cbz	r3, .L2934
13820:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13821:Src/bno055.c  **** 		} else {
13822:Src/bno055.c  **** 		/*condition check for page, accel anymotion interrupt  is
13823:Src/bno055.c  **** 		available in the page one*/
13824:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26735              		.loc 1 13824 0
 26736 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26737 0012 0546     		mov	r5, r0
 26738 0014 012A     		cmp	r2, #1
 26739 0016 04D0     		beq	.L2932
13825:Src/bno055.c  **** 			/* Write page as one */
13826:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26740              		.loc 1 13826 0
 26741 0018 0120     		movs	r0, #1
 26742              	.LVL3297:
 26743 001a FFF7FEFF 		bl	bno055_write_page_id
 26744              	.LVL3298:
 26745 001e 2368     		ldr	r3, [r4]
13827:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26746              		.loc 1 13827 0
 26747 0020 70B9     		cbnz	r0, .L2941
 26748              	.LVL3299:
 26749              	.L2932:
13828:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13829:Src/bno055.c  **** 			/* Read the value of accel anymotion interrupt */
13830:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26750              		.loc 1 13830 0
 26751 0022 1C69     		ldr	r4, [r3, #16]
 26752 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26753 0026 1021     		movs	r1, #16
 26754 0028 0123     		movs	r3, #1
 26755 002a 0DF10702 		add	r2, sp, #7
 26756 002e A047     		blx	r4
 26757              	.LVL3300:
13831:Src/bno055.c  **** 			(p_bno055->dev_addr,
13832:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_INTR_REG,
13833:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13834:Src/bno055.c  **** 			*accel_any_motion_u8 =
13835:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26758              		.loc 1 13835 0
 26759 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 26760 0034 C3F38013 		ubfx	r3, r3, #6, #1
13834:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 26761              		.loc 1 13834 0
 26762 0038 2B70     		strb	r3, [r5]
 26763              	.LVL3301:
 26764              	.L2931:
13836:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_INTR);
13837:Src/bno055.c  **** 		} else {
13838:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13839:Src/bno055.c  **** 		}
ARM GAS  /tmp/ccVWLGiI.s 			page 764


13840:Src/bno055.c  **** 	}
13841:Src/bno055.c  **** 	return com_rslt;
13842:Src/bno055.c  **** }
 26765              		.loc 1 13842 0
 26766 003a 40B2     		sxtb	r0, r0
 26767 003c 03B0     		add	sp, sp, #12
 26768              	.LCFI1102:
 26769              		.cfi_remember_state
 26770              		.cfi_def_cfa_offset 12
 26771              		@ sp needed
 26772 003e 30BD     		pop	{r4, r5, pc}
 26773              	.LVL3302:
 26774              	.L2941:
 26775              	.LCFI1103:
 26776              		.cfi_restore_state
13827:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26777              		.loc 1 13827 0 discriminator 1
 26778 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26779 0042 012A     		cmp	r2, #1
13838:Src/bno055.c  **** 		}
 26780              		.loc 1 13838 0 discriminator 1
 26781 0044 18BF     		it	ne
 26782 0046 FF20     		movne	r0, #255
13827:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26783              		.loc 1 13827 0 discriminator 1
 26784 0048 EBD0     		beq	.L2932
 26785              		.loc 1 13842 0
 26786 004a 40B2     		sxtb	r0, r0
 26787 004c 03B0     		add	sp, sp, #12
 26788              	.LCFI1104:
 26789              		.cfi_remember_state
 26790              		.cfi_def_cfa_offset 12
 26791              		@ sp needed
 26792 004e 30BD     		pop	{r4, r5, pc}
 26793              	.LVL3303:
 26794              	.L2934:
 26795              	.LCFI1105:
 26796              		.cfi_restore_state
13820:Src/bno055.c  **** 		} else {
 26797              		.loc 1 13820 0
 26798 0050 8120     		movs	r0, #129
 26799              	.LVL3304:
 26800 0052 F2E7     		b	.L2931
 26801              	.L2943:
 26802              		.align	2
 26803              	.L2942:
 26804 0054 00000000 		.word	.LANCHOR0
 26805              		.cfi_endproc
 26806              	.LFE221:
 26808              		.section	.text.bno055_set_intr_accel_any_motion,"ax",%progbits
 26809              		.align	2
 26810              		.global	bno055_set_intr_accel_any_motion
 26811              		.thumb
 26812              		.thumb_func
 26814              	bno055_set_intr_accel_any_motion:
 26815              	.LFB222:
13843:Src/bno055.c  **** /*!
ARM GAS  /tmp/ccVWLGiI.s 			page 765


13844:Src/bno055.c  ****  *	@brief This API used to write the accel anymotion interrupt
13845:Src/bno055.c  ****  *	from page one register from 0x10 bit 6
13846:Src/bno055.c  ****  *
13847:Src/bno055.c  ****  *	@param accel_any_motion_u8 : The value of accel anymotion interrupt
13848:Src/bno055.c  ****  *	accel_any_motion_u8    | result
13849:Src/bno055.c  ****  *     --------------------  |------------
13850:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13851:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13852:Src/bno055.c  ****  *
13853:Src/bno055.c  ****  *	@return results of bus communication function
13854:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13855:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13856:Src/bno055.c  ****  *
13857:Src/bno055.c  ****  *	@note While enabling the accel anymotion interrupt
13858:Src/bno055.c  ****  *	configure the following settings
13859:Src/bno055.c  ****  *
13860:Src/bno055.c  ****  *	Axis:
13861:Src/bno055.c  ****  *
13862:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13863:Src/bno055.c  ****  *
13864:Src/bno055.c  ****  *	Duration:
13865:Src/bno055.c  ****  *
13866:Src/bno055.c  ****  *	bno055_set_accel_any_motion_durn()
13867:Src/bno055.c  ****  *
13868:Src/bno055.c  ****  *	Threshold:
13869:Src/bno055.c  ****  *
13870:Src/bno055.c  ****  *	bno055_set_accel_any_motion_thres()
13871:Src/bno055.c  ****  *
13872:Src/bno055.c  ****  */
13873:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_accel_any_motion(
13874:Src/bno055.c  **** u8 accel_any_motion_u8)
13875:Src/bno055.c  **** {
 26816              		.loc 1 13875 0
 26817              		.cfi_startproc
 26818              		@ args = 0, pretend = 0, frame = 8
 26819              		@ frame_needed = 0, uses_anonymous_args = 0
 26820              	.LVL3305:
 26821 0000 70B5     		push	{r4, r5, r6, lr}
 26822              	.LCFI1106:
 26823              		.cfi_def_cfa_offset 16
 26824              		.cfi_offset 4, -16
 26825              		.cfi_offset 5, -12
 26826              		.cfi_offset 6, -8
 26827              		.cfi_offset 14, -4
13876:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13877:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13878:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13879:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13880:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26828              		.loc 1 13880 0
 26829 0002 1D4D     		ldr	r5, .L2958
13875:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 26830              		.loc 1 13875 0
 26831 0004 82B0     		sub	sp, sp, #8
 26832              	.LCFI1107:
 26833              		.cfi_def_cfa_offset 24
 26834              		.loc 1 13880 0
ARM GAS  /tmp/ccVWLGiI.s 			page 766


 26835 0006 2B68     		ldr	r3, [r5]
13877:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26836              		.loc 1 13877 0
 26837 0008 0022     		movs	r2, #0
 26838 000a 8DF80720 		strb	r2, [sp, #7]
 26839              	.LVL3306:
 26840              		.loc 1 13880 0
 26841 000e 002B     		cmp	r3, #0
 26842 0010 30D0     		beq	.L2948
13881:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13882:Src/bno055.c  **** 		} else {
13883:Src/bno055.c  **** 		/*condition check for page, accel range is
13884:Src/bno055.c  **** 		available in the page one*/
13885:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26843              		.loc 1 13885 0
 26844 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26845 0014 0446     		mov	r4, r0
 26846 0016 012A     		cmp	r2, #1
 26847 0018 04D0     		beq	.L2946
13886:Src/bno055.c  **** 			/* Write page as one */
13887:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26848              		.loc 1 13887 0
 26849 001a 0120     		movs	r0, #1
 26850              	.LVL3307:
 26851 001c FFF7FEFF 		bl	bno055_write_page_id
 26852              	.LVL3308:
 26853 0020 2B68     		ldr	r3, [r5]
13888:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26854              		.loc 1 13888 0
 26855 0022 50B9     		cbnz	r0, .L2956
 26856              	.LVL3309:
 26857              	.L2946:
13889:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13890:Src/bno055.c  **** 			/* Write the value of accel anymotion interrupt */
13891:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26858              		.loc 1 13891 0
 26859 0024 1E69     		ldr	r6, [r3, #16]
 26860 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26861 0028 0DF10702 		add	r2, sp, #7
 26862 002c 1021     		movs	r1, #16
 26863 002e 0123     		movs	r3, #1
 26864 0030 B047     		blx	r6
 26865              	.LVL3310:
13892:Src/bno055.c  **** 			(p_bno055->dev_addr,
13893:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_INTR_REG,
13894:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13895:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 26866              		.loc 1 13895 0
 26867 0032 50B1     		cbz	r0, .L2957
 26868              	.LVL3311:
 26869              	.L2945:
13896:Src/bno055.c  **** 				data_u8r =
13897:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
13898:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_INTR,
13899:Src/bno055.c  **** 				accel_any_motion_u8);
13900:Src/bno055.c  **** 				com_rslt +=
13901:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 767


13902:Src/bno055.c  **** 				(p_bno055->dev_addr,
13903:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_INTR_REG,
13904:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13905:Src/bno055.c  **** 			}
13906:Src/bno055.c  **** 		} else {
13907:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13908:Src/bno055.c  **** 		}
13909:Src/bno055.c  **** 	}
13910:Src/bno055.c  **** 	return com_rslt;
13911:Src/bno055.c  **** }
 26870              		.loc 1 13911 0
 26871 0034 40B2     		sxtb	r0, r0
 26872 0036 02B0     		add	sp, sp, #8
 26873              	.LCFI1108:
 26874              		.cfi_remember_state
 26875              		.cfi_def_cfa_offset 16
 26876              		@ sp needed
 26877 0038 70BD     		pop	{r4, r5, r6, pc}
 26878              	.LVL3312:
 26879              	.L2956:
 26880              	.LCFI1109:
 26881              		.cfi_restore_state
13888:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26882              		.loc 1 13888 0 discriminator 1
 26883 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26884 003c 012A     		cmp	r2, #1
13907:Src/bno055.c  **** 		}
 26885              		.loc 1 13907 0 discriminator 1
 26886 003e 18BF     		it	ne
 26887 0040 FF20     		movne	r0, #255
13888:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 26888              		.loc 1 13888 0 discriminator 1
 26889 0042 EFD0     		beq	.L2946
 26890              		.loc 1 13911 0
 26891 0044 40B2     		sxtb	r0, r0
 26892 0046 02B0     		add	sp, sp, #8
 26893              	.LCFI1110:
 26894              		.cfi_remember_state
 26895              		.cfi_def_cfa_offset 16
 26896              		@ sp needed
 26897 0048 70BD     		pop	{r4, r5, r6, pc}
 26898              	.LVL3313:
 26899              	.L2957:
 26900              	.LCFI1111:
 26901              		.cfi_restore_state
13896:Src/bno055.c  **** 				data_u8r =
 26902              		.loc 1 13896 0
 26903 004a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
13897:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_INTR,
 26904              		.loc 1 13897 0
 26905 004e A001     		lsls	r0, r4, #6
 26906              	.LVL3314:
13901:Src/bno055.c  **** 				(p_bno055->dev_addr,
 26907              		.loc 1 13901 0
 26908 0050 2968     		ldr	r1, [r5]
13896:Src/bno055.c  **** 				BNO055_SET_BITSLICE(data_u8r,
 26909              		.loc 1 13896 0
ARM GAS  /tmp/ccVWLGiI.s 			page 768


 26910 0052 23F04004 		bic	r4, r3, #64
 26911 0056 00F04000 		and	r0, r0, #64
 26912 005a 2043     		orrs	r0, r0, r4
 26913 005c 8DF80700 		strb	r0, [sp, #7]
13901:Src/bno055.c  **** 				(p_bno055->dev_addr,
 26914              		.loc 1 13901 0
 26915 0060 CC68     		ldr	r4, [r1, #12]
 26916 0062 0DF10702 		add	r2, sp, #7
 26917 0066 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 26918 0068 0123     		movs	r3, #1
 26919 006a 1021     		movs	r1, #16
 26920 006c A047     		blx	r4
 26921              	.LVL3315:
 26922              		.loc 1 13911 0
 26923 006e 40B2     		sxtb	r0, r0
 26924 0070 02B0     		add	sp, sp, #8
 26925              	.LCFI1112:
 26926              		.cfi_remember_state
 26927              		.cfi_def_cfa_offset 16
 26928              		@ sp needed
 26929 0072 70BD     		pop	{r4, r5, r6, pc}
 26930              	.LVL3316:
 26931              	.L2948:
 26932              	.LCFI1113:
 26933              		.cfi_restore_state
13881:Src/bno055.c  **** 		} else {
 26934              		.loc 1 13881 0
 26935 0074 8120     		movs	r0, #129
 26936              	.LVL3317:
 26937 0076 DDE7     		b	.L2945
 26938              	.L2959:
 26939              		.align	2
 26940              	.L2958:
 26941 0078 00000000 		.word	.LANCHOR0
 26942              		.cfi_endproc
 26943              	.LFE222:
 26945              		.section	.text.bno055_get_intr_accel_no_motion,"ax",%progbits
 26946              		.align	2
 26947              		.global	bno055_get_intr_accel_no_motion
 26948              		.thumb
 26949              		.thumb_func
 26951              	bno055_get_intr_accel_no_motion:
 26952              	.LFB223:
13912:Src/bno055.c  **** /*!
13913:Src/bno055.c  ****  *	@brief This API used to read the accel nomotion interrupt
13914:Src/bno055.c  ****  *	from page one register from 0x10 bit 6
13915:Src/bno055.c  ****  *
13916:Src/bno055.c  ****  *	@param accel_nomotion_u8 : The value of accel nomotion interrupt
13917:Src/bno055.c  ****  *	  accel_nomotion_u8    | result
13918:Src/bno055.c  ****  *     --------------------  |------------
13919:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13920:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13921:Src/bno055.c  ****  *
13922:Src/bno055.c  ****  *	@return results of bus communication function
13923:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13924:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13925:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 769


13926:Src/bno055.c  ****  *	@note While enabling the accel nomotion interrupt
13927:Src/bno055.c  ****  *	configure the following settings
13928:Src/bno055.c  ****  *
13929:Src/bno055.c  ****  *	Axis:
13930:Src/bno055.c  ****  *
13931:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13932:Src/bno055.c  ****  *
13933:Src/bno055.c  ****  *	Threshold :
13934:Src/bno055.c  ****  *
13935:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_thres()
13936:Src/bno055.c  ****  *
13937:Src/bno055.c  ****  *	Duration :
13938:Src/bno055.c  ****  *
13939:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_durn()
13940:Src/bno055.c  ****  *
13941:Src/bno055.c  ****  *	Slow/no motion enable:
13942:Src/bno055.c  ****  *
13943:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_enable()
13944:Src/bno055.c  ****  *
13945:Src/bno055.c  ****  */
13946:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_intr_accel_no_motion(
13947:Src/bno055.c  **** u8 *accel_nomotion_u8)
13948:Src/bno055.c  **** {
 26953              		.loc 1 13948 0
 26954              		.cfi_startproc
 26955              		@ args = 0, pretend = 0, frame = 8
 26956              		@ frame_needed = 0, uses_anonymous_args = 0
 26957              	.LVL3318:
 26958 0000 30B5     		push	{r4, r5, lr}
 26959              	.LCFI1114:
 26960              		.cfi_def_cfa_offset 12
 26961              		.cfi_offset 4, -12
 26962              		.cfi_offset 5, -8
 26963              		.cfi_offset 14, -4
13949:Src/bno055.c  **** 	/* Variable used to return value of
13950:Src/bno055.c  **** 	communication routine*/
13951:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
13952:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
13953:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
13954:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
13955:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 26964              		.loc 1 13955 0
 26965 0002 144C     		ldr	r4, .L2972
13948:Src/bno055.c  **** 	/* Variable used to return value of
 26966              		.loc 1 13948 0
 26967 0004 83B0     		sub	sp, sp, #12
 26968              	.LCFI1115:
 26969              		.cfi_def_cfa_offset 24
 26970              		.loc 1 13955 0
 26971 0006 2368     		ldr	r3, [r4]
13952:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 26972              		.loc 1 13952 0
 26973 0008 0022     		movs	r2, #0
 26974 000a 8DF80720 		strb	r2, [sp, #7]
 26975              	.LVL3319:
 26976              		.loc 1 13955 0
 26977 000e F3B1     		cbz	r3, .L2964
ARM GAS  /tmp/ccVWLGiI.s 			page 770


13956:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
13957:Src/bno055.c  **** 		} else {
13958:Src/bno055.c  **** 		/*condition check for page, accel nomotion interrupt is
13959:Src/bno055.c  **** 		available in the page one*/
13960:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 26978              		.loc 1 13960 0
 26979 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 26980 0012 0546     		mov	r5, r0
 26981 0014 012A     		cmp	r2, #1
 26982 0016 04D0     		beq	.L2962
13961:Src/bno055.c  **** 			/* Write page as one */
13962:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 26983              		.loc 1 13962 0
 26984 0018 0120     		movs	r0, #1
 26985              	.LVL3320:
 26986 001a FFF7FEFF 		bl	bno055_write_page_id
 26987              	.LVL3321:
 26988 001e 2368     		ldr	r3, [r4]
13963:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 26989              		.loc 1 13963 0
 26990 0020 68B9     		cbnz	r0, .L2971
 26991              	.LVL3322:
 26992              	.L2962:
13964:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
13965:Src/bno055.c  **** 			/* Read the value of accel nomotion interrupt*/
13966:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 26993              		.loc 1 13966 0
 26994 0022 1C69     		ldr	r4, [r3, #16]
 26995 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 26996 0026 1021     		movs	r1, #16
 26997 0028 0123     		movs	r3, #1
 26998 002a 0DF10702 		add	r2, sp, #7
 26999 002e A047     		blx	r4
 27000              	.LVL3323:
13967:Src/bno055.c  **** 			(p_bno055->dev_addr,
13968:Src/bno055.c  **** 			BNO055_ACCEL_NO_MOTION_INTR_REG,
13969:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
13970:Src/bno055.c  **** 			*accel_nomotion_u8 =
13971:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 27001              		.loc 1 13971 0
 27002 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27003 0034 DB09     		lsrs	r3, r3, #7
13970:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 27004              		.loc 1 13970 0
 27005 0036 2B70     		strb	r3, [r5]
 27006              	.LVL3324:
 27007              	.L2961:
13972:Src/bno055.c  **** 			BNO055_ACCEL_NO_MOTION_INTR);
13973:Src/bno055.c  **** 		} else {
13974:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
13975:Src/bno055.c  **** 		}
13976:Src/bno055.c  **** 	}
13977:Src/bno055.c  **** 	return com_rslt;
13978:Src/bno055.c  **** }
 27008              		.loc 1 13978 0
 27009 0038 40B2     		sxtb	r0, r0
 27010 003a 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 771


 27011              	.LCFI1116:
 27012              		.cfi_remember_state
 27013              		.cfi_def_cfa_offset 12
 27014              		@ sp needed
 27015 003c 30BD     		pop	{r4, r5, pc}
 27016              	.LVL3325:
 27017              	.L2971:
 27018              	.LCFI1117:
 27019              		.cfi_restore_state
13963:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27020              		.loc 1 13963 0 discriminator 1
 27021 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27022 0040 012A     		cmp	r2, #1
13974:Src/bno055.c  **** 		}
 27023              		.loc 1 13974 0 discriminator 1
 27024 0042 18BF     		it	ne
 27025 0044 FF20     		movne	r0, #255
13963:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27026              		.loc 1 13963 0 discriminator 1
 27027 0046 ECD0     		beq	.L2962
 27028              		.loc 1 13978 0
 27029 0048 40B2     		sxtb	r0, r0
 27030 004a 03B0     		add	sp, sp, #12
 27031              	.LCFI1118:
 27032              		.cfi_remember_state
 27033              		.cfi_def_cfa_offset 12
 27034              		@ sp needed
 27035 004c 30BD     		pop	{r4, r5, pc}
 27036              	.LVL3326:
 27037              	.L2964:
 27038              	.LCFI1119:
 27039              		.cfi_restore_state
13956:Src/bno055.c  **** 		} else {
 27040              		.loc 1 13956 0
 27041 004e 8120     		movs	r0, #129
 27042              	.LVL3327:
 27043 0050 F2E7     		b	.L2961
 27044              	.L2973:
 27045 0052 00BF     		.align	2
 27046              	.L2972:
 27047 0054 00000000 		.word	.LANCHOR0
 27048              		.cfi_endproc
 27049              	.LFE223:
 27051              		.section	.text.bno055_set_intr_accel_no_motion,"ax",%progbits
 27052              		.align	2
 27053              		.global	bno055_set_intr_accel_no_motion
 27054              		.thumb
 27055              		.thumb_func
 27057              	bno055_set_intr_accel_no_motion:
 27058              	.LFB224:
13979:Src/bno055.c  **** /*!
13980:Src/bno055.c  ****  *	@brief This API used to write the accel nomotion interrupt
13981:Src/bno055.c  ****  *	from page one register from 0x10 bit 6
13982:Src/bno055.c  ****  *
13983:Src/bno055.c  ****  *	@param accel_nomotion_u8 : The value of accel nomotion interrupt
13984:Src/bno055.c  ****  *	  accel_nomotion_u8    | result
13985:Src/bno055.c  ****  *     --------------------  |------------
ARM GAS  /tmp/ccVWLGiI.s 			page 772


13986:Src/bno055.c  ****  *              0x01         | BNO055_BIT_ENABLE
13987:Src/bno055.c  ****  *              0x00         | BNO055_BIT_DISABLE
13988:Src/bno055.c  ****  *
13989:Src/bno055.c  ****  *	@return results of bus communication function
13990:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
13991:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
13992:Src/bno055.c  ****  *
13993:Src/bno055.c  ****  *	@note While enabling the accel nomotion interrupt
13994:Src/bno055.c  ****  *	configure the following settings
13995:Src/bno055.c  ****  *
13996:Src/bno055.c  ****  *	Axis:
13997:Src/bno055.c  ****  *
13998:Src/bno055.c  ****  *	bno055_set_accel_any_motion_no_motion_axis_enable()
13999:Src/bno055.c  ****  *
14000:Src/bno055.c  ****  *	Threshold :
14001:Src/bno055.c  ****  *
14002:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_thres()
14003:Src/bno055.c  ****  *
14004:Src/bno055.c  ****  *	Duration :
14005:Src/bno055.c  ****  *
14006:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_durn()
14007:Src/bno055.c  ****  *
14008:Src/bno055.c  ****  *	Slow/no motion enable:
14009:Src/bno055.c  ****  *
14010:Src/bno055.c  ****  *	bno055_set_accel_slow_no_motion_enable()
14011:Src/bno055.c  ****  *
14012:Src/bno055.c  ****  */
14013:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_intr_accel_no_motion(
14014:Src/bno055.c  **** u8 accel_nomotion_u8)
14015:Src/bno055.c  **** {
 27059              		.loc 1 14015 0
 27060              		.cfi_startproc
 27061              		@ args = 0, pretend = 0, frame = 8
 27062              		@ frame_needed = 0, uses_anonymous_args = 0
 27063              	.LVL3328:
 27064 0000 70B5     		push	{r4, r5, r6, lr}
 27065              	.LCFI1120:
 27066              		.cfi_def_cfa_offset 16
 27067              		.cfi_offset 4, -16
 27068              		.cfi_offset 5, -12
 27069              		.cfi_offset 6, -8
 27070              		.cfi_offset 14, -4
14016:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14017:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14018:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14019:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14020:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 27071              		.loc 1 14020 0
 27072 0002 1C4D     		ldr	r5, .L2988
14015:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 27073              		.loc 1 14015 0
 27074 0004 82B0     		sub	sp, sp, #8
 27075              	.LCFI1121:
 27076              		.cfi_def_cfa_offset 24
 27077              		.loc 1 14020 0
 27078 0006 2B68     		ldr	r3, [r5]
14017:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 773


 27079              		.loc 1 14017 0
 27080 0008 0022     		movs	r2, #0
 27081 000a 8DF80720 		strb	r2, [sp, #7]
 27082              	.LVL3329:
 27083              		.loc 1 14020 0
 27084 000e 002B     		cmp	r3, #0
 27085 0010 2ED0     		beq	.L2978
14021:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
14022:Src/bno055.c  **** 	} else {
14023:Src/bno055.c  **** 	/*condition check for page,
14024:Src/bno055.c  **** 	accel nomotion interrupt is
14025:Src/bno055.c  **** 	available in the page one*/
14026:Src/bno055.c  **** 	if (p_bno055->page_id != BNO055_PAGE_ONE)
 27086              		.loc 1 14026 0
 27087 0012 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27088 0014 0446     		mov	r4, r0
 27089 0016 012A     		cmp	r2, #1
 27090 0018 04D0     		beq	.L2976
14027:Src/bno055.c  **** 		/* Write page as one */
14028:Src/bno055.c  **** 		stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 27091              		.loc 1 14028 0
 27092 001a 0120     		movs	r0, #1
 27093              	.LVL3330:
 27094 001c FFF7FEFF 		bl	bno055_write_page_id
 27095              	.LVL3331:
 27096 0020 2B68     		ldr	r3, [r5]
14029:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 27097              		.loc 1 14029 0
 27098 0022 50B9     		cbnz	r0, .L2986
 27099              	.LVL3332:
 27100              	.L2976:
14030:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14031:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 27101              		.loc 1 14031 0
 27102 0024 1E69     		ldr	r6, [r3, #16]
 27103 0026 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27104 0028 0DF10702 		add	r2, sp, #7
 27105 002c 1021     		movs	r1, #16
 27106 002e 0123     		movs	r3, #1
 27107 0030 B047     		blx	r6
 27108              	.LVL3333:
14032:Src/bno055.c  **** 			(p_bno055->dev_addr,
14033:Src/bno055.c  **** 			BNO055_ACCEL_NO_MOTION_INTR_REG,
14034:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14035:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
 27109              		.loc 1 14035 0
 27110 0032 50B1     		cbz	r0, .L2987
 27111              	.LVL3334:
 27112              	.L2975:
14036:Src/bno055.c  **** 				/* Write the value of
14037:Src/bno055.c  **** 				accel nomotion interrupt */
14038:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE(data_u8r,
14039:Src/bno055.c  **** 				BNO055_ACCEL_NO_MOTION_INTR,
14040:Src/bno055.c  **** 				accel_nomotion_u8);
14041:Src/bno055.c  **** 				com_rslt += p_bno055->BNO055_BUS_WRITE_FUNC
14042:Src/bno055.c  **** 				(p_bno055->dev_addr,
14043:Src/bno055.c  **** 				BNO055_ACCEL_NO_MOTION_INTR_REG,
ARM GAS  /tmp/ccVWLGiI.s 			page 774


14044:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14045:Src/bno055.c  **** 			}
14046:Src/bno055.c  **** 		} else {
14047:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14048:Src/bno055.c  **** 		}
14049:Src/bno055.c  **** 	}
14050:Src/bno055.c  **** 	return com_rslt;
14051:Src/bno055.c  **** }
 27113              		.loc 1 14051 0
 27114 0034 40B2     		sxtb	r0, r0
 27115 0036 02B0     		add	sp, sp, #8
 27116              	.LCFI1122:
 27117              		.cfi_remember_state
 27118              		.cfi_def_cfa_offset 16
 27119              		@ sp needed
 27120 0038 70BD     		pop	{r4, r5, r6, pc}
 27121              	.LVL3335:
 27122              	.L2986:
 27123              	.LCFI1123:
 27124              		.cfi_restore_state
14029:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27125              		.loc 1 14029 0 discriminator 1
 27126 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27127 003c 012A     		cmp	r2, #1
14047:Src/bno055.c  **** 		}
 27128              		.loc 1 14047 0 discriminator 1
 27129 003e 18BF     		it	ne
 27130 0040 FF20     		movne	r0, #255
14029:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27131              		.loc 1 14029 0 discriminator 1
 27132 0042 EFD0     		beq	.L2976
 27133              		.loc 1 14051 0
 27134 0044 40B2     		sxtb	r0, r0
 27135 0046 02B0     		add	sp, sp, #8
 27136              	.LCFI1124:
 27137              		.cfi_remember_state
 27138              		.cfi_def_cfa_offset 16
 27139              		@ sp needed
 27140 0048 70BD     		pop	{r4, r5, r6, pc}
 27141              	.LVL3336:
 27142              	.L2987:
 27143              	.LCFI1125:
 27144              		.cfi_restore_state
14038:Src/bno055.c  **** 				BNO055_ACCEL_NO_MOTION_INTR,
 27145              		.loc 1 14038 0
 27146 004a 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 27147              	.LVL3337:
14041:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27148              		.loc 1 14041 0
 27149 004e 2B68     		ldr	r3, [r5]
14038:Src/bno055.c  **** 				BNO055_ACCEL_NO_MOTION_INTR,
 27150              		.loc 1 14038 0
 27151 0050 00F07F00 		and	r0, r0, #127
 27152 0054 40EAC410 		orr	r0, r0, r4, lsl #7
 27153 0058 8DF80700 		strb	r0, [sp, #7]
14041:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27154              		.loc 1 14041 0
ARM GAS  /tmp/ccVWLGiI.s 			page 775


 27155 005c DC68     		ldr	r4, [r3, #12]
 27156 005e 0DF10702 		add	r2, sp, #7
 27157 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27158 0064 1021     		movs	r1, #16
 27159 0066 0123     		movs	r3, #1
 27160 0068 A047     		blx	r4
 27161              	.LVL3338:
 27162              		.loc 1 14051 0
 27163 006a 40B2     		sxtb	r0, r0
 27164 006c 02B0     		add	sp, sp, #8
 27165              	.LCFI1126:
 27166              		.cfi_remember_state
 27167              		.cfi_def_cfa_offset 16
 27168              		@ sp needed
 27169 006e 70BD     		pop	{r4, r5, r6, pc}
 27170              	.LVL3339:
 27171              	.L2978:
 27172              	.LCFI1127:
 27173              		.cfi_restore_state
14021:Src/bno055.c  **** 	} else {
 27174              		.loc 1 14021 0
 27175 0070 8120     		movs	r0, #129
 27176              	.LVL3340:
 27177 0072 DFE7     		b	.L2975
 27178              	.L2989:
 27179              		.align	2
 27180              	.L2988:
 27181 0074 00000000 		.word	.LANCHOR0
 27182              		.cfi_endproc
 27183              	.LFE224:
 27185              		.section	.text.bno055_get_accel_any_motion_thres,"ax",%progbits
 27186              		.align	2
 27187              		.global	bno055_get_accel_any_motion_thres
 27188              		.thumb
 27189              		.thumb_func
 27191              	bno055_get_accel_any_motion_thres:
 27192              	.LFB225:
14052:Src/bno055.c  **** /*!
14053:Src/bno055.c  ****  *	@brief This API used to read the accel any motion threshold
14054:Src/bno055.c  ****  *	from page one register from 0x11 bit 0 to 7
14055:Src/bno055.c  ****  *
14056:Src/bno055.c  ****  *	@param accel_any_motion_thres_u8 : The value of any motion threshold
14057:Src/bno055.c  ****  *  accel_any_motion_thres_u8 | result
14058:Src/bno055.c  ****  *  ------------------------    | -------------
14059:Src/bno055.c  ****  *              0x01            | BNO055_BIT_ENABLE
14060:Src/bno055.c  ****  *              0x00            | BNO055_BIT_DISABLE
14061:Src/bno055.c  ****  *
14062:Src/bno055.c  ****  *	@return results of bus communication function
14063:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14064:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14065:Src/bno055.c  ****  *
14066:Src/bno055.c  ****  *	@note Accel anymotion threshold dependent on the
14067:Src/bno055.c  ****  *	range values
14068:Src/bno055.c  ****  *
14069:Src/bno055.c  ****  *  accel_range_u8 |	threshold |	LSB
14070:Src/bno055.c  ****  * ------------- | ------------- | ---------
14071:Src/bno055.c  ****  *     2g        |    3.19mg     |   1LSB
ARM GAS  /tmp/ccVWLGiI.s 			page 776


14072:Src/bno055.c  ****  *     4g        |    7.81mg     |   1LSB
14073:Src/bno055.c  ****  *     8g        |    15.63mg    |   1LSB
14074:Src/bno055.c  ****  *     16g       |    31.25mg    |   1LSB
14075:Src/bno055.c  ****  *
14076:Src/bno055.c  ****  */
14077:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_any_motion_thres(
14078:Src/bno055.c  **** u8 *accel_any_motion_thres_u8)
14079:Src/bno055.c  **** {
 27193              		.loc 1 14079 0
 27194              		.cfi_startproc
 27195              		@ args = 0, pretend = 0, frame = 8
 27196              		@ frame_needed = 0, uses_anonymous_args = 0
 27197              	.LVL3341:
 27198 0000 30B5     		push	{r4, r5, lr}
 27199              	.LCFI1128:
 27200              		.cfi_def_cfa_offset 12
 27201              		.cfi_offset 4, -12
 27202              		.cfi_offset 5, -8
 27203              		.cfi_offset 14, -4
14080:Src/bno055.c  **** 	/* Variable used to return value of
14081:Src/bno055.c  **** 	communication routine*/
14082:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14083:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
14084:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
14085:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
14086:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 27204              		.loc 1 14086 0
 27205 0002 134D     		ldr	r5, .L3002
14079:Src/bno055.c  **** 	/* Variable used to return value of
 27206              		.loc 1 14079 0
 27207 0004 83B0     		sub	sp, sp, #12
 27208              	.LCFI1129:
 27209              		.cfi_def_cfa_offset 24
 27210              		.loc 1 14086 0
 27211 0006 2B68     		ldr	r3, [r5]
14083:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 27212              		.loc 1 14083 0
 27213 0008 0022     		movs	r2, #0
 27214 000a 8DF80720 		strb	r2, [sp, #7]
 27215              	.LVL3342:
 27216              		.loc 1 14086 0
 27217 000e EBB1     		cbz	r3, .L2994
14087:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
14088:Src/bno055.c  **** 		} else {
14089:Src/bno055.c  **** 		/*condition check for page, accel any motion threshold  is
14090:Src/bno055.c  **** 		available in the page one*/
14091:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 27218              		.loc 1 14091 0
 27219 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27220 0012 0446     		mov	r4, r0
 27221 0014 012A     		cmp	r2, #1
 27222 0016 04D0     		beq	.L2992
14092:Src/bno055.c  **** 			/* Write page as one */
14093:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 27223              		.loc 1 14093 0
 27224 0018 0120     		movs	r0, #1
 27225              	.LVL3343:
ARM GAS  /tmp/ccVWLGiI.s 			page 777


 27226 001a FFF7FEFF 		bl	bno055_write_page_id
 27227              	.LVL3344:
 27228 001e 2B68     		ldr	r3, [r5]
14094:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 27229              		.loc 1 14094 0
 27230 0020 60B9     		cbnz	r0, .L3001
 27231              	.LVL3345:
 27232              	.L2992:
14095:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14096:Src/bno055.c  **** 			/* Read the value of accel any motion threshold */
14097:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 27233              		.loc 1 14097 0
 27234 0022 1D69     		ldr	r5, [r3, #16]
 27235 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27236 0026 1121     		movs	r1, #17
 27237 0028 0123     		movs	r3, #1
 27238 002a 0DF10702 		add	r2, sp, #7
 27239 002e A847     		blx	r5
 27240              	.LVL3346:
14098:Src/bno055.c  **** 			(p_bno055->dev_addr,
14099:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_THRES_REG,
14100:Src/bno055.c  **** 			&data_u8r,
14101:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
14102:Src/bno055.c  **** 			*accel_any_motion_thres_u8 =
 27241              		.loc 1 14102 0
 27242 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27243 0034 2370     		strb	r3, [r4]
 27244              	.LVL3347:
 27245              	.L2991:
14103:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
14104:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_THRES);
14105:Src/bno055.c  **** 		} else {
14106:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14107:Src/bno055.c  **** 		}
14108:Src/bno055.c  **** 	}
14109:Src/bno055.c  **** 	return com_rslt;
14110:Src/bno055.c  **** }
 27246              		.loc 1 14110 0
 27247 0036 40B2     		sxtb	r0, r0
 27248 0038 03B0     		add	sp, sp, #12
 27249              	.LCFI1130:
 27250              		.cfi_remember_state
 27251              		.cfi_def_cfa_offset 12
 27252              		@ sp needed
 27253 003a 30BD     		pop	{r4, r5, pc}
 27254              	.LVL3348:
 27255              	.L3001:
 27256              	.LCFI1131:
 27257              		.cfi_restore_state
14094:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27258              		.loc 1 14094 0 discriminator 1
 27259 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27260 003e 012A     		cmp	r2, #1
14106:Src/bno055.c  **** 		}
 27261              		.loc 1 14106 0 discriminator 1
 27262 0040 18BF     		it	ne
 27263 0042 FF20     		movne	r0, #255
ARM GAS  /tmp/ccVWLGiI.s 			page 778


14094:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27264              		.loc 1 14094 0 discriminator 1
 27265 0044 EDD0     		beq	.L2992
 27266              		.loc 1 14110 0
 27267 0046 40B2     		sxtb	r0, r0
 27268 0048 03B0     		add	sp, sp, #12
 27269              	.LCFI1132:
 27270              		.cfi_remember_state
 27271              		.cfi_def_cfa_offset 12
 27272              		@ sp needed
 27273 004a 30BD     		pop	{r4, r5, pc}
 27274              	.LVL3349:
 27275              	.L2994:
 27276              	.LCFI1133:
 27277              		.cfi_restore_state
14087:Src/bno055.c  **** 		} else {
 27278              		.loc 1 14087 0
 27279 004c 8120     		movs	r0, #129
 27280              	.LVL3350:
 27281 004e F2E7     		b	.L2991
 27282              	.L3003:
 27283              		.align	2
 27284              	.L3002:
 27285 0050 00000000 		.word	.LANCHOR0
 27286              		.cfi_endproc
 27287              	.LFE225:
 27289              		.section	.text.bno055_set_accel_any_motion_thres,"ax",%progbits
 27290              		.align	2
 27291              		.global	bno055_set_accel_any_motion_thres
 27292              		.thumb
 27293              		.thumb_func
 27295              	bno055_set_accel_any_motion_thres:
 27296              	.LFB226:
14111:Src/bno055.c  **** /*!
14112:Src/bno055.c  ****  *	@brief This API used to write the accel any motion threshold
14113:Src/bno055.c  ****  *	from page one register from 0x11 bit 0 to 7
14114:Src/bno055.c  ****  *
14115:Src/bno055.c  ****  *	@param accel_any_motion_thres_u8 : The value of any motion threshold
14116:Src/bno055.c  ****  *  accel_any_motion_thres_u8 | result
14117:Src/bno055.c  ****  *  ------------------------    | -------------
14118:Src/bno055.c  ****  *              0x01            | BNO055_BIT_ENABLE
14119:Src/bno055.c  ****  *              0x00            | BNO055_BIT_DISABLE
14120:Src/bno055.c  ****  *
14121:Src/bno055.c  ****  *	@return results of bus communication function
14122:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14123:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14124:Src/bno055.c  ****  *
14125:Src/bno055.c  ****  *	@note Accel anymotion threshold dependent on the
14126:Src/bno055.c  ****  *	range values
14127:Src/bno055.c  ****  *
14128:Src/bno055.c  ****  *  accel_range_u8	 |	threshold	 |	LSB
14129:Src/bno055.c  ****  * ------------- | ------------- | ---------
14130:Src/bno055.c  ****  *     2g        |    3.19mg     |   1LSB
14131:Src/bno055.c  ****  *     4g        |    7.81mg     |   1LSB
14132:Src/bno055.c  ****  *     8g        |    15.63mg    |   1LSB
14133:Src/bno055.c  ****  *     16g       |    31.25mg    |   1LSB
14134:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 779


14135:Src/bno055.c  ****  */
14136:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_any_motion_thres(
14137:Src/bno055.c  **** u8 accel_any_motion_thres_u8)
14138:Src/bno055.c  **** {
 27297              		.loc 1 14138 0
 27298              		.cfi_startproc
 27299              		@ args = 0, pretend = 0, frame = 8
 27300              		@ frame_needed = 0, uses_anonymous_args = 0
 27301              	.LVL3351:
 27302 0000 30B5     		push	{r4, r5, lr}
 27303              	.LCFI1134:
 27304              		.cfi_def_cfa_offset 12
 27305              		.cfi_offset 4, -12
 27306              		.cfi_offset 5, -8
 27307              		.cfi_offset 14, -4
14139:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14140:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14141:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14142:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
14143:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
14144:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14145:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 27308              		.loc 1 14145 0
 27309 0002 234C     		ldr	r4, .L3020
14138:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 27310              		.loc 1 14138 0
 27311 0004 83B0     		sub	sp, sp, #12
 27312              	.LCFI1135:
 27313              		.cfi_def_cfa_offset 24
 27314              		.loc 1 14145 0
 27315 0006 2268     		ldr	r2, [r4]
14140:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 27316              		.loc 1 14140 0
 27317 0008 0023     		movs	r3, #0
 27318 000a 8DF80630 		strb	r3, [sp, #6]
 27319              	.LVL3352:
14143:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 27320              		.loc 1 14143 0
 27321 000e 8DF80730 		strb	r3, [sp, #7]
 27322              		.loc 1 14145 0
 27323 0012 002A     		cmp	r2, #0
 27324 0014 39D0     		beq	.L3012
 27325 0016 0546     		mov	r5, r0
14146:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
14147:Src/bno055.c  **** } else {
14148:Src/bno055.c  **** /* The write operation effective only if the operation
14149:Src/bno055.c  **** mode is in config mode, this part of code is checking the
14150:Src/bno055.c  **** current operation mode and set the config mode */
14151:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 27326              		.loc 1 14151 0
 27327 0018 0DF10700 		add	r0, sp, #7
 27328              	.LVL3353:
 27329 001c FFF7FEFF 		bl	bno055_get_operation_mode
 27330              	.LVL3354:
14152:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 27331              		.loc 1 14152 0
 27332 0020 38B1     		cbz	r0, .L3006
ARM GAS  /tmp/ccVWLGiI.s 			page 780


 27333              	.LVL3355:
 27334              	.L3010:
14153:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
14154:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
14155:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
14156:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
14157:Src/bno055.c  **** 			/* Write page as one */
14158:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
14159:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
14160:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14161:Src/bno055.c  **** 				(p_bno055->dev_addr,
14162:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_THRES_REG,
14163:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14164:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14165:Src/bno055.c  **** 					/* Write the value of
14166:Src/bno055.c  **** 					accel any motion threshold*/
14167:Src/bno055.c  **** 					data_u8r =
14168:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
14169:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_THRES,
14170:Src/bno055.c  **** 					accel_any_motion_thres_u8);
14171:Src/bno055.c  **** 					com_rslt +=
14172:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14173:Src/bno055.c  **** 					(p_bno055->dev_addr,
14174:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_THRES_REG,
14175:Src/bno055.c  **** 					&data_u8r,
14176:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14177:Src/bno055.c  **** 				}
14178:Src/bno055.c  **** 			} else {
14179:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
14180:Src/bno055.c  **** 			}
14181:Src/bno055.c  **** 		} else {
14182:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14183:Src/bno055.c  **** 		}
14184:Src/bno055.c  **** 	} else {
14185:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 27335              		.loc 1 14185 0
 27336 0022 FF24     		movs	r4, #255
 27337              	.LVL3356:
 27338              	.L3007:
14186:Src/bno055.c  **** 	}
14187:Src/bno055.c  **** }
14188:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 27339              		.loc 1 14188 0
 27340 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 27341 0028 18BB     		cbnz	r0, .L3019
 27342 002a 2046     		mov	r0, r4
 27343              	.LVL3357:
 27344              	.L3005:
14189:Src/bno055.c  **** 	/* set the operation mode of
14190:Src/bno055.c  **** 	previous operation mode*/
14191:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
14192:Src/bno055.c  **** 	(prev_opmode_u8);
14193:Src/bno055.c  **** return com_rslt;
14194:Src/bno055.c  **** }
 27345              		.loc 1 14194 0
 27346 002c 40B2     		sxtb	r0, r0
 27347 002e 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 781


 27348              	.LCFI1136:
 27349              		.cfi_remember_state
 27350              		.cfi_def_cfa_offset 12
 27351              		@ sp needed
 27352 0030 30BD     		pop	{r4, r5, pc}
 27353              	.LVL3358:
 27354              	.L3006:
 27355              	.LCFI1137:
 27356              		.cfi_restore_state
14153:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 27357              		.loc 1 14153 0
 27358 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27359 0036 1BBB     		cbnz	r3, .L3008
 27360              	.L3011:
 27361              	.LVL3359:
14158:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 27362              		.loc 1 14158 0
 27363 0038 0120     		movs	r0, #1
 27364 003a FFF7FEFF 		bl	bno055_write_page_id
 27365              	.LVL3360:
14159:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 27366              		.loc 1 14159 0
 27367 003e 0028     		cmp	r0, #0
 27368 0040 EFD1     		bne	.L3010
14160:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27369              		.loc 1 14160 0
 27370 0042 2368     		ldr	r3, [r4]
 27371 0044 0DF10602 		add	r2, sp, #6
 27372 0048 1C69     		ldr	r4, [r3, #16]
 27373 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27374              	.LVL3361:
 27375 004c 1121     		movs	r1, #17
 27376 004e 0123     		movs	r3, #1
 27377 0050 A047     		blx	r4
 27378              	.LVL3362:
 27379 0052 0F4B     		ldr	r3, .L3020
14164:Src/bno055.c  **** 					/* Write the value of
 27380              		.loc 1 14164 0
 27381 0054 0446     		mov	r4, r0
 27382 0056 0028     		cmp	r0, #0
 27383 0058 E4D1     		bne	.L3007
14172:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27384              		.loc 1 14172 0
 27385 005a 1B68     		ldr	r3, [r3]
14167:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 27386              		.loc 1 14167 0
 27387 005c 8DF80650 		strb	r5, [sp, #6]
14172:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27388              		.loc 1 14172 0
 27389 0060 DC68     		ldr	r4, [r3, #12]
 27390 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27391              	.LVL3363:
 27392 0064 0DF10602 		add	r2, sp, #6
 27393 0068 1121     		movs	r1, #17
 27394 006a 0123     		movs	r3, #1
 27395 006c A047     		blx	r4
 27396              	.LVL3364:
ARM GAS  /tmp/ccVWLGiI.s 			page 782


 27397 006e 0446     		mov	r4, r0
 27398              	.LVL3365:
 27399 0070 D8E7     		b	.L3007
 27400              	.L3019:
14191:Src/bno055.c  **** 	(prev_opmode_u8);
 27401              		.loc 1 14191 0
 27402 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 27403              	.LVL3366:
 27404 0076 2044     		add	r0, r0, r4
 27405 0078 C0B2     		uxtb	r0, r0
 27406              	.LVL3367:
 27407              		.loc 1 14194 0
 27408 007a 40B2     		sxtb	r0, r0
 27409 007c 03B0     		add	sp, sp, #12
 27410              	.LCFI1138:
 27411              		.cfi_remember_state
 27412              		.cfi_def_cfa_offset 12
 27413              		@ sp needed
 27414 007e 30BD     		pop	{r4, r5, pc}
 27415              	.LVL3368:
 27416              	.L3008:
 27417              	.LCFI1139:
 27418              		.cfi_restore_state
14154:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 27419              		.loc 1 14154 0
 27420 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 27421              	.LVL3369:
14156:Src/bno055.c  **** 			/* Write page as one */
 27422              		.loc 1 14156 0
 27423 0084 0028     		cmp	r0, #0
 27424 0086 CCD1     		bne	.L3010
 27425 0088 D6E7     		b	.L3011
 27426              	.LVL3370:
 27427              	.L3012:
14146:Src/bno055.c  **** } else {
 27428              		.loc 1 14146 0
 27429 008a 8120     		movs	r0, #129
 27430              	.LVL3371:
 27431 008c CEE7     		b	.L3005
 27432              	.L3021:
 27433 008e 00BF     		.align	2
 27434              	.L3020:
 27435 0090 00000000 		.word	.LANCHOR0
 27436              		.cfi_endproc
 27437              	.LFE226:
 27439              		.section	.text.bno055_get_accel_any_motion_durn,"ax",%progbits
 27440              		.align	2
 27441              		.global	bno055_get_accel_any_motion_durn
 27442              		.thumb
 27443              		.thumb_func
 27445              	bno055_get_accel_any_motion_durn:
 27446              	.LFB227:
14195:Src/bno055.c  **** /*!
14196:Src/bno055.c  ****  *	@brief This API used to read the accel anymotion duration
14197:Src/bno055.c  ****  *	from page one register from 0x12 bit 0 to 1
14198:Src/bno055.c  ****  *
14199:Src/bno055.c  ****  *	@param accel_any_motion_durn_u8 : The value of accel anymotion duration
ARM GAS  /tmp/ccVWLGiI.s 			page 783


14200:Src/bno055.c  ****  * accel_any_motion_durn_u8  | result
14201:Src/bno055.c  ****  *  -------------------------  | -------------
14202:Src/bno055.c  ****  *              0x01           | BNO055_BIT_ENABLE
14203:Src/bno055.c  ****  *              0x00           | BNO055_BIT_DISABLE
14204:Src/bno055.c  ****  *
14205:Src/bno055.c  ****  *	@return results of bus communication function
14206:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14207:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14208:Src/bno055.c  ****  *
14209:Src/bno055.c  ****  *
14210:Src/bno055.c  ****  */
14211:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_any_motion_durn(
14212:Src/bno055.c  **** u8 *accel_any_motion_durn_u8)
14213:Src/bno055.c  **** {
 27447              		.loc 1 14213 0
 27448              		.cfi_startproc
 27449              		@ args = 0, pretend = 0, frame = 8
 27450              		@ frame_needed = 0, uses_anonymous_args = 0
 27451              	.LVL3372:
 27452 0000 30B5     		push	{r4, r5, lr}
 27453              	.LCFI1140:
 27454              		.cfi_def_cfa_offset 12
 27455              		.cfi_offset 4, -12
 27456              		.cfi_offset 5, -8
 27457              		.cfi_offset 14, -4
14214:Src/bno055.c  **** 	/* Variable used to return value of
14215:Src/bno055.c  **** 	communication routine*/
14216:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14217:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
14218:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
14219:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
14220:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 27458              		.loc 1 14220 0
 27459 0002 144C     		ldr	r4, .L3034
14213:Src/bno055.c  **** 	/* Variable used to return value of
 27460              		.loc 1 14213 0
 27461 0004 83B0     		sub	sp, sp, #12
 27462              	.LCFI1141:
 27463              		.cfi_def_cfa_offset 24
 27464              		.loc 1 14220 0
 27465 0006 2368     		ldr	r3, [r4]
14217:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 27466              		.loc 1 14217 0
 27467 0008 0022     		movs	r2, #0
 27468 000a 8DF80720 		strb	r2, [sp, #7]
 27469              	.LVL3373:
 27470              		.loc 1 14220 0
 27471 000e FBB1     		cbz	r3, .L3026
14221:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
14222:Src/bno055.c  **** 		} else {
14223:Src/bno055.c  **** 		/*condition check for page, accel anymotion duration  is
14224:Src/bno055.c  **** 		available in the page one*/
14225:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 27472              		.loc 1 14225 0
 27473 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27474 0012 0546     		mov	r5, r0
 27475 0014 012A     		cmp	r2, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 784


 27476 0016 04D0     		beq	.L3024
14226:Src/bno055.c  **** 			/* Write page as one */
14227:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 27477              		.loc 1 14227 0
 27478 0018 0120     		movs	r0, #1
 27479              	.LVL3374:
 27480 001a FFF7FEFF 		bl	bno055_write_page_id
 27481              	.LVL3375:
 27482 001e 2368     		ldr	r3, [r4]
14228:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 27483              		.loc 1 14228 0
 27484 0020 70B9     		cbnz	r0, .L3033
 27485              	.LVL3376:
 27486              	.L3024:
14229:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14230:Src/bno055.c  **** 			/* Read the value of accel anymotion duration */
14231:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 27487              		.loc 1 14231 0
 27488 0022 1C69     		ldr	r4, [r3, #16]
 27489 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27490 0026 1221     		movs	r1, #18
 27491 0028 0123     		movs	r3, #1
 27492 002a 0DF10702 		add	r2, sp, #7
 27493 002e A047     		blx	r4
 27494              	.LVL3377:
14232:Src/bno055.c  **** 			(p_bno055->dev_addr,
14233:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_DURN_SET_REG,
14234:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14235:Src/bno055.c  **** 			*accel_any_motion_durn_u8 =
 27495              		.loc 1 14235 0
 27496 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27497 0034 03F00303 		and	r3, r3, #3
 27498 0038 2B70     		strb	r3, [r5]
 27499              	.LVL3378:
 27500              	.L3023:
14236:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
14237:Src/bno055.c  **** 			BNO055_ACCEL_ANY_MOTION_DURN_SET);
14238:Src/bno055.c  **** 		} else {
14239:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14240:Src/bno055.c  **** 		}
14241:Src/bno055.c  **** 	}
14242:Src/bno055.c  **** 	return com_rslt;
14243:Src/bno055.c  **** }
 27501              		.loc 1 14243 0
 27502 003a 40B2     		sxtb	r0, r0
 27503 003c 03B0     		add	sp, sp, #12
 27504              	.LCFI1142:
 27505              		.cfi_remember_state
 27506              		.cfi_def_cfa_offset 12
 27507              		@ sp needed
 27508 003e 30BD     		pop	{r4, r5, pc}
 27509              	.LVL3379:
 27510              	.L3033:
 27511              	.LCFI1143:
 27512              		.cfi_restore_state
14228:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27513              		.loc 1 14228 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 785


 27514 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 27515 0042 012A     		cmp	r2, #1
14239:Src/bno055.c  **** 		}
 27516              		.loc 1 14239 0 discriminator 1
 27517 0044 18BF     		it	ne
 27518 0046 FF20     		movne	r0, #255
14228:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27519              		.loc 1 14228 0 discriminator 1
 27520 0048 EBD0     		beq	.L3024
 27521              		.loc 1 14243 0
 27522 004a 40B2     		sxtb	r0, r0
 27523 004c 03B0     		add	sp, sp, #12
 27524              	.LCFI1144:
 27525              		.cfi_remember_state
 27526              		.cfi_def_cfa_offset 12
 27527              		@ sp needed
 27528 004e 30BD     		pop	{r4, r5, pc}
 27529              	.LVL3380:
 27530              	.L3026:
 27531              	.LCFI1145:
 27532              		.cfi_restore_state
14221:Src/bno055.c  **** 		} else {
 27533              		.loc 1 14221 0
 27534 0050 8120     		movs	r0, #129
 27535              	.LVL3381:
 27536 0052 F2E7     		b	.L3023
 27537              	.L3035:
 27538              		.align	2
 27539              	.L3034:
 27540 0054 00000000 		.word	.LANCHOR0
 27541              		.cfi_endproc
 27542              	.LFE227:
 27544              		.section	.text.bno055_set_accel_any_motion_durn,"ax",%progbits
 27545              		.align	2
 27546              		.global	bno055_set_accel_any_motion_durn
 27547              		.thumb
 27548              		.thumb_func
 27550              	bno055_set_accel_any_motion_durn:
 27551              	.LFB228:
14244:Src/bno055.c  **** /*!
14245:Src/bno055.c  ****  *	@brief This API used to write the accel anymotion duration
14246:Src/bno055.c  ****  *	from page one register from 0x12 bit 0 to 1
14247:Src/bno055.c  ****  *
14248:Src/bno055.c  ****  *	@param accel_any_motion_durn_u8 : The value of accel anymotion duration
14249:Src/bno055.c  ****  *
14250:Src/bno055.c  ****  * accel_any_motion_durn_u8  | result
14251:Src/bno055.c  ****  *  -------------------------  | -------------
14252:Src/bno055.c  ****  *              0x01           | BNO055_BIT_ENABLE
14253:Src/bno055.c  ****  *              0x00           | BNO055_BIT_DISABLE
14254:Src/bno055.c  ****  *
14255:Src/bno055.c  ****  *	@return results of bus communication function
14256:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14257:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14258:Src/bno055.c  ****  *
14259:Src/bno055.c  ****  *
14260:Src/bno055.c  ****  */
14261:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_any_motion_durn(
ARM GAS  /tmp/ccVWLGiI.s 			page 786


14262:Src/bno055.c  **** u8 accel_any_motion_durn_u8)
14263:Src/bno055.c  **** {
 27552              		.loc 1 14263 0
 27553              		.cfi_startproc
 27554              		@ args = 0, pretend = 0, frame = 8
 27555              		@ frame_needed = 0, uses_anonymous_args = 0
 27556              	.LVL3382:
 27557 0000 30B5     		push	{r4, r5, lr}
 27558              	.LCFI1146:
 27559              		.cfi_def_cfa_offset 12
 27560              		.cfi_offset 4, -12
 27561              		.cfi_offset 5, -8
 27562              		.cfi_offset 14, -4
14264:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14265:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14266:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14267:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
14268:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
14269:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14270:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 27563              		.loc 1 14270 0
 27564 0002 264C     		ldr	r4, .L3052
14263:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 27565              		.loc 1 14263 0
 27566 0004 83B0     		sub	sp, sp, #12
 27567              	.LCFI1147:
 27568              		.cfi_def_cfa_offset 24
 27569              		.loc 1 14270 0
 27570 0006 2268     		ldr	r2, [r4]
14265:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 27571              		.loc 1 14265 0
 27572 0008 0023     		movs	r3, #0
 27573 000a 8DF80630 		strb	r3, [sp, #6]
 27574              	.LVL3383:
14268:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 27575              		.loc 1 14268 0
 27576 000e 8DF80730 		strb	r3, [sp, #7]
 27577              		.loc 1 14270 0
 27578 0012 002A     		cmp	r2, #0
 27579 0014 40D0     		beq	.L3044
 27580 0016 0546     		mov	r5, r0
14271:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
14272:Src/bno055.c  **** } else {
14273:Src/bno055.c  **** /* The write operation effective only if the operation
14274:Src/bno055.c  **** mode is in config mode, this part of code is checking the
14275:Src/bno055.c  **** current operation mode and set the config mode */
14276:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 27581              		.loc 1 14276 0
 27582 0018 0DF10700 		add	r0, sp, #7
 27583              	.LVL3384:
 27584 001c FFF7FEFF 		bl	bno055_get_operation_mode
 27585              	.LVL3385:
14277:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 27586              		.loc 1 14277 0
 27587 0020 38B1     		cbz	r0, .L3038
 27588              	.LVL3386:
 27589              	.L3042:
ARM GAS  /tmp/ccVWLGiI.s 			page 787


14278:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
14279:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
14280:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
14281:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
14282:Src/bno055.c  **** 			/* Write page as one */
14283:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
14284:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
14285:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14286:Src/bno055.c  **** 				(p_bno055->dev_addr,
14287:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_DURN_SET_REG,
14288:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14289:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14290:Src/bno055.c  **** 					/* Write the value of
14291:Src/bno055.c  **** 					accel anymotion duration*/
14292:Src/bno055.c  **** 					data_u8r =
14293:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
14294:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_DURN_SET,
14295:Src/bno055.c  **** 					accel_any_motion_durn_u8);
14296:Src/bno055.c  **** 					com_rslt +=
14297:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14298:Src/bno055.c  **** 					(p_bno055->dev_addr,
14299:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_DURN_SET_REG,
14300:Src/bno055.c  **** 					&data_u8r,
14301:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14302:Src/bno055.c  **** 				}
14303:Src/bno055.c  **** 			} else {
14304:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
14305:Src/bno055.c  **** 			}
14306:Src/bno055.c  **** 		} else {
14307:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14308:Src/bno055.c  **** 		}
14309:Src/bno055.c  **** 	} else {
14310:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 27590              		.loc 1 14310 0
 27591 0022 FF24     		movs	r4, #255
 27592              	.LVL3387:
 27593              	.L3039:
14311:Src/bno055.c  **** 	}
14312:Src/bno055.c  **** }
14313:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 27594              		.loc 1 14313 0
 27595 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 27596 0028 50BB     		cbnz	r0, .L3051
 27597 002a 2046     		mov	r0, r4
 27598              	.LVL3388:
 27599              	.L3037:
14314:Src/bno055.c  **** 	/* set the operation mode of
14315:Src/bno055.c  **** 	previous operation mode*/
14316:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
14317:Src/bno055.c  **** 	(prev_opmode_u8);
14318:Src/bno055.c  **** return com_rslt;
14319:Src/bno055.c  **** }
 27600              		.loc 1 14319 0
 27601 002c 40B2     		sxtb	r0, r0
 27602 002e 03B0     		add	sp, sp, #12
 27603              	.LCFI1148:
 27604              		.cfi_remember_state
ARM GAS  /tmp/ccVWLGiI.s 			page 788


 27605              		.cfi_def_cfa_offset 12
 27606              		@ sp needed
 27607 0030 30BD     		pop	{r4, r5, pc}
 27608              	.LVL3389:
 27609              	.L3038:
 27610              	.LCFI1149:
 27611              		.cfi_restore_state
14278:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 27612              		.loc 1 14278 0
 27613 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27614 0036 53BB     		cbnz	r3, .L3040
 27615              	.L3043:
 27616              	.LVL3390:
14283:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 27617              		.loc 1 14283 0
 27618 0038 0120     		movs	r0, #1
 27619 003a FFF7FEFF 		bl	bno055_write_page_id
 27620              	.LVL3391:
14284:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 27621              		.loc 1 14284 0
 27622 003e 0028     		cmp	r0, #0
 27623 0040 EFD1     		bne	.L3042
14285:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27624              		.loc 1 14285 0
 27625 0042 2368     		ldr	r3, [r4]
 27626 0044 0DF10602 		add	r2, sp, #6
 27627 0048 1C69     		ldr	r4, [r3, #16]
 27628 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27629              	.LVL3392:
 27630 004c 1221     		movs	r1, #18
 27631 004e 0123     		movs	r3, #1
 27632 0050 A047     		blx	r4
 27633              	.LVL3393:
 27634 0052 124A     		ldr	r2, .L3052
14289:Src/bno055.c  **** 					/* Write the value of
 27635              		.loc 1 14289 0
 27636 0054 0446     		mov	r4, r0
 27637 0056 0028     		cmp	r0, #0
 27638 0058 E4D1     		bne	.L3039
14292:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 27639              		.loc 1 14292 0
 27640 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
14297:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27641              		.loc 1 14297 0
 27642 005e 1168     		ldr	r1, [r2]
14292:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 27643              		.loc 1 14292 0
 27644 0060 23F00303 		bic	r3, r3, #3
 27645 0064 05F00300 		and	r0, r5, #3
 27646              	.LVL3394:
 27647 0068 1843     		orrs	r0, r0, r3
14297:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27648              		.loc 1 14297 0
 27649 006a CC68     		ldr	r4, [r1, #12]
14292:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 27650              		.loc 1 14292 0
 27651 006c 8DF80600 		strb	r0, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 789


14297:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27652              		.loc 1 14297 0
 27653 0070 0DF10602 		add	r2, sp, #6
 27654 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 27655 0076 0123     		movs	r3, #1
 27656 0078 1221     		movs	r1, #18
 27657 007a A047     		blx	r4
 27658              	.LVL3395:
 27659 007c 0446     		mov	r4, r0
 27660              	.LVL3396:
 27661 007e D1E7     		b	.L3039
 27662              	.L3051:
14316:Src/bno055.c  **** 	(prev_opmode_u8);
 27663              		.loc 1 14316 0
 27664 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 27665              	.LVL3397:
 27666 0084 2044     		add	r0, r0, r4
 27667 0086 C0B2     		uxtb	r0, r0
 27668              	.LVL3398:
 27669              		.loc 1 14319 0
 27670 0088 40B2     		sxtb	r0, r0
 27671 008a 03B0     		add	sp, sp, #12
 27672              	.LCFI1150:
 27673              		.cfi_remember_state
 27674              		.cfi_def_cfa_offset 12
 27675              		@ sp needed
 27676 008c 30BD     		pop	{r4, r5, pc}
 27677              	.LVL3399:
 27678              	.L3040:
 27679              	.LCFI1151:
 27680              		.cfi_restore_state
14279:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 27681              		.loc 1 14279 0
 27682 008e FFF7FEFF 		bl	bno055_set_operation_mode
 27683              	.LVL3400:
14281:Src/bno055.c  **** 			/* Write page as one */
 27684              		.loc 1 14281 0
 27685 0092 0028     		cmp	r0, #0
 27686 0094 C5D1     		bne	.L3042
 27687 0096 CFE7     		b	.L3043
 27688              	.LVL3401:
 27689              	.L3044:
14271:Src/bno055.c  **** } else {
 27690              		.loc 1 14271 0
 27691 0098 8120     		movs	r0, #129
 27692              	.LVL3402:
 27693 009a C7E7     		b	.L3037
 27694              	.L3053:
 27695              		.align	2
 27696              	.L3052:
 27697 009c 00000000 		.word	.LANCHOR0
 27698              		.cfi_endproc
 27699              	.LFE228:
 27701              		.section	.text.bno055_get_accel_any_motion_no_motion_axis_enable,"ax",%progbits
 27702              		.align	2
 27703              		.global	bno055_get_accel_any_motion_no_motion_axis_enable
 27704              		.thumb
ARM GAS  /tmp/ccVWLGiI.s 			page 790


 27705              		.thumb_func
 27707              	bno055_get_accel_any_motion_no_motion_axis_enable:
 27708              	.LFB229:
14320:Src/bno055.c  **** /*!
14321:Src/bno055.c  ****  *	@brief This API used to read the accel anymotion enable
14322:Src/bno055.c  ****  *	from page one register from 0x12 bit 2 to 4
14323:Src/bno055.c  ****  *
14324:Src/bno055.c  ****  *	@param data_u8 : The value of accel anymotion enable
14325:Src/bno055.c  ****  *	   data_u8 | result
14326:Src/bno055.c  ****  *  ------------ | -------------
14327:Src/bno055.c  ****  *      0x01     | BNO055_BIT_ENABLE
14328:Src/bno055.c  ****  *      0x00     | BNO055_BIT_DISABLE
14329:Src/bno055.c  ****  *	@param channel_u8 : The value of accel anymotion axis selection
14330:Src/bno055.c  ****  *           channel_u8                        | value
14331:Src/bno055.c  ****  *     --------------------------                | ----------
14332:Src/bno055.c  ****  *     BNO055_ACCEL_ANY_MOTION_NO_MOTION_X_AXIS  |   0
14333:Src/bno055.c  ****  *     BNO055_ACCEL_ANY_MOTION_NO_MOTION_Y_AXIS  |   1
14334:Src/bno055.c  ****  *     BNO055_ACCEL_ANY_MOTION_NO_MOTION_Y_AXIS  |   2
14335:Src/bno055.c  ****  *
14336:Src/bno055.c  ****  *	@return results of bus communication function
14337:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14338:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14339:Src/bno055.c  ****  *
14340:Src/bno055.c  ****  *
14341:Src/bno055.c  ****  */
14342:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_any_motion_no_motion_axis_enable(
14343:Src/bno055.c  **** u8 channel_u8, u8 *data_u8)
14344:Src/bno055.c  **** {
 27709              		.loc 1 14344 0
 27710              		.cfi_startproc
 27711              		@ args = 0, pretend = 0, frame = 8
 27712              		@ frame_needed = 0, uses_anonymous_args = 0
 27713              	.LVL3403:
 27714 0000 70B5     		push	{r4, r5, r6, lr}
 27715              	.LCFI1152:
 27716              		.cfi_def_cfa_offset 16
 27717              		.cfi_offset 4, -16
 27718              		.cfi_offset 5, -12
 27719              		.cfi_offset 6, -8
 27720              		.cfi_offset 14, -4
14345:Src/bno055.c  **** 	/* Variable used to return value of
14346:Src/bno055.c  **** 	communication routine*/
14347:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14348:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
14349:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
14350:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
14351:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 27721              		.loc 1 14351 0
 27722 0002 294D     		ldr	r5, .L3074
14344:Src/bno055.c  **** 	/* Variable used to return value of
 27723              		.loc 1 14344 0
 27724 0004 82B0     		sub	sp, sp, #8
 27725              	.LCFI1153:
 27726              		.cfi_def_cfa_offset 24
 27727              		.loc 1 14351 0
 27728 0006 2B68     		ldr	r3, [r5]
14348:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 791


 27729              		.loc 1 14348 0
 27730 0008 0022     		movs	r2, #0
 27731 000a 8DF80720 		strb	r2, [sp, #7]
 27732              	.LVL3404:
 27733              		.loc 1 14351 0
 27734 000e 002B     		cmp	r3, #0
 27735 0010 48D0     		beq	.L3061
14352:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
14353:Src/bno055.c  **** 		} else {
14354:Src/bno055.c  **** 		/*condition check for page, accel anymotion enable is
14355:Src/bno055.c  **** 		available in the page one*/
14356:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 27736              		.loc 1 14356 0
 27737 0012 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 27738 0014 0E46     		mov	r6, r1
 27739 0016 012B     		cmp	r3, #1
 27740 0018 0446     		mov	r4, r0
 27741 001a 04D0     		beq	.L3060
14357:Src/bno055.c  **** 			/* Write page as one */
14358:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 27742              		.loc 1 14358 0
 27743 001c 0120     		movs	r0, #1
 27744              	.LVL3405:
 27745 001e FFF7FEFF 		bl	bno055_write_page_id
 27746              	.LVL3406:
14359:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 27747              		.loc 1 14359 0
 27748 0022 0028     		cmp	r0, #0
 27749 0024 38D1     		bne	.L3072
 27750              	.LVL3407:
 27751              	.L3060:
14360:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14361:Src/bno055.c  **** 			switch (channel_u8) {
 27752              		.loc 1 14361 0
 27753 0026 012C     		cmp	r4, #1
 27754 0028 26D0     		beq	.L3057
 27755 002a 15D3     		bcc	.L3058
 27756 002c 022C     		cmp	r4, #2
 27757 002e 0FD1     		bne	.L3073
14362:Src/bno055.c  **** 			case BNO055_ACCEL_ANY_MOTION_NO_MOTION_X_AXIS:
14363:Src/bno055.c  **** 				/* Read the value of accel anymotion x enable*/
14364:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14365:Src/bno055.c  **** 				(p_bno055->dev_addr,
14366:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_X_AXIS_REG,
14367:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14368:Src/bno055.c  **** 				*data_u8 =
14369:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
14370:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_X_AXIS);
14371:Src/bno055.c  **** 				break;
14372:Src/bno055.c  **** 			case BNO055_ACCEL_ANY_MOTION_NO_MOTION_Y_AXIS:
14373:Src/bno055.c  **** 				/* Read the value of accel anymotion y enable*/
14374:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14375:Src/bno055.c  **** 				(p_bno055->dev_addr,
14376:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Y_AXIS_REG,
14377:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14378:Src/bno055.c  **** 				*data_u8 =
14379:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 792


14380:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Y_AXIS);
14381:Src/bno055.c  **** 				break;
14382:Src/bno055.c  **** 			case BNO055_ACCEL_ANY_MOTION_NO_MOTION_Z_AXIS:
14383:Src/bno055.c  **** 				/* Read the value of accel anymotion z enable*/
14384:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 27758              		.loc 1 14384 0
 27759 0030 2B68     		ldr	r3, [r5]
 27760 0032 1221     		movs	r1, #18
 27761 0034 1C69     		ldr	r4, [r3, #16]
 27762 0036 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27763 0038 0DF10702 		add	r2, sp, #7
 27764 003c 0123     		movs	r3, #1
 27765 003e A047     		blx	r4
 27766              	.LVL3408:
14385:Src/bno055.c  **** 				(p_bno055->dev_addr,
14386:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Z_AXIS_REG,
14387:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14388:Src/bno055.c  **** 				*data_u8 =
14389:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 27767              		.loc 1 14389 0
 27768 0040 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27769 0044 C3F30013 		ubfx	r3, r3, #4, #1
14388:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 27770              		.loc 1 14388 0
 27771 0048 3370     		strb	r3, [r6]
 27772              	.LVL3409:
 27773              	.L3055:
14390:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Z_AXIS);
14391:Src/bno055.c  **** 				break;
14392:Src/bno055.c  **** 			default:
14393:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
14394:Src/bno055.c  **** 				break;
14395:Src/bno055.c  **** 			}
14396:Src/bno055.c  **** 		} else {
14397:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14398:Src/bno055.c  **** 		}
14399:Src/bno055.c  **** 	}
14400:Src/bno055.c  **** 	return com_rslt;
14401:Src/bno055.c  **** }
 27774              		.loc 1 14401 0
 27775 004a 40B2     		sxtb	r0, r0
 27776 004c 02B0     		add	sp, sp, #8
 27777              	.LCFI1154:
 27778              		.cfi_remember_state
 27779              		.cfi_def_cfa_offset 16
 27780              		@ sp needed
 27781 004e 70BD     		pop	{r4, r5, r6, pc}
 27782              	.LVL3410:
 27783              	.L3073:
 27784              	.LCFI1155:
 27785              		.cfi_restore_state
14393:Src/bno055.c  **** 				break;
 27786              		.loc 1 14393 0
 27787 0050 FE20     		movs	r0, #254
 27788              		.loc 1 14401 0
 27789 0052 40B2     		sxtb	r0, r0
 27790 0054 02B0     		add	sp, sp, #8
ARM GAS  /tmp/ccVWLGiI.s 			page 793


 27791              	.LCFI1156:
 27792              		.cfi_remember_state
 27793              		.cfi_def_cfa_offset 16
 27794              		@ sp needed
 27795 0056 70BD     		pop	{r4, r5, r6, pc}
 27796              	.LVL3411:
 27797              	.L3058:
 27798              	.LCFI1157:
 27799              		.cfi_restore_state
14364:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27800              		.loc 1 14364 0
 27801 0058 2B68     		ldr	r3, [r5]
 27802 005a 1221     		movs	r1, #18
 27803 005c 1C69     		ldr	r4, [r3, #16]
 27804 005e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27805 0060 0DF10702 		add	r2, sp, #7
 27806 0064 0123     		movs	r3, #1
 27807 0066 A047     		blx	r4
 27808              	.LVL3412:
14369:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_X_AXIS);
 27809              		.loc 1 14369 0
 27810 0068 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27811              		.loc 1 14401 0
 27812 006c 40B2     		sxtb	r0, r0
14369:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_X_AXIS);
 27813              		.loc 1 14369 0
 27814 006e C3F38003 		ubfx	r3, r3, #2, #1
14368:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 27815              		.loc 1 14368 0
 27816 0072 3370     		strb	r3, [r6]
 27817              		.loc 1 14401 0
 27818 0074 02B0     		add	sp, sp, #8
 27819              	.LCFI1158:
 27820              		.cfi_remember_state
 27821              		.cfi_def_cfa_offset 16
 27822              		@ sp needed
 27823 0076 70BD     		pop	{r4, r5, r6, pc}
 27824              	.LVL3413:
 27825              	.L3057:
 27826              	.LCFI1159:
 27827              		.cfi_restore_state
14374:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27828              		.loc 1 14374 0
 27829 0078 2A68     		ldr	r2, [r5]
 27830 007a 2346     		mov	r3, r4
 27831 007c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 27832 007e 1469     		ldr	r4, [r2, #16]
 27833 0080 1221     		movs	r1, #18
 27834 0082 0DF10702 		add	r2, sp, #7
 27835 0086 A047     		blx	r4
 27836              	.LVL3414:
14379:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Y_AXIS);
 27837              		.loc 1 14379 0
 27838 0088 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27839              		.loc 1 14401 0
 27840 008c 40B2     		sxtb	r0, r0
14379:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Y_AXIS);
ARM GAS  /tmp/ccVWLGiI.s 			page 794


 27841              		.loc 1 14379 0
 27842 008e C3F3C003 		ubfx	r3, r3, #3, #1
14378:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 27843              		.loc 1 14378 0
 27844 0092 3370     		strb	r3, [r6]
 27845              		.loc 1 14401 0
 27846 0094 02B0     		add	sp, sp, #8
 27847              	.LCFI1160:
 27848              		.cfi_remember_state
 27849              		.cfi_def_cfa_offset 16
 27850              		@ sp needed
 27851 0096 70BD     		pop	{r4, r5, r6, pc}
 27852              	.LVL3415:
 27853              	.L3072:
 27854              	.LCFI1161:
 27855              		.cfi_restore_state
14360:Src/bno055.c  **** 			switch (channel_u8) {
 27856              		.loc 1 14360 0 discriminator 1
 27857 0098 2B68     		ldr	r3, [r5]
14359:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 27858              		.loc 1 14359 0 discriminator 1
 27859 009a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 27860 009c 012B     		cmp	r3, #1
 27861 009e C2D0     		beq	.L3060
14397:Src/bno055.c  **** 		}
 27862              		.loc 1 14397 0
 27863 00a0 FF20     		movs	r0, #255
 27864 00a2 D2E7     		b	.L3055
 27865              	.LVL3416:
 27866              	.L3061:
14352:Src/bno055.c  **** 		} else {
 27867              		.loc 1 14352 0
 27868 00a4 8120     		movs	r0, #129
 27869              	.LVL3417:
 27870 00a6 D0E7     		b	.L3055
 27871              	.L3075:
 27872              		.align	2
 27873              	.L3074:
 27874 00a8 00000000 		.word	.LANCHOR0
 27875              		.cfi_endproc
 27876              	.LFE229:
 27878              		.section	.text.bno055_set_accel_any_motion_no_motion_axis_enable,"ax",%progbits
 27879              		.align	2
 27880              		.global	bno055_set_accel_any_motion_no_motion_axis_enable
 27881              		.thumb
 27882              		.thumb_func
 27884              	bno055_set_accel_any_motion_no_motion_axis_enable:
 27885              	.LFB230:
14402:Src/bno055.c  **** /*!
14403:Src/bno055.c  ****  *	@brief This API used to write the accel anymotion enable
14404:Src/bno055.c  ****  *	from page one register from 0x12 bit 2 to 4
14405:Src/bno055.c  ****  *
14406:Src/bno055.c  ****  *	@param data_u8 : The value of accel anymotion enable
14407:Src/bno055.c  ****  *	   data_u8 | result
14408:Src/bno055.c  ****  *  ------------ | -------------
14409:Src/bno055.c  ****  *      0x01     | BNO055_BIT_ENABLE
14410:Src/bno055.c  ****  *      0x00     | BNO055_BIT_DISABLE
ARM GAS  /tmp/ccVWLGiI.s 			page 795


14411:Src/bno055.c  ****  *	@param channel_u8 : The value of accel anymotion axis selection
14412:Src/bno055.c  ****  *           channel_u8                        | value
14413:Src/bno055.c  ****  *     --------------------------                | ----------
14414:Src/bno055.c  ****  *     BNO055_ACCEL_ANY_MOTION_NO_MOTION_X_AXIS  |   0
14415:Src/bno055.c  ****  *     BNO055_ACCEL_ANY_MOTION_NO_MOTION_Y_AXIS  |   1
14416:Src/bno055.c  ****  *     BNO055_ACCEL_ANY_MOTION_NO_MOTION_Y_AXIS  |   2
14417:Src/bno055.c  ****  *
14418:Src/bno055.c  ****  *	@return results of bus communication function
14419:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14420:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14421:Src/bno055.c  ****  *
14422:Src/bno055.c  ****  *
14423:Src/bno055.c  ****  */
14424:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_any_motion_no_motion_axis_enable(
14425:Src/bno055.c  **** u8 channel_u8, u8 data_u8)
14426:Src/bno055.c  **** {
 27886              		.loc 1 14426 0
 27887              		.cfi_startproc
 27888              		@ args = 0, pretend = 0, frame = 8
 27889              		@ frame_needed = 0, uses_anonymous_args = 0
 27890              	.LVL3418:
 27891 0000 70B5     		push	{r4, r5, r6, lr}
 27892              	.LCFI1162:
 27893              		.cfi_def_cfa_offset 16
 27894              		.cfi_offset 4, -16
 27895              		.cfi_offset 5, -12
 27896              		.cfi_offset 6, -8
 27897              		.cfi_offset 14, -4
14427:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14428:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14429:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14430:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
14431:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
14432:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14433:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 27898              		.loc 1 14433 0
 27899 0002 4C4C     		ldr	r4, .L3098
14426:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 27900              		.loc 1 14426 0
 27901 0004 82B0     		sub	sp, sp, #8
 27902              	.LCFI1163:
 27903              		.cfi_def_cfa_offset 24
 27904              		.loc 1 14433 0
 27905 0006 2568     		ldr	r5, [r4]
14428:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 27906              		.loc 1 14428 0
 27907 0008 0022     		movs	r2, #0
 27908 000a 8DF80620 		strb	r2, [sp, #6]
 27909              	.LVL3419:
14431:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 27910              		.loc 1 14431 0
 27911 000e 8DF80720 		strb	r2, [sp, #7]
 27912              		.loc 1 14433 0
 27913 0012 002D     		cmp	r5, #0
 27914 0014 00F08C80 		beq	.L3087
 27915 0018 0546     		mov	r5, r0
14434:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
ARM GAS  /tmp/ccVWLGiI.s 			page 796


14435:Src/bno055.c  **** } else {
14436:Src/bno055.c  **** /* The write operation effective only if the operation
14437:Src/bno055.c  **** mode is in config mode, this part of code is checking the
14438:Src/bno055.c  **** current operation mode and set the config mode */
14439:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 27916              		.loc 1 14439 0
 27917 001a 0DF10700 		add	r0, sp, #7
 27918              	.LVL3420:
 27919 001e 0E46     		mov	r6, r1
 27920 0020 FFF7FEFF 		bl	bno055_get_operation_mode
 27921              	.LVL3421:
14440:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 27922              		.loc 1 14440 0
 27923 0024 40B1     		cbz	r0, .L3078
 27924              	.LVL3422:
 27925              	.L3082:
14441:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
14442:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
14443:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
14444:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
14445:Src/bno055.c  **** 			/* Write page as one */
14446:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
14447:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
14448:Src/bno055.c  **** 				switch (channel_u8) {
14449:Src/bno055.c  **** 				case BNO055_ACCEL_ANY_MOTION_NO_MOTION_X_AXIS:
14450:Src/bno055.c  **** 				/* Write the value of
14451:Src/bno055.c  **** 				accel anymotion x enable*/
14452:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14453:Src/bno055.c  **** 				(p_bno055->dev_addr,
14454:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_X_AXIS_REG,
14455:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14456:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14457:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
14458:Src/bno055.c  **** 					(data_u8r,
14459:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_X_AXIS,
14460:Src/bno055.c  **** 					data_u8);
14461:Src/bno055.c  **** 					com_rslt +=
14462:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14463:Src/bno055.c  **** 					(p_bno055->dev_addr,
14464:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_X_AXIS_REG,
14465:Src/bno055.c  **** 					&data_u8r,
14466:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14467:Src/bno055.c  **** 				}
14468:Src/bno055.c  **** 				break;
14469:Src/bno055.c  **** 				case BNO055_ACCEL_ANY_MOTION_NO_MOTION_Y_AXIS:
14470:Src/bno055.c  **** 				/* Write the value of
14471:Src/bno055.c  **** 				accel anymotion y enable*/
14472:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14473:Src/bno055.c  **** 				(p_bno055->dev_addr,
14474:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Y_AXIS_REG,
14475:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14476:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14477:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
14478:Src/bno055.c  **** 					(data_u8r,
14479:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_Y_AXIS,
14480:Src/bno055.c  **** 					data_u8);
14481:Src/bno055.c  **** 					com_rslt +=
ARM GAS  /tmp/ccVWLGiI.s 			page 797


14482:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14483:Src/bno055.c  **** 					(p_bno055->dev_addr,
14484:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_Y_AXIS_REG,
14485:Src/bno055.c  **** 					&data_u8r,
14486:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14487:Src/bno055.c  **** 				}
14488:Src/bno055.c  **** 				break;
14489:Src/bno055.c  **** 				case BNO055_ACCEL_ANY_MOTION_NO_MOTION_Z_AXIS:
14490:Src/bno055.c  **** 				/* Write the value of
14491:Src/bno055.c  **** 				accel anymotion z enable*/
14492:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14493:Src/bno055.c  **** 				(p_bno055->dev_addr,
14494:Src/bno055.c  **** 				BNO055_ACCEL_ANY_MOTION_Z_AXIS_REG,
14495:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14496:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14497:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
14498:Src/bno055.c  **** 					(data_u8r,
14499:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_Z_AXIS,
14500:Src/bno055.c  **** 					data_u8);
14501:Src/bno055.c  **** 					com_rslt +=
14502:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14503:Src/bno055.c  **** 					(p_bno055->dev_addr,
14504:Src/bno055.c  **** 					BNO055_ACCEL_ANY_MOTION_Z_AXIS_REG,
14505:Src/bno055.c  **** 					&data_u8r,
14506:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14507:Src/bno055.c  **** 				}
14508:Src/bno055.c  **** 				break;
14509:Src/bno055.c  **** 				default:
14510:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
14511:Src/bno055.c  **** 				break;
14512:Src/bno055.c  **** 				}
14513:Src/bno055.c  **** 			} else {
14514:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
14515:Src/bno055.c  **** 			}
14516:Src/bno055.c  **** 		} else {
14517:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14518:Src/bno055.c  **** 		}
14519:Src/bno055.c  **** 	} else {
14520:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 27926              		.loc 1 14520 0
 27927 0026 FF24     		movs	r4, #255
 27928              	.LVL3423:
 27929              	.L3079:
14521:Src/bno055.c  **** 	}
14522:Src/bno055.c  **** }
14523:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 27930              		.loc 1 14523 0
 27931 0028 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 27932 002c 0028     		cmp	r0, #0
 27933 002e 31D1     		bne	.L3096
 27934 0030 2046     		mov	r0, r4
 27935              	.LVL3424:
 27936              	.L3077:
14524:Src/bno055.c  **** 	/* set the operation mode of
14525:Src/bno055.c  **** 	previous operation mode*/
14526:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
14527:Src/bno055.c  **** 	(prev_opmode_u8);
ARM GAS  /tmp/ccVWLGiI.s 			page 798


14528:Src/bno055.c  **** return com_rslt;
14529:Src/bno055.c  **** }
 27937              		.loc 1 14529 0
 27938 0032 40B2     		sxtb	r0, r0
 27939 0034 02B0     		add	sp, sp, #8
 27940              	.LCFI1164:
 27941              		.cfi_remember_state
 27942              		.cfi_def_cfa_offset 16
 27943              		@ sp needed
 27944 0036 70BD     		pop	{r4, r5, r6, pc}
 27945              	.LVL3425:
 27946              	.L3078:
 27947              	.LCFI1165:
 27948              		.cfi_restore_state
14441:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 27949              		.loc 1 14441 0
 27950 0038 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 27951 003c 002B     		cmp	r3, #0
 27952 003e 30D1     		bne	.L3080
 27953              	.L3083:
 27954              	.LVL3426:
14446:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 27955              		.loc 1 14446 0
 27956 0040 0120     		movs	r0, #1
 27957 0042 FFF7FEFF 		bl	bno055_write_page_id
 27958              	.LVL3427:
14447:Src/bno055.c  **** 				switch (channel_u8) {
 27959              		.loc 1 14447 0
 27960 0046 0028     		cmp	r0, #0
 27961 0048 EDD1     		bne	.L3082
14448:Src/bno055.c  **** 				case BNO055_ACCEL_ANY_MOTION_NO_MOTION_X_AXIS:
 27962              		.loc 1 14448 0
 27963 004a 012D     		cmp	r5, #1
 27964 004c 50D0     		beq	.L3084
 27965 004e 2DD3     		bcc	.L3085
 27966 0050 022D     		cmp	r5, #2
 27967 0052 4BD1     		bne	.L3097
14492:Src/bno055.c  **** 				(p_bno055->dev_addr,
 27968              		.loc 1 14492 0
 27969 0054 2368     		ldr	r3, [r4]
 27970 0056 1221     		movs	r1, #18
 27971 0058 1C69     		ldr	r4, [r3, #16]
 27972 005a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 27973              	.LVL3428:
 27974 005c 0DF10602 		add	r2, sp, #6
 27975 0060 0123     		movs	r3, #1
 27976 0062 A047     		blx	r4
 27977              	.LVL3429:
 27978 0064 3349     		ldr	r1, .L3098
14496:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 27979              		.loc 1 14496 0
 27980 0066 0446     		mov	r4, r0
 27981 0068 0028     		cmp	r0, #0
 27982 006a DDD1     		bne	.L3079
14497:Src/bno055.c  **** 					(data_u8r,
 27983              		.loc 1 14497 0
 27984 006c 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 799


 27985 0070 3301     		lsls	r3, r6, #4
14502:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27986              		.loc 1 14502 0
 27987 0072 0968     		ldr	r1, [r1]
14497:Src/bno055.c  **** 					(data_u8r,
 27988              		.loc 1 14497 0
 27989 0074 22F01002 		bic	r2, r2, #16
 27990 0078 03F01003 		and	r3, r3, #16
 27991 007c 1343     		orrs	r3, r3, r2
14502:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27992              		.loc 1 14502 0
 27993 007e CC68     		ldr	r4, [r1, #12]
14497:Src/bno055.c  **** 					(data_u8r,
 27994              		.loc 1 14497 0
 27995 0080 8DF80630 		strb	r3, [sp, #6]
14502:Src/bno055.c  **** 					(p_bno055->dev_addr,
 27996              		.loc 1 14502 0
 27997 0084 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 27998              	.LVL3430:
 27999 0086 0DF10602 		add	r2, sp, #6
 28000 008a 1221     		movs	r1, #18
 28001 008c 0123     		movs	r3, #1
 28002 008e A047     		blx	r4
 28003              	.LVL3431:
 28004 0090 0446     		mov	r4, r0
 28005              	.LVL3432:
 28006 0092 C9E7     		b	.L3079
 28007              	.L3096:
14526:Src/bno055.c  **** 	(prev_opmode_u8);
 28008              		.loc 1 14526 0
 28009 0094 FFF7FEFF 		bl	bno055_set_operation_mode
 28010              	.LVL3433:
 28011 0098 2044     		add	r0, r0, r4
 28012 009a C0B2     		uxtb	r0, r0
 28013              	.LVL3434:
 28014              		.loc 1 14529 0
 28015 009c 40B2     		sxtb	r0, r0
 28016 009e 02B0     		add	sp, sp, #8
 28017              	.LCFI1166:
 28018              		.cfi_remember_state
 28019              		.cfi_def_cfa_offset 16
 28020              		@ sp needed
 28021 00a0 70BD     		pop	{r4, r5, r6, pc}
 28022              	.LVL3435:
 28023              	.L3080:
 28024              	.LCFI1167:
 28025              		.cfi_restore_state
14442:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 28026              		.loc 1 14442 0
 28027 00a2 FFF7FEFF 		bl	bno055_set_operation_mode
 28028              	.LVL3436:
14444:Src/bno055.c  **** 			/* Write page as one */
 28029              		.loc 1 14444 0
 28030 00a6 0028     		cmp	r0, #0
 28031 00a8 BDD1     		bne	.L3082
 28032 00aa C9E7     		b	.L3083
 28033              	.LVL3437:
ARM GAS  /tmp/ccVWLGiI.s 			page 800


 28034              	.L3085:
14452:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28035              		.loc 1 14452 0
 28036 00ac 2368     		ldr	r3, [r4]
 28037 00ae 0DF10602 		add	r2, sp, #6
 28038 00b2 1C69     		ldr	r4, [r3, #16]
 28039 00b4 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28040              	.LVL3438:
 28041 00b6 1221     		movs	r1, #18
 28042 00b8 0123     		movs	r3, #1
 28043 00ba A047     		blx	r4
 28044              	.LVL3439:
 28045 00bc 1D4A     		ldr	r2, .L3098
14456:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 28046              		.loc 1 14456 0
 28047 00be 0446     		mov	r4, r0
 28048 00c0 0028     		cmp	r0, #0
 28049 00c2 B1D1     		bne	.L3079
14457:Src/bno055.c  **** 					(data_u8r,
 28050              		.loc 1 14457 0
 28051 00c4 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 28052 00c8 B100     		lsls	r1, r6, #2
14462:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28053              		.loc 1 14462 0
 28054 00ca 1068     		ldr	r0, [r2]
 28055              	.LVL3440:
14457:Src/bno055.c  **** 					(data_u8r,
 28056              		.loc 1 14457 0
 28057 00cc 01F00401 		and	r1, r1, #4
 28058 00d0 23F00403 		bic	r3, r3, #4
 28059 00d4 0B43     		orrs	r3, r3, r1
14462:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28060              		.loc 1 14462 0
 28061 00d6 C468     		ldr	r4, [r0, #12]
14457:Src/bno055.c  **** 					(data_u8r,
 28062              		.loc 1 14457 0
 28063 00d8 8DF80630 		strb	r3, [sp, #6]
14462:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28064              		.loc 1 14462 0
 28065 00dc 0DF10602 		add	r2, sp, #6
 28066 00e0 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 28067 00e2 1221     		movs	r1, #18
 28068 00e4 0123     		movs	r3, #1
 28069 00e6 A047     		blx	r4
 28070              	.LVL3441:
 28071 00e8 0446     		mov	r4, r0
 28072              	.LVL3442:
 28073 00ea 9DE7     		b	.L3079
 28074              	.LVL3443:
 28075              	.L3097:
14510:Src/bno055.c  **** 				break;
 28076              		.loc 1 14510 0
 28077 00ec FE24     		movs	r4, #254
 28078 00ee 9BE7     		b	.L3079
 28079              	.L3084:
14472:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28080              		.loc 1 14472 0
ARM GAS  /tmp/ccVWLGiI.s 			page 801


 28081 00f0 2368     		ldr	r3, [r4]
 28082 00f2 0DF10602 		add	r2, sp, #6
 28083 00f6 1C69     		ldr	r4, [r3, #16]
 28084 00f8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28085              	.LVL3444:
 28086 00fa 1221     		movs	r1, #18
 28087 00fc 2B46     		mov	r3, r5
 28088 00fe A047     		blx	r4
 28089              	.LVL3445:
 28090 0100 0C4A     		ldr	r2, .L3098
14476:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 28091              		.loc 1 14476 0
 28092 0102 0446     		mov	r4, r0
 28093 0104 0028     		cmp	r0, #0
 28094 0106 8FD1     		bne	.L3079
14477:Src/bno055.c  **** 					(data_u8r,
 28095              		.loc 1 14477 0
 28096 0108 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 28097 010c F100     		lsls	r1, r6, #3
14482:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28098              		.loc 1 14482 0
 28099 010e 1068     		ldr	r0, [r2]
 28100              	.LVL3446:
14477:Src/bno055.c  **** 					(data_u8r,
 28101              		.loc 1 14477 0
 28102 0110 23F00803 		bic	r3, r3, #8
 28103 0114 01F00801 		and	r1, r1, #8
 28104 0118 1943     		orrs	r1, r1, r3
14482:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28105              		.loc 1 14482 0
 28106 011a C468     		ldr	r4, [r0, #12]
14477:Src/bno055.c  **** 					(data_u8r,
 28107              		.loc 1 14477 0
 28108 011c 8DF80610 		strb	r1, [sp, #6]
14482:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28109              		.loc 1 14482 0
 28110 0120 0DF10602 		add	r2, sp, #6
 28111 0124 2B46     		mov	r3, r5
 28112 0126 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 28113 0128 1221     		movs	r1, #18
 28114 012a A047     		blx	r4
 28115              	.LVL3447:
 28116 012c 0446     		mov	r4, r0
 28117              	.LVL3448:
 28118 012e 7BE7     		b	.L3079
 28119              	.LVL3449:
 28120              	.L3087:
14434:Src/bno055.c  **** } else {
 28121              		.loc 1 14434 0
 28122 0130 8120     		movs	r0, #129
 28123              	.LVL3450:
 28124 0132 7EE7     		b	.L3077
 28125              	.L3099:
 28126              		.align	2
 28127              	.L3098:
 28128 0134 00000000 		.word	.LANCHOR0
 28129              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 802


 28130              	.LFE230:
 28132              		.section	.text.bno055_get_accel_high_g_axis_enable,"ax",%progbits
 28133              		.align	2
 28134              		.global	bno055_get_accel_high_g_axis_enable
 28135              		.thumb
 28136              		.thumb_func
 28138              	bno055_get_accel_high_g_axis_enable:
 28139              	.LFB231:
14530:Src/bno055.c  **** /*!
14531:Src/bno055.c  ****  *	@brief This API used to read the accel highg enable
14532:Src/bno055.c  ****  *	from page one register from 0x12 bit 5 to 7
14533:Src/bno055.c  ****  *
14534:Src/bno055.c  ****  *	@param data_u8 : The value of accel highg enable
14535:Src/bno055.c  ****  *      data_u8| result
14536:Src/bno055.c  ****  *  ------------ | -------------
14537:Src/bno055.c  ****  *      0x01     | BNO055_BIT_ENABLE
14538:Src/bno055.c  ****  *      0x00     | BNO055_BIT_DISABLE
14539:Src/bno055.c  ****  *	@param channel_u8 : The value of accel highg axis selection
14540:Src/bno055.c  ****  *               channel_u8     | value
14541:Src/bno055.c  ****  *     -------------------------- | ----------
14542:Src/bno055.c  ****  *     BNO055_ACCEL_HIGH_G_X_AXIS |   0
14543:Src/bno055.c  ****  *     BNO055_ACCEL_HIGH_G_Y_AXIS |   1
14544:Src/bno055.c  ****  *     BNO055_ACCEL_HIGH_G_Z_AXIS |   2
14545:Src/bno055.c  ****  *
14546:Src/bno055.c  ****  *	@return results of bus communication function
14547:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14548:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14549:Src/bno055.c  ****  *
14550:Src/bno055.c  ****  *
14551:Src/bno055.c  ****  */
14552:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_high_g_axis_enable(
14553:Src/bno055.c  **** u8 channel_u8, u8 *data_u8)
14554:Src/bno055.c  **** {
 28140              		.loc 1 14554 0
 28141              		.cfi_startproc
 28142              		@ args = 0, pretend = 0, frame = 8
 28143              		@ frame_needed = 0, uses_anonymous_args = 0
 28144              	.LVL3451:
 28145 0000 70B5     		push	{r4, r5, r6, lr}
 28146              	.LCFI1168:
 28147              		.cfi_def_cfa_offset 16
 28148              		.cfi_offset 4, -16
 28149              		.cfi_offset 5, -12
 28150              		.cfi_offset 6, -8
 28151              		.cfi_offset 14, -4
14555:Src/bno055.c  **** 	/* Variable used to return value of
14556:Src/bno055.c  **** 	communication routine*/
14557:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14558:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
14559:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
14560:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
14561:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 28152              		.loc 1 14561 0
 28153 0002 294D     		ldr	r5, .L3120
14554:Src/bno055.c  **** 	/* Variable used to return value of
 28154              		.loc 1 14554 0
 28155 0004 82B0     		sub	sp, sp, #8
ARM GAS  /tmp/ccVWLGiI.s 			page 803


 28156              	.LCFI1169:
 28157              		.cfi_def_cfa_offset 24
 28158              		.loc 1 14561 0
 28159 0006 2B68     		ldr	r3, [r5]
14558:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 28160              		.loc 1 14558 0
 28161 0008 0022     		movs	r2, #0
 28162 000a 8DF80720 		strb	r2, [sp, #7]
 28163              	.LVL3452:
 28164              		.loc 1 14561 0
 28165 000e 002B     		cmp	r3, #0
 28166 0010 47D0     		beq	.L3107
14562:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
14563:Src/bno055.c  **** 		} else {
14564:Src/bno055.c  **** 		/*condition check for page, accel highg enable is
14565:Src/bno055.c  **** 		available in the page one*/
14566:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 28167              		.loc 1 14566 0
 28168 0012 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 28169 0014 0E46     		mov	r6, r1
 28170 0016 012B     		cmp	r3, #1
 28171 0018 0446     		mov	r4, r0
 28172 001a 04D0     		beq	.L3106
14567:Src/bno055.c  **** 			/* Write page as one */
14568:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 28173              		.loc 1 14568 0
 28174 001c 0120     		movs	r0, #1
 28175              	.LVL3453:
 28176 001e FFF7FEFF 		bl	bno055_write_page_id
 28177              	.LVL3454:
14569:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 28178              		.loc 1 14569 0
 28179 0022 0028     		cmp	r0, #0
 28180 0024 37D1     		bne	.L3118
 28181              	.LVL3455:
 28182              	.L3106:
14570:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14571:Src/bno055.c  **** 			switch (channel_u8) {
 28183              		.loc 1 14571 0
 28184 0026 012C     		cmp	r4, #1
 28185 0028 25D0     		beq	.L3103
 28186 002a 14D3     		bcc	.L3104
 28187 002c 022C     		cmp	r4, #2
 28188 002e 0ED1     		bne	.L3119
14572:Src/bno055.c  **** 			case BNO055_ACCEL_HIGH_G_X_AXIS:
14573:Src/bno055.c  **** 				/* Read the value of accel x highg enable*/
14574:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14575:Src/bno055.c  **** 				(p_bno055->dev_addr,
14576:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_X_AXIS_REG,
14577:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14578:Src/bno055.c  **** 				*data_u8 =
14579:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
14580:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_X_AXIS);
14581:Src/bno055.c  **** 				break;
14582:Src/bno055.c  **** 			case BNO055_ACCEL_HIGH_G_Y_AXIS:
14583:Src/bno055.c  **** 				/* Read the value of accel y highg enable*/
14584:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 804


14585:Src/bno055.c  **** 				(p_bno055->dev_addr,
14586:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Y_AXIS_REG,
14587:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14588:Src/bno055.c  **** 				*data_u8 =
14589:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
14590:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Y_AXIS);
14591:Src/bno055.c  **** 				break;
14592:Src/bno055.c  **** 			case BNO055_ACCEL_HIGH_G_Z_AXIS:
14593:Src/bno055.c  **** 				/* Read the value of accel z highg enable*/
14594:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 28189              		.loc 1 14594 0
 28190 0030 2B68     		ldr	r3, [r5]
 28191 0032 1221     		movs	r1, #18
 28192 0034 1C69     		ldr	r4, [r3, #16]
 28193 0036 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28194 0038 0DF10702 		add	r2, sp, #7
 28195 003c 0123     		movs	r3, #1
 28196 003e A047     		blx	r4
 28197              	.LVL3456:
14595:Src/bno055.c  **** 				(p_bno055->dev_addr,
14596:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Z_AXIS_REG,
14597:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14598:Src/bno055.c  **** 				*data_u8 =
14599:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 28198              		.loc 1 14599 0
 28199 0040 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28200 0044 DB09     		lsrs	r3, r3, #7
14598:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 28201              		.loc 1 14598 0
 28202 0046 3370     		strb	r3, [r6]
 28203              	.LVL3457:
 28204              	.L3101:
14600:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Z_AXIS);
14601:Src/bno055.c  **** 				break;
14602:Src/bno055.c  **** 			default:
14603:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
14604:Src/bno055.c  **** 				break;
14605:Src/bno055.c  **** 			}
14606:Src/bno055.c  **** 		} else {
14607:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14608:Src/bno055.c  **** 		}
14609:Src/bno055.c  **** 	}
14610:Src/bno055.c  **** 	return com_rslt;
14611:Src/bno055.c  **** }
 28205              		.loc 1 14611 0
 28206 0048 40B2     		sxtb	r0, r0
 28207 004a 02B0     		add	sp, sp, #8
 28208              	.LCFI1170:
 28209              		.cfi_remember_state
 28210              		.cfi_def_cfa_offset 16
 28211              		@ sp needed
 28212 004c 70BD     		pop	{r4, r5, r6, pc}
 28213              	.LVL3458:
 28214              	.L3119:
 28215              	.LCFI1171:
 28216              		.cfi_restore_state
14603:Src/bno055.c  **** 				break;
ARM GAS  /tmp/ccVWLGiI.s 			page 805


 28217              		.loc 1 14603 0
 28218 004e FE20     		movs	r0, #254
 28219              		.loc 1 14611 0
 28220 0050 40B2     		sxtb	r0, r0
 28221 0052 02B0     		add	sp, sp, #8
 28222              	.LCFI1172:
 28223              		.cfi_remember_state
 28224              		.cfi_def_cfa_offset 16
 28225              		@ sp needed
 28226 0054 70BD     		pop	{r4, r5, r6, pc}
 28227              	.LVL3459:
 28228              	.L3104:
 28229              	.LCFI1173:
 28230              		.cfi_restore_state
14574:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28231              		.loc 1 14574 0
 28232 0056 2B68     		ldr	r3, [r5]
 28233 0058 1221     		movs	r1, #18
 28234 005a 1C69     		ldr	r4, [r3, #16]
 28235 005c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28236 005e 0DF10702 		add	r2, sp, #7
 28237 0062 0123     		movs	r3, #1
 28238 0064 A047     		blx	r4
 28239              	.LVL3460:
14579:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_X_AXIS);
 28240              		.loc 1 14579 0
 28241 0066 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28242              		.loc 1 14611 0
 28243 006a 40B2     		sxtb	r0, r0
14579:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_X_AXIS);
 28244              		.loc 1 14579 0
 28245 006c C3F34013 		ubfx	r3, r3, #5, #1
14578:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 28246              		.loc 1 14578 0
 28247 0070 3370     		strb	r3, [r6]
 28248              		.loc 1 14611 0
 28249 0072 02B0     		add	sp, sp, #8
 28250              	.LCFI1174:
 28251              		.cfi_remember_state
 28252              		.cfi_def_cfa_offset 16
 28253              		@ sp needed
 28254 0074 70BD     		pop	{r4, r5, r6, pc}
 28255              	.LVL3461:
 28256              	.L3103:
 28257              	.LCFI1175:
 28258              		.cfi_restore_state
14584:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28259              		.loc 1 14584 0
 28260 0076 2A68     		ldr	r2, [r5]
 28261 0078 2346     		mov	r3, r4
 28262 007a 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 28263 007c 1469     		ldr	r4, [r2, #16]
 28264 007e 1221     		movs	r1, #18
 28265 0080 0DF10702 		add	r2, sp, #7
 28266 0084 A047     		blx	r4
 28267              	.LVL3462:
14589:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Y_AXIS);
ARM GAS  /tmp/ccVWLGiI.s 			page 806


 28268              		.loc 1 14589 0
 28269 0086 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28270              		.loc 1 14611 0
 28271 008a 40B2     		sxtb	r0, r0
14589:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Y_AXIS);
 28272              		.loc 1 14589 0
 28273 008c C3F38013 		ubfx	r3, r3, #6, #1
14588:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 28274              		.loc 1 14588 0
 28275 0090 3370     		strb	r3, [r6]
 28276              		.loc 1 14611 0
 28277 0092 02B0     		add	sp, sp, #8
 28278              	.LCFI1176:
 28279              		.cfi_remember_state
 28280              		.cfi_def_cfa_offset 16
 28281              		@ sp needed
 28282 0094 70BD     		pop	{r4, r5, r6, pc}
 28283              	.LVL3463:
 28284              	.L3118:
 28285              	.LCFI1177:
 28286              		.cfi_restore_state
14570:Src/bno055.c  **** 			switch (channel_u8) {
 28287              		.loc 1 14570 0 discriminator 1
 28288 0096 2B68     		ldr	r3, [r5]
14569:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 28289              		.loc 1 14569 0 discriminator 1
 28290 0098 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 28291 009a 012B     		cmp	r3, #1
 28292 009c C3D0     		beq	.L3106
14607:Src/bno055.c  **** 		}
 28293              		.loc 1 14607 0
 28294 009e FF20     		movs	r0, #255
 28295 00a0 D2E7     		b	.L3101
 28296              	.LVL3464:
 28297              	.L3107:
14562:Src/bno055.c  **** 		} else {
 28298              		.loc 1 14562 0
 28299 00a2 8120     		movs	r0, #129
 28300              	.LVL3465:
 28301 00a4 D0E7     		b	.L3101
 28302              	.L3121:
 28303 00a6 00BF     		.align	2
 28304              	.L3120:
 28305 00a8 00000000 		.word	.LANCHOR0
 28306              		.cfi_endproc
 28307              	.LFE231:
 28309              		.section	.text.bno055_set_accel_high_g_axis_enable,"ax",%progbits
 28310              		.align	2
 28311              		.global	bno055_set_accel_high_g_axis_enable
 28312              		.thumb
 28313              		.thumb_func
 28315              	bno055_set_accel_high_g_axis_enable:
 28316              	.LFB232:
14612:Src/bno055.c  **** /*!
14613:Src/bno055.c  ****  *	@brief This API used to write the accel highg enable
14614:Src/bno055.c  ****  *	from page one register from 0x12 bit 5 to 7
14615:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 807


14616:Src/bno055.c  ****  *	@param data_u8 : The value of accel highg enable
14617:Src/bno055.c  ****  *      data_u8| result
14618:Src/bno055.c  ****  *  ------------ | -------------
14619:Src/bno055.c  ****  *      0x01     | BNO055_BIT_ENABLE
14620:Src/bno055.c  ****  *      0x00     | BNO055_BIT_DISABLE
14621:Src/bno055.c  ****  *	@param channel_u8 : The value of accel highg axis selection
14622:Src/bno055.c  ****  *               channel_u8     | value
14623:Src/bno055.c  ****  *     -------------------------- | ----------
14624:Src/bno055.c  ****  *     BNO055_ACCEL_HIGH_G_X_AXIS |   0
14625:Src/bno055.c  ****  *     BNO055_ACCEL_HIGH_G_Y_AXIS |   1
14626:Src/bno055.c  ****  *     BNO055_ACCEL_HIGH_G_Z_AXIS |   2
14627:Src/bno055.c  ****  *
14628:Src/bno055.c  ****  *	@return results of bus communication function
14629:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14630:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14631:Src/bno055.c  ****  *
14632:Src/bno055.c  ****  *
14633:Src/bno055.c  ****  */
14634:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_high_g_axis_enable(
14635:Src/bno055.c  **** u8 channel_u8, u8 data_u8)
14636:Src/bno055.c  **** {
 28317              		.loc 1 14636 0
 28318              		.cfi_startproc
 28319              		@ args = 0, pretend = 0, frame = 8
 28320              		@ frame_needed = 0, uses_anonymous_args = 0
 28321              	.LVL3466:
 28322 0000 70B5     		push	{r4, r5, r6, lr}
 28323              	.LCFI1178:
 28324              		.cfi_def_cfa_offset 16
 28325              		.cfi_offset 4, -16
 28326              		.cfi_offset 5, -12
 28327              		.cfi_offset 6, -8
 28328              		.cfi_offset 14, -4
14637:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14638:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14639:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14640:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
14641:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
14642:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14643:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 28329              		.loc 1 14643 0
 28330 0002 4A4C     		ldr	r4, .L3144
14636:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 28331              		.loc 1 14636 0
 28332 0004 82B0     		sub	sp, sp, #8
 28333              	.LCFI1179:
 28334              		.cfi_def_cfa_offset 24
 28335              		.loc 1 14643 0
 28336 0006 2568     		ldr	r5, [r4]
14638:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 28337              		.loc 1 14638 0
 28338 0008 0022     		movs	r2, #0
 28339 000a 8DF80620 		strb	r2, [sp, #6]
 28340              	.LVL3467:
14641:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 28341              		.loc 1 14641 0
 28342 000e 8DF80720 		strb	r2, [sp, #7]
ARM GAS  /tmp/ccVWLGiI.s 			page 808


 28343              		.loc 1 14643 0
 28344 0012 002D     		cmp	r5, #0
 28345 0014 00F08880 		beq	.L3133
 28346 0018 0546     		mov	r5, r0
14644:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
14645:Src/bno055.c  **** } else {
14646:Src/bno055.c  **** /* The write operation effective only if the operation
14647:Src/bno055.c  **** mode is in config mode, this part of code is checking the
14648:Src/bno055.c  **** current operation mode and set the config mode */
14649:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 28347              		.loc 1 14649 0
 28348 001a 0DF10700 		add	r0, sp, #7
 28349              	.LVL3468:
 28350 001e 0E46     		mov	r6, r1
 28351 0020 FFF7FEFF 		bl	bno055_get_operation_mode
 28352              	.LVL3469:
14650:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 28353              		.loc 1 14650 0
 28354 0024 38B1     		cbz	r0, .L3124
 28355              	.LVL3470:
 28356              	.L3128:
14651:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
14652:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
14653:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
14654:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
14655:Src/bno055.c  **** 			/* Write page as one */
14656:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
14657:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
14658:Src/bno055.c  **** 				switch (channel_u8) {
14659:Src/bno055.c  **** 				case BNO055_ACCEL_HIGH_G_X_AXIS:
14660:Src/bno055.c  **** 				/* Write the value of
14661:Src/bno055.c  **** 				accel x highg enable*/
14662:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14663:Src/bno055.c  **** 				(p_bno055->dev_addr,
14664:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_X_AXIS_REG,
14665:Src/bno055.c  **** 				&data_u8r,
14666:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
14667:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14668:Src/bno055.c  **** 					data_u8r =
14669:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
14670:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_X_AXIS, data_u8);
14671:Src/bno055.c  **** 					com_rslt +=
14672:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14673:Src/bno055.c  **** 					(p_bno055->dev_addr,
14674:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_X_AXIS_REG,
14675:Src/bno055.c  **** 					&data_u8r,
14676:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14677:Src/bno055.c  **** 				}
14678:Src/bno055.c  **** 				break;
14679:Src/bno055.c  **** 				case BNO055_ACCEL_HIGH_G_Y_AXIS:
14680:Src/bno055.c  **** 				/* Write the value of
14681:Src/bno055.c  **** 				accel y highg enable*/
14682:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14683:Src/bno055.c  **** 				(p_bno055->dev_addr,
14684:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Y_AXIS_REG,
14685:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14686:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 809


14687:Src/bno055.c  **** 					data_u8r =
14688:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
14689:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_Y_AXIS,
14690:Src/bno055.c  **** 					data_u8);
14691:Src/bno055.c  **** 					com_rslt +=
14692:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14693:Src/bno055.c  **** 					(p_bno055->dev_addr,
14694:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_Y_AXIS_REG,
14695:Src/bno055.c  **** 					&data_u8r,
14696:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14697:Src/bno055.c  **** 				}
14698:Src/bno055.c  **** 				break;
14699:Src/bno055.c  **** 				case BNO055_ACCEL_HIGH_G_Z_AXIS:
14700:Src/bno055.c  **** 				/* Write the value of
14701:Src/bno055.c  **** 				accel z highg enable*/
14702:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
14703:Src/bno055.c  **** 				(p_bno055->dev_addr,
14704:Src/bno055.c  **** 				BNO055_ACCEL_HIGH_G_Z_AXIS_REG,
14705:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14706:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
14707:Src/bno055.c  **** 					data_u8r =
14708:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
14709:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_Z_AXIS, data_u8);
14710:Src/bno055.c  **** 					com_rslt +=
14711:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
14712:Src/bno055.c  **** 					(p_bno055->dev_addr,
14713:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_Z_AXIS_REG,
14714:Src/bno055.c  **** 					&data_u8r,
14715:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14716:Src/bno055.c  **** 				}
14717:Src/bno055.c  **** 				break;
14718:Src/bno055.c  **** 				default:
14719:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
14720:Src/bno055.c  **** 				break;
14721:Src/bno055.c  **** 				}
14722:Src/bno055.c  **** 			} else {
14723:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
14724:Src/bno055.c  **** 			}
14725:Src/bno055.c  **** 		} else {
14726:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14727:Src/bno055.c  **** 		}
14728:Src/bno055.c  **** 	} else {
14729:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 28357              		.loc 1 14729 0
 28358 0026 FF24     		movs	r4, #255
 28359              	.LVL3471:
 28360              	.L3125:
14730:Src/bno055.c  **** 	}
14731:Src/bno055.c  **** }
14732:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 28361              		.loc 1 14732 0
 28362 0028 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 28363 002c 70BB     		cbnz	r0, .L3142
 28364 002e 2046     		mov	r0, r4
 28365              	.LVL3472:
 28366              	.L3123:
14733:Src/bno055.c  **** 	/* set the operation mode of
ARM GAS  /tmp/ccVWLGiI.s 			page 810


14734:Src/bno055.c  **** 	previous operation mode*/
14735:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
14736:Src/bno055.c  **** 	(prev_opmode_u8);
14737:Src/bno055.c  **** return com_rslt;
14738:Src/bno055.c  **** }
 28367              		.loc 1 14738 0
 28368 0030 40B2     		sxtb	r0, r0
 28369 0032 02B0     		add	sp, sp, #8
 28370              	.LCFI1180:
 28371              		.cfi_remember_state
 28372              		.cfi_def_cfa_offset 16
 28373              		@ sp needed
 28374 0034 70BD     		pop	{r4, r5, r6, pc}
 28375              	.LVL3473:
 28376              	.L3124:
 28377              	.LCFI1181:
 28378              		.cfi_restore_state
14651:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 28379              		.loc 1 14651 0
 28380 0036 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28381 003a 73BB     		cbnz	r3, .L3126
 28382              	.L3129:
 28383              	.LVL3474:
14656:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 28384              		.loc 1 14656 0
 28385 003c 0120     		movs	r0, #1
 28386 003e FFF7FEFF 		bl	bno055_write_page_id
 28387              	.LVL3475:
14657:Src/bno055.c  **** 				switch (channel_u8) {
 28388              		.loc 1 14657 0
 28389 0042 0028     		cmp	r0, #0
 28390 0044 EFD1     		bne	.L3128
14658:Src/bno055.c  **** 				case BNO055_ACCEL_HIGH_G_X_AXIS:
 28391              		.loc 1 14658 0
 28392 0046 012D     		cmp	r5, #1
 28393 0048 4ED0     		beq	.L3130
 28394 004a 2BD3     		bcc	.L3131
 28395 004c 022D     		cmp	r5, #2
 28396 004e 49D1     		bne	.L3143
14702:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28397              		.loc 1 14702 0
 28398 0050 2368     		ldr	r3, [r4]
 28399 0052 0DF10602 		add	r2, sp, #6
 28400 0056 1C69     		ldr	r4, [r3, #16]
 28401 0058 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28402              	.LVL3476:
 28403 005a 1221     		movs	r1, #18
 28404 005c 0123     		movs	r3, #1
 28405 005e A047     		blx	r4
 28406              	.LVL3477:
 28407 0060 324B     		ldr	r3, .L3144
14706:Src/bno055.c  **** 					data_u8r =
 28408              		.loc 1 14706 0
 28409 0062 0446     		mov	r4, r0
 28410 0064 0028     		cmp	r0, #0
 28411 0066 DFD1     		bne	.L3125
14707:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 811


 28412              		.loc 1 14707 0
 28413 0068 9DF80610 		ldrb	r1, [sp, #6]	@ zero_extendqisi2
14711:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28414              		.loc 1 14711 0
 28415 006c 1B68     		ldr	r3, [r3]
14707:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28416              		.loc 1 14707 0
 28417 006e 01F07F01 		and	r1, r1, #127
 28418 0072 41EAC611 		orr	r1, r1, r6, lsl #7
14711:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28419              		.loc 1 14711 0
 28420 0076 DC68     		ldr	r4, [r3, #12]
14707:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28421              		.loc 1 14707 0
 28422 0078 8DF80610 		strb	r1, [sp, #6]
14711:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28423              		.loc 1 14711 0
 28424 007c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28425              	.LVL3478:
 28426 007e 0DF10602 		add	r2, sp, #6
 28427 0082 1221     		movs	r1, #18
 28428 0084 0123     		movs	r3, #1
 28429 0086 A047     		blx	r4
 28430              	.LVL3479:
 28431 0088 0446     		mov	r4, r0
 28432              	.LVL3480:
 28433 008a CDE7     		b	.L3125
 28434              	.L3142:
14735:Src/bno055.c  **** 	(prev_opmode_u8);
 28435              		.loc 1 14735 0
 28436 008c FFF7FEFF 		bl	bno055_set_operation_mode
 28437              	.LVL3481:
 28438 0090 2044     		add	r0, r0, r4
 28439 0092 C0B2     		uxtb	r0, r0
 28440              	.LVL3482:
 28441              		.loc 1 14738 0
 28442 0094 40B2     		sxtb	r0, r0
 28443 0096 02B0     		add	sp, sp, #8
 28444              	.LCFI1182:
 28445              		.cfi_remember_state
 28446              		.cfi_def_cfa_offset 16
 28447              		@ sp needed
 28448 0098 70BD     		pop	{r4, r5, r6, pc}
 28449              	.LVL3483:
 28450              	.L3126:
 28451              	.LCFI1183:
 28452              		.cfi_restore_state
14652:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 28453              		.loc 1 14652 0
 28454 009a FFF7FEFF 		bl	bno055_set_operation_mode
 28455              	.LVL3484:
14654:Src/bno055.c  **** 			/* Write page as one */
 28456              		.loc 1 14654 0
 28457 009e 0028     		cmp	r0, #0
 28458 00a0 C1D1     		bne	.L3128
 28459 00a2 CBE7     		b	.L3129
 28460              	.LVL3485:
ARM GAS  /tmp/ccVWLGiI.s 			page 812


 28461              	.L3131:
14662:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28462              		.loc 1 14662 0
 28463 00a4 2368     		ldr	r3, [r4]
 28464 00a6 0DF10602 		add	r2, sp, #6
 28465 00aa 1C69     		ldr	r4, [r3, #16]
 28466 00ac 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28467              	.LVL3486:
 28468 00ae 1221     		movs	r1, #18
 28469 00b0 0123     		movs	r3, #1
 28470 00b2 A047     		blx	r4
 28471              	.LVL3487:
 28472 00b4 1D4A     		ldr	r2, .L3144
14667:Src/bno055.c  **** 					data_u8r =
 28473              		.loc 1 14667 0
 28474 00b6 0446     		mov	r4, r0
 28475 00b8 0028     		cmp	r0, #0
 28476 00ba B5D1     		bne	.L3125
14668:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28477              		.loc 1 14668 0
 28478 00bc 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
14669:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_X_AXIS, data_u8);
 28479              		.loc 1 14669 0
 28480 00c0 7101     		lsls	r1, r6, #5
14672:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28481              		.loc 1 14672 0
 28482 00c2 1068     		ldr	r0, [r2]
 28483              	.LVL3488:
14668:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28484              		.loc 1 14668 0
 28485 00c4 01F02001 		and	r1, r1, #32
 28486 00c8 23F02003 		bic	r3, r3, #32
 28487 00cc 0B43     		orrs	r3, r3, r1
14672:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28488              		.loc 1 14672 0
 28489 00ce C468     		ldr	r4, [r0, #12]
14668:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28490              		.loc 1 14668 0
 28491 00d0 8DF80630 		strb	r3, [sp, #6]
14672:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28492              		.loc 1 14672 0
 28493 00d4 0DF10602 		add	r2, sp, #6
 28494 00d8 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 28495 00da 1221     		movs	r1, #18
 28496 00dc 0123     		movs	r3, #1
 28497 00de A047     		blx	r4
 28498              	.LVL3489:
 28499 00e0 0446     		mov	r4, r0
 28500              	.LVL3490:
 28501 00e2 A1E7     		b	.L3125
 28502              	.LVL3491:
 28503              	.L3143:
14719:Src/bno055.c  **** 				break;
 28504              		.loc 1 14719 0
 28505 00e4 FE24     		movs	r4, #254
 28506 00e6 9FE7     		b	.L3125
 28507              	.L3130:
ARM GAS  /tmp/ccVWLGiI.s 			page 813


14682:Src/bno055.c  **** 				(p_bno055->dev_addr,
 28508              		.loc 1 14682 0
 28509 00e8 2368     		ldr	r3, [r4]
 28510 00ea 0DF10602 		add	r2, sp, #6
 28511 00ee 1C69     		ldr	r4, [r3, #16]
 28512 00f0 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28513              	.LVL3492:
 28514 00f2 1221     		movs	r1, #18
 28515 00f4 2B46     		mov	r3, r5
 28516 00f6 A047     		blx	r4
 28517              	.LVL3493:
 28518 00f8 0C4A     		ldr	r2, .L3144
14686:Src/bno055.c  **** 					data_u8r =
 28519              		.loc 1 14686 0
 28520 00fa 0446     		mov	r4, r0
 28521 00fc 0028     		cmp	r0, #0
 28522 00fe 93D1     		bne	.L3125
14687:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28523              		.loc 1 14687 0
 28524 0100 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
14688:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_Y_AXIS,
 28525              		.loc 1 14688 0
 28526 0104 B101     		lsls	r1, r6, #6
14692:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28527              		.loc 1 14692 0
 28528 0106 1068     		ldr	r0, [r2]
 28529              	.LVL3494:
14687:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28530              		.loc 1 14687 0
 28531 0108 23F04003 		bic	r3, r3, #64
 28532 010c 01F04001 		and	r1, r1, #64
 28533 0110 1943     		orrs	r1, r1, r3
14692:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28534              		.loc 1 14692 0
 28535 0112 C468     		ldr	r4, [r0, #12]
14687:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 28536              		.loc 1 14687 0
 28537 0114 8DF80610 		strb	r1, [sp, #6]
14692:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28538              		.loc 1 14692 0
 28539 0118 0DF10602 		add	r2, sp, #6
 28540 011c 2B46     		mov	r3, r5
 28541 011e 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 28542 0120 1221     		movs	r1, #18
 28543 0122 A047     		blx	r4
 28544              	.LVL3495:
 28545 0124 0446     		mov	r4, r0
 28546              	.LVL3496:
 28547 0126 7FE7     		b	.L3125
 28548              	.LVL3497:
 28549              	.L3133:
14644:Src/bno055.c  **** } else {
 28550              		.loc 1 14644 0
 28551 0128 8120     		movs	r0, #129
 28552              	.LVL3498:
 28553 012a 81E7     		b	.L3123
 28554              	.L3145:
ARM GAS  /tmp/ccVWLGiI.s 			page 814


 28555              		.align	2
 28556              	.L3144:
 28557 012c 00000000 		.word	.LANCHOR0
 28558              		.cfi_endproc
 28559              	.LFE232:
 28561              		.section	.text.bno055_get_accel_high_g_durn,"ax",%progbits
 28562              		.align	2
 28563              		.global	bno055_get_accel_high_g_durn
 28564              		.thumb
 28565              		.thumb_func
 28567              	bno055_get_accel_high_g_durn:
 28568              	.LFB233:
14739:Src/bno055.c  **** /*!
14740:Src/bno055.c  ****  *	@brief This API used to read the accel highg duration
14741:Src/bno055.c  ****  *	from page one register from 0x13 bit 0 to 7
14742:Src/bno055.c  ****  *
14743:Src/bno055.c  ****  *	@param accel_high_g_durn_u8 : The value of accel highg duration
14744:Src/bno055.c  ****  *
14745:Src/bno055.c  ****  *	@return results of bus communication function
14746:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14747:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14748:Src/bno055.c  ****  *
14749:Src/bno055.c  ****  *	@note The high-g interrupt trigger delay according
14750:Src/bno055.c  ****  *	to [highg duration  + 1] * 2 ms
14751:Src/bno055.c  ****  *
14752:Src/bno055.c  ****  *	in a range from 2 ms to 512 ms
14753:Src/bno055.c  ****  *
14754:Src/bno055.c  ****  */
14755:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_high_g_durn(
14756:Src/bno055.c  **** u8 *accel_high_g_durn_u8)
14757:Src/bno055.c  **** {
 28569              		.loc 1 14757 0
 28570              		.cfi_startproc
 28571              		@ args = 0, pretend = 0, frame = 8
 28572              		@ frame_needed = 0, uses_anonymous_args = 0
 28573              	.LVL3499:
 28574 0000 30B5     		push	{r4, r5, lr}
 28575              	.LCFI1184:
 28576              		.cfi_def_cfa_offset 12
 28577              		.cfi_offset 4, -12
 28578              		.cfi_offset 5, -8
 28579              		.cfi_offset 14, -4
14758:Src/bno055.c  **** 	/* Variable used to return value of
14759:Src/bno055.c  **** 	communication routine*/
14760:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14761:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
14762:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
14763:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
14764:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE) {
 28580              		.loc 1 14764 0
 28581 0002 134D     		ldr	r5, .L3158
14757:Src/bno055.c  **** 	/* Variable used to return value of
 28582              		.loc 1 14757 0
 28583 0004 83B0     		sub	sp, sp, #12
 28584              	.LCFI1185:
 28585              		.cfi_def_cfa_offset 24
 28586              		.loc 1 14764 0
ARM GAS  /tmp/ccVWLGiI.s 			page 815


 28587 0006 2B68     		ldr	r3, [r5]
14761:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 28588              		.loc 1 14761 0
 28589 0008 0022     		movs	r2, #0
 28590 000a 8DF80720 		strb	r2, [sp, #7]
 28591              	.LVL3500:
 28592              		.loc 1 14764 0
 28593 000e EBB1     		cbz	r3, .L3150
14765:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
14766:Src/bno055.c  **** 		} else {
14767:Src/bno055.c  **** 		/*condition check for page, accel highg duration is
14768:Src/bno055.c  **** 		available in the page one*/
14769:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 28594              		.loc 1 14769 0
 28595 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 28596 0012 0446     		mov	r4, r0
 28597 0014 012A     		cmp	r2, #1
 28598 0016 04D0     		beq	.L3148
14770:Src/bno055.c  **** 			/* Write page as one */
14771:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 28599              		.loc 1 14771 0
 28600 0018 0120     		movs	r0, #1
 28601              	.LVL3501:
 28602 001a FFF7FEFF 		bl	bno055_write_page_id
 28603              	.LVL3502:
 28604 001e 2B68     		ldr	r3, [r5]
14772:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 28605              		.loc 1 14772 0
 28606 0020 60B9     		cbnz	r0, .L3157
 28607              	.LVL3503:
 28608              	.L3148:
14773:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14774:Src/bno055.c  **** 			/* Read the value of accel highg duration*/
14775:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 28609              		.loc 1 14775 0
 28610 0022 1D69     		ldr	r5, [r3, #16]
 28611 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28612 0026 1321     		movs	r1, #19
 28613 0028 0123     		movs	r3, #1
 28614 002a 0DF10702 		add	r2, sp, #7
 28615 002e A847     		blx	r5
 28616              	.LVL3504:
14776:Src/bno055.c  **** 			(p_bno055->dev_addr,
14777:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_DURN_REG,
14778:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14779:Src/bno055.c  **** 			*accel_high_g_durn_u8 =
 28617              		.loc 1 14779 0
 28618 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28619 0034 2370     		strb	r3, [r4]
 28620              	.LVL3505:
 28621              	.L3147:
14780:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
14781:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_DURN);
14782:Src/bno055.c  **** 		} else {
14783:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14784:Src/bno055.c  **** 		}
14785:Src/bno055.c  **** 	}
ARM GAS  /tmp/ccVWLGiI.s 			page 816


14786:Src/bno055.c  **** 	return com_rslt;
14787:Src/bno055.c  **** }
 28622              		.loc 1 14787 0
 28623 0036 40B2     		sxtb	r0, r0
 28624 0038 03B0     		add	sp, sp, #12
 28625              	.LCFI1186:
 28626              		.cfi_remember_state
 28627              		.cfi_def_cfa_offset 12
 28628              		@ sp needed
 28629 003a 30BD     		pop	{r4, r5, pc}
 28630              	.LVL3506:
 28631              	.L3157:
 28632              	.LCFI1187:
 28633              		.cfi_restore_state
14772:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 28634              		.loc 1 14772 0 discriminator 1
 28635 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 28636 003e 012A     		cmp	r2, #1
14783:Src/bno055.c  **** 		}
 28637              		.loc 1 14783 0 discriminator 1
 28638 0040 18BF     		it	ne
 28639 0042 FF20     		movne	r0, #255
14772:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 28640              		.loc 1 14772 0 discriminator 1
 28641 0044 EDD0     		beq	.L3148
 28642              		.loc 1 14787 0
 28643 0046 40B2     		sxtb	r0, r0
 28644 0048 03B0     		add	sp, sp, #12
 28645              	.LCFI1188:
 28646              		.cfi_remember_state
 28647              		.cfi_def_cfa_offset 12
 28648              		@ sp needed
 28649 004a 30BD     		pop	{r4, r5, pc}
 28650              	.LVL3507:
 28651              	.L3150:
 28652              	.LCFI1189:
 28653              		.cfi_restore_state
14765:Src/bno055.c  **** 		} else {
 28654              		.loc 1 14765 0
 28655 004c 8120     		movs	r0, #129
 28656              	.LVL3508:
 28657 004e F2E7     		b	.L3147
 28658              	.L3159:
 28659              		.align	2
 28660              	.L3158:
 28661 0050 00000000 		.word	.LANCHOR0
 28662              		.cfi_endproc
 28663              	.LFE233:
 28665              		.section	.text.bno055_set_accel_high_g_durn,"ax",%progbits
 28666              		.align	2
 28667              		.global	bno055_set_accel_high_g_durn
 28668              		.thumb
 28669              		.thumb_func
 28671              	bno055_set_accel_high_g_durn:
 28672              	.LFB234:
14788:Src/bno055.c  **** /*!
14789:Src/bno055.c  ****  *	@brief This API used to write the accel highg duration
ARM GAS  /tmp/ccVWLGiI.s 			page 817


14790:Src/bno055.c  ****  *	from page one register from 0x13 bit 0 to 7
14791:Src/bno055.c  ****  *
14792:Src/bno055.c  ****  *	@param accel_high_g_durn_u8 : The value of accel highg duration
14793:Src/bno055.c  ****  *
14794:Src/bno055.c  ****  *	@return results of bus communication function
14795:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14796:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14797:Src/bno055.c  ****  *
14798:Src/bno055.c  ****  *	@note The high-g interrupt trigger delay according
14799:Src/bno055.c  ****  *	to [highg duration  + 1] * 2 ms
14800:Src/bno055.c  ****  *
14801:Src/bno055.c  ****  *	in a range from 2 ms to 512 ms
14802:Src/bno055.c  ****  *
14803:Src/bno055.c  ****  */
14804:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_high_g_durn(
14805:Src/bno055.c  **** u8 accel_high_g_durn_u8)
14806:Src/bno055.c  **** {
 28673              		.loc 1 14806 0
 28674              		.cfi_startproc
 28675              		@ args = 0, pretend = 0, frame = 8
 28676              		@ frame_needed = 0, uses_anonymous_args = 0
 28677              	.LVL3509:
 28678 0000 30B5     		push	{r4, r5, lr}
 28679              	.LCFI1190:
 28680              		.cfi_def_cfa_offset 12
 28681              		.cfi_offset 4, -12
 28682              		.cfi_offset 5, -8
 28683              		.cfi_offset 14, -4
14807:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14808:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14809:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14810:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
14811:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
14812:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14813:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE) {
 28684              		.loc 1 14813 0
 28685 0002 234C     		ldr	r4, .L3176
14806:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 28686              		.loc 1 14806 0
 28687 0004 83B0     		sub	sp, sp, #12
 28688              	.LCFI1191:
 28689              		.cfi_def_cfa_offset 24
 28690              		.loc 1 14813 0
 28691 0006 2268     		ldr	r2, [r4]
14808:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 28692              		.loc 1 14808 0
 28693 0008 0023     		movs	r3, #0
 28694 000a 8DF80630 		strb	r3, [sp, #6]
 28695              	.LVL3510:
14810:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 28696              		.loc 1 14810 0
 28697 000e 8DF80730 		strb	r3, [sp, #7]
 28698              	.LVL3511:
 28699              		.loc 1 14813 0
 28700 0012 002A     		cmp	r2, #0
 28701 0014 39D0     		beq	.L3168
 28702 0016 0546     		mov	r5, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 818


14814:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
14815:Src/bno055.c  **** } else {
14816:Src/bno055.c  **** 	/* The write operation effective only if the operation
14817:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
14818:Src/bno055.c  **** 	current operation mode and set the config mode */
14819:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 28703              		.loc 1 14819 0
 28704 0018 0DF10700 		add	r0, sp, #7
 28705              	.LVL3512:
 28706 001c FFF7FEFF 		bl	bno055_get_operation_mode
 28707              	.LVL3513:
14820:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 28708              		.loc 1 14820 0
 28709 0020 38B1     		cbz	r0, .L3162
 28710              	.LVL3514:
 28711              	.L3166:
14821:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
14822:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
14823:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
14824:Src/bno055.c  **** 
14825:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
14826:Src/bno055.c  **** 				/* Write page as one */
14827:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
14828:Src/bno055.c  **** 					BNO055_PAGE_ONE);
14829:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
14830:Src/bno055.c  **** 					com_rslt =
14831:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
14832:Src/bno055.c  **** 					(p_bno055->dev_addr,
14833:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_DURN_REG,
14834:Src/bno055.c  **** 					&data_u8r,
14835:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14836:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
14837:Src/bno055.c  **** 						/* Write the value of
14838:Src/bno055.c  **** 						accel highg duration*/
14839:Src/bno055.c  **** 						data_u8r =
14840:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
14841:Src/bno055.c  **** 						BNO055_ACCEL_HIGH_G_DURN,
14842:Src/bno055.c  **** 						accel_high_g_durn_u8);
14843:Src/bno055.c  **** 						com_rslt +=
14844:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
14845:Src/bno055.c  **** 						(p_bno055->dev_addr,
14846:Src/bno055.c  **** 						BNO055_ACCEL_HIGH_G_DURN_REG,
14847:Src/bno055.c  **** 						&data_u8r,
14848:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
14849:Src/bno055.c  **** 					}
14850:Src/bno055.c  **** 				} else {
14851:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
14852:Src/bno055.c  **** 				}
14853:Src/bno055.c  **** 			} else {
14854:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
14855:Src/bno055.c  **** 			}
14856:Src/bno055.c  **** 		} else {
14857:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 28712              		.loc 1 14857 0
 28713 0022 FF24     		movs	r4, #255
 28714              	.LVL3515:
 28715              	.L3163:
ARM GAS  /tmp/ccVWLGiI.s 			page 819


14858:Src/bno055.c  **** 		}
14859:Src/bno055.c  **** 	}
14860:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 28716              		.loc 1 14860 0
 28717 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 28718 0028 18BB     		cbnz	r0, .L3175
 28719 002a 2046     		mov	r0, r4
 28720              	.LVL3516:
 28721              	.L3161:
14861:Src/bno055.c  **** 		/* set the operation mode of
14862:Src/bno055.c  **** 		previous operation mode*/
14863:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
14864:Src/bno055.c  **** 		(prev_opmode_u8);
14865:Src/bno055.c  **** 	return com_rslt;
14866:Src/bno055.c  **** }
 28722              		.loc 1 14866 0
 28723 002c 40B2     		sxtb	r0, r0
 28724 002e 03B0     		add	sp, sp, #12
 28725              	.LCFI1192:
 28726              		.cfi_remember_state
 28727              		.cfi_def_cfa_offset 12
 28728              		@ sp needed
 28729 0030 30BD     		pop	{r4, r5, pc}
 28730              	.LVL3517:
 28731              	.L3162:
 28732              	.LCFI1193:
 28733              		.cfi_restore_state
14821:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 28734              		.loc 1 14821 0
 28735 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28736 0036 1BBB     		cbnz	r3, .L3164
 28737              	.L3167:
 28738              	.LVL3518:
14827:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 28739              		.loc 1 14827 0
 28740 0038 0120     		movs	r0, #1
 28741 003a FFF7FEFF 		bl	bno055_write_page_id
 28742              	.LVL3519:
14829:Src/bno055.c  **** 					com_rslt =
 28743              		.loc 1 14829 0
 28744 003e 0028     		cmp	r0, #0
 28745 0040 EFD1     		bne	.L3166
14831:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28746              		.loc 1 14831 0
 28747 0042 2368     		ldr	r3, [r4]
14830:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 28748              		.loc 1 14830 0
 28749 0044 0DF10602 		add	r2, sp, #6
 28750 0048 1C69     		ldr	r4, [r3, #16]
 28751 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28752              	.LVL3520:
 28753 004c 1321     		movs	r1, #19
 28754 004e 0123     		movs	r3, #1
 28755 0050 A047     		blx	r4
 28756              	.LVL3521:
14831:Src/bno055.c  **** 					(p_bno055->dev_addr,
 28757              		.loc 1 14831 0
ARM GAS  /tmp/ccVWLGiI.s 			page 820


 28758 0052 0F4B     		ldr	r3, .L3176
14836:Src/bno055.c  **** 						/* Write the value of
 28759              		.loc 1 14836 0
 28760 0054 0446     		mov	r4, r0
 28761 0056 0028     		cmp	r0, #0
 28762 0058 E4D1     		bne	.L3163
14844:Src/bno055.c  **** 						(p_bno055->dev_addr,
 28763              		.loc 1 14844 0
 28764 005a 1B68     		ldr	r3, [r3]
14839:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 28765              		.loc 1 14839 0
 28766 005c 8DF80650 		strb	r5, [sp, #6]
14844:Src/bno055.c  **** 						(p_bno055->dev_addr,
 28767              		.loc 1 14844 0
 28768 0060 DC68     		ldr	r4, [r3, #12]
 28769 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28770              	.LVL3522:
 28771 0064 0DF10602 		add	r2, sp, #6
 28772 0068 1321     		movs	r1, #19
 28773 006a 0123     		movs	r3, #1
 28774 006c A047     		blx	r4
 28775              	.LVL3523:
 28776 006e 0446     		mov	r4, r0
 28777              	.LVL3524:
 28778 0070 D8E7     		b	.L3163
 28779              	.L3175:
14863:Src/bno055.c  **** 		(prev_opmode_u8);
 28780              		.loc 1 14863 0
 28781 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 28782              	.LVL3525:
 28783 0076 2044     		add	r0, r0, r4
 28784 0078 C0B2     		uxtb	r0, r0
 28785              	.LVL3526:
 28786              		.loc 1 14866 0
 28787 007a 40B2     		sxtb	r0, r0
 28788 007c 03B0     		add	sp, sp, #12
 28789              	.LCFI1194:
 28790              		.cfi_remember_state
 28791              		.cfi_def_cfa_offset 12
 28792              		@ sp needed
 28793 007e 30BD     		pop	{r4, r5, pc}
 28794              	.LVL3527:
 28795              	.L3164:
 28796              	.LCFI1195:
 28797              		.cfi_restore_state
14822:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 28798              		.loc 1 14822 0
 28799 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 28800              	.LVL3528:
14825:Src/bno055.c  **** 				/* Write page as one */
 28801              		.loc 1 14825 0
 28802 0084 0028     		cmp	r0, #0
 28803 0086 CCD1     		bne	.L3166
 28804 0088 D6E7     		b	.L3167
 28805              	.LVL3529:
 28806              	.L3168:
14814:Src/bno055.c  **** } else {
ARM GAS  /tmp/ccVWLGiI.s 			page 821


 28807              		.loc 1 14814 0
 28808 008a 8120     		movs	r0, #129
 28809              	.LVL3530:
 28810 008c CEE7     		b	.L3161
 28811              	.L3177:
 28812 008e 00BF     		.align	2
 28813              	.L3176:
 28814 0090 00000000 		.word	.LANCHOR0
 28815              		.cfi_endproc
 28816              	.LFE234:
 28818              		.section	.text.bno055_get_accel_high_g_thres,"ax",%progbits
 28819              		.align	2
 28820              		.global	bno055_get_accel_high_g_thres
 28821              		.thumb
 28822              		.thumb_func
 28824              	bno055_get_accel_high_g_thres:
 28825              	.LFB235:
14867:Src/bno055.c  **** /*!
14868:Src/bno055.c  ****  *	@brief This API used to read the accel highg threshold
14869:Src/bno055.c  ****  *	from page one register from 0x14 bit 0 to 7
14870:Src/bno055.c  ****  *
14871:Src/bno055.c  ****  *	@param accel_high_g_thres_u8 : The value of accel highg threshold
14872:Src/bno055.c  ****  *
14873:Src/bno055.c  ****  *	@return results of bus communication function
14874:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14875:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14876:Src/bno055.c  ****  *
14877:Src/bno055.c  ****  *	@note Accel highg interrupt threshold dependent
14878:Src/bno055.c  ****  *	for accel g range
14879:Src/bno055.c  ****  *
14880:Src/bno055.c  ****  *  accel_range_u8	 |	threshold	 |	LSB
14881:Src/bno055.c  ****  * ------------- | ------------- | ---------
14882:Src/bno055.c  ****  *     2g        |    7.81mg     |   1LSB
14883:Src/bno055.c  ****  *     4g        |    15.63mg    |   1LSB
14884:Src/bno055.c  ****  *     8g        |    31.25mg    |   1LSB
14885:Src/bno055.c  ****  *     16g       |    62.5mg     |   1LSB
14886:Src/bno055.c  ****  *
14887:Src/bno055.c  ****  */
14888:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_high_g_thres(
14889:Src/bno055.c  **** u8 *accel_high_g_thres_u8)
14890:Src/bno055.c  **** {
 28826              		.loc 1 14890 0
 28827              		.cfi_startproc
 28828              		@ args = 0, pretend = 0, frame = 8
 28829              		@ frame_needed = 0, uses_anonymous_args = 0
 28830              	.LVL3531:
 28831 0000 30B5     		push	{r4, r5, lr}
 28832              	.LCFI1196:
 28833              		.cfi_def_cfa_offset 12
 28834              		.cfi_offset 4, -12
 28835              		.cfi_offset 5, -8
 28836              		.cfi_offset 14, -4
14891:Src/bno055.c  **** 	/* Variable used to return value of
14892:Src/bno055.c  **** 	communication routine*/
14893:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14894:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
14895:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 822


14896:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
14897:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 28837              		.loc 1 14897 0
 28838 0002 134D     		ldr	r5, .L3190
14890:Src/bno055.c  **** 	/* Variable used to return value of
 28839              		.loc 1 14890 0
 28840 0004 83B0     		sub	sp, sp, #12
 28841              	.LCFI1197:
 28842              		.cfi_def_cfa_offset 24
 28843              		.loc 1 14897 0
 28844 0006 2B68     		ldr	r3, [r5]
14894:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 28845              		.loc 1 14894 0
 28846 0008 0022     		movs	r2, #0
 28847 000a 8DF80720 		strb	r2, [sp, #7]
 28848              	.LVL3532:
 28849              		.loc 1 14897 0
 28850 000e EBB1     		cbz	r3, .L3182
14898:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
14899:Src/bno055.c  **** 		} else {
14900:Src/bno055.c  **** 		/*condition check for page, highg threshold is
14901:Src/bno055.c  **** 		available in the page one*/
14902:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 28851              		.loc 1 14902 0
 28852 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 28853 0012 0446     		mov	r4, r0
 28854 0014 012A     		cmp	r2, #1
 28855 0016 04D0     		beq	.L3180
14903:Src/bno055.c  **** 			/* Write page as one */
14904:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 28856              		.loc 1 14904 0
 28857 0018 0120     		movs	r0, #1
 28858              	.LVL3533:
 28859 001a FFF7FEFF 		bl	bno055_write_page_id
 28860              	.LVL3534:
 28861 001e 2B68     		ldr	r3, [r5]
14905:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 28862              		.loc 1 14905 0
 28863 0020 60B9     		cbnz	r0, .L3189
 28864              	.LVL3535:
 28865              	.L3180:
14906:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
14907:Src/bno055.c  **** 			/* Read the value of highg threshold */
14908:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 28866              		.loc 1 14908 0
 28867 0022 1D69     		ldr	r5, [r3, #16]
 28868 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 28869 0026 1421     		movs	r1, #20
 28870 0028 0123     		movs	r3, #1
 28871 002a 0DF10702 		add	r2, sp, #7
 28872 002e A847     		blx	r5
 28873              	.LVL3536:
14909:Src/bno055.c  **** 			(p_bno055->dev_addr,
14910:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_THRES_REG,
14911:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
14912:Src/bno055.c  **** 			*accel_high_g_thres_u8 =
 28874              		.loc 1 14912 0
ARM GAS  /tmp/ccVWLGiI.s 			page 823


 28875 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28876 0034 2370     		strb	r3, [r4]
 28877              	.LVL3537:
 28878              	.L3179:
14913:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
14914:Src/bno055.c  **** 			BNO055_ACCEL_HIGH_G_THRES);
14915:Src/bno055.c  **** 		} else {
14916:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
14917:Src/bno055.c  **** 		}
14918:Src/bno055.c  **** 	}
14919:Src/bno055.c  **** 	return com_rslt;
14920:Src/bno055.c  **** }
 28879              		.loc 1 14920 0
 28880 0036 40B2     		sxtb	r0, r0
 28881 0038 03B0     		add	sp, sp, #12
 28882              	.LCFI1198:
 28883              		.cfi_remember_state
 28884              		.cfi_def_cfa_offset 12
 28885              		@ sp needed
 28886 003a 30BD     		pop	{r4, r5, pc}
 28887              	.LVL3538:
 28888              	.L3189:
 28889              	.LCFI1199:
 28890              		.cfi_restore_state
14905:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 28891              		.loc 1 14905 0 discriminator 1
 28892 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 28893 003e 012A     		cmp	r2, #1
14916:Src/bno055.c  **** 		}
 28894              		.loc 1 14916 0 discriminator 1
 28895 0040 18BF     		it	ne
 28896 0042 FF20     		movne	r0, #255
14905:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 28897              		.loc 1 14905 0 discriminator 1
 28898 0044 EDD0     		beq	.L3180
 28899              		.loc 1 14920 0
 28900 0046 40B2     		sxtb	r0, r0
 28901 0048 03B0     		add	sp, sp, #12
 28902              	.LCFI1200:
 28903              		.cfi_remember_state
 28904              		.cfi_def_cfa_offset 12
 28905              		@ sp needed
 28906 004a 30BD     		pop	{r4, r5, pc}
 28907              	.LVL3539:
 28908              	.L3182:
 28909              	.LCFI1201:
 28910              		.cfi_restore_state
14898:Src/bno055.c  **** 		} else {
 28911              		.loc 1 14898 0
 28912 004c 8120     		movs	r0, #129
 28913              	.LVL3540:
 28914 004e F2E7     		b	.L3179
 28915              	.L3191:
 28916              		.align	2
 28917              	.L3190:
 28918 0050 00000000 		.word	.LANCHOR0
 28919              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 824


 28920              	.LFE235:
 28922              		.section	.text.bno055_set_accel_high_g_thres,"ax",%progbits
 28923              		.align	2
 28924              		.global	bno055_set_accel_high_g_thres
 28925              		.thumb
 28926              		.thumb_func
 28928              	bno055_set_accel_high_g_thres:
 28929              	.LFB236:
14921:Src/bno055.c  **** /*!
14922:Src/bno055.c  ****  *	@brief This API used to write the accel highg threshold
14923:Src/bno055.c  ****  *	from page one register from 0x14 bit 0 to 7
14924:Src/bno055.c  ****  *
14925:Src/bno055.c  ****  *	@param accel_high_g_thres_u8 : The value of accel highg threshold
14926:Src/bno055.c  ****  *
14927:Src/bno055.c  ****  *	@return results of bus communication function
14928:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
14929:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
14930:Src/bno055.c  ****  *
14931:Src/bno055.c  ****  *	@note Accel highg interrupt threshold dependent
14932:Src/bno055.c  ****  *	for accel g range
14933:Src/bno055.c  ****  *
14934:Src/bno055.c  ****  *  accel_range_u8	 |	threshold	 |	LSB
14935:Src/bno055.c  ****  * ------------- | ------------- | ---------
14936:Src/bno055.c  ****  *     2g        |    7.81mg     |   1LSB
14937:Src/bno055.c  ****  *     4g        |    15.63mg    |   1LSB
14938:Src/bno055.c  ****  *     8g        |    31.25mg    |   1LSB
14939:Src/bno055.c  ****  *     16g       |    62.5mg     |   1LSB
14940:Src/bno055.c  ****  *
14941:Src/bno055.c  ****  */
14942:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_high_g_thres(
14943:Src/bno055.c  **** u8 accel_high_g_thres_u8)
14944:Src/bno055.c  **** {
 28930              		.loc 1 14944 0
 28931              		.cfi_startproc
 28932              		@ args = 0, pretend = 0, frame = 8
 28933              		@ frame_needed = 0, uses_anonymous_args = 0
 28934              	.LVL3541:
 28935 0000 30B5     		push	{r4, r5, lr}
 28936              	.LCFI1202:
 28937              		.cfi_def_cfa_offset 12
 28938              		.cfi_offset 4, -12
 28939              		.cfi_offset 5, -8
 28940              		.cfi_offset 14, -4
14945:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
14946:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
14947:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
14948:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
14949:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
14950:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
14951:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 28941              		.loc 1 14951 0
 28942 0002 234C     		ldr	r4, .L3208
14944:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 28943              		.loc 1 14944 0
 28944 0004 83B0     		sub	sp, sp, #12
 28945              	.LCFI1203:
 28946              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccVWLGiI.s 			page 825


 28947              		.loc 1 14951 0
 28948 0006 2268     		ldr	r2, [r4]
14946:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 28949              		.loc 1 14946 0
 28950 0008 0023     		movs	r3, #0
 28951 000a 8DF80630 		strb	r3, [sp, #6]
 28952              	.LVL3542:
14948:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 28953              		.loc 1 14948 0
 28954 000e 8DF80730 		strb	r3, [sp, #7]
 28955              	.LVL3543:
 28956              		.loc 1 14951 0
 28957 0012 002A     		cmp	r2, #0
 28958 0014 39D0     		beq	.L3200
 28959 0016 0546     		mov	r5, r0
14952:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
14953:Src/bno055.c  **** 	} else {
14954:Src/bno055.c  **** 	/* The write operation effective only if the operation
14955:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
14956:Src/bno055.c  **** 	current operation mode and set the config mode */
14957:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 28960              		.loc 1 14957 0
 28961 0018 0DF10700 		add	r0, sp, #7
 28962              	.LVL3544:
 28963 001c FFF7FEFF 		bl	bno055_get_operation_mode
 28964              	.LVL3545:
14958:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 28965              		.loc 1 14958 0
 28966 0020 38B1     		cbz	r0, .L3194
 28967              	.LVL3546:
 28968              	.L3198:
14959:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
14960:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
14961:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
14962:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
14963:Src/bno055.c  **** 				/* Write page as one */
14964:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
14965:Src/bno055.c  **** 					BNO055_PAGE_ONE);
14966:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
14967:Src/bno055.c  **** 					com_rslt =
14968:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
14969:Src/bno055.c  **** 					(p_bno055->dev_addr,
14970:Src/bno055.c  **** 					BNO055_ACCEL_HIGH_G_THRES_REG,
14971:Src/bno055.c  **** 					&data_u8r,
14972:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
14973:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
14974:Src/bno055.c  **** 						/* Write the value of
14975:Src/bno055.c  **** 						accel highg threshold */
14976:Src/bno055.c  **** 						data_u8r =
14977:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
14978:Src/bno055.c  **** 						BNO055_ACCEL_HIGH_G_THRES,
14979:Src/bno055.c  **** 						accel_high_g_thres_u8);
14980:Src/bno055.c  **** 						com_rslt +=
14981:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
14982:Src/bno055.c  **** 						(p_bno055->dev_addr,
14983:Src/bno055.c  **** 						BNO055_ACCEL_HIGH_G_THRES_REG,
14984:Src/bno055.c  **** 						&data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 826


14985:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
14986:Src/bno055.c  **** 					}
14987:Src/bno055.c  **** 				} else {
14988:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
14989:Src/bno055.c  **** 				}
14990:Src/bno055.c  **** 			} else {
14991:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
14992:Src/bno055.c  **** 			}
14993:Src/bno055.c  **** 		} else {
14994:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 28969              		.loc 1 14994 0
 28970 0022 FF24     		movs	r4, #255
 28971              	.LVL3547:
 28972              	.L3195:
14995:Src/bno055.c  **** 		}
14996:Src/bno055.c  **** 	}
14997:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 28973              		.loc 1 14997 0
 28974 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 28975 0028 18BB     		cbnz	r0, .L3207
 28976 002a 2046     		mov	r0, r4
 28977              	.LVL3548:
 28978              	.L3193:
14998:Src/bno055.c  **** 		/* set the operation mode of
14999:Src/bno055.c  **** 		previous operation mode*/
15000:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
15001:Src/bno055.c  **** 		(prev_opmode_u8);
15002:Src/bno055.c  **** 	return com_rslt;
15003:Src/bno055.c  **** }
 28979              		.loc 1 15003 0
 28980 002c 40B2     		sxtb	r0, r0
 28981 002e 03B0     		add	sp, sp, #12
 28982              	.LCFI1204:
 28983              		.cfi_remember_state
 28984              		.cfi_def_cfa_offset 12
 28985              		@ sp needed
 28986 0030 30BD     		pop	{r4, r5, pc}
 28987              	.LVL3549:
 28988              	.L3194:
 28989              	.LCFI1205:
 28990              		.cfi_restore_state
14959:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 28991              		.loc 1 14959 0
 28992 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 28993 0036 1BBB     		cbnz	r3, .L3196
 28994              	.L3199:
 28995              	.LVL3550:
14964:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 28996              		.loc 1 14964 0
 28997 0038 0120     		movs	r0, #1
 28998 003a FFF7FEFF 		bl	bno055_write_page_id
 28999              	.LVL3551:
14966:Src/bno055.c  **** 					com_rslt =
 29000              		.loc 1 14966 0
 29001 003e 0028     		cmp	r0, #0
 29002 0040 EFD1     		bne	.L3198
14968:Src/bno055.c  **** 					(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 827


 29003              		.loc 1 14968 0
 29004 0042 2368     		ldr	r3, [r4]
14967:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 29005              		.loc 1 14967 0
 29006 0044 0DF10602 		add	r2, sp, #6
 29007 0048 1C69     		ldr	r4, [r3, #16]
 29008 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29009              	.LVL3552:
 29010 004c 1421     		movs	r1, #20
 29011 004e 0123     		movs	r3, #1
 29012 0050 A047     		blx	r4
 29013              	.LVL3553:
14968:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29014              		.loc 1 14968 0
 29015 0052 0F4B     		ldr	r3, .L3208
14973:Src/bno055.c  **** 						/* Write the value of
 29016              		.loc 1 14973 0
 29017 0054 0446     		mov	r4, r0
 29018 0056 0028     		cmp	r0, #0
 29019 0058 E4D1     		bne	.L3195
14981:Src/bno055.c  **** 						(p_bno055->dev_addr,
 29020              		.loc 1 14981 0
 29021 005a 1B68     		ldr	r3, [r3]
14976:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 29022              		.loc 1 14976 0
 29023 005c 8DF80650 		strb	r5, [sp, #6]
14981:Src/bno055.c  **** 						(p_bno055->dev_addr,
 29024              		.loc 1 14981 0
 29025 0060 DC68     		ldr	r4, [r3, #12]
 29026 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29027              	.LVL3554:
 29028 0064 0DF10602 		add	r2, sp, #6
 29029 0068 1421     		movs	r1, #20
 29030 006a 0123     		movs	r3, #1
 29031 006c A047     		blx	r4
 29032              	.LVL3555:
 29033 006e 0446     		mov	r4, r0
 29034              	.LVL3556:
 29035 0070 D8E7     		b	.L3195
 29036              	.L3207:
15000:Src/bno055.c  **** 		(prev_opmode_u8);
 29037              		.loc 1 15000 0
 29038 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 29039              	.LVL3557:
 29040 0076 2044     		add	r0, r0, r4
 29041 0078 C0B2     		uxtb	r0, r0
 29042              	.LVL3558:
 29043              		.loc 1 15003 0
 29044 007a 40B2     		sxtb	r0, r0
 29045 007c 03B0     		add	sp, sp, #12
 29046              	.LCFI1206:
 29047              		.cfi_remember_state
 29048              		.cfi_def_cfa_offset 12
 29049              		@ sp needed
 29050 007e 30BD     		pop	{r4, r5, pc}
 29051              	.LVL3559:
 29052              	.L3196:
ARM GAS  /tmp/ccVWLGiI.s 			page 828


 29053              	.LCFI1207:
 29054              		.cfi_restore_state
14960:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 29055              		.loc 1 14960 0
 29056 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 29057              	.LVL3560:
14962:Src/bno055.c  **** 				/* Write page as one */
 29058              		.loc 1 14962 0
 29059 0084 0028     		cmp	r0, #0
 29060 0086 CCD1     		bne	.L3198
 29061 0088 D6E7     		b	.L3199
 29062              	.LVL3561:
 29063              	.L3200:
14952:Src/bno055.c  **** 	} else {
 29064              		.loc 1 14952 0
 29065 008a 8120     		movs	r0, #129
 29066              	.LVL3562:
 29067 008c CEE7     		b	.L3193
 29068              	.L3209:
 29069 008e 00BF     		.align	2
 29070              	.L3208:
 29071 0090 00000000 		.word	.LANCHOR0
 29072              		.cfi_endproc
 29073              	.LFE236:
 29075              		.section	.text.bno055_get_accel_slow_no_motion_thres,"ax",%progbits
 29076              		.align	2
 29077              		.global	bno055_get_accel_slow_no_motion_thres
 29078              		.thumb
 29079              		.thumb_func
 29081              	bno055_get_accel_slow_no_motion_thres:
 29082              	.LFB237:
15004:Src/bno055.c  **** /*!
15005:Src/bno055.c  ****  *	@brief This API used to read the accel slownomotion threshold
15006:Src/bno055.c  ****  *	from page one register from 0x15 bit 0 to 7
15007:Src/bno055.c  ****  *
15008:Src/bno055.c  ****  *	@param accel_slow_no_motion_thres_u8 :
15009:Src/bno055.c  ****  *	The value of accel slownomotion threshold
15010:Src/bno055.c  ****  *
15011:Src/bno055.c  ****  *	@return results of bus communication function
15012:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15013:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15014:Src/bno055.c  ****  *
15015:Src/bno055.c  ****  *	@note Accel slow no motion interrupt threshold dependent
15016:Src/bno055.c  ****  *	for accel g range
15017:Src/bno055.c  ****  *
15018:Src/bno055.c  ****  *  accel_range_u8	 |	threshold	 |	LSB
15019:Src/bno055.c  ****  * ------------- | ------------- | ---------
15020:Src/bno055.c  ****  *     2g        |    3.19mg     |   1LSB
15021:Src/bno055.c  ****  *     4g        |    7.81mg     |   1LSB
15022:Src/bno055.c  ****  *     8g        |    15.63mg    |   1LSB
15023:Src/bno055.c  ****  *     16g       |    31.25mg    |   1LSB
15024:Src/bno055.c  ****  */
15025:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_slow_no_motion_thres(
15026:Src/bno055.c  **** u8 *accel_slow_no_motion_thres_u8)
15027:Src/bno055.c  **** {
 29083              		.loc 1 15027 0
 29084              		.cfi_startproc
ARM GAS  /tmp/ccVWLGiI.s 			page 829


 29085              		@ args = 0, pretend = 0, frame = 8
 29086              		@ frame_needed = 0, uses_anonymous_args = 0
 29087              	.LVL3563:
 29088 0000 30B5     		push	{r4, r5, lr}
 29089              	.LCFI1208:
 29090              		.cfi_def_cfa_offset 12
 29091              		.cfi_offset 4, -12
 29092              		.cfi_offset 5, -8
 29093              		.cfi_offset 14, -4
15028:Src/bno055.c  **** 	/* Variable used to return value of
15029:Src/bno055.c  **** 	communication routine*/
15030:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15031:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
15032:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
15033:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
15034:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 29094              		.loc 1 15034 0
 29095 0002 134D     		ldr	r5, .L3222
15027:Src/bno055.c  **** 	/* Variable used to return value of
 29096              		.loc 1 15027 0
 29097 0004 83B0     		sub	sp, sp, #12
 29098              	.LCFI1209:
 29099              		.cfi_def_cfa_offset 24
 29100              		.loc 1 15034 0
 29101 0006 2B68     		ldr	r3, [r5]
15031:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 29102              		.loc 1 15031 0
 29103 0008 0022     		movs	r2, #0
 29104 000a 8DF80720 		strb	r2, [sp, #7]
 29105              	.LVL3564:
 29106              		.loc 1 15034 0
 29107 000e EBB1     		cbz	r3, .L3214
15035:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
15036:Src/bno055.c  **** 		} else {
15037:Src/bno055.c  **** 		/*condition check for page, accel slownomotion threshold is
15038:Src/bno055.c  **** 		available in the page one*/
15039:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 29108              		.loc 1 15039 0
 29109 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 29110 0012 0446     		mov	r4, r0
 29111 0014 012A     		cmp	r2, #1
 29112 0016 04D0     		beq	.L3212
15040:Src/bno055.c  **** 			/* Write page as one */
15041:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 29113              		.loc 1 15041 0
 29114 0018 0120     		movs	r0, #1
 29115              	.LVL3565:
 29116 001a FFF7FEFF 		bl	bno055_write_page_id
 29117              	.LVL3566:
 29118 001e 2B68     		ldr	r3, [r5]
15042:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 29119              		.loc 1 15042 0
 29120 0020 60B9     		cbnz	r0, .L3221
 29121              	.LVL3567:
 29122              	.L3212:
15043:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
15044:Src/bno055.c  **** 			/* Read the value of slownomotion threshold */
ARM GAS  /tmp/ccVWLGiI.s 			page 830


15045:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 29123              		.loc 1 15045 0
 29124 0022 1D69     		ldr	r5, [r3, #16]
 29125 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29126 0026 1521     		movs	r1, #21
 29127 0028 0123     		movs	r3, #1
 29128 002a 0DF10702 		add	r2, sp, #7
 29129 002e A847     		blx	r5
 29130              	.LVL3568:
15046:Src/bno055.c  **** 			(p_bno055->dev_addr,
15047:Src/bno055.c  **** 			BNO055_ACCEL_SLOW_NO_MOTION_THRES_REG,
15048:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15049:Src/bno055.c  **** 			*accel_slow_no_motion_thres_u8 =
 29131              		.loc 1 15049 0
 29132 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29133 0034 2370     		strb	r3, [r4]
 29134              	.LVL3569:
 29135              	.L3211:
15050:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
15051:Src/bno055.c  **** 			BNO055_ACCEL_SLOW_NO_MOTION_THRES);
15052:Src/bno055.c  **** 		} else {
15053:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15054:Src/bno055.c  **** 		}
15055:Src/bno055.c  **** 	}
15056:Src/bno055.c  **** 	return com_rslt;
15057:Src/bno055.c  **** }
 29136              		.loc 1 15057 0
 29137 0036 40B2     		sxtb	r0, r0
 29138 0038 03B0     		add	sp, sp, #12
 29139              	.LCFI1210:
 29140              		.cfi_remember_state
 29141              		.cfi_def_cfa_offset 12
 29142              		@ sp needed
 29143 003a 30BD     		pop	{r4, r5, pc}
 29144              	.LVL3570:
 29145              	.L3221:
 29146              	.LCFI1211:
 29147              		.cfi_restore_state
15042:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 29148              		.loc 1 15042 0 discriminator 1
 29149 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 29150 003e 012A     		cmp	r2, #1
15053:Src/bno055.c  **** 		}
 29151              		.loc 1 15053 0 discriminator 1
 29152 0040 18BF     		it	ne
 29153 0042 FF20     		movne	r0, #255
15042:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 29154              		.loc 1 15042 0 discriminator 1
 29155 0044 EDD0     		beq	.L3212
 29156              		.loc 1 15057 0
 29157 0046 40B2     		sxtb	r0, r0
 29158 0048 03B0     		add	sp, sp, #12
 29159              	.LCFI1212:
 29160              		.cfi_remember_state
 29161              		.cfi_def_cfa_offset 12
 29162              		@ sp needed
 29163 004a 30BD     		pop	{r4, r5, pc}
ARM GAS  /tmp/ccVWLGiI.s 			page 831


 29164              	.LVL3571:
 29165              	.L3214:
 29166              	.LCFI1213:
 29167              		.cfi_restore_state
15035:Src/bno055.c  **** 		} else {
 29168              		.loc 1 15035 0
 29169 004c 8120     		movs	r0, #129
 29170              	.LVL3572:
 29171 004e F2E7     		b	.L3211
 29172              	.L3223:
 29173              		.align	2
 29174              	.L3222:
 29175 0050 00000000 		.word	.LANCHOR0
 29176              		.cfi_endproc
 29177              	.LFE237:
 29179              		.section	.text.bno055_set_accel_slow_no_motion_thres,"ax",%progbits
 29180              		.align	2
 29181              		.global	bno055_set_accel_slow_no_motion_thres
 29182              		.thumb
 29183              		.thumb_func
 29185              	bno055_set_accel_slow_no_motion_thres:
 29186              	.LFB238:
15058:Src/bno055.c  **** /*!
15059:Src/bno055.c  ****  *	@brief This API used to write the accel slownomotion threshold
15060:Src/bno055.c  ****  *	from page one register from 0x15 bit 0 to 7
15061:Src/bno055.c  ****  *
15062:Src/bno055.c  ****  *	@param accel_slow_no_motion_thres_u8 :
15063:Src/bno055.c  ****  *	The value of accel slownomotion threshold
15064:Src/bno055.c  ****  *
15065:Src/bno055.c  ****  *	@return results of bus communication function
15066:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15067:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15068:Src/bno055.c  ****  *
15069:Src/bno055.c  ****  *	@note Accel slow no motion interrupt threshold dependent
15070:Src/bno055.c  ****  *	for accel g range
15071:Src/bno055.c  ****  *
15072:Src/bno055.c  ****  *  accel_range_u8	 |	threshold	 |	LSB
15073:Src/bno055.c  ****  * ------------- | ------------- | ---------
15074:Src/bno055.c  ****  *     2g        |    3.19mg     |   1LSB
15075:Src/bno055.c  ****  *     4g        |    7.81mg     |   1LSB
15076:Src/bno055.c  ****  *     8g        |    15.63mg    |   1LSB
15077:Src/bno055.c  ****  *     16g       |    31.25mg    |   1LSB
15078:Src/bno055.c  ****  */
15079:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_slow_no_motion_thres(
15080:Src/bno055.c  **** u8 accel_slow_no_motion_thres_u8)
15081:Src/bno055.c  **** {
 29187              		.loc 1 15081 0
 29188              		.cfi_startproc
 29189              		@ args = 0, pretend = 0, frame = 8
 29190              		@ frame_needed = 0, uses_anonymous_args = 0
 29191              	.LVL3573:
 29192 0000 30B5     		push	{r4, r5, lr}
 29193              	.LCFI1214:
 29194              		.cfi_def_cfa_offset 12
 29195              		.cfi_offset 4, -12
 29196              		.cfi_offset 5, -8
 29197              		.cfi_offset 14, -4
ARM GAS  /tmp/ccVWLGiI.s 			page 832


15082:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15083:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15084:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15085:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
15086:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15087:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15088:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 29198              		.loc 1 15088 0
 29199 0002 234C     		ldr	r4, .L3240
15081:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 29200              		.loc 1 15081 0
 29201 0004 83B0     		sub	sp, sp, #12
 29202              	.LCFI1215:
 29203              		.cfi_def_cfa_offset 24
 29204              		.loc 1 15088 0
 29205 0006 2268     		ldr	r2, [r4]
15083:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 29206              		.loc 1 15083 0
 29207 0008 0023     		movs	r3, #0
 29208 000a 8DF80630 		strb	r3, [sp, #6]
 29209              	.LVL3574:
15085:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 29210              		.loc 1 15085 0
 29211 000e 8DF80730 		strb	r3, [sp, #7]
 29212              	.LVL3575:
 29213              		.loc 1 15088 0
 29214 0012 002A     		cmp	r2, #0
 29215 0014 39D0     		beq	.L3232
 29216 0016 0546     		mov	r5, r0
15089:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15090:Src/bno055.c  **** } else {
15091:Src/bno055.c  **** /* The write operation effective only if the operation
15092:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15093:Src/bno055.c  **** current operation mode and set the config mode */
15094:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 29217              		.loc 1 15094 0
 29218 0018 0DF10700 		add	r0, sp, #7
 29219              	.LVL3576:
 29220 001c FFF7FEFF 		bl	bno055_get_operation_mode
 29221              	.LVL3577:
15095:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 29222              		.loc 1 15095 0
 29223 0020 38B1     		cbz	r0, .L3226
 29224              	.LVL3578:
 29225              	.L3230:
15096:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
15097:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
15098:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
15099:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
15100:Src/bno055.c  **** 			/* Write page as one */
15101:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
15102:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
15103:Src/bno055.c  **** 				/* Write the value of
15104:Src/bno055.c  **** 				slownomotion threshold */
15105:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15106:Src/bno055.c  **** 				(p_bno055->dev_addr,
15107:Src/bno055.c  **** 				BNO055_ACCEL_SLOW_NO_MOTION_THRES_REG,
ARM GAS  /tmp/ccVWLGiI.s 			page 833


15108:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15109:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15110:Src/bno055.c  **** 					data_u8r =
15111:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
15112:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_THRES,
15113:Src/bno055.c  **** 					accel_slow_no_motion_thres_u8);
15114:Src/bno055.c  **** 					com_rslt +=
15115:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15116:Src/bno055.c  **** 					(p_bno055->dev_addr,
15117:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_THRES_REG,
15118:Src/bno055.c  **** 					&data_u8r,
15119:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15120:Src/bno055.c  **** 				}
15121:Src/bno055.c  **** 			} else {
15122:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
15123:Src/bno055.c  **** 			}
15124:Src/bno055.c  **** 		} else {
15125:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15126:Src/bno055.c  **** 		}
15127:Src/bno055.c  **** 	} else {
15128:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 29226              		.loc 1 15128 0
 29227 0022 FF24     		movs	r4, #255
 29228              	.LVL3579:
 29229              	.L3227:
15129:Src/bno055.c  **** 	}
15130:Src/bno055.c  **** }
15131:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 29230              		.loc 1 15131 0
 29231 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 29232 0028 18BB     		cbnz	r0, .L3239
 29233 002a 2046     		mov	r0, r4
 29234              	.LVL3580:
 29235              	.L3225:
15132:Src/bno055.c  **** 	/* set the operation mode of
15133:Src/bno055.c  **** 	previous operation mode*/
15134:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
15135:Src/bno055.c  **** 	(prev_opmode_u8);
15136:Src/bno055.c  **** return com_rslt;
15137:Src/bno055.c  **** }
 29236              		.loc 1 15137 0
 29237 002c 40B2     		sxtb	r0, r0
 29238 002e 03B0     		add	sp, sp, #12
 29239              	.LCFI1216:
 29240              		.cfi_remember_state
 29241              		.cfi_def_cfa_offset 12
 29242              		@ sp needed
 29243 0030 30BD     		pop	{r4, r5, pc}
 29244              	.LVL3581:
 29245              	.L3226:
 29246              	.LCFI1217:
 29247              		.cfi_restore_state
15096:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 29248              		.loc 1 15096 0
 29249 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29250 0036 1BBB     		cbnz	r3, .L3228
 29251              	.L3231:
ARM GAS  /tmp/ccVWLGiI.s 			page 834


 29252              	.LVL3582:
15101:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 29253              		.loc 1 15101 0
 29254 0038 0120     		movs	r0, #1
 29255 003a FFF7FEFF 		bl	bno055_write_page_id
 29256              	.LVL3583:
15102:Src/bno055.c  **** 				/* Write the value of
 29257              		.loc 1 15102 0
 29258 003e 0028     		cmp	r0, #0
 29259 0040 EFD1     		bne	.L3230
15105:Src/bno055.c  **** 				(p_bno055->dev_addr,
 29260              		.loc 1 15105 0
 29261 0042 2368     		ldr	r3, [r4]
 29262 0044 0DF10602 		add	r2, sp, #6
 29263 0048 1C69     		ldr	r4, [r3, #16]
 29264 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29265              	.LVL3584:
 29266 004c 1521     		movs	r1, #21
 29267 004e 0123     		movs	r3, #1
 29268 0050 A047     		blx	r4
 29269              	.LVL3585:
 29270 0052 0F4B     		ldr	r3, .L3240
15109:Src/bno055.c  **** 					data_u8r =
 29271              		.loc 1 15109 0
 29272 0054 0446     		mov	r4, r0
 29273 0056 0028     		cmp	r0, #0
 29274 0058 E4D1     		bne	.L3227
15115:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29275              		.loc 1 15115 0
 29276 005a 1B68     		ldr	r3, [r3]
15110:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29277              		.loc 1 15110 0
 29278 005c 8DF80650 		strb	r5, [sp, #6]
15115:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29279              		.loc 1 15115 0
 29280 0060 DC68     		ldr	r4, [r3, #12]
 29281 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29282              	.LVL3586:
 29283 0064 0DF10602 		add	r2, sp, #6
 29284 0068 1521     		movs	r1, #21
 29285 006a 0123     		movs	r3, #1
 29286 006c A047     		blx	r4
 29287              	.LVL3587:
 29288 006e 0446     		mov	r4, r0
 29289              	.LVL3588:
 29290 0070 D8E7     		b	.L3227
 29291              	.L3239:
15134:Src/bno055.c  **** 	(prev_opmode_u8);
 29292              		.loc 1 15134 0
 29293 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 29294              	.LVL3589:
 29295 0076 2044     		add	r0, r0, r4
 29296 0078 C0B2     		uxtb	r0, r0
 29297              	.LVL3590:
 29298              		.loc 1 15137 0
 29299 007a 40B2     		sxtb	r0, r0
 29300 007c 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 835


 29301              	.LCFI1218:
 29302              		.cfi_remember_state
 29303              		.cfi_def_cfa_offset 12
 29304              		@ sp needed
 29305 007e 30BD     		pop	{r4, r5, pc}
 29306              	.LVL3591:
 29307              	.L3228:
 29308              	.LCFI1219:
 29309              		.cfi_restore_state
15097:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 29310              		.loc 1 15097 0
 29311 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 29312              	.LVL3592:
15099:Src/bno055.c  **** 			/* Write page as one */
 29313              		.loc 1 15099 0
 29314 0084 0028     		cmp	r0, #0
 29315 0086 CCD1     		bne	.L3230
 29316 0088 D6E7     		b	.L3231
 29317              	.LVL3593:
 29318              	.L3232:
15089:Src/bno055.c  **** } else {
 29319              		.loc 1 15089 0
 29320 008a 8120     		movs	r0, #129
 29321              	.LVL3594:
 29322 008c CEE7     		b	.L3225
 29323              	.L3241:
 29324 008e 00BF     		.align	2
 29325              	.L3240:
 29326 0090 00000000 		.word	.LANCHOR0
 29327              		.cfi_endproc
 29328              	.LFE238:
 29330              		.section	.text.bno055_get_accel_slow_no_motion_enable,"ax",%progbits
 29331              		.align	2
 29332              		.global	bno055_get_accel_slow_no_motion_enable
 29333              		.thumb
 29334              		.thumb_func
 29336              	bno055_get_accel_slow_no_motion_enable:
 29337              	.LFB239:
15138:Src/bno055.c  **** /*!
15139:Src/bno055.c  ****  *	@brief This API used to read accel slownomotion enable
15140:Src/bno055.c  ****  *	from page one register from 0x16 bit 0
15141:Src/bno055.c  ****  *
15142:Src/bno055.c  ****  *	@param accel_slow_no_motion_en_u8 : The value of accel slownomotion enable
15143:Src/bno055.c  ****  *	  accel_slow_no_motion_en_u8   | result
15144:Src/bno055.c  ****  *     ------------------------      | --------
15145:Src/bno055.c  ****  *              0x01                 | Slow motion
15146:Src/bno055.c  ****  *              0x00                 | No motion
15147:Src/bno055.c  ****  *
15148:Src/bno055.c  ****  *	@return results of bus communication function
15149:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15150:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15151:Src/bno055.c  ****  *
15152:Src/bno055.c  ****  */
15153:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_slow_no_motion_enable(
15154:Src/bno055.c  **** u8 *accel_slow_no_motion_en_u8)
15155:Src/bno055.c  **** {
 29338              		.loc 1 15155 0
ARM GAS  /tmp/ccVWLGiI.s 			page 836


 29339              		.cfi_startproc
 29340              		@ args = 0, pretend = 0, frame = 8
 29341              		@ frame_needed = 0, uses_anonymous_args = 0
 29342              	.LVL3595:
 29343 0000 30B5     		push	{r4, r5, lr}
 29344              	.LCFI1220:
 29345              		.cfi_def_cfa_offset 12
 29346              		.cfi_offset 4, -12
 29347              		.cfi_offset 5, -8
 29348              		.cfi_offset 14, -4
15156:Src/bno055.c  **** 	/* Variable used to return value of
15157:Src/bno055.c  **** 	communication routine*/
15158:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15159:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
15160:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
15161:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
15162:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 29349              		.loc 1 15162 0
 29350 0002 144C     		ldr	r4, .L3254
15155:Src/bno055.c  **** 	/* Variable used to return value of
 29351              		.loc 1 15155 0
 29352 0004 83B0     		sub	sp, sp, #12
 29353              	.LCFI1221:
 29354              		.cfi_def_cfa_offset 24
 29355              		.loc 1 15162 0
 29356 0006 2368     		ldr	r3, [r4]
15159:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 29357              		.loc 1 15159 0
 29358 0008 0022     		movs	r2, #0
 29359 000a 8DF80720 		strb	r2, [sp, #7]
 29360              	.LVL3596:
 29361              		.loc 1 15162 0
 29362 000e FBB1     		cbz	r3, .L3246
15163:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
15164:Src/bno055.c  **** 		} else {
15165:Src/bno055.c  **** 		/*condition check for page, accel slownomotion enable is
15166:Src/bno055.c  **** 		available in the page one*/
15167:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 29363              		.loc 1 15167 0
 29364 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 29365 0012 0546     		mov	r5, r0
 29366 0014 012A     		cmp	r2, #1
 29367 0016 04D0     		beq	.L3244
15168:Src/bno055.c  **** 			/* Write page as one */
15169:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 29368              		.loc 1 15169 0
 29369 0018 0120     		movs	r0, #1
 29370              	.LVL3597:
 29371 001a FFF7FEFF 		bl	bno055_write_page_id
 29372              	.LVL3598:
 29373 001e 2368     		ldr	r3, [r4]
15170:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 29374              		.loc 1 15170 0
 29375 0020 70B9     		cbnz	r0, .L3253
 29376              	.LVL3599:
 29377              	.L3244:
15171:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
ARM GAS  /tmp/ccVWLGiI.s 			page 837


15172:Src/bno055.c  **** 			/* Read the value of accel slownomotion enable */
15173:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 29378              		.loc 1 15173 0
 29379 0022 1C69     		ldr	r4, [r3, #16]
 29380 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29381 0026 1621     		movs	r1, #22
 29382 0028 0123     		movs	r3, #1
 29383 002a 0DF10702 		add	r2, sp, #7
 29384 002e A047     		blx	r4
 29385              	.LVL3600:
15174:Src/bno055.c  **** 			(p_bno055->dev_addr,
15175:Src/bno055.c  **** 			BNO055_ACCEL_SLOW_NO_MOTION_ENABLE_REG,
15176:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15177:Src/bno055.c  **** 			*accel_slow_no_motion_en_u8 =
 29386              		.loc 1 15177 0
 29387 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29388 0034 03F00103 		and	r3, r3, #1
 29389 0038 2B70     		strb	r3, [r5]
 29390              	.LVL3601:
 29391              	.L3243:
15178:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
15179:Src/bno055.c  **** 			BNO055_ACCEL_SLOW_NO_MOTION_ENABLE);
15180:Src/bno055.c  **** 		} else {
15181:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15182:Src/bno055.c  **** 		}
15183:Src/bno055.c  **** 	}
15184:Src/bno055.c  **** 	return com_rslt;
15185:Src/bno055.c  **** }
 29392              		.loc 1 15185 0
 29393 003a 40B2     		sxtb	r0, r0
 29394 003c 03B0     		add	sp, sp, #12
 29395              	.LCFI1222:
 29396              		.cfi_remember_state
 29397              		.cfi_def_cfa_offset 12
 29398              		@ sp needed
 29399 003e 30BD     		pop	{r4, r5, pc}
 29400              	.LVL3602:
 29401              	.L3253:
 29402              	.LCFI1223:
 29403              		.cfi_restore_state
15170:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 29404              		.loc 1 15170 0 discriminator 1
 29405 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 29406 0042 012A     		cmp	r2, #1
15181:Src/bno055.c  **** 		}
 29407              		.loc 1 15181 0 discriminator 1
 29408 0044 18BF     		it	ne
 29409 0046 FF20     		movne	r0, #255
15170:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 29410              		.loc 1 15170 0 discriminator 1
 29411 0048 EBD0     		beq	.L3244
 29412              		.loc 1 15185 0
 29413 004a 40B2     		sxtb	r0, r0
 29414 004c 03B0     		add	sp, sp, #12
 29415              	.LCFI1224:
 29416              		.cfi_remember_state
 29417              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 838


 29418              		@ sp needed
 29419 004e 30BD     		pop	{r4, r5, pc}
 29420              	.LVL3603:
 29421              	.L3246:
 29422              	.LCFI1225:
 29423              		.cfi_restore_state
15163:Src/bno055.c  **** 		} else {
 29424              		.loc 1 15163 0
 29425 0050 8120     		movs	r0, #129
 29426              	.LVL3604:
 29427 0052 F2E7     		b	.L3243
 29428              	.L3255:
 29429              		.align	2
 29430              	.L3254:
 29431 0054 00000000 		.word	.LANCHOR0
 29432              		.cfi_endproc
 29433              	.LFE239:
 29435              		.section	.text.bno055_set_accel_slow_no_motion_enable,"ax",%progbits
 29436              		.align	2
 29437              		.global	bno055_set_accel_slow_no_motion_enable
 29438              		.thumb
 29439              		.thumb_func
 29441              	bno055_set_accel_slow_no_motion_enable:
 29442              	.LFB240:
15186:Src/bno055.c  **** /*!
15187:Src/bno055.c  ****  *	@brief This API used to write accel slownomotion enable
15188:Src/bno055.c  ****  *	from page one register from 0x16 bit 0
15189:Src/bno055.c  ****  *
15190:Src/bno055.c  ****  *	@param accel_slow_no_motion_en_u8 : The value of accel slownomotion enable
15191:Src/bno055.c  ****  *	  accel_slow_no_motion_en_u8   | result
15192:Src/bno055.c  ****  *     ------------------------      | --------
15193:Src/bno055.c  ****  *              0x01                 | Slow motion
15194:Src/bno055.c  ****  *              0x00                 | No motion
15195:Src/bno055.c  ****  *
15196:Src/bno055.c  ****  *	@return results of bus communication function
15197:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15198:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15199:Src/bno055.c  ****  *
15200:Src/bno055.c  ****  */
15201:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_slow_no_motion_enable(
15202:Src/bno055.c  **** u8 accel_slow_no_motion_en_u8)
15203:Src/bno055.c  **** {
 29443              		.loc 1 15203 0
 29444              		.cfi_startproc
 29445              		@ args = 0, pretend = 0, frame = 8
 29446              		@ frame_needed = 0, uses_anonymous_args = 0
 29447              	.LVL3605:
 29448 0000 30B5     		push	{r4, r5, lr}
 29449              	.LCFI1226:
 29450              		.cfi_def_cfa_offset 12
 29451              		.cfi_offset 4, -12
 29452              		.cfi_offset 5, -8
 29453              		.cfi_offset 14, -4
15204:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15205:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15206:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15207:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
ARM GAS  /tmp/ccVWLGiI.s 			page 839


15208:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15209:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15210:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 29454              		.loc 1 15210 0
 29455 0002 264C     		ldr	r4, .L3272
15203:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 29456              		.loc 1 15203 0
 29457 0004 83B0     		sub	sp, sp, #12
 29458              	.LCFI1227:
 29459              		.cfi_def_cfa_offset 24
 29460              		.loc 1 15210 0
 29461 0006 2268     		ldr	r2, [r4]
15205:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 29462              		.loc 1 15205 0
 29463 0008 0023     		movs	r3, #0
 29464 000a 8DF80630 		strb	r3, [sp, #6]
 29465              	.LVL3606:
15207:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 29466              		.loc 1 15207 0
 29467 000e 8DF80730 		strb	r3, [sp, #7]
 29468              	.LVL3607:
 29469              		.loc 1 15210 0
 29470 0012 002A     		cmp	r2, #0
 29471 0014 40D0     		beq	.L3264
 29472 0016 0546     		mov	r5, r0
15211:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15212:Src/bno055.c  **** } else {
15213:Src/bno055.c  **** /* The write operation effective only if the operation
15214:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15215:Src/bno055.c  **** current operation mode and set the config mode */
15216:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 29473              		.loc 1 15216 0
 29474 0018 0DF10700 		add	r0, sp, #7
 29475              	.LVL3608:
 29476 001c FFF7FEFF 		bl	bno055_get_operation_mode
 29477              	.LVL3609:
15217:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 29478              		.loc 1 15217 0
 29479 0020 38B1     		cbz	r0, .L3258
 29480              	.LVL3610:
 29481              	.L3262:
15218:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
15219:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
15220:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
15221:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
15222:Src/bno055.c  **** 			/* Write page as one */
15223:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
15224:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
15225:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15226:Src/bno055.c  **** 				(p_bno055->dev_addr,
15227:Src/bno055.c  **** 				BNO055_ACCEL_SLOW_NO_MOTION_ENABLE_REG,
15228:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15229:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15230:Src/bno055.c  **** 					/* Read the value of
15231:Src/bno055.c  **** 					accel slownomotion enable */
15232:Src/bno055.c  **** 					data_u8r =
15233:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 840


15234:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_ENABLE,
15235:Src/bno055.c  **** 					accel_slow_no_motion_en_u8);
15236:Src/bno055.c  **** 					com_rslt +=
15237:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15238:Src/bno055.c  **** 					(p_bno055->dev_addr,
15239:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_ENABLE_REG,
15240:Src/bno055.c  **** 					&data_u8r,
15241:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15242:Src/bno055.c  **** 				}
15243:Src/bno055.c  **** 			} else {
15244:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
15245:Src/bno055.c  **** 			}
15246:Src/bno055.c  **** 		} else {
15247:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15248:Src/bno055.c  **** 		}
15249:Src/bno055.c  **** 	} else {
15250:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 29482              		.loc 1 15250 0
 29483 0022 FF24     		movs	r4, #255
 29484              	.LVL3611:
 29485              	.L3259:
15251:Src/bno055.c  **** 	}
15252:Src/bno055.c  **** }
15253:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 29486              		.loc 1 15253 0
 29487 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 29488 0028 50BB     		cbnz	r0, .L3271
 29489 002a 2046     		mov	r0, r4
 29490              	.LVL3612:
 29491              	.L3257:
15254:Src/bno055.c  **** 	/* set the operation mode of
15255:Src/bno055.c  **** 	previous operation mode*/
15256:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
15257:Src/bno055.c  **** 	(prev_opmode_u8);
15258:Src/bno055.c  **** return com_rslt;
15259:Src/bno055.c  **** }
 29492              		.loc 1 15259 0
 29493 002c 40B2     		sxtb	r0, r0
 29494 002e 03B0     		add	sp, sp, #12
 29495              	.LCFI1228:
 29496              		.cfi_remember_state
 29497              		.cfi_def_cfa_offset 12
 29498              		@ sp needed
 29499 0030 30BD     		pop	{r4, r5, pc}
 29500              	.LVL3613:
 29501              	.L3258:
 29502              	.LCFI1229:
 29503              		.cfi_restore_state
15218:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 29504              		.loc 1 15218 0
 29505 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29506 0036 53BB     		cbnz	r3, .L3260
 29507              	.L3263:
 29508              	.LVL3614:
15223:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 29509              		.loc 1 15223 0
 29510 0038 0120     		movs	r0, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 841


 29511 003a FFF7FEFF 		bl	bno055_write_page_id
 29512              	.LVL3615:
15224:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 29513              		.loc 1 15224 0
 29514 003e 0028     		cmp	r0, #0
 29515 0040 EFD1     		bne	.L3262
15225:Src/bno055.c  **** 				(p_bno055->dev_addr,
 29516              		.loc 1 15225 0
 29517 0042 2368     		ldr	r3, [r4]
 29518 0044 0DF10602 		add	r2, sp, #6
 29519 0048 1C69     		ldr	r4, [r3, #16]
 29520 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29521              	.LVL3616:
 29522 004c 1621     		movs	r1, #22
 29523 004e 0123     		movs	r3, #1
 29524 0050 A047     		blx	r4
 29525              	.LVL3617:
 29526 0052 124A     		ldr	r2, .L3272
15229:Src/bno055.c  **** 					/* Read the value of
 29527              		.loc 1 15229 0
 29528 0054 0446     		mov	r4, r0
 29529 0056 0028     		cmp	r0, #0
 29530 0058 E4D1     		bne	.L3259
15232:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29531              		.loc 1 15232 0
 29532 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
15237:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29533              		.loc 1 15237 0
 29534 005e 1168     		ldr	r1, [r2]
15232:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29535              		.loc 1 15232 0
 29536 0060 23F00103 		bic	r3, r3, #1
 29537 0064 05F00100 		and	r0, r5, #1
 29538              	.LVL3618:
 29539 0068 1843     		orrs	r0, r0, r3
15237:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29540              		.loc 1 15237 0
 29541 006a CC68     		ldr	r4, [r1, #12]
15232:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29542              		.loc 1 15232 0
 29543 006c 8DF80600 		strb	r0, [sp, #6]
15237:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29544              		.loc 1 15237 0
 29545 0070 0DF10602 		add	r2, sp, #6
 29546 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 29547 0076 0123     		movs	r3, #1
 29548 0078 1621     		movs	r1, #22
 29549 007a A047     		blx	r4
 29550              	.LVL3619:
 29551 007c 0446     		mov	r4, r0
 29552              	.LVL3620:
 29553 007e D1E7     		b	.L3259
 29554              	.L3271:
15256:Src/bno055.c  **** 	(prev_opmode_u8);
 29555              		.loc 1 15256 0
 29556 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 29557              	.LVL3621:
ARM GAS  /tmp/ccVWLGiI.s 			page 842


 29558 0084 2044     		add	r0, r0, r4
 29559 0086 C0B2     		uxtb	r0, r0
 29560              	.LVL3622:
 29561              		.loc 1 15259 0
 29562 0088 40B2     		sxtb	r0, r0
 29563 008a 03B0     		add	sp, sp, #12
 29564              	.LCFI1230:
 29565              		.cfi_remember_state
 29566              		.cfi_def_cfa_offset 12
 29567              		@ sp needed
 29568 008c 30BD     		pop	{r4, r5, pc}
 29569              	.LVL3623:
 29570              	.L3260:
 29571              	.LCFI1231:
 29572              		.cfi_restore_state
15219:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 29573              		.loc 1 15219 0
 29574 008e FFF7FEFF 		bl	bno055_set_operation_mode
 29575              	.LVL3624:
15221:Src/bno055.c  **** 			/* Write page as one */
 29576              		.loc 1 15221 0
 29577 0092 0028     		cmp	r0, #0
 29578 0094 C5D1     		bne	.L3262
 29579 0096 CFE7     		b	.L3263
 29580              	.LVL3625:
 29581              	.L3264:
15211:Src/bno055.c  **** } else {
 29582              		.loc 1 15211 0
 29583 0098 8120     		movs	r0, #129
 29584              	.LVL3626:
 29585 009a C7E7     		b	.L3257
 29586              	.L3273:
 29587              		.align	2
 29588              	.L3272:
 29589 009c 00000000 		.word	.LANCHOR0
 29590              		.cfi_endproc
 29591              	.LFE240:
 29593              		.section	.text.bno055_get_accel_slow_no_motion_durn,"ax",%progbits
 29594              		.align	2
 29595              		.global	bno055_get_accel_slow_no_motion_durn
 29596              		.thumb
 29597              		.thumb_func
 29599              	bno055_get_accel_slow_no_motion_durn:
 29600              	.LFB241:
15260:Src/bno055.c  **** /*!
15261:Src/bno055.c  ****  *	@brief This API used to read accel slownomotion duration
15262:Src/bno055.c  ****  *	from page one register from 0x16 bit 1 to 6
15263:Src/bno055.c  ****  *
15264:Src/bno055.c  ****  *	@param accel_slow_no_motion_durn_u8 :
15265:Src/bno055.c  ****  *	The value of accel slownomotion duration
15266:Src/bno055.c  ****  *
15267:Src/bno055.c  ****  *	@return results of bus communication function
15268:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15269:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15270:Src/bno055.c  ****  *
15271:Src/bno055.c  ****  */
15272:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_accel_slow_no_motion_durn(
ARM GAS  /tmp/ccVWLGiI.s 			page 843


15273:Src/bno055.c  **** u8 *accel_slow_no_motion_durn_u8)
15274:Src/bno055.c  **** {
 29601              		.loc 1 15274 0
 29602              		.cfi_startproc
 29603              		@ args = 0, pretend = 0, frame = 8
 29604              		@ frame_needed = 0, uses_anonymous_args = 0
 29605              	.LVL3627:
 29606 0000 30B5     		push	{r4, r5, lr}
 29607              	.LCFI1232:
 29608              		.cfi_def_cfa_offset 12
 29609              		.cfi_offset 4, -12
 29610              		.cfi_offset 5, -8
 29611              		.cfi_offset 14, -4
15275:Src/bno055.c  **** 	/* Variable used to return value of
15276:Src/bno055.c  **** 	communication routine*/
15277:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15278:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
15279:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
15280:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
15281:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 29612              		.loc 1 15281 0
 29613 0002 144C     		ldr	r4, .L3286
15274:Src/bno055.c  **** 	/* Variable used to return value of
 29614              		.loc 1 15274 0
 29615 0004 83B0     		sub	sp, sp, #12
 29616              	.LCFI1233:
 29617              		.cfi_def_cfa_offset 24
 29618              		.loc 1 15281 0
 29619 0006 2368     		ldr	r3, [r4]
15278:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 29620              		.loc 1 15278 0
 29621 0008 0022     		movs	r2, #0
 29622 000a 8DF80720 		strb	r2, [sp, #7]
 29623              	.LVL3628:
 29624              		.loc 1 15281 0
 29625 000e FBB1     		cbz	r3, .L3278
15282:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
15283:Src/bno055.c  **** 		} else {
15284:Src/bno055.c  **** 		/*condition check for page, accel slownomotion duration is
15285:Src/bno055.c  **** 		available in the page one*/
15286:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 29626              		.loc 1 15286 0
 29627 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 29628 0012 0546     		mov	r5, r0
 29629 0014 012A     		cmp	r2, #1
 29630 0016 04D0     		beq	.L3276
15287:Src/bno055.c  **** 			/* Write page as one */
15288:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 29631              		.loc 1 15288 0
 29632 0018 0120     		movs	r0, #1
 29633              	.LVL3629:
 29634 001a FFF7FEFF 		bl	bno055_write_page_id
 29635              	.LVL3630:
 29636 001e 2368     		ldr	r3, [r4]
15289:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 29637              		.loc 1 15289 0
 29638 0020 70B9     		cbnz	r0, .L3285
ARM GAS  /tmp/ccVWLGiI.s 			page 844


 29639              	.LVL3631:
 29640              	.L3276:
15290:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
15291:Src/bno055.c  **** 			/*read value of accel slownomotion duration*/
15292:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 29641              		.loc 1 15292 0
 29642 0022 1C69     		ldr	r4, [r3, #16]
 29643 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29644 0026 1621     		movs	r1, #22
 29645 0028 0123     		movs	r3, #1
 29646 002a 0DF10702 		add	r2, sp, #7
 29647 002e A047     		blx	r4
 29648              	.LVL3632:
15293:Src/bno055.c  **** 			(p_bno055->dev_addr,
15294:Src/bno055.c  **** 			BNO055_ACCEL_SLOW_NO_MOTION_DURN_REG,
15295:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15296:Src/bno055.c  **** 			*accel_slow_no_motion_durn_u8 =
15297:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 29649              		.loc 1 15297 0
 29650 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29651 0034 C3F34503 		ubfx	r3, r3, #1, #6
15296:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 29652              		.loc 1 15296 0
 29653 0038 2B70     		strb	r3, [r5]
 29654              	.LVL3633:
 29655              	.L3275:
15298:Src/bno055.c  **** 			BNO055_ACCEL_SLOW_NO_MOTION_DURN);
15299:Src/bno055.c  **** 		} else {
15300:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15301:Src/bno055.c  **** 		}
15302:Src/bno055.c  **** 	}
15303:Src/bno055.c  **** 	return com_rslt;
15304:Src/bno055.c  **** }
 29656              		.loc 1 15304 0
 29657 003a 40B2     		sxtb	r0, r0
 29658 003c 03B0     		add	sp, sp, #12
 29659              	.LCFI1234:
 29660              		.cfi_remember_state
 29661              		.cfi_def_cfa_offset 12
 29662              		@ sp needed
 29663 003e 30BD     		pop	{r4, r5, pc}
 29664              	.LVL3634:
 29665              	.L3285:
 29666              	.LCFI1235:
 29667              		.cfi_restore_state
15289:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 29668              		.loc 1 15289 0 discriminator 1
 29669 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 29670 0042 012A     		cmp	r2, #1
15300:Src/bno055.c  **** 		}
 29671              		.loc 1 15300 0 discriminator 1
 29672 0044 18BF     		it	ne
 29673 0046 FF20     		movne	r0, #255
15289:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 29674              		.loc 1 15289 0 discriminator 1
 29675 0048 EBD0     		beq	.L3276
 29676              		.loc 1 15304 0
ARM GAS  /tmp/ccVWLGiI.s 			page 845


 29677 004a 40B2     		sxtb	r0, r0
 29678 004c 03B0     		add	sp, sp, #12
 29679              	.LCFI1236:
 29680              		.cfi_remember_state
 29681              		.cfi_def_cfa_offset 12
 29682              		@ sp needed
 29683 004e 30BD     		pop	{r4, r5, pc}
 29684              	.LVL3635:
 29685              	.L3278:
 29686              	.LCFI1237:
 29687              		.cfi_restore_state
15282:Src/bno055.c  **** 		} else {
 29688              		.loc 1 15282 0
 29689 0050 8120     		movs	r0, #129
 29690              	.LVL3636:
 29691 0052 F2E7     		b	.L3275
 29692              	.L3287:
 29693              		.align	2
 29694              	.L3286:
 29695 0054 00000000 		.word	.LANCHOR0
 29696              		.cfi_endproc
 29697              	.LFE241:
 29699              		.section	.text.bno055_set_accel_slow_no_motion_durn,"ax",%progbits
 29700              		.align	2
 29701              		.global	bno055_set_accel_slow_no_motion_durn
 29702              		.thumb
 29703              		.thumb_func
 29705              	bno055_set_accel_slow_no_motion_durn:
 29706              	.LFB242:
15305:Src/bno055.c  **** /*!
15306:Src/bno055.c  ****  *	@brief This API used to write accel slownomotion duration
15307:Src/bno055.c  ****  *	from page one register from 0x16 bit 1 to 6
15308:Src/bno055.c  ****  *
15309:Src/bno055.c  ****  *	@param accel_slow_no_motion_durn_u8 :
15310:Src/bno055.c  ****  *	The value of accel slownomotion duration
15311:Src/bno055.c  ****  *
15312:Src/bno055.c  ****  *	@return results of bus communication function
15313:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15314:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15315:Src/bno055.c  ****  *
15316:Src/bno055.c  ****  */
15317:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_accel_slow_no_motion_durn(
15318:Src/bno055.c  **** u8 accel_slow_no_motion_durn_u8)
15319:Src/bno055.c  **** {
 29707              		.loc 1 15319 0
 29708              		.cfi_startproc
 29709              		@ args = 0, pretend = 0, frame = 8
 29710              		@ frame_needed = 0, uses_anonymous_args = 0
 29711              	.LVL3637:
 29712 0000 30B5     		push	{r4, r5, lr}
 29713              	.LCFI1238:
 29714              		.cfi_def_cfa_offset 12
 29715              		.cfi_offset 4, -12
 29716              		.cfi_offset 5, -8
 29717              		.cfi_offset 14, -4
15320:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15321:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
ARM GAS  /tmp/ccVWLGiI.s 			page 846


15322:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15323:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
15324:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15325:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15326:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 29718              		.loc 1 15326 0
 29719 0002 274C     		ldr	r4, .L3304
15319:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 29720              		.loc 1 15319 0
 29721 0004 83B0     		sub	sp, sp, #12
 29722              	.LCFI1239:
 29723              		.cfi_def_cfa_offset 24
 29724              		.loc 1 15326 0
 29725 0006 2268     		ldr	r2, [r4]
15321:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 29726              		.loc 1 15321 0
 29727 0008 0023     		movs	r3, #0
 29728 000a 8DF80630 		strb	r3, [sp, #6]
 29729              	.LVL3638:
15323:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 29730              		.loc 1 15323 0
 29731 000e 8DF80730 		strb	r3, [sp, #7]
 29732              	.LVL3639:
 29733              		.loc 1 15326 0
 29734 0012 002A     		cmp	r2, #0
 29735 0014 41D0     		beq	.L3296
 29736 0016 0546     		mov	r5, r0
15327:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15328:Src/bno055.c  **** } else {
15329:Src/bno055.c  **** /* The write operation effective only if the operation
15330:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15331:Src/bno055.c  **** current operation mode and set the config mode */
15332:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 29737              		.loc 1 15332 0
 29738 0018 0DF10700 		add	r0, sp, #7
 29739              	.LVL3640:
 29740 001c FFF7FEFF 		bl	bno055_get_operation_mode
 29741              	.LVL3641:
15333:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 29742              		.loc 1 15333 0
 29743 0020 38B1     		cbz	r0, .L3290
 29744              	.LVL3642:
 29745              	.L3294:
15334:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
15335:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
15336:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
15337:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
15338:Src/bno055.c  **** 			/* Write page as one */
15339:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
15340:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
15341:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15342:Src/bno055.c  **** 				(p_bno055->dev_addr,
15343:Src/bno055.c  **** 				BNO055_ACCEL_SLOW_NO_MOTION_DURN_REG,
15344:Src/bno055.c  **** 				&data_u8r,
15345:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
15346:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15347:Src/bno055.c  **** 					/*Write the value of accel
ARM GAS  /tmp/ccVWLGiI.s 			page 847


15348:Src/bno055.c  **** 					slownomotion duration*/
15349:Src/bno055.c  **** 					data_u8r =
15350:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
15351:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_DURN,
15352:Src/bno055.c  **** 					accel_slow_no_motion_durn_u8);
15353:Src/bno055.c  **** 					com_rslt +=
15354:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15355:Src/bno055.c  **** 					(p_bno055->dev_addr,
15356:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_DURN_REG,
15357:Src/bno055.c  **** 					&data_u8r,
15358:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15359:Src/bno055.c  **** 				}
15360:Src/bno055.c  **** 			} else {
15361:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
15362:Src/bno055.c  **** 			}
15363:Src/bno055.c  **** 		} else {
15364:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15365:Src/bno055.c  **** 		}
15366:Src/bno055.c  **** 	} else {
15367:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 29746              		.loc 1 15367 0
 29747 0022 FF24     		movs	r4, #255
 29748              	.LVL3643:
 29749              	.L3291:
15368:Src/bno055.c  **** 	}
15369:Src/bno055.c  **** }
15370:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 29750              		.loc 1 15370 0
 29751 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 29752 0028 58BB     		cbnz	r0, .L3303
 29753 002a 2046     		mov	r0, r4
 29754              	.LVL3644:
 29755              	.L3289:
15371:Src/bno055.c  **** 	/* set the operation mode of
15372:Src/bno055.c  **** 	previous operation mode*/
15373:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
15374:Src/bno055.c  **** 	(prev_opmode_u8);
15375:Src/bno055.c  **** return com_rslt;
15376:Src/bno055.c  **** }
 29756              		.loc 1 15376 0
 29757 002c 40B2     		sxtb	r0, r0
 29758 002e 03B0     		add	sp, sp, #12
 29759              	.LCFI1240:
 29760              		.cfi_remember_state
 29761              		.cfi_def_cfa_offset 12
 29762              		@ sp needed
 29763 0030 30BD     		pop	{r4, r5, pc}
 29764              	.LVL3645:
 29765              	.L3290:
 29766              	.LCFI1241:
 29767              		.cfi_restore_state
15334:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 29768              		.loc 1 15334 0
 29769 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29770 0036 5BBB     		cbnz	r3, .L3292
 29771              	.L3295:
 29772              	.LVL3646:
ARM GAS  /tmp/ccVWLGiI.s 			page 848


15339:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 29773              		.loc 1 15339 0
 29774 0038 0120     		movs	r0, #1
 29775 003a FFF7FEFF 		bl	bno055_write_page_id
 29776              	.LVL3647:
15340:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 29777              		.loc 1 15340 0
 29778 003e 0028     		cmp	r0, #0
 29779 0040 EFD1     		bne	.L3294
15341:Src/bno055.c  **** 				(p_bno055->dev_addr,
 29780              		.loc 1 15341 0
 29781 0042 2368     		ldr	r3, [r4]
 29782 0044 1621     		movs	r1, #22
 29783 0046 1C69     		ldr	r4, [r3, #16]
 29784 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29785              	.LVL3648:
 29786 004a 0DF10602 		add	r2, sp, #6
 29787 004e 0123     		movs	r3, #1
 29788 0050 A047     		blx	r4
 29789              	.LVL3649:
 29790 0052 1349     		ldr	r1, .L3304
15346:Src/bno055.c  **** 					/*Write the value of accel
 29791              		.loc 1 15346 0
 29792 0054 0446     		mov	r4, r0
 29793 0056 0028     		cmp	r0, #0
 29794 0058 E4D1     		bne	.L3291
15349:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29795              		.loc 1 15349 0
 29796 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
15350:Src/bno055.c  **** 					BNO055_ACCEL_SLOW_NO_MOTION_DURN,
 29797              		.loc 1 15350 0
 29798 005e 6B00     		lsls	r3, r5, #1
15354:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29799              		.loc 1 15354 0
 29800 0060 0968     		ldr	r1, [r1]
15349:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29801              		.loc 1 15349 0
 29802 0062 22F07E02 		bic	r2, r2, #126
 29803 0066 03F07E03 		and	r3, r3, #126
 29804 006a 1343     		orrs	r3, r3, r2
15354:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29805              		.loc 1 15354 0
 29806 006c CC68     		ldr	r4, [r1, #12]
15349:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 29807              		.loc 1 15349 0
 29808 006e 8DF80630 		strb	r3, [sp, #6]
15354:Src/bno055.c  **** 					(p_bno055->dev_addr,
 29809              		.loc 1 15354 0
 29810 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 29811              	.LVL3650:
 29812 0074 0DF10602 		add	r2, sp, #6
 29813 0078 1621     		movs	r1, #22
 29814 007a 0123     		movs	r3, #1
 29815 007c A047     		blx	r4
 29816              	.LVL3651:
 29817 007e 0446     		mov	r4, r0
 29818              	.LVL3652:
ARM GAS  /tmp/ccVWLGiI.s 			page 849


 29819 0080 D0E7     		b	.L3291
 29820              	.L3303:
15373:Src/bno055.c  **** 	(prev_opmode_u8);
 29821              		.loc 1 15373 0
 29822 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 29823              	.LVL3653:
 29824 0086 2044     		add	r0, r0, r4
 29825 0088 C0B2     		uxtb	r0, r0
 29826              	.LVL3654:
 29827              		.loc 1 15376 0
 29828 008a 40B2     		sxtb	r0, r0
 29829 008c 03B0     		add	sp, sp, #12
 29830              	.LCFI1242:
 29831              		.cfi_remember_state
 29832              		.cfi_def_cfa_offset 12
 29833              		@ sp needed
 29834 008e 30BD     		pop	{r4, r5, pc}
 29835              	.LVL3655:
 29836              	.L3292:
 29837              	.LCFI1243:
 29838              		.cfi_restore_state
15335:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 29839              		.loc 1 15335 0
 29840 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 29841              	.LVL3656:
15337:Src/bno055.c  **** 			/* Write page as one */
 29842              		.loc 1 15337 0
 29843 0094 0028     		cmp	r0, #0
 29844 0096 C4D1     		bne	.L3294
 29845 0098 CEE7     		b	.L3295
 29846              	.LVL3657:
 29847              	.L3296:
15327:Src/bno055.c  **** } else {
 29848              		.loc 1 15327 0
 29849 009a 8120     		movs	r0, #129
 29850              	.LVL3658:
 29851 009c C6E7     		b	.L3289
 29852              	.L3305:
 29853 009e 00BF     		.align	2
 29854              	.L3304:
 29855 00a0 00000000 		.word	.LANCHOR0
 29856              		.cfi_endproc
 29857              	.LFE242:
 29859              		.section	.text.bno055_get_gyro_any_motion_axis_enable,"ax",%progbits
 29860              		.align	2
 29861              		.global	bno055_get_gyro_any_motion_axis_enable
 29862              		.thumb
 29863              		.thumb_func
 29865              	bno055_get_gyro_any_motion_axis_enable:
 29866              	.LFB243:
15377:Src/bno055.c  **** /*!
15378:Src/bno055.c  ****  *	@brief This API used to read the gyro anymotion enable
15379:Src/bno055.c  ****  *	from page one register from 0x17 bit 0 to 2
15380:Src/bno055.c  ****  *
15381:Src/bno055.c  ****  *	@param data_u8 : The value of gyro anymotion enable
15382:Src/bno055.c  ****  *      data_u8     | result
15383:Src/bno055.c  ****  *  ----------------- |-------------
ARM GAS  /tmp/ccVWLGiI.s 			page 850


15384:Src/bno055.c  ****  *      0x01          | BNO055_BIT_ENABLE
15385:Src/bno055.c  ****  *      0x00          | BNO055_BIT_DISABLE
15386:Src/bno055.c  ****  *	@param channel_u8 : The value of gyro anymotion axis selection
15387:Src/bno055.c  ****  *               channel_u8         | value
15388:Src/bno055.c  ****  *     ---------------------------    | ----------
15389:Src/bno055.c  ****  *     BNO055_GYRO_ANY_MOTIONX_AXIS   |   0
15390:Src/bno055.c  ****  *     BNO055_GYRO_ANY_MOTIONY_AXIS   |   1
15391:Src/bno055.c  ****  *     BNO055_GYRO_ANY_MOTIONZ_AXIS   |   2
15392:Src/bno055.c  ****  *
15393:Src/bno055.c  ****  *
15394:Src/bno055.c  ****  *	@return results of bus communication function
15395:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15396:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15397:Src/bno055.c  ****  *
15398:Src/bno055.c  ****  *
15399:Src/bno055.c  ****  */
15400:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_any_motion_axis_enable(
15401:Src/bno055.c  **** u8 channel_u8, u8 *data_u8)
15402:Src/bno055.c  **** {
 29867              		.loc 1 15402 0
 29868              		.cfi_startproc
 29869              		@ args = 0, pretend = 0, frame = 8
 29870              		@ frame_needed = 0, uses_anonymous_args = 0
 29871              	.LVL3659:
 29872 0000 70B5     		push	{r4, r5, r6, lr}
 29873              	.LCFI1244:
 29874              		.cfi_def_cfa_offset 16
 29875              		.cfi_offset 4, -16
 29876              		.cfi_offset 5, -12
 29877              		.cfi_offset 6, -8
 29878              		.cfi_offset 14, -4
15403:Src/bno055.c  **** /* Variable used to return value of
15404:Src/bno055.c  **** communication routine*/
15405:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15406:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15407:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15408:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15409:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 29879              		.loc 1 15409 0
 29880 0002 294D     		ldr	r5, .L3326
15402:Src/bno055.c  **** /* Variable used to return value of
 29881              		.loc 1 15402 0
 29882 0004 82B0     		sub	sp, sp, #8
 29883              	.LCFI1245:
 29884              		.cfi_def_cfa_offset 24
 29885              		.loc 1 15409 0
 29886 0006 2B68     		ldr	r3, [r5]
15406:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 29887              		.loc 1 15406 0
 29888 0008 0022     		movs	r2, #0
 29889 000a 8DF80720 		strb	r2, [sp, #7]
 29890              	.LVL3660:
 29891              		.loc 1 15409 0
 29892 000e 002B     		cmp	r3, #0
 29893 0010 48D0     		beq	.L3313
15410:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15411:Src/bno055.c  **** 	} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 851


15412:Src/bno055.c  **** 	/*condition check for page, gyro anymotion axis is
15413:Src/bno055.c  **** 	available in the page one*/
15414:Src/bno055.c  **** 	if (p_bno055->page_id != BNO055_PAGE_ONE)
 29894              		.loc 1 15414 0
 29895 0012 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 29896 0014 0E46     		mov	r6, r1
 29897 0016 012B     		cmp	r3, #1
 29898 0018 0446     		mov	r4, r0
 29899 001a 04D0     		beq	.L3312
15415:Src/bno055.c  **** 		/* Write page as one */
15416:Src/bno055.c  **** 		stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 29900              		.loc 1 15416 0
 29901 001c 0120     		movs	r0, #1
 29902              	.LVL3661:
 29903 001e FFF7FEFF 		bl	bno055_write_page_id
 29904              	.LVL3662:
15417:Src/bno055.c  **** 	if ((stat_s8 == BNO055_SUCCESS) ||
 29905              		.loc 1 15417 0
 29906 0022 0028     		cmp	r0, #0
 29907 0024 38D1     		bne	.L3324
 29908              	.LVL3663:
 29909              	.L3312:
15418:Src/bno055.c  **** 	(p_bno055->page_id == BNO055_PAGE_ONE)) {
15419:Src/bno055.c  **** 		switch (channel_u8) {
 29910              		.loc 1 15419 0
 29911 0026 012C     		cmp	r4, #1
 29912 0028 26D0     		beq	.L3309
 29913 002a 15D3     		bcc	.L3310
 29914 002c 022C     		cmp	r4, #2
 29915 002e 0FD1     		bne	.L3325
15420:Src/bno055.c  **** 		case BNO055_GYRO_ANY_MOTION_X_AXIS:
15421:Src/bno055.c  **** 			/* Read the gyro anymotion x enable*/
15422:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15423:Src/bno055.c  **** 			(p_bno055->dev_addr,
15424:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_X_AXIS_REG,
15425:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15426:Src/bno055.c  **** 			*data_u8 =
15427:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
15428:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_X_AXIS);
15429:Src/bno055.c  **** 			break;
15430:Src/bno055.c  **** 		case BNO055_GYRO_ANY_MOTION_Y_AXIS:
15431:Src/bno055.c  **** 			/* Read the gyro anymotion y enable*/
15432:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15433:Src/bno055.c  **** 			(p_bno055->dev_addr,
15434:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_Y_AXIS_REG,
15435:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15436:Src/bno055.c  **** 			*data_u8 =
15437:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
15438:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_Y_AXIS);
15439:Src/bno055.c  **** 			break;
15440:Src/bno055.c  **** 		case BNO055_GYRO_ANY_MOTION_Z_AXIS:
15441:Src/bno055.c  **** 			/* Read the gyro anymotion z enable*/
15442:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 29916              		.loc 1 15442 0
 29917 0030 2B68     		ldr	r3, [r5]
 29918 0032 1721     		movs	r1, #23
 29919 0034 1C69     		ldr	r4, [r3, #16]
ARM GAS  /tmp/ccVWLGiI.s 			page 852


 29920 0036 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29921 0038 0DF10702 		add	r2, sp, #7
 29922 003c 0123     		movs	r3, #1
 29923 003e A047     		blx	r4
 29924              	.LVL3664:
15443:Src/bno055.c  **** 			(p_bno055->dev_addr,
15444:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_Z_AXIS_REG,
15445:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15446:Src/bno055.c  **** 			*data_u8 =
15447:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 29925              		.loc 1 15447 0
 29926 0040 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29927 0044 C3F38003 		ubfx	r3, r3, #2, #1
15446:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 29928              		.loc 1 15446 0
 29929 0048 3370     		strb	r3, [r6]
 29930              	.LVL3665:
 29931              	.L3307:
15448:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_Z_AXIS);
15449:Src/bno055.c  **** 			break;
15450:Src/bno055.c  **** 		default:
15451:Src/bno055.c  **** 			com_rslt = BNO055_OUT_OF_RANGE;
15452:Src/bno055.c  **** 			break;
15453:Src/bno055.c  **** 		}
15454:Src/bno055.c  **** 	} else {
15455:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
15456:Src/bno055.c  **** 	}
15457:Src/bno055.c  **** }
15458:Src/bno055.c  **** return com_rslt;
15459:Src/bno055.c  **** }
 29932              		.loc 1 15459 0
 29933 004a 40B2     		sxtb	r0, r0
 29934 004c 02B0     		add	sp, sp, #8
 29935              	.LCFI1246:
 29936              		.cfi_remember_state
 29937              		.cfi_def_cfa_offset 16
 29938              		@ sp needed
 29939 004e 70BD     		pop	{r4, r5, r6, pc}
 29940              	.LVL3666:
 29941              	.L3325:
 29942              	.LCFI1247:
 29943              		.cfi_restore_state
15451:Src/bno055.c  **** 			break;
 29944              		.loc 1 15451 0
 29945 0050 FE20     		movs	r0, #254
 29946              		.loc 1 15459 0
 29947 0052 40B2     		sxtb	r0, r0
 29948 0054 02B0     		add	sp, sp, #8
 29949              	.LCFI1248:
 29950              		.cfi_remember_state
 29951              		.cfi_def_cfa_offset 16
 29952              		@ sp needed
 29953 0056 70BD     		pop	{r4, r5, r6, pc}
 29954              	.LVL3667:
 29955              	.L3310:
 29956              	.LCFI1249:
 29957              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 853


15422:Src/bno055.c  **** 			(p_bno055->dev_addr,
 29958              		.loc 1 15422 0
 29959 0058 2B68     		ldr	r3, [r5]
 29960 005a 1721     		movs	r1, #23
 29961 005c 1C69     		ldr	r4, [r3, #16]
 29962 005e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 29963 0060 0DF10702 		add	r2, sp, #7
 29964 0064 0123     		movs	r3, #1
 29965 0066 A047     		blx	r4
 29966              	.LVL3668:
15426:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 29967              		.loc 1 15426 0
 29968 0068 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29969              		.loc 1 15459 0
 29970 006c 40B2     		sxtb	r0, r0
15426:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 29971              		.loc 1 15426 0
 29972 006e 03F00103 		and	r3, r3, #1
 29973 0072 3370     		strb	r3, [r6]
 29974              		.loc 1 15459 0
 29975 0074 02B0     		add	sp, sp, #8
 29976              	.LCFI1250:
 29977              		.cfi_remember_state
 29978              		.cfi_def_cfa_offset 16
 29979              		@ sp needed
 29980 0076 70BD     		pop	{r4, r5, r6, pc}
 29981              	.LVL3669:
 29982              	.L3309:
 29983              	.LCFI1251:
 29984              		.cfi_restore_state
15432:Src/bno055.c  **** 			(p_bno055->dev_addr,
 29985              		.loc 1 15432 0
 29986 0078 2A68     		ldr	r2, [r5]
 29987 007a 2346     		mov	r3, r4
 29988 007c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 29989 007e 1469     		ldr	r4, [r2, #16]
 29990 0080 1721     		movs	r1, #23
 29991 0082 0DF10702 		add	r2, sp, #7
 29992 0086 A047     		blx	r4
 29993              	.LVL3670:
15437:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_Y_AXIS);
 29994              		.loc 1 15437 0
 29995 0088 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 29996              		.loc 1 15459 0
 29997 008c 40B2     		sxtb	r0, r0
15437:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_Y_AXIS);
 29998              		.loc 1 15437 0
 29999 008e C3F34003 		ubfx	r3, r3, #1, #1
15436:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 30000              		.loc 1 15436 0
 30001 0092 3370     		strb	r3, [r6]
 30002              		.loc 1 15459 0
 30003 0094 02B0     		add	sp, sp, #8
 30004              	.LCFI1252:
 30005              		.cfi_remember_state
 30006              		.cfi_def_cfa_offset 16
 30007              		@ sp needed
ARM GAS  /tmp/ccVWLGiI.s 			page 854


 30008 0096 70BD     		pop	{r4, r5, r6, pc}
 30009              	.LVL3671:
 30010              	.L3324:
 30011              	.LCFI1253:
 30012              		.cfi_restore_state
15418:Src/bno055.c  **** 		switch (channel_u8) {
 30013              		.loc 1 15418 0 discriminator 1
 30014 0098 2B68     		ldr	r3, [r5]
15417:Src/bno055.c  **** 	(p_bno055->page_id == BNO055_PAGE_ONE)) {
 30015              		.loc 1 15417 0 discriminator 1
 30016 009a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 30017 009c 012B     		cmp	r3, #1
 30018 009e C2D0     		beq	.L3312
15455:Src/bno055.c  **** 	}
 30019              		.loc 1 15455 0
 30020 00a0 FF20     		movs	r0, #255
 30021 00a2 D2E7     		b	.L3307
 30022              	.LVL3672:
 30023              	.L3313:
15410:Src/bno055.c  **** 	} else {
 30024              		.loc 1 15410 0
 30025 00a4 8120     		movs	r0, #129
 30026              	.LVL3673:
 30027 00a6 D0E7     		b	.L3307
 30028              	.L3327:
 30029              		.align	2
 30030              	.L3326:
 30031 00a8 00000000 		.word	.LANCHOR0
 30032              		.cfi_endproc
 30033              	.LFE243:
 30035              		.section	.text.bno055_set_gyro_any_motion_axis_enable,"ax",%progbits
 30036              		.align	2
 30037              		.global	bno055_set_gyro_any_motion_axis_enable
 30038              		.thumb
 30039              		.thumb_func
 30041              	bno055_set_gyro_any_motion_axis_enable:
 30042              	.LFB244:
15460:Src/bno055.c  **** /*!
15461:Src/bno055.c  ****  *	@brief This API used to write the gyro anymotion enable
15462:Src/bno055.c  ****  *	from page one register from 0x17 bit 0 to 2
15463:Src/bno055.c  ****  *
15464:Src/bno055.c  ****  *	@param data_u8 : The value of gyro anymotion enable
15465:Src/bno055.c  ****  *      data_u8     | result
15466:Src/bno055.c  ****  *  ----------------- |-------------
15467:Src/bno055.c  ****  *      0x01          | BNO055_BIT_ENABLE
15468:Src/bno055.c  ****  *      0x00          | BNO055_BIT_DISABLE
15469:Src/bno055.c  ****  *	@param channel_u8 : The value of gyro anymotion axis selection
15470:Src/bno055.c  ****  *               channel_u8         | value
15471:Src/bno055.c  ****  *     ---------------------------    | ----------
15472:Src/bno055.c  ****  *     BNO055_GYRO_ANY_MOTIONX_AXIS   |   0
15473:Src/bno055.c  ****  *     BNO055_GYRO_ANY_MOTIONY_AXIS   |   1
15474:Src/bno055.c  ****  *     BNO055_GYRO_ANY_MOTIONZ_AXIS   |   2
15475:Src/bno055.c  ****  *
15476:Src/bno055.c  ****  *	@return results of bus communication function
15477:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15478:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15479:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 855


15480:Src/bno055.c  ****  *
15481:Src/bno055.c  ****  */
15482:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_any_motion_axis_enable(
15483:Src/bno055.c  **** u8 channel_u8, u8  data_u8)
15484:Src/bno055.c  **** {
 30043              		.loc 1 15484 0
 30044              		.cfi_startproc
 30045              		@ args = 0, pretend = 0, frame = 8
 30046              		@ frame_needed = 0, uses_anonymous_args = 0
 30047              	.LVL3674:
 30048 0000 70B5     		push	{r4, r5, r6, lr}
 30049              	.LCFI1254:
 30050              		.cfi_def_cfa_offset 16
 30051              		.cfi_offset 4, -16
 30052              		.cfi_offset 5, -12
 30053              		.cfi_offset 6, -8
 30054              		.cfi_offset 14, -4
15485:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15486:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15487:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15488:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
15489:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15490:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15491:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 30055              		.loc 1 15491 0
 30056 0002 4C4C     		ldr	r4, .L3350
15484:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 30057              		.loc 1 15484 0
 30058 0004 82B0     		sub	sp, sp, #8
 30059              	.LCFI1255:
 30060              		.cfi_def_cfa_offset 24
 30061              		.loc 1 15491 0
 30062 0006 2568     		ldr	r5, [r4]
15486:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 30063              		.loc 1 15486 0
 30064 0008 0022     		movs	r2, #0
 30065 000a 8DF80620 		strb	r2, [sp, #6]
 30066              	.LVL3675:
15488:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 30067              		.loc 1 15488 0
 30068 000e 8DF80720 		strb	r2, [sp, #7]
 30069              	.LVL3676:
 30070              		.loc 1 15491 0
 30071 0012 002D     		cmp	r5, #0
 30072 0014 00F08B80 		beq	.L3339
 30073 0018 0546     		mov	r5, r0
15492:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15493:Src/bno055.c  **** } else {
15494:Src/bno055.c  **** /* The write operation effective only if the operation
15495:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15496:Src/bno055.c  **** current operation mode and set the config mode */
15497:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 30074              		.loc 1 15497 0
 30075 001a 0DF10700 		add	r0, sp, #7
 30076              	.LVL3677:
 30077 001e 0E46     		mov	r6, r1
 30078 0020 FFF7FEFF 		bl	bno055_get_operation_mode
ARM GAS  /tmp/ccVWLGiI.s 			page 856


 30079              	.LVL3678:
15498:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 30080              		.loc 1 15498 0
 30081 0024 40B1     		cbz	r0, .L3330
 30082              	.LVL3679:
 30083              	.L3334:
15499:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
15500:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
15501:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
15502:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
15503:Src/bno055.c  **** 		/* Write page as one */
15504:Src/bno055.c  **** 		pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
15505:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
15506:Src/bno055.c  **** 			switch (channel_u8) {
15507:Src/bno055.c  **** 			case BNO055_GYRO_ANY_MOTION_X_AXIS:
15508:Src/bno055.c  **** 				/* Write the gyro
15509:Src/bno055.c  **** 				anymotion x enable*/
15510:Src/bno055.c  **** 				com_rslt =
15511:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
15512:Src/bno055.c  **** 				(p_bno055->dev_addr,
15513:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_X_AXIS_REG,
15514:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15515:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
15516:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
15517:Src/bno055.c  **** 				(data_u8r,
15518:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_X_AXIS,
15519:Src/bno055.c  **** 				data_u8);
15520:Src/bno055.c  **** 				com_rslt +=
15521:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
15522:Src/bno055.c  **** 				(p_bno055->dev_addr,
15523:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_X_AXIS_REG,
15524:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15525:Src/bno055.c  **** 			}
15526:Src/bno055.c  **** 			break;
15527:Src/bno055.c  **** 			case BNO055_GYRO_ANY_MOTION_Y_AXIS:
15528:Src/bno055.c  **** 				/* Write the gyro
15529:Src/bno055.c  **** 				anymotion y enable*/
15530:Src/bno055.c  **** 				com_rslt =
15531:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
15532:Src/bno055.c  **** 				(p_bno055->dev_addr,
15533:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_Y_AXIS_REG,
15534:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15535:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
15536:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
15537:Src/bno055.c  **** 				(data_u8r,
15538:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_Y_AXIS, data_u8);
15539:Src/bno055.c  **** 				com_rslt +=
15540:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
15541:Src/bno055.c  **** 				(p_bno055->dev_addr,
15542:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_Y_AXIS_REG,
15543:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15544:Src/bno055.c  **** 			}
15545:Src/bno055.c  **** 			break;
15546:Src/bno055.c  **** 			case BNO055_GYRO_ANY_MOTION_Z_AXIS:
15547:Src/bno055.c  **** 				/* Write the gyro
15548:Src/bno055.c  **** 				anymotion z enable*/
15549:Src/bno055.c  **** 				com_rslt =
ARM GAS  /tmp/ccVWLGiI.s 			page 857


15550:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
15551:Src/bno055.c  **** 				(p_bno055->dev_addr,
15552:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_Z_AXIS_REG,
15553:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15554:Src/bno055.c  **** 			if (com_rslt == BNO055_SUCCESS) {
15555:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
15556:Src/bno055.c  **** 				(data_u8r,
15557:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_Z_AXIS,
15558:Src/bno055.c  **** 				data_u8);
15559:Src/bno055.c  **** 				com_rslt +=
15560:Src/bno055.c  **** 				p_bno055->BNO055_BUS_WRITE_FUNC
15561:Src/bno055.c  **** 				(p_bno055->dev_addr,
15562:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_Z_AXIS_REG,
15563:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15564:Src/bno055.c  **** 			}
15565:Src/bno055.c  **** 			break;
15566:Src/bno055.c  **** 			default:
15567:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
15568:Src/bno055.c  **** 				break;
15569:Src/bno055.c  **** 			}
15570:Src/bno055.c  **** 		} else {
15571:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15572:Src/bno055.c  **** 		}
15573:Src/bno055.c  **** 	} else {
15574:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
15575:Src/bno055.c  **** 	}
15576:Src/bno055.c  **** } else {
15577:Src/bno055.c  **** com_rslt = BNO055_ERROR;
 30084              		.loc 1 15577 0
 30085 0026 FF24     		movs	r4, #255
 30086              	.LVL3680:
 30087              	.L3331:
15578:Src/bno055.c  **** }
15579:Src/bno055.c  **** }
15580:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 30088              		.loc 1 15580 0
 30089 0028 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 30090 002c 0028     		cmp	r0, #0
 30091 002e 31D1     		bne	.L3348
 30092 0030 2046     		mov	r0, r4
 30093              	.LVL3681:
 30094              	.L3329:
15581:Src/bno055.c  **** 	/* set the operation mode of
15582:Src/bno055.c  **** 	previous operation mode*/
15583:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
15584:Src/bno055.c  **** 	(prev_opmode_u8);
15585:Src/bno055.c  **** return com_rslt;
15586:Src/bno055.c  **** }
 30095              		.loc 1 15586 0
 30096 0032 40B2     		sxtb	r0, r0
 30097 0034 02B0     		add	sp, sp, #8
 30098              	.LCFI1256:
 30099              		.cfi_remember_state
 30100              		.cfi_def_cfa_offset 16
 30101              		@ sp needed
 30102 0036 70BD     		pop	{r4, r5, r6, pc}
 30103              	.LVL3682:
ARM GAS  /tmp/ccVWLGiI.s 			page 858


 30104              	.L3330:
 30105              	.LCFI1257:
 30106              		.cfi_restore_state
15499:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 30107              		.loc 1 15499 0
 30108 0038 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30109 003c 002B     		cmp	r3, #0
 30110 003e 30D1     		bne	.L3332
 30111              	.L3335:
 30112              	.LVL3683:
15504:Src/bno055.c  **** 		if (pg_stat_s8 == BNO055_SUCCESS) {
 30113              		.loc 1 15504 0
 30114 0040 0120     		movs	r0, #1
 30115 0042 FFF7FEFF 		bl	bno055_write_page_id
 30116              	.LVL3684:
15505:Src/bno055.c  **** 			switch (channel_u8) {
 30117              		.loc 1 15505 0
 30118 0046 0028     		cmp	r0, #0
 30119 0048 EDD1     		bne	.L3334
15506:Src/bno055.c  **** 			case BNO055_GYRO_ANY_MOTION_X_AXIS:
 30120              		.loc 1 15506 0
 30121 004a 012D     		cmp	r5, #1
 30122 004c 4FD0     		beq	.L3336
 30123 004e 2DD3     		bcc	.L3337
 30124 0050 022D     		cmp	r5, #2
 30125 0052 4AD1     		bne	.L3349
15550:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30126              		.loc 1 15550 0
 30127 0054 2368     		ldr	r3, [r4]
15549:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 30128              		.loc 1 15549 0
 30129 0056 1721     		movs	r1, #23
 30130 0058 1C69     		ldr	r4, [r3, #16]
 30131 005a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30132              	.LVL3685:
 30133 005c 0DF10602 		add	r2, sp, #6
 30134 0060 0123     		movs	r3, #1
 30135 0062 A047     		blx	r4
 30136              	.LVL3686:
15550:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30137              		.loc 1 15550 0
 30138 0064 3349     		ldr	r1, .L3350
15554:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
 30139              		.loc 1 15554 0
 30140 0066 0446     		mov	r4, r0
 30141 0068 0028     		cmp	r0, #0
 30142 006a DDD1     		bne	.L3331
15555:Src/bno055.c  **** 				(data_u8r,
 30143              		.loc 1 15555 0
 30144 006c 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 30145 0070 B300     		lsls	r3, r6, #2
15560:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30146              		.loc 1 15560 0
 30147 0072 0968     		ldr	r1, [r1]
15555:Src/bno055.c  **** 				(data_u8r,
 30148              		.loc 1 15555 0
 30149 0074 22F00402 		bic	r2, r2, #4
ARM GAS  /tmp/ccVWLGiI.s 			page 859


 30150 0078 03F00403 		and	r3, r3, #4
 30151 007c 1343     		orrs	r3, r3, r2
15560:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30152              		.loc 1 15560 0
 30153 007e CC68     		ldr	r4, [r1, #12]
15555:Src/bno055.c  **** 				(data_u8r,
 30154              		.loc 1 15555 0
 30155 0080 8DF80630 		strb	r3, [sp, #6]
15560:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30156              		.loc 1 15560 0
 30157 0084 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 30158              	.LVL3687:
 30159 0086 0DF10602 		add	r2, sp, #6
 30160 008a 1721     		movs	r1, #23
 30161 008c 0123     		movs	r3, #1
 30162 008e A047     		blx	r4
 30163              	.LVL3688:
 30164 0090 0446     		mov	r4, r0
 30165              	.LVL3689:
 30166 0092 C9E7     		b	.L3331
 30167              	.L3348:
15583:Src/bno055.c  **** 	(prev_opmode_u8);
 30168              		.loc 1 15583 0
 30169 0094 FFF7FEFF 		bl	bno055_set_operation_mode
 30170              	.LVL3690:
 30171 0098 2044     		add	r0, r0, r4
 30172 009a C0B2     		uxtb	r0, r0
 30173              	.LVL3691:
 30174              		.loc 1 15586 0
 30175 009c 40B2     		sxtb	r0, r0
 30176 009e 02B0     		add	sp, sp, #8
 30177              	.LCFI1258:
 30178              		.cfi_remember_state
 30179              		.cfi_def_cfa_offset 16
 30180              		@ sp needed
 30181 00a0 70BD     		pop	{r4, r5, r6, pc}
 30182              	.LVL3692:
 30183              	.L3332:
 30184              	.LCFI1259:
 30185              		.cfi_restore_state
15500:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 30186              		.loc 1 15500 0
 30187 00a2 FFF7FEFF 		bl	bno055_set_operation_mode
 30188              	.LVL3693:
15502:Src/bno055.c  **** 		/* Write page as one */
 30189              		.loc 1 15502 0
 30190 00a6 0028     		cmp	r0, #0
 30191 00a8 BDD1     		bne	.L3334
 30192 00aa C9E7     		b	.L3335
 30193              	.LVL3694:
 30194              	.L3337:
15511:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30195              		.loc 1 15511 0
 30196 00ac 2368     		ldr	r3, [r4]
15510:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 30197              		.loc 1 15510 0
 30198 00ae 0DF10602 		add	r2, sp, #6
ARM GAS  /tmp/ccVWLGiI.s 			page 860


 30199 00b2 1C69     		ldr	r4, [r3, #16]
 30200 00b4 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30201              	.LVL3695:
 30202 00b6 1721     		movs	r1, #23
 30203 00b8 0123     		movs	r3, #1
 30204 00ba A047     		blx	r4
 30205              	.LVL3696:
15511:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30206              		.loc 1 15511 0
 30207 00bc 1D4A     		ldr	r2, .L3350
15515:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
 30208              		.loc 1 15515 0
 30209 00be 0446     		mov	r4, r0
 30210 00c0 0028     		cmp	r0, #0
 30211 00c2 B1D1     		bne	.L3331
15516:Src/bno055.c  **** 				(data_u8r,
 30212              		.loc 1 15516 0
 30213 00c4 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
15521:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30214              		.loc 1 15521 0
 30215 00c8 1068     		ldr	r0, [r2]
 30216              	.LVL3697:
15516:Src/bno055.c  **** 				(data_u8r,
 30217              		.loc 1 15516 0
 30218 00ca 06F00101 		and	r1, r6, #1
 30219 00ce 23F00103 		bic	r3, r3, #1
 30220 00d2 0B43     		orrs	r3, r3, r1
15521:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30221              		.loc 1 15521 0
 30222 00d4 C468     		ldr	r4, [r0, #12]
15516:Src/bno055.c  **** 				(data_u8r,
 30223              		.loc 1 15516 0
 30224 00d6 8DF80630 		strb	r3, [sp, #6]
15521:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30225              		.loc 1 15521 0
 30226 00da 0DF10602 		add	r2, sp, #6
 30227 00de 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 30228 00e0 1721     		movs	r1, #23
 30229 00e2 0123     		movs	r3, #1
 30230 00e4 A047     		blx	r4
 30231              	.LVL3698:
 30232 00e6 0446     		mov	r4, r0
 30233              	.LVL3699:
 30234 00e8 9EE7     		b	.L3331
 30235              	.LVL3700:
 30236              	.L3349:
15567:Src/bno055.c  **** 				break;
 30237              		.loc 1 15567 0
 30238 00ea FE24     		movs	r4, #254
 30239 00ec 9CE7     		b	.L3331
 30240              	.L3336:
15531:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30241              		.loc 1 15531 0
 30242 00ee 2368     		ldr	r3, [r4]
15530:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 30243              		.loc 1 15530 0
 30244 00f0 0DF10602 		add	r2, sp, #6
ARM GAS  /tmp/ccVWLGiI.s 			page 861


 30245 00f4 1C69     		ldr	r4, [r3, #16]
 30246 00f6 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30247              	.LVL3701:
 30248 00f8 1721     		movs	r1, #23
 30249 00fa 2B46     		mov	r3, r5
 30250 00fc A047     		blx	r4
 30251              	.LVL3702:
15531:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30252              		.loc 1 15531 0
 30253 00fe 0D4A     		ldr	r2, .L3350
15535:Src/bno055.c  **** 				data_u8r = BNO055_SET_BITSLICE
 30254              		.loc 1 15535 0
 30255 0100 0446     		mov	r4, r0
 30256 0102 0028     		cmp	r0, #0
 30257 0104 90D1     		bne	.L3331
15536:Src/bno055.c  **** 				(data_u8r,
 30258              		.loc 1 15536 0
 30259 0106 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 30260 010a 7100     		lsls	r1, r6, #1
15540:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30261              		.loc 1 15540 0
 30262 010c 1068     		ldr	r0, [r2]
 30263              	.LVL3703:
15536:Src/bno055.c  **** 				(data_u8r,
 30264              		.loc 1 15536 0
 30265 010e 23F00203 		bic	r3, r3, #2
 30266 0112 01F00201 		and	r1, r1, #2
 30267 0116 1943     		orrs	r1, r1, r3
15540:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30268              		.loc 1 15540 0
 30269 0118 C468     		ldr	r4, [r0, #12]
15536:Src/bno055.c  **** 				(data_u8r,
 30270              		.loc 1 15536 0
 30271 011a 8DF80610 		strb	r1, [sp, #6]
15540:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30272              		.loc 1 15540 0
 30273 011e 0DF10602 		add	r2, sp, #6
 30274 0122 2B46     		mov	r3, r5
 30275 0124 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 30276 0126 1721     		movs	r1, #23
 30277 0128 A047     		blx	r4
 30278              	.LVL3704:
 30279 012a 0446     		mov	r4, r0
 30280              	.LVL3705:
 30281 012c 7CE7     		b	.L3331
 30282              	.LVL3706:
 30283              	.L3339:
15492:Src/bno055.c  **** } else {
 30284              		.loc 1 15492 0
 30285 012e 8120     		movs	r0, #129
 30286              	.LVL3707:
 30287 0130 7FE7     		b	.L3329
 30288              	.L3351:
 30289 0132 00BF     		.align	2
 30290              	.L3350:
 30291 0134 00000000 		.word	.LANCHOR0
 30292              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 862


 30293              	.LFE244:
 30295              		.section	.text.bno055_get_gyro_highrate_axis_enable,"ax",%progbits
 30296              		.align	2
 30297              		.global	bno055_get_gyro_highrate_axis_enable
 30298              		.thumb
 30299              		.thumb_func
 30301              	bno055_get_gyro_highrate_axis_enable:
 30302              	.LFB245:
15587:Src/bno055.c  **** /*!
15588:Src/bno055.c  ****  *	@brief This API used to read the gyro highrate enable
15589:Src/bno055.c  ****  *	from page one register from 0x17 bit 3 to 5
15590:Src/bno055.c  ****  *
15591:Src/bno055.c  ****  *	@param data_u8 : The value of gyro highrate enable
15592:Src/bno055.c  ****  *      data_u8     | result
15593:Src/bno055.c  ****  *  ----------------  |-------------
15594:Src/bno055.c  ****  *      0x01          | BNO055_BIT_ENABLE
15595:Src/bno055.c  ****  *      0x00          | BNO055_BIT_DISABLE
15596:Src/bno055.c  ****  *	@param channel_u8 : The value of gyro highrate axis selection
15597:Src/bno055.c  ****  *               channel_u8         | value
15598:Src/bno055.c  ****  *     ------------------------       | ----------
15599:Src/bno055.c  ****  *     BNO055_GYRO_HIGHRATE_X_AXIS    |   0
15600:Src/bno055.c  ****  *     BNO055_GYRO_HIGHRATE_Y_AXIS    |   1
15601:Src/bno055.c  ****  *     BNO055_GYRO_HIGHRATE_Z_AXIS    |   2
15602:Src/bno055.c  ****  *
15603:Src/bno055.c  ****  *
15604:Src/bno055.c  ****  *	@return results of bus communication function
15605:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15606:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15607:Src/bno055.c  ****  *
15608:Src/bno055.c  ****  *
15609:Src/bno055.c  ****  */
15610:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_axis_enable(
15611:Src/bno055.c  **** u8 channel_u8, u8 *data_u8)
15612:Src/bno055.c  **** {
 30303              		.loc 1 15612 0
 30304              		.cfi_startproc
 30305              		@ args = 0, pretend = 0, frame = 8
 30306              		@ frame_needed = 0, uses_anonymous_args = 0
 30307              	.LVL3708:
 30308 0000 70B5     		push	{r4, r5, r6, lr}
 30309              	.LCFI1260:
 30310              		.cfi_def_cfa_offset 16
 30311              		.cfi_offset 4, -16
 30312              		.cfi_offset 5, -12
 30313              		.cfi_offset 6, -8
 30314              		.cfi_offset 14, -4
15613:Src/bno055.c  **** 	/* Variable used to return value of
15614:Src/bno055.c  **** 	communication routine*/
15615:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15616:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
15617:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
15618:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
15619:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 30315              		.loc 1 15619 0
 30316 0002 294D     		ldr	r5, .L3372
15612:Src/bno055.c  **** 	/* Variable used to return value of
 30317              		.loc 1 15612 0
ARM GAS  /tmp/ccVWLGiI.s 			page 863


 30318 0004 82B0     		sub	sp, sp, #8
 30319              	.LCFI1261:
 30320              		.cfi_def_cfa_offset 24
 30321              		.loc 1 15619 0
 30322 0006 2B68     		ldr	r3, [r5]
15616:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 30323              		.loc 1 15616 0
 30324 0008 0022     		movs	r2, #0
 30325 000a 8DF80720 		strb	r2, [sp, #7]
 30326              	.LVL3709:
 30327              		.loc 1 15619 0
 30328 000e 002B     		cmp	r3, #0
 30329 0010 48D0     		beq	.L3359
15620:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
15621:Src/bno055.c  **** 		} else {
15622:Src/bno055.c  **** 		/*condition check for page, gyro highrate enable is
15623:Src/bno055.c  **** 		available in the page one*/
15624:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 30330              		.loc 1 15624 0
 30331 0012 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 30332 0014 0E46     		mov	r6, r1
 30333 0016 012B     		cmp	r3, #1
 30334 0018 0446     		mov	r4, r0
 30335 001a 04D0     		beq	.L3358
15625:Src/bno055.c  **** 			/* Write page as one */
15626:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 30336              		.loc 1 15626 0
 30337 001c 0120     		movs	r0, #1
 30338              	.LVL3710:
 30339 001e FFF7FEFF 		bl	bno055_write_page_id
 30340              	.LVL3711:
15627:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 30341              		.loc 1 15627 0
 30342 0022 0028     		cmp	r0, #0
 30343 0024 38D1     		bne	.L3370
 30344              	.LVL3712:
 30345              	.L3358:
15628:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
15629:Src/bno055.c  **** 			switch (channel_u8) {
 30346              		.loc 1 15629 0
 30347 0026 012C     		cmp	r4, #1
 30348 0028 26D0     		beq	.L3355
 30349 002a 15D3     		bcc	.L3356
 30350 002c 022C     		cmp	r4, #2
 30351 002e 0FD1     		bne	.L3371
15630:Src/bno055.c  **** 			case BNO055_GYRO_HIGHRATE_X_AXIS:
15631:Src/bno055.c  **** 				/* Read the gyro highrate x enable */
15632:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15633:Src/bno055.c  **** 				(p_bno055->dev_addr,
15634:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_AXIS_REG,
15635:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15636:Src/bno055.c  **** 				*data_u8 =
15637:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
15638:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_AXIS);
15639:Src/bno055.c  **** 				break;
15640:Src/bno055.c  **** 			case BNO055_GYRO_HIGHRATE_Y_AXIS:
15641:Src/bno055.c  **** 				/* Read the gyro highrate y enable */
ARM GAS  /tmp/ccVWLGiI.s 			page 864


15642:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15643:Src/bno055.c  **** 				(p_bno055->dev_addr,
15644:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_AXIS_REG,
15645:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15646:Src/bno055.c  **** 				*data_u8 =
15647:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
15648:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_AXIS);
15649:Src/bno055.c  **** 				break;
15650:Src/bno055.c  **** 			case BNO055_GYRO_HIGHRATE_Z_AXIS:
15651:Src/bno055.c  **** 				/* Read the gyro highrate z enable */
15652:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 30352              		.loc 1 15652 0
 30353 0030 2B68     		ldr	r3, [r5]
 30354 0032 1721     		movs	r1, #23
 30355 0034 1C69     		ldr	r4, [r3, #16]
 30356 0036 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30357 0038 0DF10702 		add	r2, sp, #7
 30358 003c 0123     		movs	r3, #1
 30359 003e A047     		blx	r4
 30360              	.LVL3713:
15653:Src/bno055.c  **** 				(p_bno055->dev_addr,
15654:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Z_AXIS_REG,
15655:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15656:Src/bno055.c  **** 				*data_u8 =
15657:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 30361              		.loc 1 15657 0
 30362 0040 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30363 0044 C3F34013 		ubfx	r3, r3, #5, #1
15656:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 30364              		.loc 1 15656 0
 30365 0048 3370     		strb	r3, [r6]
 30366              	.LVL3714:
 30367              	.L3353:
15658:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Z_AXIS);
15659:Src/bno055.c  **** 				break;
15660:Src/bno055.c  **** 			default:
15661:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
15662:Src/bno055.c  **** 				break;
15663:Src/bno055.c  **** 			}
15664:Src/bno055.c  **** 		} else {
15665:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15666:Src/bno055.c  **** 		}
15667:Src/bno055.c  **** 	}
15668:Src/bno055.c  **** 	return com_rslt;
15669:Src/bno055.c  **** }
 30368              		.loc 1 15669 0
 30369 004a 40B2     		sxtb	r0, r0
 30370 004c 02B0     		add	sp, sp, #8
 30371              	.LCFI1262:
 30372              		.cfi_remember_state
 30373              		.cfi_def_cfa_offset 16
 30374              		@ sp needed
 30375 004e 70BD     		pop	{r4, r5, r6, pc}
 30376              	.LVL3715:
 30377              	.L3371:
 30378              	.LCFI1263:
 30379              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 865


15661:Src/bno055.c  **** 				break;
 30380              		.loc 1 15661 0
 30381 0050 FE20     		movs	r0, #254
 30382              		.loc 1 15669 0
 30383 0052 40B2     		sxtb	r0, r0
 30384 0054 02B0     		add	sp, sp, #8
 30385              	.LCFI1264:
 30386              		.cfi_remember_state
 30387              		.cfi_def_cfa_offset 16
 30388              		@ sp needed
 30389 0056 70BD     		pop	{r4, r5, r6, pc}
 30390              	.LVL3716:
 30391              	.L3356:
 30392              	.LCFI1265:
 30393              		.cfi_restore_state
15632:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30394              		.loc 1 15632 0
 30395 0058 2B68     		ldr	r3, [r5]
 30396 005a 1721     		movs	r1, #23
 30397 005c 1C69     		ldr	r4, [r3, #16]
 30398 005e 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30399 0060 0DF10702 		add	r2, sp, #7
 30400 0064 0123     		movs	r3, #1
 30401 0066 A047     		blx	r4
 30402              	.LVL3717:
15637:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_AXIS);
 30403              		.loc 1 15637 0
 30404 0068 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30405              		.loc 1 15669 0
 30406 006c 40B2     		sxtb	r0, r0
15637:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_AXIS);
 30407              		.loc 1 15637 0
 30408 006e C3F3C003 		ubfx	r3, r3, #3, #1
15636:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 30409              		.loc 1 15636 0
 30410 0072 3370     		strb	r3, [r6]
 30411              		.loc 1 15669 0
 30412 0074 02B0     		add	sp, sp, #8
 30413              	.LCFI1266:
 30414              		.cfi_remember_state
 30415              		.cfi_def_cfa_offset 16
 30416              		@ sp needed
 30417 0076 70BD     		pop	{r4, r5, r6, pc}
 30418              	.LVL3718:
 30419              	.L3355:
 30420              	.LCFI1267:
 30421              		.cfi_restore_state
15642:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30422              		.loc 1 15642 0
 30423 0078 2A68     		ldr	r2, [r5]
 30424 007a 2346     		mov	r3, r4
 30425 007c 507A     		ldrb	r0, [r2, #9]	@ zero_extendqisi2
 30426 007e 1469     		ldr	r4, [r2, #16]
 30427 0080 1721     		movs	r1, #23
 30428 0082 0DF10702 		add	r2, sp, #7
 30429 0086 A047     		blx	r4
 30430              	.LVL3719:
ARM GAS  /tmp/ccVWLGiI.s 			page 866


15647:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_AXIS);
 30431              		.loc 1 15647 0
 30432 0088 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30433              		.loc 1 15669 0
 30434 008c 40B2     		sxtb	r0, r0
15647:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_AXIS);
 30435              		.loc 1 15647 0
 30436 008e C3F30013 		ubfx	r3, r3, #4, #1
15646:Src/bno055.c  **** 				BNO055_GET_BITSLICE(data_u8r,
 30437              		.loc 1 15646 0
 30438 0092 3370     		strb	r3, [r6]
 30439              		.loc 1 15669 0
 30440 0094 02B0     		add	sp, sp, #8
 30441              	.LCFI1268:
 30442              		.cfi_remember_state
 30443              		.cfi_def_cfa_offset 16
 30444              		@ sp needed
 30445 0096 70BD     		pop	{r4, r5, r6, pc}
 30446              	.LVL3720:
 30447              	.L3370:
 30448              	.LCFI1269:
 30449              		.cfi_restore_state
15628:Src/bno055.c  **** 			switch (channel_u8) {
 30450              		.loc 1 15628 0 discriminator 1
 30451 0098 2B68     		ldr	r3, [r5]
15627:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 30452              		.loc 1 15627 0 discriminator 1
 30453 009a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 30454 009c 012B     		cmp	r3, #1
 30455 009e C2D0     		beq	.L3358
15665:Src/bno055.c  **** 		}
 30456              		.loc 1 15665 0
 30457 00a0 FF20     		movs	r0, #255
 30458 00a2 D2E7     		b	.L3353
 30459              	.LVL3721:
 30460              	.L3359:
15620:Src/bno055.c  **** 		} else {
 30461              		.loc 1 15620 0
 30462 00a4 8120     		movs	r0, #129
 30463              	.LVL3722:
 30464 00a6 D0E7     		b	.L3353
 30465              	.L3373:
 30466              		.align	2
 30467              	.L3372:
 30468 00a8 00000000 		.word	.LANCHOR0
 30469              		.cfi_endproc
 30470              	.LFE245:
 30472              		.section	.text.bno055_set_gyro_highrate_axis_enable,"ax",%progbits
 30473              		.align	2
 30474              		.global	bno055_set_gyro_highrate_axis_enable
 30475              		.thumb
 30476              		.thumb_func
 30478              	bno055_set_gyro_highrate_axis_enable:
 30479              	.LFB246:
15670:Src/bno055.c  **** /*!
15671:Src/bno055.c  ****  *	@brief This API used to write the gyro highrate enable
15672:Src/bno055.c  ****  *	from page one register from 0x17 bit 3 to 5
ARM GAS  /tmp/ccVWLGiI.s 			page 867


15673:Src/bno055.c  ****  *
15674:Src/bno055.c  ****  *	@param data_u8 : The value of gyro highrate enable
15675:Src/bno055.c  ****  *      data_u8     | result
15676:Src/bno055.c  ****  *  ----------------  |-------------
15677:Src/bno055.c  ****  *      0x01          | BNO055_BIT_ENABLE
15678:Src/bno055.c  ****  *      0x00          | BNO055_BIT_DISABLE
15679:Src/bno055.c  ****  *	@param channel_u8 : The value of gyro highrate axis selection
15680:Src/bno055.c  ****  *               channel_u8         | value
15681:Src/bno055.c  ****  *     ------------------------       | ----------
15682:Src/bno055.c  ****  *     BNO055_GYRO_HIGHRATE_X_AXIS    |   0
15683:Src/bno055.c  ****  *     BNO055_GYRO_HIGHRATE_Y_AXIS    |   1
15684:Src/bno055.c  ****  *     BNO055_GYRO_HIGHRATE_Z_AXIS    |   2
15685:Src/bno055.c  ****  *
15686:Src/bno055.c  ****  *	@return results of bus communication function
15687:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15688:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15689:Src/bno055.c  ****  *
15690:Src/bno055.c  ****  *
15691:Src/bno055.c  ****  */
15692:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_axis_enable(
15693:Src/bno055.c  **** u8 channel_u8, u8 data_u8)
15694:Src/bno055.c  **** {
 30480              		.loc 1 15694 0
 30481              		.cfi_startproc
 30482              		@ args = 0, pretend = 0, frame = 8
 30483              		@ frame_needed = 0, uses_anonymous_args = 0
 30484              	.LVL3723:
 30485 0000 70B5     		push	{r4, r5, r6, lr}
 30486              	.LCFI1270:
 30487              		.cfi_def_cfa_offset 16
 30488              		.cfi_offset 4, -16
 30489              		.cfi_offset 5, -12
 30490              		.cfi_offset 6, -8
 30491              		.cfi_offset 14, -4
15695:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15696:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15697:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15698:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
15699:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15700:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15701:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 30492              		.loc 1 15701 0
 30493 0002 4C4C     		ldr	r4, .L3396
15694:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 30494              		.loc 1 15694 0
 30495 0004 82B0     		sub	sp, sp, #8
 30496              	.LCFI1271:
 30497              		.cfi_def_cfa_offset 24
 30498              		.loc 1 15701 0
 30499 0006 2568     		ldr	r5, [r4]
15696:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 30500              		.loc 1 15696 0
 30501 0008 0022     		movs	r2, #0
 30502 000a 8DF80620 		strb	r2, [sp, #6]
 30503              	.LVL3724:
15698:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 30504              		.loc 1 15698 0
ARM GAS  /tmp/ccVWLGiI.s 			page 868


 30505 000e 8DF80720 		strb	r2, [sp, #7]
 30506              	.LVL3725:
 30507              		.loc 1 15701 0
 30508 0012 002D     		cmp	r5, #0
 30509 0014 00F08C80 		beq	.L3385
 30510 0018 0546     		mov	r5, r0
15702:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15703:Src/bno055.c  **** } else {
15704:Src/bno055.c  **** /* The write operation effective only if the operation
15705:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15706:Src/bno055.c  **** current operation mode and set the config mode */
15707:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 30511              		.loc 1 15707 0
 30512 001a 0DF10700 		add	r0, sp, #7
 30513              	.LVL3726:
 30514 001e 0E46     		mov	r6, r1
 30515 0020 FFF7FEFF 		bl	bno055_get_operation_mode
 30516              	.LVL3727:
15708:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 30517              		.loc 1 15708 0
 30518 0024 40B1     		cbz	r0, .L3376
 30519              	.LVL3728:
 30520              	.L3380:
15709:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
15710:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
15711:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
15712:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
15713:Src/bno055.c  **** 			/* Write page as one */
15714:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
15715:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
15716:Src/bno055.c  **** 				switch (channel_u8) {
15717:Src/bno055.c  **** 				case BNO055_GYRO_HIGHRATE_X_AXIS:
15718:Src/bno055.c  **** 				/* Write the value of
15719:Src/bno055.c  **** 				gyro highrate x enable*/
15720:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15721:Src/bno055.c  **** 				(p_bno055->dev_addr,
15722:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_AXIS_REG,
15723:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15724:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15725:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
15726:Src/bno055.c  **** 					(data_u8r,
15727:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_AXIS, data_u8);
15728:Src/bno055.c  **** 					com_rslt +=
15729:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15730:Src/bno055.c  **** 					(p_bno055->dev_addr,
15731:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_AXIS_REG,
15732:Src/bno055.c  **** 					&data_u8r,
15733:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15734:Src/bno055.c  **** 				}
15735:Src/bno055.c  **** 				break;
15736:Src/bno055.c  **** 				case BNO055_GYRO_HIGHRATE_Y_AXIS:
15737:Src/bno055.c  **** 				/* Write the value of
15738:Src/bno055.c  **** 				gyro highrate y enable*/
15739:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15740:Src/bno055.c  **** 				(p_bno055->dev_addr,
15741:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_AXIS_REG,
15742:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 869


15743:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15744:Src/bno055.c  **** 					data_u8r =
15745:Src/bno055.c  **** 					BNO055_SET_BITSLICE(
15746:Src/bno055.c  **** 					data_u8r,
15747:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_AXIS, data_u8);
15748:Src/bno055.c  **** 					com_rslt +=
15749:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15750:Src/bno055.c  **** 					(p_bno055->dev_addr,
15751:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_AXIS_REG,
15752:Src/bno055.c  **** 					&data_u8r,
15753:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15754:Src/bno055.c  **** 				}
15755:Src/bno055.c  **** 				break;
15756:Src/bno055.c  **** 				case BNO055_GYRO_HIGHRATE_Z_AXIS:
15757:Src/bno055.c  **** 				/* Write the value of
15758:Src/bno055.c  **** 				gyro highrate z enable*/
15759:Src/bno055.c  **** 				com_rslt =
15760:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
15761:Src/bno055.c  **** 				(p_bno055->dev_addr,
15762:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Z_AXIS_REG,
15763:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15764:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15765:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
15766:Src/bno055.c  **** 					(data_u8r,
15767:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_AXIS, data_u8);
15768:Src/bno055.c  **** 					com_rslt +=
15769:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15770:Src/bno055.c  **** 					(p_bno055->dev_addr,
15771:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_AXIS_REG,
15772:Src/bno055.c  **** 					&data_u8r,
15773:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15774:Src/bno055.c  **** 				}
15775:Src/bno055.c  **** 				break;
15776:Src/bno055.c  **** 				default:
15777:Src/bno055.c  **** 				com_rslt = BNO055_OUT_OF_RANGE;
15778:Src/bno055.c  **** 				break;
15779:Src/bno055.c  **** 				}
15780:Src/bno055.c  **** 			} else {
15781:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
15782:Src/bno055.c  **** 			}
15783:Src/bno055.c  **** 		} else {
15784:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15785:Src/bno055.c  **** 		}
15786:Src/bno055.c  **** 	} else {
15787:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 30521              		.loc 1 15787 0
 30522 0026 FF24     		movs	r4, #255
 30523              	.LVL3729:
 30524              	.L3377:
15788:Src/bno055.c  **** 	}
15789:Src/bno055.c  **** }
15790:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 30525              		.loc 1 15790 0
 30526 0028 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 30527 002c 0028     		cmp	r0, #0
 30528 002e 31D1     		bne	.L3394
 30529 0030 2046     		mov	r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 870


 30530              	.LVL3730:
 30531              	.L3375:
15791:Src/bno055.c  **** 	/* set the operation mode of
15792:Src/bno055.c  **** 	previous operation mode*/
15793:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
15794:Src/bno055.c  **** 	(prev_opmode_u8);
15795:Src/bno055.c  **** return com_rslt;
15796:Src/bno055.c  **** }
 30532              		.loc 1 15796 0
 30533 0032 40B2     		sxtb	r0, r0
 30534 0034 02B0     		add	sp, sp, #8
 30535              	.LCFI1272:
 30536              		.cfi_remember_state
 30537              		.cfi_def_cfa_offset 16
 30538              		@ sp needed
 30539 0036 70BD     		pop	{r4, r5, r6, pc}
 30540              	.LVL3731:
 30541              	.L3376:
 30542              	.LCFI1273:
 30543              		.cfi_restore_state
15709:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 30544              		.loc 1 15709 0
 30545 0038 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30546 003c 002B     		cmp	r3, #0
 30547 003e 30D1     		bne	.L3378
 30548              	.L3381:
 30549              	.LVL3732:
15714:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 30550              		.loc 1 15714 0
 30551 0040 0120     		movs	r0, #1
 30552 0042 FFF7FEFF 		bl	bno055_write_page_id
 30553              	.LVL3733:
15715:Src/bno055.c  **** 				switch (channel_u8) {
 30554              		.loc 1 15715 0
 30555 0046 0028     		cmp	r0, #0
 30556 0048 EDD1     		bne	.L3380
15716:Src/bno055.c  **** 				case BNO055_GYRO_HIGHRATE_X_AXIS:
 30557              		.loc 1 15716 0
 30558 004a 012D     		cmp	r5, #1
 30559 004c 50D0     		beq	.L3382
 30560 004e 2DD3     		bcc	.L3383
 30561 0050 022D     		cmp	r5, #2
 30562 0052 4BD1     		bne	.L3395
15760:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30563              		.loc 1 15760 0
 30564 0054 2368     		ldr	r3, [r4]
15759:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 30565              		.loc 1 15759 0
 30566 0056 1721     		movs	r1, #23
 30567 0058 1C69     		ldr	r4, [r3, #16]
 30568 005a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30569              	.LVL3734:
 30570 005c 0DF10602 		add	r2, sp, #6
 30571 0060 0123     		movs	r3, #1
 30572 0062 A047     		blx	r4
 30573              	.LVL3735:
15760:Src/bno055.c  **** 				(p_bno055->dev_addr,
ARM GAS  /tmp/ccVWLGiI.s 			page 871


 30574              		.loc 1 15760 0
 30575 0064 3349     		ldr	r1, .L3396
15764:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 30576              		.loc 1 15764 0
 30577 0066 0446     		mov	r4, r0
 30578 0068 0028     		cmp	r0, #0
 30579 006a DDD1     		bne	.L3377
15765:Src/bno055.c  **** 					(data_u8r,
 30580              		.loc 1 15765 0
 30581 006c 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 30582 0070 7301     		lsls	r3, r6, #5
15769:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30583              		.loc 1 15769 0
 30584 0072 0968     		ldr	r1, [r1]
15765:Src/bno055.c  **** 					(data_u8r,
 30585              		.loc 1 15765 0
 30586 0074 22F02002 		bic	r2, r2, #32
 30587 0078 03F02003 		and	r3, r3, #32
 30588 007c 1343     		orrs	r3, r3, r2
15769:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30589              		.loc 1 15769 0
 30590 007e CC68     		ldr	r4, [r1, #12]
15765:Src/bno055.c  **** 					(data_u8r,
 30591              		.loc 1 15765 0
 30592 0080 8DF80630 		strb	r3, [sp, #6]
15769:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30593              		.loc 1 15769 0
 30594 0084 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 30595              	.LVL3736:
 30596 0086 0DF10602 		add	r2, sp, #6
 30597 008a 1721     		movs	r1, #23
 30598 008c 0123     		movs	r3, #1
 30599 008e A047     		blx	r4
 30600              	.LVL3737:
 30601 0090 0446     		mov	r4, r0
 30602              	.LVL3738:
 30603 0092 C9E7     		b	.L3377
 30604              	.L3394:
15793:Src/bno055.c  **** 	(prev_opmode_u8);
 30605              		.loc 1 15793 0
 30606 0094 FFF7FEFF 		bl	bno055_set_operation_mode
 30607              	.LVL3739:
 30608 0098 2044     		add	r0, r0, r4
 30609 009a C0B2     		uxtb	r0, r0
 30610              	.LVL3740:
 30611              		.loc 1 15796 0
 30612 009c 40B2     		sxtb	r0, r0
 30613 009e 02B0     		add	sp, sp, #8
 30614              	.LCFI1274:
 30615              		.cfi_remember_state
 30616              		.cfi_def_cfa_offset 16
 30617              		@ sp needed
 30618 00a0 70BD     		pop	{r4, r5, r6, pc}
 30619              	.LVL3741:
 30620              	.L3378:
 30621              	.LCFI1275:
 30622              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 872


15710:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 30623              		.loc 1 15710 0
 30624 00a2 FFF7FEFF 		bl	bno055_set_operation_mode
 30625              	.LVL3742:
15712:Src/bno055.c  **** 			/* Write page as one */
 30626              		.loc 1 15712 0
 30627 00a6 0028     		cmp	r0, #0
 30628 00a8 BDD1     		bne	.L3380
 30629 00aa C9E7     		b	.L3381
 30630              	.LVL3743:
 30631              	.L3383:
15720:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30632              		.loc 1 15720 0
 30633 00ac 2368     		ldr	r3, [r4]
 30634 00ae 0DF10602 		add	r2, sp, #6
 30635 00b2 1C69     		ldr	r4, [r3, #16]
 30636 00b4 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30637              	.LVL3744:
 30638 00b6 1721     		movs	r1, #23
 30639 00b8 0123     		movs	r3, #1
 30640 00ba A047     		blx	r4
 30641              	.LVL3745:
 30642 00bc 1D4A     		ldr	r2, .L3396
15724:Src/bno055.c  **** 					data_u8r = BNO055_SET_BITSLICE
 30643              		.loc 1 15724 0
 30644 00be 0446     		mov	r4, r0
 30645 00c0 0028     		cmp	r0, #0
 30646 00c2 B1D1     		bne	.L3377
15725:Src/bno055.c  **** 					(data_u8r,
 30647              		.loc 1 15725 0
 30648 00c4 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 30649 00c8 F100     		lsls	r1, r6, #3
15729:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30650              		.loc 1 15729 0
 30651 00ca 1068     		ldr	r0, [r2]
 30652              	.LVL3746:
15725:Src/bno055.c  **** 					(data_u8r,
 30653              		.loc 1 15725 0
 30654 00cc 01F00801 		and	r1, r1, #8
 30655 00d0 23F00803 		bic	r3, r3, #8
 30656 00d4 0B43     		orrs	r3, r3, r1
15729:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30657              		.loc 1 15729 0
 30658 00d6 C468     		ldr	r4, [r0, #12]
15725:Src/bno055.c  **** 					(data_u8r,
 30659              		.loc 1 15725 0
 30660 00d8 8DF80630 		strb	r3, [sp, #6]
15729:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30661              		.loc 1 15729 0
 30662 00dc 0DF10602 		add	r2, sp, #6
 30663 00e0 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 30664 00e2 1721     		movs	r1, #23
 30665 00e4 0123     		movs	r3, #1
 30666 00e6 A047     		blx	r4
 30667              	.LVL3747:
 30668 00e8 0446     		mov	r4, r0
 30669              	.LVL3748:
ARM GAS  /tmp/ccVWLGiI.s 			page 873


 30670 00ea 9DE7     		b	.L3377
 30671              	.LVL3749:
 30672              	.L3395:
15777:Src/bno055.c  **** 				break;
 30673              		.loc 1 15777 0
 30674 00ec FE24     		movs	r4, #254
 30675 00ee 9BE7     		b	.L3377
 30676              	.L3382:
15739:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30677              		.loc 1 15739 0
 30678 00f0 2368     		ldr	r3, [r4]
 30679 00f2 0DF10602 		add	r2, sp, #6
 30680 00f6 1C69     		ldr	r4, [r3, #16]
 30681 00f8 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30682              	.LVL3750:
 30683 00fa 1721     		movs	r1, #23
 30684 00fc 2B46     		mov	r3, r5
 30685 00fe A047     		blx	r4
 30686              	.LVL3751:
 30687 0100 0C4A     		ldr	r2, .L3396
15743:Src/bno055.c  **** 					data_u8r =
 30688              		.loc 1 15743 0
 30689 0102 0446     		mov	r4, r0
 30690 0104 0028     		cmp	r0, #0
 30691 0106 8FD1     		bne	.L3377
15744:Src/bno055.c  **** 					BNO055_SET_BITSLICE(
 30692              		.loc 1 15744 0
 30693 0108 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
15745:Src/bno055.c  **** 					data_u8r,
 30694              		.loc 1 15745 0
 30695 010c 3101     		lsls	r1, r6, #4
15749:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30696              		.loc 1 15749 0
 30697 010e 1068     		ldr	r0, [r2]
 30698              	.LVL3752:
15744:Src/bno055.c  **** 					BNO055_SET_BITSLICE(
 30699              		.loc 1 15744 0
 30700 0110 23F01003 		bic	r3, r3, #16
 30701 0114 01F01001 		and	r1, r1, #16
 30702 0118 1943     		orrs	r1, r1, r3
15749:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30703              		.loc 1 15749 0
 30704 011a C468     		ldr	r4, [r0, #12]
15744:Src/bno055.c  **** 					BNO055_SET_BITSLICE(
 30705              		.loc 1 15744 0
 30706 011c 8DF80610 		strb	r1, [sp, #6]
15749:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30707              		.loc 1 15749 0
 30708 0120 0DF10602 		add	r2, sp, #6
 30709 0124 2B46     		mov	r3, r5
 30710 0126 407A     		ldrb	r0, [r0, #9]	@ zero_extendqisi2
 30711 0128 1721     		movs	r1, #23
 30712 012a A047     		blx	r4
 30713              	.LVL3753:
 30714 012c 0446     		mov	r4, r0
 30715              	.LVL3754:
 30716 012e 7BE7     		b	.L3377
ARM GAS  /tmp/ccVWLGiI.s 			page 874


 30717              	.LVL3755:
 30718              	.L3385:
15702:Src/bno055.c  **** } else {
 30719              		.loc 1 15702 0
 30720 0130 8120     		movs	r0, #129
 30721              	.LVL3756:
 30722 0132 7EE7     		b	.L3375
 30723              	.L3397:
 30724              		.align	2
 30725              	.L3396:
 30726 0134 00000000 		.word	.LANCHOR0
 30727              		.cfi_endproc
 30728              	.LFE246:
 30730              		.section	.text.bno055_get_gyro_any_motion_filter,"ax",%progbits
 30731              		.align	2
 30732              		.global	bno055_get_gyro_any_motion_filter
 30733              		.thumb
 30734              		.thumb_func
 30736              	bno055_get_gyro_any_motion_filter:
 30737              	.LFB247:
15797:Src/bno055.c  **** /*!
15798:Src/bno055.c  ****  *	@brief This API used to read gyro anymotion filter
15799:Src/bno055.c  ****  *	from page one register from 0x17 bit 6
15800:Src/bno055.c  ****  *
15801:Src/bno055.c  ****  *	@param gyro_any_motion_filter_u8 : The value of gyro anymotion filter
15802:Src/bno055.c  ****  *   gyro_any_motion_filter_u8  | result
15803:Src/bno055.c  ****  *  ---------------------------   |------------
15804:Src/bno055.c  ****  *      0x00                      | BNO055_GYRO_FILTERED_CONFIG
15805:Src/bno055.c  ****  *      0x01                      | BNO055_GYRO_UNFILTERED_CONFIG
15806:Src/bno055.c  ****  *
15807:Src/bno055.c  ****  *	@return results of bus communication function
15808:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15809:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15810:Src/bno055.c  ****  *
15811:Src/bno055.c  ****  */
15812:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_any_motion_filter(
15813:Src/bno055.c  **** u8 *gyro_any_motion_filter_u8)
15814:Src/bno055.c  **** {
 30738              		.loc 1 15814 0
 30739              		.cfi_startproc
 30740              		@ args = 0, pretend = 0, frame = 8
 30741              		@ frame_needed = 0, uses_anonymous_args = 0
 30742              	.LVL3757:
 30743 0000 30B5     		push	{r4, r5, lr}
 30744              	.LCFI1276:
 30745              		.cfi_def_cfa_offset 12
 30746              		.cfi_offset 4, -12
 30747              		.cfi_offset 5, -8
 30748              		.cfi_offset 14, -4
15815:Src/bno055.c  **** 	/* Variable used to return value of
15816:Src/bno055.c  **** 	communication routine*/
15817:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15818:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
15819:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
15820:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
15821:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 30749              		.loc 1 15821 0
ARM GAS  /tmp/ccVWLGiI.s 			page 875


 30750 0002 144C     		ldr	r4, .L3410
15814:Src/bno055.c  **** 	/* Variable used to return value of
 30751              		.loc 1 15814 0
 30752 0004 83B0     		sub	sp, sp, #12
 30753              	.LCFI1277:
 30754              		.cfi_def_cfa_offset 24
 30755              		.loc 1 15821 0
 30756 0006 2368     		ldr	r3, [r4]
15818:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 30757              		.loc 1 15818 0
 30758 0008 0022     		movs	r2, #0
 30759 000a 8DF80720 		strb	r2, [sp, #7]
 30760              	.LVL3758:
 30761              		.loc 1 15821 0
 30762 000e FBB1     		cbz	r3, .L3402
15822:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
15823:Src/bno055.c  **** 		} else {
15824:Src/bno055.c  **** 		/*condition check for page, gyro anymotion filter is
15825:Src/bno055.c  **** 		available in the page one*/
15826:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 30763              		.loc 1 15826 0
 30764 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 30765 0012 0546     		mov	r5, r0
 30766 0014 012A     		cmp	r2, #1
 30767 0016 04D0     		beq	.L3400
15827:Src/bno055.c  **** 			/* Write page as one */
15828:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 30768              		.loc 1 15828 0
 30769 0018 0120     		movs	r0, #1
 30770              	.LVL3759:
 30771 001a FFF7FEFF 		bl	bno055_write_page_id
 30772              	.LVL3760:
 30773 001e 2368     		ldr	r3, [r4]
15829:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 30774              		.loc 1 15829 0
 30775 0020 70B9     		cbnz	r0, .L3409
 30776              	.LVL3761:
 30777              	.L3400:
15830:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
15831:Src/bno055.c  **** 			/* Read the value of gyro anymotion filter*/
15832:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 30778              		.loc 1 15832 0
 30779 0022 1C69     		ldr	r4, [r3, #16]
 30780 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30781 0026 1721     		movs	r1, #23
 30782 0028 0123     		movs	r3, #1
 30783 002a 0DF10702 		add	r2, sp, #7
 30784 002e A047     		blx	r4
 30785              	.LVL3762:
15833:Src/bno055.c  **** 			(p_bno055->dev_addr,
15834:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_FILTER_REG,
15835:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15836:Src/bno055.c  **** 			*gyro_any_motion_filter_u8 =
15837:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 30786              		.loc 1 15837 0
 30787 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30788 0034 C3F38013 		ubfx	r3, r3, #6, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 876


15836:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 30789              		.loc 1 15836 0
 30790 0038 2B70     		strb	r3, [r5]
 30791              	.LVL3763:
 30792              	.L3399:
15838:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_FILTER);
15839:Src/bno055.c  **** 		} else {
15840:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15841:Src/bno055.c  **** 		}
15842:Src/bno055.c  **** 	}
15843:Src/bno055.c  **** 	return com_rslt;
15844:Src/bno055.c  **** }
 30793              		.loc 1 15844 0
 30794 003a 40B2     		sxtb	r0, r0
 30795 003c 03B0     		add	sp, sp, #12
 30796              	.LCFI1278:
 30797              		.cfi_remember_state
 30798              		.cfi_def_cfa_offset 12
 30799              		@ sp needed
 30800 003e 30BD     		pop	{r4, r5, pc}
 30801              	.LVL3764:
 30802              	.L3409:
 30803              	.LCFI1279:
 30804              		.cfi_restore_state
15829:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 30805              		.loc 1 15829 0 discriminator 1
 30806 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 30807 0042 012A     		cmp	r2, #1
15840:Src/bno055.c  **** 		}
 30808              		.loc 1 15840 0 discriminator 1
 30809 0044 18BF     		it	ne
 30810 0046 FF20     		movne	r0, #255
15829:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 30811              		.loc 1 15829 0 discriminator 1
 30812 0048 EBD0     		beq	.L3400
 30813              		.loc 1 15844 0
 30814 004a 40B2     		sxtb	r0, r0
 30815 004c 03B0     		add	sp, sp, #12
 30816              	.LCFI1280:
 30817              		.cfi_remember_state
 30818              		.cfi_def_cfa_offset 12
 30819              		@ sp needed
 30820 004e 30BD     		pop	{r4, r5, pc}
 30821              	.LVL3765:
 30822              	.L3402:
 30823              	.LCFI1281:
 30824              		.cfi_restore_state
15822:Src/bno055.c  **** 		} else {
 30825              		.loc 1 15822 0
 30826 0050 8120     		movs	r0, #129
 30827              	.LVL3766:
 30828 0052 F2E7     		b	.L3399
 30829              	.L3411:
 30830              		.align	2
 30831              	.L3410:
 30832 0054 00000000 		.word	.LANCHOR0
 30833              		.cfi_endproc
ARM GAS  /tmp/ccVWLGiI.s 			page 877


 30834              	.LFE247:
 30836              		.section	.text.bno055_set_gyro_any_motion_filter,"ax",%progbits
 30837              		.align	2
 30838              		.global	bno055_set_gyro_any_motion_filter
 30839              		.thumb
 30840              		.thumb_func
 30842              	bno055_set_gyro_any_motion_filter:
 30843              	.LFB248:
15845:Src/bno055.c  **** /*!
15846:Src/bno055.c  ****  *	@brief This API used to write gyro anymotion filter
15847:Src/bno055.c  ****  *	from page one register from 0x17 bit 6
15848:Src/bno055.c  ****  *
15849:Src/bno055.c  ****  *	@param gyro_any_motion_filter_u8 : The value of gyro anymotion filter
15850:Src/bno055.c  ****  *   gyro_any_motion_filter_u8  | result
15851:Src/bno055.c  ****  *  ---------------------------   |------------
15852:Src/bno055.c  ****  *      0x00                      | BNO055_GYRO_FILTERED_CONFIG
15853:Src/bno055.c  ****  *      0x01                      | BNO055_GYRO_UNFILTERED_CONFIG
15854:Src/bno055.c  ****  *
15855:Src/bno055.c  ****  *	@return results of bus communication function
15856:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15857:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15858:Src/bno055.c  ****  *
15859:Src/bno055.c  ****  */
15860:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_any_motion_filter(
15861:Src/bno055.c  **** u8 gyro_any_motion_filter_u8)
15862:Src/bno055.c  **** {
 30844              		.loc 1 15862 0
 30845              		.cfi_startproc
 30846              		@ args = 0, pretend = 0, frame = 8
 30847              		@ frame_needed = 0, uses_anonymous_args = 0
 30848              	.LVL3767:
 30849 0000 30B5     		push	{r4, r5, lr}
 30850              	.LCFI1282:
 30851              		.cfi_def_cfa_offset 12
 30852              		.cfi_offset 4, -12
 30853              		.cfi_offset 5, -8
 30854              		.cfi_offset 14, -4
15863:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15864:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15865:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15866:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
15867:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15868:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15869:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 30855              		.loc 1 15869 0
 30856 0002 274C     		ldr	r4, .L3428
15862:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 30857              		.loc 1 15862 0
 30858 0004 83B0     		sub	sp, sp, #12
 30859              	.LCFI1283:
 30860              		.cfi_def_cfa_offset 24
 30861              		.loc 1 15869 0
 30862 0006 2268     		ldr	r2, [r4]
15864:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 30863              		.loc 1 15864 0
 30864 0008 0023     		movs	r3, #0
 30865 000a 8DF80630 		strb	r3, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 878


 30866              	.LVL3768:
15866:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 30867              		.loc 1 15866 0
 30868 000e 8DF80730 		strb	r3, [sp, #7]
 30869              	.LVL3769:
 30870              		.loc 1 15869 0
 30871 0012 002A     		cmp	r2, #0
 30872 0014 41D0     		beq	.L3420
 30873 0016 0546     		mov	r5, r0
15870:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15871:Src/bno055.c  **** } else {
15872:Src/bno055.c  **** /* The write operation effective only if the operation
15873:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15874:Src/bno055.c  **** current operation mode and set the config mode */
15875:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 30874              		.loc 1 15875 0
 30875 0018 0DF10700 		add	r0, sp, #7
 30876              	.LVL3770:
 30877 001c FFF7FEFF 		bl	bno055_get_operation_mode
 30878              	.LVL3771:
15876:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 30879              		.loc 1 15876 0
 30880 0020 38B1     		cbz	r0, .L3414
 30881              	.LVL3772:
 30882              	.L3418:
15877:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
15878:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
15879:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
15880:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
15881:Src/bno055.c  **** 			/* Write page as one */
15882:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
15883:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
15884:Src/bno055.c  **** 				/* Write the value of
15885:Src/bno055.c  **** 				gyro anymotion filter*/
15886:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
15887:Src/bno055.c  **** 				(p_bno055->dev_addr,
15888:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_FILTER_REG,
15889:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15890:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
15891:Src/bno055.c  **** 					data_u8r =
15892:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
15893:Src/bno055.c  **** 					BNO055_GYRO_ANY_MOTION_FILTER,
15894:Src/bno055.c  **** 					gyro_any_motion_filter_u8);
15895:Src/bno055.c  **** 					com_rslt +=
15896:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
15897:Src/bno055.c  **** 					(p_bno055->dev_addr,
15898:Src/bno055.c  **** 					BNO055_GYRO_ANY_MOTION_FILTER_REG,
15899:Src/bno055.c  **** 					&data_u8r,
15900:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
15901:Src/bno055.c  **** 				}
15902:Src/bno055.c  **** 			} else {
15903:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
15904:Src/bno055.c  **** 			}
15905:Src/bno055.c  **** 		} else {
15906:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15907:Src/bno055.c  **** 		}
15908:Src/bno055.c  **** 	} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 879


15909:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 30883              		.loc 1 15909 0
 30884 0022 FF24     		movs	r4, #255
 30885              	.LVL3773:
 30886              	.L3415:
15910:Src/bno055.c  **** 	}
15911:Src/bno055.c  **** }
15912:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 30887              		.loc 1 15912 0
 30888 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 30889 0028 58BB     		cbnz	r0, .L3427
 30890 002a 2046     		mov	r0, r4
 30891              	.LVL3774:
 30892              	.L3413:
15913:Src/bno055.c  **** 	/* set the operation mode of
15914:Src/bno055.c  **** 	previous operation mode*/
15915:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
15916:Src/bno055.c  **** 	(prev_opmode_u8);
15917:Src/bno055.c  **** return com_rslt;
15918:Src/bno055.c  **** }
 30893              		.loc 1 15918 0
 30894 002c 40B2     		sxtb	r0, r0
 30895 002e 03B0     		add	sp, sp, #12
 30896              	.LCFI1284:
 30897              		.cfi_remember_state
 30898              		.cfi_def_cfa_offset 12
 30899              		@ sp needed
 30900 0030 30BD     		pop	{r4, r5, pc}
 30901              	.LVL3775:
 30902              	.L3414:
 30903              	.LCFI1285:
 30904              		.cfi_restore_state
15877:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 30905              		.loc 1 15877 0
 30906 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 30907 0036 5BBB     		cbnz	r3, .L3416
 30908              	.L3419:
 30909              	.LVL3776:
15882:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 30910              		.loc 1 15882 0
 30911 0038 0120     		movs	r0, #1
 30912 003a FFF7FEFF 		bl	bno055_write_page_id
 30913              	.LVL3777:
15883:Src/bno055.c  **** 				/* Write the value of
 30914              		.loc 1 15883 0
 30915 003e 0028     		cmp	r0, #0
 30916 0040 EFD1     		bne	.L3418
15886:Src/bno055.c  **** 				(p_bno055->dev_addr,
 30917              		.loc 1 15886 0
 30918 0042 2368     		ldr	r3, [r4]
 30919 0044 1721     		movs	r1, #23
 30920 0046 1C69     		ldr	r4, [r3, #16]
 30921 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 30922              	.LVL3778:
 30923 004a 0DF10602 		add	r2, sp, #6
 30924 004e 0123     		movs	r3, #1
 30925 0050 A047     		blx	r4
ARM GAS  /tmp/ccVWLGiI.s 			page 880


 30926              	.LVL3779:
 30927 0052 1349     		ldr	r1, .L3428
15890:Src/bno055.c  **** 					data_u8r =
 30928              		.loc 1 15890 0
 30929 0054 0446     		mov	r4, r0
 30930 0056 0028     		cmp	r0, #0
 30931 0058 E4D1     		bne	.L3415
15891:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 30932              		.loc 1 15891 0
 30933 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
15892:Src/bno055.c  **** 					BNO055_GYRO_ANY_MOTION_FILTER,
 30934              		.loc 1 15892 0
 30935 005e AB01     		lsls	r3, r5, #6
15896:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30936              		.loc 1 15896 0
 30937 0060 0968     		ldr	r1, [r1]
15891:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 30938              		.loc 1 15891 0
 30939 0062 22F04002 		bic	r2, r2, #64
 30940 0066 03F04003 		and	r3, r3, #64
 30941 006a 1343     		orrs	r3, r3, r2
15896:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30942              		.loc 1 15896 0
 30943 006c CC68     		ldr	r4, [r1, #12]
15891:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 30944              		.loc 1 15891 0
 30945 006e 8DF80630 		strb	r3, [sp, #6]
15896:Src/bno055.c  **** 					(p_bno055->dev_addr,
 30946              		.loc 1 15896 0
 30947 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 30948              	.LVL3780:
 30949 0074 0DF10602 		add	r2, sp, #6
 30950 0078 1721     		movs	r1, #23
 30951 007a 0123     		movs	r3, #1
 30952 007c A047     		blx	r4
 30953              	.LVL3781:
 30954 007e 0446     		mov	r4, r0
 30955              	.LVL3782:
 30956 0080 D0E7     		b	.L3415
 30957              	.L3427:
15915:Src/bno055.c  **** 	(prev_opmode_u8);
 30958              		.loc 1 15915 0
 30959 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 30960              	.LVL3783:
 30961 0086 2044     		add	r0, r0, r4
 30962 0088 C0B2     		uxtb	r0, r0
 30963              	.LVL3784:
 30964              		.loc 1 15918 0
 30965 008a 40B2     		sxtb	r0, r0
 30966 008c 03B0     		add	sp, sp, #12
 30967              	.LCFI1286:
 30968              		.cfi_remember_state
 30969              		.cfi_def_cfa_offset 12
 30970              		@ sp needed
 30971 008e 30BD     		pop	{r4, r5, pc}
 30972              	.LVL3785:
 30973              	.L3416:
ARM GAS  /tmp/ccVWLGiI.s 			page 881


 30974              	.LCFI1287:
 30975              		.cfi_restore_state
15878:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 30976              		.loc 1 15878 0
 30977 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 30978              	.LVL3786:
15880:Src/bno055.c  **** 			/* Write page as one */
 30979              		.loc 1 15880 0
 30980 0094 0028     		cmp	r0, #0
 30981 0096 C4D1     		bne	.L3418
 30982 0098 CEE7     		b	.L3419
 30983              	.LVL3787:
 30984              	.L3420:
15870:Src/bno055.c  **** } else {
 30985              		.loc 1 15870 0
 30986 009a 8120     		movs	r0, #129
 30987              	.LVL3788:
 30988 009c C6E7     		b	.L3413
 30989              	.L3429:
 30990 009e 00BF     		.align	2
 30991              	.L3428:
 30992 00a0 00000000 		.word	.LANCHOR0
 30993              		.cfi_endproc
 30994              	.LFE248:
 30996              		.section	.text.bno055_get_gyro_highrate_filter,"ax",%progbits
 30997              		.align	2
 30998              		.global	bno055_get_gyro_highrate_filter
 30999              		.thumb
 31000              		.thumb_func
 31002              	bno055_get_gyro_highrate_filter:
 31003              	.LFB249:
15919:Src/bno055.c  **** /*!
15920:Src/bno055.c  ****  *	@brief This API used to read gyro highrate filter
15921:Src/bno055.c  ****  *	from page one register from 0x17 bit 7
15922:Src/bno055.c  ****  *
15923:Src/bno055.c  ****  *	@param gyro_highrate_filter_u8 : The value of gyro highrate filter
15924:Src/bno055.c  ****  *   gyro_highrate_filter_u8  | result
15925:Src/bno055.c  ****  *  --------------------------- |------------
15926:Src/bno055.c  ****  *         0x00                 | BNO055_GYRO_FILTERED_CONFIG
15927:Src/bno055.c  ****  *         0x01                 | BNO055_GYRO_UNFILTERED_CONFIG
15928:Src/bno055.c  ****  *
15929:Src/bno055.c  ****  *	@return results of bus communication function
15930:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15931:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15932:Src/bno055.c  ****  *
15933:Src/bno055.c  ****  */
15934:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_filter(
15935:Src/bno055.c  **** u8 *gyro_highrate_filter_u8)
15936:Src/bno055.c  **** {
 31004              		.loc 1 15936 0
 31005              		.cfi_startproc
 31006              		@ args = 0, pretend = 0, frame = 8
 31007              		@ frame_needed = 0, uses_anonymous_args = 0
 31008              	.LVL3789:
 31009 0000 30B5     		push	{r4, r5, lr}
 31010              	.LCFI1288:
 31011              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 882


 31012              		.cfi_offset 4, -12
 31013              		.cfi_offset 5, -8
 31014              		.cfi_offset 14, -4
15937:Src/bno055.c  **** 	/* Variable used to return value of
15938:Src/bno055.c  **** 	communication routine*/
15939:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15940:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
15941:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
15942:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
15943:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 31015              		.loc 1 15943 0
 31016 0002 144C     		ldr	r4, .L3442
15936:Src/bno055.c  **** 	/* Variable used to return value of
 31017              		.loc 1 15936 0
 31018 0004 83B0     		sub	sp, sp, #12
 31019              	.LCFI1289:
 31020              		.cfi_def_cfa_offset 24
 31021              		.loc 1 15943 0
 31022 0006 2368     		ldr	r3, [r4]
15940:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 31023              		.loc 1 15940 0
 31024 0008 0022     		movs	r2, #0
 31025 000a 8DF80720 		strb	r2, [sp, #7]
 31026              	.LVL3790:
 31027              		.loc 1 15943 0
 31028 000e F3B1     		cbz	r3, .L3434
15944:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
15945:Src/bno055.c  **** 		} else {
15946:Src/bno055.c  **** 		/*condition check for page, gyro highrate filter is
15947:Src/bno055.c  **** 		available in the page one*/
15948:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 31029              		.loc 1 15948 0
 31030 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31031 0012 0546     		mov	r5, r0
 31032 0014 012A     		cmp	r2, #1
 31033 0016 04D0     		beq	.L3432
15949:Src/bno055.c  **** 			/* Write page as one */
15950:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 31034              		.loc 1 15950 0
 31035 0018 0120     		movs	r0, #1
 31036              	.LVL3791:
 31037 001a FFF7FEFF 		bl	bno055_write_page_id
 31038              	.LVL3792:
 31039 001e 2368     		ldr	r3, [r4]
15951:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 31040              		.loc 1 15951 0
 31041 0020 68B9     		cbnz	r0, .L3441
 31042              	.LVL3793:
 31043              	.L3432:
15952:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
15953:Src/bno055.c  **** 			/* Read the value of gyro highrate filter */
15954:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 31044              		.loc 1 15954 0
 31045 0022 1C69     		ldr	r4, [r3, #16]
 31046 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31047 0026 1721     		movs	r1, #23
 31048 0028 0123     		movs	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 883


 31049 002a 0DF10702 		add	r2, sp, #7
 31050 002e A047     		blx	r4
 31051              	.LVL3794:
15955:Src/bno055.c  **** 			(p_bno055->dev_addr,
15956:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_FILTER_REG,
15957:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
15958:Src/bno055.c  **** 			*gyro_highrate_filter_u8 =
15959:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 31052              		.loc 1 15959 0
 31053 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31054 0034 DB09     		lsrs	r3, r3, #7
15958:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 31055              		.loc 1 15958 0
 31056 0036 2B70     		strb	r3, [r5]
 31057              	.LVL3795:
 31058              	.L3431:
15960:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_FILTER);
15961:Src/bno055.c  **** 		} else {
15962:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
15963:Src/bno055.c  **** 		}
15964:Src/bno055.c  **** 	}
15965:Src/bno055.c  **** 	return com_rslt;
15966:Src/bno055.c  **** }
 31059              		.loc 1 15966 0
 31060 0038 40B2     		sxtb	r0, r0
 31061 003a 03B0     		add	sp, sp, #12
 31062              	.LCFI1290:
 31063              		.cfi_remember_state
 31064              		.cfi_def_cfa_offset 12
 31065              		@ sp needed
 31066 003c 30BD     		pop	{r4, r5, pc}
 31067              	.LVL3796:
 31068              	.L3441:
 31069              	.LCFI1291:
 31070              		.cfi_restore_state
15951:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31071              		.loc 1 15951 0 discriminator 1
 31072 003e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31073 0040 012A     		cmp	r2, #1
15962:Src/bno055.c  **** 		}
 31074              		.loc 1 15962 0 discriminator 1
 31075 0042 18BF     		it	ne
 31076 0044 FF20     		movne	r0, #255
15951:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31077              		.loc 1 15951 0 discriminator 1
 31078 0046 ECD0     		beq	.L3432
 31079              		.loc 1 15966 0
 31080 0048 40B2     		sxtb	r0, r0
 31081 004a 03B0     		add	sp, sp, #12
 31082              	.LCFI1292:
 31083              		.cfi_remember_state
 31084              		.cfi_def_cfa_offset 12
 31085              		@ sp needed
 31086 004c 30BD     		pop	{r4, r5, pc}
 31087              	.LVL3797:
 31088              	.L3434:
 31089              	.LCFI1293:
ARM GAS  /tmp/ccVWLGiI.s 			page 884


 31090              		.cfi_restore_state
15944:Src/bno055.c  **** 		} else {
 31091              		.loc 1 15944 0
 31092 004e 8120     		movs	r0, #129
 31093              	.LVL3798:
 31094 0050 F2E7     		b	.L3431
 31095              	.L3443:
 31096 0052 00BF     		.align	2
 31097              	.L3442:
 31098 0054 00000000 		.word	.LANCHOR0
 31099              		.cfi_endproc
 31100              	.LFE249:
 31102              		.section	.text.bno055_set_gyro_highrate_filter,"ax",%progbits
 31103              		.align	2
 31104              		.global	bno055_set_gyro_highrate_filter
 31105              		.thumb
 31106              		.thumb_func
 31108              	bno055_set_gyro_highrate_filter:
 31109              	.LFB250:
15967:Src/bno055.c  **** /*!
15968:Src/bno055.c  ****  *	@brief This API used to write gyro highrate filter
15969:Src/bno055.c  ****  *	from page one register from 0x17 bit 7
15970:Src/bno055.c  ****  *
15971:Src/bno055.c  ****  *	@param gyro_highrate_filter_u8 : The value of gyro highrate filter
15972:Src/bno055.c  ****  *   gyro_highrate_filter_u8  | result
15973:Src/bno055.c  ****  *  --------------------------- |------------
15974:Src/bno055.c  ****  *         0x00                 | BNO055_GYRO_FILTERED_CONFIG
15975:Src/bno055.c  ****  *         0x01                 | BNO055_GYRO_UNFILTERED_CONFIG
15976:Src/bno055.c  ****  *
15977:Src/bno055.c  ****  *	@return results of bus communication function
15978:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
15979:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
15980:Src/bno055.c  ****  *
15981:Src/bno055.c  ****  */
15982:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_filter(
15983:Src/bno055.c  **** u8 gyro_highrate_filter_u8)
15984:Src/bno055.c  **** {
 31110              		.loc 1 15984 0
 31111              		.cfi_startproc
 31112              		@ args = 0, pretend = 0, frame = 8
 31113              		@ frame_needed = 0, uses_anonymous_args = 0
 31114              	.LVL3799:
 31115 0000 30B5     		push	{r4, r5, lr}
 31116              	.LCFI1294:
 31117              		.cfi_def_cfa_offset 12
 31118              		.cfi_offset 4, -12
 31119              		.cfi_offset 5, -8
 31120              		.cfi_offset 14, -4
15985:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
15986:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
15987:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
15988:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
15989:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
15990:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
15991:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 31121              		.loc 1 15991 0
 31122 0002 264C     		ldr	r4, .L3460
ARM GAS  /tmp/ccVWLGiI.s 			page 885


15984:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 31123              		.loc 1 15984 0
 31124 0004 83B0     		sub	sp, sp, #12
 31125              	.LCFI1295:
 31126              		.cfi_def_cfa_offset 24
 31127              		.loc 1 15991 0
 31128 0006 2268     		ldr	r2, [r4]
15986:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 31129              		.loc 1 15986 0
 31130 0008 0023     		movs	r3, #0
 31131 000a 8DF80630 		strb	r3, [sp, #6]
 31132              	.LVL3800:
15989:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 31133              		.loc 1 15989 0
 31134 000e 8DF80730 		strb	r3, [sp, #7]
 31135              		.loc 1 15991 0
 31136 0012 002A     		cmp	r2, #0
 31137 0014 3FD0     		beq	.L3452
 31138 0016 0546     		mov	r5, r0
15992:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
15993:Src/bno055.c  **** } else {
15994:Src/bno055.c  **** /* The write operation effective only if the operation
15995:Src/bno055.c  **** mode is in config mode, this part of code is checking the
15996:Src/bno055.c  **** current operation mode and set the config mode */
15997:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 31139              		.loc 1 15997 0
 31140 0018 0DF10700 		add	r0, sp, #7
 31141              	.LVL3801:
 31142 001c FFF7FEFF 		bl	bno055_get_operation_mode
 31143              	.LVL3802:
15998:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 31144              		.loc 1 15998 0
 31145 0020 38B1     		cbz	r0, .L3446
 31146              	.LVL3803:
 31147              	.L3450:
15999:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16000:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16001:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16002:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16003:Src/bno055.c  **** 			/* Write page as one */
16004:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16005:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16006:Src/bno055.c  **** 				/* Write the value of
16007:Src/bno055.c  **** 				gyro highrate filter*/
16008:Src/bno055.c  **** 				com_rslt =
16009:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
16010:Src/bno055.c  **** 				(p_bno055->dev_addr,
16011:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_FILTER_REG,
16012:Src/bno055.c  **** 				&data_u8r,
16013:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
16014:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16015:Src/bno055.c  **** 					data_u8r =
16016:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16017:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_FILTER,
16018:Src/bno055.c  **** 					gyro_highrate_filter_u8);
16019:Src/bno055.c  **** 					com_rslt +=
16020:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
ARM GAS  /tmp/ccVWLGiI.s 			page 886


16021:Src/bno055.c  **** 					(p_bno055->dev_addr,
16022:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_FILTER_REG,
16023:Src/bno055.c  **** 					&data_u8r,
16024:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16025:Src/bno055.c  **** 				}
16026:Src/bno055.c  **** 			} else {
16027:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16028:Src/bno055.c  **** 			}
16029:Src/bno055.c  **** 		} else {
16030:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16031:Src/bno055.c  **** 		}
16032:Src/bno055.c  **** 	} else {
16033:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 31148              		.loc 1 16033 0
 31149 0022 FF24     		movs	r4, #255
 31150              	.LVL3804:
 31151              	.L3447:
16034:Src/bno055.c  **** 	}
16035:Src/bno055.c  **** }
16036:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 31152              		.loc 1 16036 0
 31153 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 31154 0028 48BB     		cbnz	r0, .L3459
 31155 002a 2046     		mov	r0, r4
 31156              	.LVL3805:
 31157              	.L3445:
16037:Src/bno055.c  **** 	/* set the operation mode of
16038:Src/bno055.c  **** 	previous operation mode*/
16039:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
16040:Src/bno055.c  **** 	(prev_opmode_u8);
16041:Src/bno055.c  **** return com_rslt;
16042:Src/bno055.c  **** }
 31158              		.loc 1 16042 0
 31159 002c 40B2     		sxtb	r0, r0
 31160 002e 03B0     		add	sp, sp, #12
 31161              	.LCFI1296:
 31162              		.cfi_remember_state
 31163              		.cfi_def_cfa_offset 12
 31164              		@ sp needed
 31165 0030 30BD     		pop	{r4, r5, pc}
 31166              	.LVL3806:
 31167              	.L3446:
 31168              	.LCFI1297:
 31169              		.cfi_restore_state
15999:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 31170              		.loc 1 15999 0
 31171 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31172 0036 4BBB     		cbnz	r3, .L3448
 31173              	.L3451:
 31174              	.LVL3807:
16004:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 31175              		.loc 1 16004 0
 31176 0038 0120     		movs	r0, #1
 31177 003a FFF7FEFF 		bl	bno055_write_page_id
 31178              	.LVL3808:
16005:Src/bno055.c  **** 				/* Write the value of
 31179              		.loc 1 16005 0
ARM GAS  /tmp/ccVWLGiI.s 			page 887


 31180 003e 0028     		cmp	r0, #0
 31181 0040 EFD1     		bne	.L3450
16009:Src/bno055.c  **** 				(p_bno055->dev_addr,
 31182              		.loc 1 16009 0
 31183 0042 2368     		ldr	r3, [r4]
16008:Src/bno055.c  **** 				p_bno055->BNO055_BUS_READ_FUNC
 31184              		.loc 1 16008 0
 31185 0044 0DF10602 		add	r2, sp, #6
 31186 0048 1C69     		ldr	r4, [r3, #16]
 31187 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31188              	.LVL3809:
 31189 004c 1721     		movs	r1, #23
 31190 004e 0123     		movs	r3, #1
 31191 0050 A047     		blx	r4
 31192              	.LVL3810:
16009:Src/bno055.c  **** 				(p_bno055->dev_addr,
 31193              		.loc 1 16009 0
 31194 0052 124B     		ldr	r3, .L3460
16014:Src/bno055.c  **** 					data_u8r =
 31195              		.loc 1 16014 0
 31196 0054 0446     		mov	r4, r0
 31197 0056 0028     		cmp	r0, #0
 31198 0058 E4D1     		bne	.L3447
16015:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31199              		.loc 1 16015 0
 31200 005a 9DF80600 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 31201              	.LVL3811:
16020:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31202              		.loc 1 16020 0
 31203 005e 1B68     		ldr	r3, [r3]
16015:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31204              		.loc 1 16015 0
 31205 0060 00F07F00 		and	r0, r0, #127
 31206 0064 40EAC510 		orr	r0, r0, r5, lsl #7
16020:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31207              		.loc 1 16020 0
 31208 0068 DC68     		ldr	r4, [r3, #12]
16015:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31209              		.loc 1 16015 0
 31210 006a 8DF80600 		strb	r0, [sp, #6]
16020:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31211              		.loc 1 16020 0
 31212 006e 0DF10602 		add	r2, sp, #6
 31213 0072 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31214 0074 1721     		movs	r1, #23
 31215 0076 0123     		movs	r3, #1
 31216 0078 A047     		blx	r4
 31217              	.LVL3812:
 31218 007a 0446     		mov	r4, r0
 31219              	.LVL3813:
 31220 007c D2E7     		b	.L3447
 31221              	.L3459:
16039:Src/bno055.c  **** 	(prev_opmode_u8);
 31222              		.loc 1 16039 0
 31223 007e FFF7FEFF 		bl	bno055_set_operation_mode
 31224              	.LVL3814:
 31225 0082 2044     		add	r0, r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 888


 31226 0084 C0B2     		uxtb	r0, r0
 31227              	.LVL3815:
 31228              		.loc 1 16042 0
 31229 0086 40B2     		sxtb	r0, r0
 31230 0088 03B0     		add	sp, sp, #12
 31231              	.LCFI1298:
 31232              		.cfi_remember_state
 31233              		.cfi_def_cfa_offset 12
 31234              		@ sp needed
 31235 008a 30BD     		pop	{r4, r5, pc}
 31236              	.LVL3816:
 31237              	.L3448:
 31238              	.LCFI1299:
 31239              		.cfi_restore_state
16000:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 31240              		.loc 1 16000 0
 31241 008c FFF7FEFF 		bl	bno055_set_operation_mode
 31242              	.LVL3817:
16002:Src/bno055.c  **** 			/* Write page as one */
 31243              		.loc 1 16002 0
 31244 0090 0028     		cmp	r0, #0
 31245 0092 C6D1     		bne	.L3450
 31246 0094 D0E7     		b	.L3451
 31247              	.LVL3818:
 31248              	.L3452:
15992:Src/bno055.c  **** } else {
 31249              		.loc 1 15992 0
 31250 0096 8120     		movs	r0, #129
 31251              	.LVL3819:
 31252 0098 C8E7     		b	.L3445
 31253              	.L3461:
 31254 009a 00BF     		.align	2
 31255              	.L3460:
 31256 009c 00000000 		.word	.LANCHOR0
 31257              		.cfi_endproc
 31258              	.LFE250:
 31260              		.section	.text.bno055_get_gyro_highrate_x_thres,"ax",%progbits
 31261              		.align	2
 31262              		.global	bno055_get_gyro_highrate_x_thres
 31263              		.thumb
 31264              		.thumb_func
 31266              	bno055_get_gyro_highrate_x_thres:
 31267              	.LFB251:
16043:Src/bno055.c  **** /*!
16044:Src/bno055.c  ****  *	@brief This API used to read gyro highrate x threshold
16045:Src/bno055.c  ****  *	from page one register from 0x18 bit 0 to 4
16046:Src/bno055.c  ****  *
16047:Src/bno055.c  ****  *	@param gyro_highrate_x_thres_u8 : The value of gyro x highrate threshold
16048:Src/bno055.c  ****  *
16049:Src/bno055.c  ****  *	@return results of bus communication function
16050:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16051:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16052:Src/bno055.c  ****  *
16053:Src/bno055.c  ****  *	@note Gyro highrate threshold dependent on the
16054:Src/bno055.c  ****  *	selection of gyro range
16055:Src/bno055.c  ****  *
16056:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold		|     LSB
ARM GAS  /tmp/ccVWLGiI.s 			page 889


16057:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16058:Src/bno055.c  ****  *     2000           |    62.5dps      |   1LSB
16059:Src/bno055.c  ****  *     1000           |    31.25dps     |   1LSB
16060:Src/bno055.c  ****  *     500            |    15.625dps    |   1LSB
16061:Src/bno055.c  ****  *     125            |    7.8125dps    |   1LSB
16062:Src/bno055.c  ****  *
16063:Src/bno055.c  ****  */
16064:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_x_thres(
16065:Src/bno055.c  **** u8 *gyro_highrate_x_thres_u8)
16066:Src/bno055.c  **** {
 31268              		.loc 1 16066 0
 31269              		.cfi_startproc
 31270              		@ args = 0, pretend = 0, frame = 8
 31271              		@ frame_needed = 0, uses_anonymous_args = 0
 31272              	.LVL3820:
 31273 0000 30B5     		push	{r4, r5, lr}
 31274              	.LCFI1300:
 31275              		.cfi_def_cfa_offset 12
 31276              		.cfi_offset 4, -12
 31277              		.cfi_offset 5, -8
 31278              		.cfi_offset 14, -4
16067:Src/bno055.c  **** 	/* Variable used to return value of
16068:Src/bno055.c  **** 	communication routine*/
16069:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16070:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16071:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16072:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16073:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 31279              		.loc 1 16073 0
 31280 0002 144C     		ldr	r4, .L3474
16066:Src/bno055.c  **** 	/* Variable used to return value of
 31281              		.loc 1 16066 0
 31282 0004 83B0     		sub	sp, sp, #12
 31283              	.LCFI1301:
 31284              		.cfi_def_cfa_offset 24
 31285              		.loc 1 16073 0
 31286 0006 2368     		ldr	r3, [r4]
16070:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 31287              		.loc 1 16070 0
 31288 0008 0022     		movs	r2, #0
 31289 000a 8DF80720 		strb	r2, [sp, #7]
 31290              	.LVL3821:
 31291              		.loc 1 16073 0
 31292 000e FBB1     		cbz	r3, .L3466
16074:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16075:Src/bno055.c  **** 		} else {
16076:Src/bno055.c  **** 		/*condition check for page, gyro highrate x threshold is
16077:Src/bno055.c  **** 		available in the page one*/
16078:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 31293              		.loc 1 16078 0
 31294 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31295 0012 0546     		mov	r5, r0
 31296 0014 012A     		cmp	r2, #1
 31297 0016 04D0     		beq	.L3464
16079:Src/bno055.c  **** 			/* Write page as one */
16080:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 31298              		.loc 1 16080 0
ARM GAS  /tmp/ccVWLGiI.s 			page 890


 31299 0018 0120     		movs	r0, #1
 31300              	.LVL3822:
 31301 001a FFF7FEFF 		bl	bno055_write_page_id
 31302              	.LVL3823:
 31303 001e 2368     		ldr	r3, [r4]
16081:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 31304              		.loc 1 16081 0
 31305 0020 70B9     		cbnz	r0, .L3473
 31306              	.LVL3824:
 31307              	.L3464:
16082:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16083:Src/bno055.c  **** 			/* Read the value of gyro highrate threshold*/
16084:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 31308              		.loc 1 16084 0
 31309 0022 1C69     		ldr	r4, [r3, #16]
 31310 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31311 0026 1821     		movs	r1, #24
 31312 0028 0123     		movs	r3, #1
 31313 002a 0DF10702 		add	r2, sp, #7
 31314 002e A047     		blx	r4
 31315              	.LVL3825:
16085:Src/bno055.c  **** 			(p_bno055->dev_addr,
16086:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_X_THRES_REG,
16087:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16088:Src/bno055.c  **** 			*gyro_highrate_x_thres_u8 =
 31316              		.loc 1 16088 0
 31317 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31318 0034 03F01F03 		and	r3, r3, #31
 31319 0038 2B70     		strb	r3, [r5]
 31320              	.LVL3826:
 31321              	.L3463:
16089:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
16090:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_X_THRES);
16091:Src/bno055.c  **** 		} else {
16092:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16093:Src/bno055.c  **** 		}
16094:Src/bno055.c  **** 	}
16095:Src/bno055.c  **** 	return com_rslt;
16096:Src/bno055.c  **** }
 31322              		.loc 1 16096 0
 31323 003a 40B2     		sxtb	r0, r0
 31324 003c 03B0     		add	sp, sp, #12
 31325              	.LCFI1302:
 31326              		.cfi_remember_state
 31327              		.cfi_def_cfa_offset 12
 31328              		@ sp needed
 31329 003e 30BD     		pop	{r4, r5, pc}
 31330              	.LVL3827:
 31331              	.L3473:
 31332              	.LCFI1303:
 31333              		.cfi_restore_state
16081:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31334              		.loc 1 16081 0 discriminator 1
 31335 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31336 0042 012A     		cmp	r2, #1
16092:Src/bno055.c  **** 		}
 31337              		.loc 1 16092 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 891


 31338 0044 18BF     		it	ne
 31339 0046 FF20     		movne	r0, #255
16081:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31340              		.loc 1 16081 0 discriminator 1
 31341 0048 EBD0     		beq	.L3464
 31342              		.loc 1 16096 0
 31343 004a 40B2     		sxtb	r0, r0
 31344 004c 03B0     		add	sp, sp, #12
 31345              	.LCFI1304:
 31346              		.cfi_remember_state
 31347              		.cfi_def_cfa_offset 12
 31348              		@ sp needed
 31349 004e 30BD     		pop	{r4, r5, pc}
 31350              	.LVL3828:
 31351              	.L3466:
 31352              	.LCFI1305:
 31353              		.cfi_restore_state
16074:Src/bno055.c  **** 		} else {
 31354              		.loc 1 16074 0
 31355 0050 8120     		movs	r0, #129
 31356              	.LVL3829:
 31357 0052 F2E7     		b	.L3463
 31358              	.L3475:
 31359              		.align	2
 31360              	.L3474:
 31361 0054 00000000 		.word	.LANCHOR0
 31362              		.cfi_endproc
 31363              	.LFE251:
 31365              		.section	.text.bno055_set_gyro_highrate_x_thres,"ax",%progbits
 31366              		.align	2
 31367              		.global	bno055_set_gyro_highrate_x_thres
 31368              		.thumb
 31369              		.thumb_func
 31371              	bno055_set_gyro_highrate_x_thres:
 31372              	.LFB252:
16097:Src/bno055.c  **** /*!
16098:Src/bno055.c  ****  *	@brief This API used to write gyro highrate x threshold
16099:Src/bno055.c  ****  *	from page one register from 0x18 bit 0 to 4
16100:Src/bno055.c  ****  *
16101:Src/bno055.c  ****  *	@param gyro_highrate_x_thres_u8 : The value of gyro x highrate threshold
16102:Src/bno055.c  ****  *
16103:Src/bno055.c  ****  *	@return results of bus communication function
16104:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16105:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16106:Src/bno055.c  ****  *
16107:Src/bno055.c  ****  *	@note Gyro highrate threshold dependent on the
16108:Src/bno055.c  ****  *	selection of gyro range
16109:Src/bno055.c  ****  *
16110:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold		|     LSB
16111:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16112:Src/bno055.c  ****  *     2000           |    62.5dps      |   1LSB
16113:Src/bno055.c  ****  *     1000           |    31.25dps     |   1LSB
16114:Src/bno055.c  ****  *     500            |    15.625dps    |   1LSB
16115:Src/bno055.c  ****  *     125            |    7.8125dps    |   1LSB
16116:Src/bno055.c  ****  *
16117:Src/bno055.c  ****  */
16118:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_x_thres(
ARM GAS  /tmp/ccVWLGiI.s 			page 892


16119:Src/bno055.c  **** u8 gyro_highrate_x_thres_u8)
16120:Src/bno055.c  **** {
 31373              		.loc 1 16120 0
 31374              		.cfi_startproc
 31375              		@ args = 0, pretend = 0, frame = 8
 31376              		@ frame_needed = 0, uses_anonymous_args = 0
 31377              	.LVL3830:
 31378 0000 30B5     		push	{r4, r5, lr}
 31379              	.LCFI1306:
 31380              		.cfi_def_cfa_offset 12
 31381              		.cfi_offset 4, -12
 31382              		.cfi_offset 5, -8
 31383              		.cfi_offset 14, -4
16121:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16122:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16123:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16124:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
16125:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16126:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16127:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 31384              		.loc 1 16127 0
 31385 0002 264C     		ldr	r4, .L3492
16120:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 31386              		.loc 1 16120 0
 31387 0004 83B0     		sub	sp, sp, #12
 31388              	.LCFI1307:
 31389              		.cfi_def_cfa_offset 24
 31390              		.loc 1 16127 0
 31391 0006 2268     		ldr	r2, [r4]
16122:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 31392              		.loc 1 16122 0
 31393 0008 0023     		movs	r3, #0
 31394 000a 8DF80630 		strb	r3, [sp, #6]
 31395              	.LVL3831:
16124:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 31396              		.loc 1 16124 0
 31397 000e 8DF80730 		strb	r3, [sp, #7]
 31398              	.LVL3832:
 31399              		.loc 1 16127 0
 31400 0012 002A     		cmp	r2, #0
 31401 0014 40D0     		beq	.L3484
 31402 0016 0546     		mov	r5, r0
16128:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16129:Src/bno055.c  **** } else {
16130:Src/bno055.c  **** /* The write operation effective only if the operation
16131:Src/bno055.c  **** mode is in config mode, this part of code is checking the
16132:Src/bno055.c  **** current operation mode and set the config mode */
16133:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 31403              		.loc 1 16133 0
 31404 0018 0DF10700 		add	r0, sp, #7
 31405              	.LVL3833:
 31406 001c FFF7FEFF 		bl	bno055_get_operation_mode
 31407              	.LVL3834:
16134:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 31408              		.loc 1 16134 0
 31409 0020 38B1     		cbz	r0, .L3478
 31410              	.LVL3835:
ARM GAS  /tmp/ccVWLGiI.s 			page 893


 31411              	.L3482:
16135:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16136:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16137:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16138:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16139:Src/bno055.c  **** 			/* Write page as one */
16140:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16141:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16142:Src/bno055.c  **** 				/* Write the value of
16143:Src/bno055.c  **** 				gyro highrate x threshold*/
16144:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16145:Src/bno055.c  **** 				(p_bno055->dev_addr,
16146:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_THRES_REG,
16147:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16148:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16149:Src/bno055.c  **** 					data_u8r =
16150:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16151:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_THRES,
16152:Src/bno055.c  **** 					gyro_highrate_x_thres_u8);
16153:Src/bno055.c  **** 					com_rslt +=
16154:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16155:Src/bno055.c  **** 					(p_bno055->dev_addr,
16156:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_THRES_REG,
16157:Src/bno055.c  **** 					&data_u8r,
16158:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16159:Src/bno055.c  **** 				}
16160:Src/bno055.c  **** 			} else {
16161:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16162:Src/bno055.c  **** 			}
16163:Src/bno055.c  **** 		} else {
16164:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16165:Src/bno055.c  **** 		}
16166:Src/bno055.c  **** 	} else {
16167:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 31412              		.loc 1 16167 0
 31413 0022 FF24     		movs	r4, #255
 31414              	.LVL3836:
 31415              	.L3479:
16168:Src/bno055.c  **** 	}
16169:Src/bno055.c  **** }
16170:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 31416              		.loc 1 16170 0
 31417 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 31418 0028 50BB     		cbnz	r0, .L3491
 31419 002a 2046     		mov	r0, r4
 31420              	.LVL3837:
 31421              	.L3477:
16171:Src/bno055.c  **** 	/* set the operation mode of
16172:Src/bno055.c  **** 	previous operation mode*/
16173:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
16174:Src/bno055.c  **** 	(prev_opmode_u8);
16175:Src/bno055.c  **** return com_rslt;
16176:Src/bno055.c  **** }
 31422              		.loc 1 16176 0
 31423 002c 40B2     		sxtb	r0, r0
 31424 002e 03B0     		add	sp, sp, #12
 31425              	.LCFI1308:
ARM GAS  /tmp/ccVWLGiI.s 			page 894


 31426              		.cfi_remember_state
 31427              		.cfi_def_cfa_offset 12
 31428              		@ sp needed
 31429 0030 30BD     		pop	{r4, r5, pc}
 31430              	.LVL3838:
 31431              	.L3478:
 31432              	.LCFI1309:
 31433              		.cfi_restore_state
16135:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 31434              		.loc 1 16135 0
 31435 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31436 0036 53BB     		cbnz	r3, .L3480
 31437              	.L3483:
 31438              	.LVL3839:
16140:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 31439              		.loc 1 16140 0
 31440 0038 0120     		movs	r0, #1
 31441 003a FFF7FEFF 		bl	bno055_write_page_id
 31442              	.LVL3840:
16141:Src/bno055.c  **** 				/* Write the value of
 31443              		.loc 1 16141 0
 31444 003e 0028     		cmp	r0, #0
 31445 0040 EFD1     		bne	.L3482
16144:Src/bno055.c  **** 				(p_bno055->dev_addr,
 31446              		.loc 1 16144 0
 31447 0042 2368     		ldr	r3, [r4]
 31448 0044 0DF10602 		add	r2, sp, #6
 31449 0048 1C69     		ldr	r4, [r3, #16]
 31450 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31451              	.LVL3841:
 31452 004c 1821     		movs	r1, #24
 31453 004e 0123     		movs	r3, #1
 31454 0050 A047     		blx	r4
 31455              	.LVL3842:
 31456 0052 124A     		ldr	r2, .L3492
16148:Src/bno055.c  **** 					data_u8r =
 31457              		.loc 1 16148 0
 31458 0054 0446     		mov	r4, r0
 31459 0056 0028     		cmp	r0, #0
 31460 0058 E4D1     		bne	.L3479
16149:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31461              		.loc 1 16149 0
 31462 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
16154:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31463              		.loc 1 16154 0
 31464 005e 1168     		ldr	r1, [r2]
16149:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31465              		.loc 1 16149 0
 31466 0060 23F01F03 		bic	r3, r3, #31
 31467 0064 05F01F00 		and	r0, r5, #31
 31468              	.LVL3843:
 31469 0068 1843     		orrs	r0, r0, r3
16154:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31470              		.loc 1 16154 0
 31471 006a CC68     		ldr	r4, [r1, #12]
16149:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31472              		.loc 1 16149 0
ARM GAS  /tmp/ccVWLGiI.s 			page 895


 31473 006c 8DF80600 		strb	r0, [sp, #6]
16154:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31474              		.loc 1 16154 0
 31475 0070 0DF10602 		add	r2, sp, #6
 31476 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 31477 0076 0123     		movs	r3, #1
 31478 0078 1821     		movs	r1, #24
 31479 007a A047     		blx	r4
 31480              	.LVL3844:
 31481 007c 0446     		mov	r4, r0
 31482              	.LVL3845:
 31483 007e D1E7     		b	.L3479
 31484              	.L3491:
16173:Src/bno055.c  **** 	(prev_opmode_u8);
 31485              		.loc 1 16173 0
 31486 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 31487              	.LVL3846:
 31488 0084 2044     		add	r0, r0, r4
 31489 0086 C0B2     		uxtb	r0, r0
 31490              	.LVL3847:
 31491              		.loc 1 16176 0
 31492 0088 40B2     		sxtb	r0, r0
 31493 008a 03B0     		add	sp, sp, #12
 31494              	.LCFI1310:
 31495              		.cfi_remember_state
 31496              		.cfi_def_cfa_offset 12
 31497              		@ sp needed
 31498 008c 30BD     		pop	{r4, r5, pc}
 31499              	.LVL3848:
 31500              	.L3480:
 31501              	.LCFI1311:
 31502              		.cfi_restore_state
16136:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 31503              		.loc 1 16136 0
 31504 008e FFF7FEFF 		bl	bno055_set_operation_mode
 31505              	.LVL3849:
16138:Src/bno055.c  **** 			/* Write page as one */
 31506              		.loc 1 16138 0
 31507 0092 0028     		cmp	r0, #0
 31508 0094 C5D1     		bne	.L3482
 31509 0096 CFE7     		b	.L3483
 31510              	.LVL3850:
 31511              	.L3484:
16128:Src/bno055.c  **** } else {
 31512              		.loc 1 16128 0
 31513 0098 8120     		movs	r0, #129
 31514              	.LVL3851:
 31515 009a C7E7     		b	.L3477
 31516              	.L3493:
 31517              		.align	2
 31518              	.L3492:
 31519 009c 00000000 		.word	.LANCHOR0
 31520              		.cfi_endproc
 31521              	.LFE252:
 31523              		.section	.text.bno055_get_gyro_highrate_x_hyst,"ax",%progbits
 31524              		.align	2
 31525              		.global	bno055_get_gyro_highrate_x_hyst
ARM GAS  /tmp/ccVWLGiI.s 			page 896


 31526              		.thumb
 31527              		.thumb_func
 31529              	bno055_get_gyro_highrate_x_hyst:
 31530              	.LFB253:
16177:Src/bno055.c  **** /*!
16178:Src/bno055.c  ****  *	@brief This API used to read gyro highrate x hysteresis
16179:Src/bno055.c  ****  *	from page one register from 0x18 bit 5 to 6
16180:Src/bno055.c  ****  *
16181:Src/bno055.c  ****  *	@param gyro_highrate_x_hyst_u8 : The value of gyro highrate x hysteresis
16182:Src/bno055.c  ****  *
16183:Src/bno055.c  ****  *	@return results of bus communication function
16184:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16185:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16186:Src/bno055.c  ****  *
16187:Src/bno055.c  ****  *	@note Gyro high rate hysteresis calculated by
16188:Src/bno055.c  ****  *
16189:Src/bno055.c  ****  *	using this (255 + 256 * gyro_highrate_x_hyst_u8) *4 LSB
16190:Src/bno055.c  ****  *
16191:Src/bno055.c  ****  *	The high rate value scales with the range setting
16192:Src/bno055.c  ****  *
16193:Src/bno055.c  ****  *  gyro_range_u8	  |	hysteresis		|     LSB
16194:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16195:Src/bno055.c  ****  *     2000           |    62.26dps     |   1LSB
16196:Src/bno055.c  ****  *     1000           |    31.13dps     |   1LSB
16197:Src/bno055.c  ****  *     500            |    15.56dps     |   1LSB
16198:Src/bno055.c  ****  *
16199:Src/bno055.c  ****  */
16200:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_x_hyst(
16201:Src/bno055.c  **** u8 *gyro_highrate_x_hyst_u8)
16202:Src/bno055.c  **** {
 31531              		.loc 1 16202 0
 31532              		.cfi_startproc
 31533              		@ args = 0, pretend = 0, frame = 8
 31534              		@ frame_needed = 0, uses_anonymous_args = 0
 31535              	.LVL3852:
 31536 0000 30B5     		push	{r4, r5, lr}
 31537              	.LCFI1312:
 31538              		.cfi_def_cfa_offset 12
 31539              		.cfi_offset 4, -12
 31540              		.cfi_offset 5, -8
 31541              		.cfi_offset 14, -4
16203:Src/bno055.c  **** 	/* Variable used to return value of
16204:Src/bno055.c  **** 	communication routine*/
16205:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16206:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16207:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16208:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16209:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 31542              		.loc 1 16209 0
 31543 0002 144C     		ldr	r4, .L3506
16202:Src/bno055.c  **** 	/* Variable used to return value of
 31544              		.loc 1 16202 0
 31545 0004 83B0     		sub	sp, sp, #12
 31546              	.LCFI1313:
 31547              		.cfi_def_cfa_offset 24
 31548              		.loc 1 16209 0
 31549 0006 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 897


16206:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 31550              		.loc 1 16206 0
 31551 0008 0022     		movs	r2, #0
 31552 000a 8DF80720 		strb	r2, [sp, #7]
 31553              	.LVL3853:
 31554              		.loc 1 16209 0
 31555 000e FBB1     		cbz	r3, .L3498
16210:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16211:Src/bno055.c  **** 		} else {
16212:Src/bno055.c  **** 		/*condition check for page,gyro highrate x hysteresis is
16213:Src/bno055.c  **** 		available in the page one*/
16214:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 31556              		.loc 1 16214 0
 31557 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31558 0012 0546     		mov	r5, r0
 31559 0014 012A     		cmp	r2, #1
 31560 0016 04D0     		beq	.L3496
16215:Src/bno055.c  **** 			/* Write page as one */
16216:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 31561              		.loc 1 16216 0
 31562 0018 0120     		movs	r0, #1
 31563              	.LVL3854:
 31564 001a FFF7FEFF 		bl	bno055_write_page_id
 31565              	.LVL3855:
 31566 001e 2368     		ldr	r3, [r4]
16217:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 31567              		.loc 1 16217 0
 31568 0020 70B9     		cbnz	r0, .L3505
 31569              	.LVL3856:
 31570              	.L3496:
16218:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16219:Src/bno055.c  **** 			/* Read the value of gyro highrate x hysteresis*/
16220:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 31571              		.loc 1 16220 0
 31572 0022 1C69     		ldr	r4, [r3, #16]
 31573 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31574 0026 1821     		movs	r1, #24
 31575 0028 0123     		movs	r3, #1
 31576 002a 0DF10702 		add	r2, sp, #7
 31577 002e A047     		blx	r4
 31578              	.LVL3857:
16221:Src/bno055.c  **** 			(p_bno055->dev_addr,
16222:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_X_HYST_REG,
16223:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16224:Src/bno055.c  **** 			*gyro_highrate_x_hyst_u8 =
16225:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 31579              		.loc 1 16225 0
 31580 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31581 0034 C3F34113 		ubfx	r3, r3, #5, #2
16224:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 31582              		.loc 1 16224 0
 31583 0038 2B70     		strb	r3, [r5]
 31584              	.LVL3858:
 31585              	.L3495:
16226:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_X_HYST);
16227:Src/bno055.c  **** 		} else {
16228:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 898


16229:Src/bno055.c  **** 		}
16230:Src/bno055.c  **** 	}
16231:Src/bno055.c  **** 	return com_rslt;
16232:Src/bno055.c  **** }
 31586              		.loc 1 16232 0
 31587 003a 40B2     		sxtb	r0, r0
 31588 003c 03B0     		add	sp, sp, #12
 31589              	.LCFI1314:
 31590              		.cfi_remember_state
 31591              		.cfi_def_cfa_offset 12
 31592              		@ sp needed
 31593 003e 30BD     		pop	{r4, r5, pc}
 31594              	.LVL3859:
 31595              	.L3505:
 31596              	.LCFI1315:
 31597              		.cfi_restore_state
16217:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31598              		.loc 1 16217 0 discriminator 1
 31599 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31600 0042 012A     		cmp	r2, #1
16228:Src/bno055.c  **** 		}
 31601              		.loc 1 16228 0 discriminator 1
 31602 0044 18BF     		it	ne
 31603 0046 FF20     		movne	r0, #255
16217:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31604              		.loc 1 16217 0 discriminator 1
 31605 0048 EBD0     		beq	.L3496
 31606              		.loc 1 16232 0
 31607 004a 40B2     		sxtb	r0, r0
 31608 004c 03B0     		add	sp, sp, #12
 31609              	.LCFI1316:
 31610              		.cfi_remember_state
 31611              		.cfi_def_cfa_offset 12
 31612              		@ sp needed
 31613 004e 30BD     		pop	{r4, r5, pc}
 31614              	.LVL3860:
 31615              	.L3498:
 31616              	.LCFI1317:
 31617              		.cfi_restore_state
16210:Src/bno055.c  **** 		} else {
 31618              		.loc 1 16210 0
 31619 0050 8120     		movs	r0, #129
 31620              	.LVL3861:
 31621 0052 F2E7     		b	.L3495
 31622              	.L3507:
 31623              		.align	2
 31624              	.L3506:
 31625 0054 00000000 		.word	.LANCHOR0
 31626              		.cfi_endproc
 31627              	.LFE253:
 31629              		.section	.text.bno055_set_gyro_highrate_x_hyst,"ax",%progbits
 31630              		.align	2
 31631              		.global	bno055_set_gyro_highrate_x_hyst
 31632              		.thumb
 31633              		.thumb_func
 31635              	bno055_set_gyro_highrate_x_hyst:
 31636              	.LFB254:
ARM GAS  /tmp/ccVWLGiI.s 			page 899


16233:Src/bno055.c  **** /*!
16234:Src/bno055.c  ****  *	@brief This API used to write gyro highrate x hysteresis
16235:Src/bno055.c  ****  *	from page one register from 0x18 bit 5 to 6
16236:Src/bno055.c  ****  *
16237:Src/bno055.c  ****  *	@param gyro_highrate_x_hyst_u8 : The value of gyro highrate x hysteresis
16238:Src/bno055.c  ****  *
16239:Src/bno055.c  ****  *	@return results of bus communication function
16240:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16241:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16242:Src/bno055.c  ****  *
16243:Src/bno055.c  ****  *	@note Gyro high rate hysteresis calculated by
16244:Src/bno055.c  ****  *
16245:Src/bno055.c  ****  *	using this (255 + 256 * gyro_highrate_x_hyst_u8) *4 LSB
16246:Src/bno055.c  ****  *
16247:Src/bno055.c  ****  *	The high rate value scales with the range setting
16248:Src/bno055.c  ****  *
16249:Src/bno055.c  ****  *  gyro_range_u8	  |	hysteresis		|     LSB
16250:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16251:Src/bno055.c  ****  *     2000           |    62.26dps     |   1LSB
16252:Src/bno055.c  ****  *     1000           |    31.13dps     |   1LSB
16253:Src/bno055.c  ****  *     500            |    15.56dps     |   1LSB
16254:Src/bno055.c  ****  *
16255:Src/bno055.c  ****  */
16256:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_x_hyst(
16257:Src/bno055.c  **** u8 gyro_highrate_x_hyst_u8)
16258:Src/bno055.c  **** {
 31637              		.loc 1 16258 0
 31638              		.cfi_startproc
 31639              		@ args = 0, pretend = 0, frame = 8
 31640              		@ frame_needed = 0, uses_anonymous_args = 0
 31641              	.LVL3862:
 31642 0000 30B5     		push	{r4, r5, lr}
 31643              	.LCFI1318:
 31644              		.cfi_def_cfa_offset 12
 31645              		.cfi_offset 4, -12
 31646              		.cfi_offset 5, -8
 31647              		.cfi_offset 14, -4
16259:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16260:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16261:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16262:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
16263:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16264:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16265:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 31648              		.loc 1 16265 0
 31649 0002 274C     		ldr	r4, .L3524
16258:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 31650              		.loc 1 16258 0
 31651 0004 83B0     		sub	sp, sp, #12
 31652              	.LCFI1319:
 31653              		.cfi_def_cfa_offset 24
 31654              		.loc 1 16265 0
 31655 0006 2268     		ldr	r2, [r4]
16260:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 31656              		.loc 1 16260 0
 31657 0008 0023     		movs	r3, #0
 31658 000a 8DF80630 		strb	r3, [sp, #6]
ARM GAS  /tmp/ccVWLGiI.s 			page 900


 31659              	.LVL3863:
16262:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 31660              		.loc 1 16262 0
 31661 000e 8DF80730 		strb	r3, [sp, #7]
 31662              	.LVL3864:
 31663              		.loc 1 16265 0
 31664 0012 002A     		cmp	r2, #0
 31665 0014 41D0     		beq	.L3516
 31666 0016 0546     		mov	r5, r0
16266:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16267:Src/bno055.c  **** } else {
16268:Src/bno055.c  **** /* The write operation effective only if the operation
16269:Src/bno055.c  **** mode is in config mode, this part of code is checking the
16270:Src/bno055.c  **** current operation mode and set the config mode */
16271:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 31667              		.loc 1 16271 0
 31668 0018 0DF10700 		add	r0, sp, #7
 31669              	.LVL3865:
 31670 001c FFF7FEFF 		bl	bno055_get_operation_mode
 31671              	.LVL3866:
16272:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 31672              		.loc 1 16272 0
 31673 0020 38B1     		cbz	r0, .L3510
 31674              	.LVL3867:
 31675              	.L3514:
16273:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16274:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16275:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16276:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16277:Src/bno055.c  **** 			/* Write page as one */
16278:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16279:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16280:Src/bno055.c  **** 				/*Write the value of
16281:Src/bno055.c  **** 				gyro highrate x hysteresis*/
16282:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16283:Src/bno055.c  **** 				(p_bno055->dev_addr,
16284:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_HYST_REG,
16285:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16286:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16287:Src/bno055.c  **** 					data_u8r =
16288:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16289:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_HYST,
16290:Src/bno055.c  **** 					gyro_highrate_x_hyst_u8);
16291:Src/bno055.c  **** 					com_rslt +=
16292:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16293:Src/bno055.c  **** 					(p_bno055->dev_addr,
16294:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_HYST_REG,
16295:Src/bno055.c  **** 					&data_u8r,
16296:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16297:Src/bno055.c  **** 				}
16298:Src/bno055.c  **** 			} else {
16299:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16300:Src/bno055.c  **** 			}
16301:Src/bno055.c  **** 		} else {
16302:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16303:Src/bno055.c  **** 		}
16304:Src/bno055.c  **** 	} else {
ARM GAS  /tmp/ccVWLGiI.s 			page 901


16305:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 31676              		.loc 1 16305 0
 31677 0022 FF24     		movs	r4, #255
 31678              	.LVL3868:
 31679              	.L3511:
16306:Src/bno055.c  **** 	}
16307:Src/bno055.c  **** }
16308:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 31680              		.loc 1 16308 0
 31681 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 31682 0028 58BB     		cbnz	r0, .L3523
 31683 002a 2046     		mov	r0, r4
 31684              	.LVL3869:
 31685              	.L3509:
16309:Src/bno055.c  **** 	/* set the operation mode of
16310:Src/bno055.c  **** 	previous operation mode*/
16311:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
16312:Src/bno055.c  **** 	(prev_opmode_u8);
16313:Src/bno055.c  **** return com_rslt;
16314:Src/bno055.c  **** }
 31686              		.loc 1 16314 0
 31687 002c 40B2     		sxtb	r0, r0
 31688 002e 03B0     		add	sp, sp, #12
 31689              	.LCFI1320:
 31690              		.cfi_remember_state
 31691              		.cfi_def_cfa_offset 12
 31692              		@ sp needed
 31693 0030 30BD     		pop	{r4, r5, pc}
 31694              	.LVL3870:
 31695              	.L3510:
 31696              	.LCFI1321:
 31697              		.cfi_restore_state
16273:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 31698              		.loc 1 16273 0
 31699 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31700 0036 5BBB     		cbnz	r3, .L3512
 31701              	.L3515:
 31702              	.LVL3871:
16278:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 31703              		.loc 1 16278 0
 31704 0038 0120     		movs	r0, #1
 31705 003a FFF7FEFF 		bl	bno055_write_page_id
 31706              	.LVL3872:
16279:Src/bno055.c  **** 				/*Write the value of
 31707              		.loc 1 16279 0
 31708 003e 0028     		cmp	r0, #0
 31709 0040 EFD1     		bne	.L3514
16282:Src/bno055.c  **** 				(p_bno055->dev_addr,
 31710              		.loc 1 16282 0
 31711 0042 2368     		ldr	r3, [r4]
 31712 0044 1821     		movs	r1, #24
 31713 0046 1C69     		ldr	r4, [r3, #16]
 31714 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31715              	.LVL3873:
 31716 004a 0DF10602 		add	r2, sp, #6
 31717 004e 0123     		movs	r3, #1
 31718 0050 A047     		blx	r4
ARM GAS  /tmp/ccVWLGiI.s 			page 902


 31719              	.LVL3874:
 31720 0052 1349     		ldr	r1, .L3524
16286:Src/bno055.c  **** 					data_u8r =
 31721              		.loc 1 16286 0
 31722 0054 0446     		mov	r4, r0
 31723 0056 0028     		cmp	r0, #0
 31724 0058 E4D1     		bne	.L3511
16287:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31725              		.loc 1 16287 0
 31726 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
16288:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_HYST,
 31727              		.loc 1 16288 0
 31728 005e 6B01     		lsls	r3, r5, #5
16292:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31729              		.loc 1 16292 0
 31730 0060 0968     		ldr	r1, [r1]
16287:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31731              		.loc 1 16287 0
 31732 0062 22F06002 		bic	r2, r2, #96
 31733 0066 03F06003 		and	r3, r3, #96
 31734 006a 1343     		orrs	r3, r3, r2
16292:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31735              		.loc 1 16292 0
 31736 006c CC68     		ldr	r4, [r1, #12]
16287:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31737              		.loc 1 16287 0
 31738 006e 8DF80630 		strb	r3, [sp, #6]
16292:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31739              		.loc 1 16292 0
 31740 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 31741              	.LVL3875:
 31742 0074 0DF10602 		add	r2, sp, #6
 31743 0078 1821     		movs	r1, #24
 31744 007a 0123     		movs	r3, #1
 31745 007c A047     		blx	r4
 31746              	.LVL3876:
 31747 007e 0446     		mov	r4, r0
 31748              	.LVL3877:
 31749 0080 D0E7     		b	.L3511
 31750              	.L3523:
16311:Src/bno055.c  **** 	(prev_opmode_u8);
 31751              		.loc 1 16311 0
 31752 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 31753              	.LVL3878:
 31754 0086 2044     		add	r0, r0, r4
 31755 0088 C0B2     		uxtb	r0, r0
 31756              	.LVL3879:
 31757              		.loc 1 16314 0
 31758 008a 40B2     		sxtb	r0, r0
 31759 008c 03B0     		add	sp, sp, #12
 31760              	.LCFI1322:
 31761              		.cfi_remember_state
 31762              		.cfi_def_cfa_offset 12
 31763              		@ sp needed
 31764 008e 30BD     		pop	{r4, r5, pc}
 31765              	.LVL3880:
 31766              	.L3512:
ARM GAS  /tmp/ccVWLGiI.s 			page 903


 31767              	.LCFI1323:
 31768              		.cfi_restore_state
16274:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 31769              		.loc 1 16274 0
 31770 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 31771              	.LVL3881:
16276:Src/bno055.c  **** 			/* Write page as one */
 31772              		.loc 1 16276 0
 31773 0094 0028     		cmp	r0, #0
 31774 0096 C4D1     		bne	.L3514
 31775 0098 CEE7     		b	.L3515
 31776              	.LVL3882:
 31777              	.L3516:
16266:Src/bno055.c  **** } else {
 31778              		.loc 1 16266 0
 31779 009a 8120     		movs	r0, #129
 31780              	.LVL3883:
 31781 009c C6E7     		b	.L3509
 31782              	.L3525:
 31783 009e 00BF     		.align	2
 31784              	.L3524:
 31785 00a0 00000000 		.word	.LANCHOR0
 31786              		.cfi_endproc
 31787              	.LFE254:
 31789              		.section	.text.bno055_get_gyro_highrate_x_durn,"ax",%progbits
 31790              		.align	2
 31791              		.global	bno055_get_gyro_highrate_x_durn
 31792              		.thumb
 31793              		.thumb_func
 31795              	bno055_get_gyro_highrate_x_durn:
 31796              	.LFB255:
16315:Src/bno055.c  **** /*!
16316:Src/bno055.c  ****  *	@brief This API used to read gyro highrate x duration
16317:Src/bno055.c  ****  *	from page one register from 0x19 bit 0 to 7
16318:Src/bno055.c  ****  *
16319:Src/bno055.c  ****  *	@param gyro_highrate_x_durn_u8 : The value of gyro highrate x duration
16320:Src/bno055.c  ****  *
16321:Src/bno055.c  ****  *	@return results of bus communication function
16322:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16323:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16324:Src/bno055.c  ****  *
16325:Src/bno055.c  ****  *	@note Gyro highrate duration calculate by using the formula
16326:Src/bno055.c  ****  *
16327:Src/bno055.c  ****  *	(1 + gyro_highrate_x_durn_u8)*2.5ms
16328:Src/bno055.c  ****  *
16329:Src/bno055.c  ****  */
16330:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_x_durn(
16331:Src/bno055.c  **** u8 *gyro_highrate_x_durn_u8)
16332:Src/bno055.c  **** {
 31797              		.loc 1 16332 0
 31798              		.cfi_startproc
 31799              		@ args = 0, pretend = 0, frame = 8
 31800              		@ frame_needed = 0, uses_anonymous_args = 0
 31801              	.LVL3884:
 31802 0000 30B5     		push	{r4, r5, lr}
 31803              	.LCFI1324:
 31804              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 904


 31805              		.cfi_offset 4, -12
 31806              		.cfi_offset 5, -8
 31807              		.cfi_offset 14, -4
16333:Src/bno055.c  **** 	/* Variable used to return value of
16334:Src/bno055.c  **** 	communication routine*/
16335:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16336:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16337:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16338:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16339:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 31808              		.loc 1 16339 0
 31809 0002 134D     		ldr	r5, .L3538
16332:Src/bno055.c  **** 	/* Variable used to return value of
 31810              		.loc 1 16332 0
 31811 0004 83B0     		sub	sp, sp, #12
 31812              	.LCFI1325:
 31813              		.cfi_def_cfa_offset 24
 31814              		.loc 1 16339 0
 31815 0006 2B68     		ldr	r3, [r5]
16336:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 31816              		.loc 1 16336 0
 31817 0008 0022     		movs	r2, #0
 31818 000a 8DF80720 		strb	r2, [sp, #7]
 31819              	.LVL3885:
 31820              		.loc 1 16339 0
 31821 000e EBB1     		cbz	r3, .L3530
16340:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16341:Src/bno055.c  **** 		} else {
16342:Src/bno055.c  **** 		/*condition check for page, gyro highrate x duration is
16343:Src/bno055.c  **** 		available in the page one*/
16344:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 31822              		.loc 1 16344 0
 31823 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31824 0012 0446     		mov	r4, r0
 31825 0014 012A     		cmp	r2, #1
 31826 0016 04D0     		beq	.L3528
16345:Src/bno055.c  **** 			/* Write page as one */
16346:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 31827              		.loc 1 16346 0
 31828 0018 0120     		movs	r0, #1
 31829              	.LVL3886:
 31830 001a FFF7FEFF 		bl	bno055_write_page_id
 31831              	.LVL3887:
 31832 001e 2B68     		ldr	r3, [r5]
16347:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 31833              		.loc 1 16347 0
 31834 0020 60B9     		cbnz	r0, .L3537
 31835              	.LVL3888:
 31836              	.L3528:
16348:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16349:Src/bno055.c  **** 			/* Read the value of gyro highrate x duration*/
16350:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 31837              		.loc 1 16350 0
 31838 0022 1D69     		ldr	r5, [r3, #16]
 31839 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31840 0026 1921     		movs	r1, #25
 31841 0028 0123     		movs	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 905


 31842 002a 0DF10702 		add	r2, sp, #7
 31843 002e A847     		blx	r5
 31844              	.LVL3889:
16351:Src/bno055.c  **** 			(p_bno055->dev_addr,
16352:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_X_DURN_REG,
16353:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16354:Src/bno055.c  **** 			*gyro_highrate_x_durn_u8 =
 31845              		.loc 1 16354 0
 31846 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31847 0034 2370     		strb	r3, [r4]
 31848              	.LVL3890:
 31849              	.L3527:
16355:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
16356:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_X_DURN);
16357:Src/bno055.c  **** 		} else {
16358:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16359:Src/bno055.c  **** 		}
16360:Src/bno055.c  **** 	}
16361:Src/bno055.c  **** 	return com_rslt;
16362:Src/bno055.c  **** }
 31850              		.loc 1 16362 0
 31851 0036 40B2     		sxtb	r0, r0
 31852 0038 03B0     		add	sp, sp, #12
 31853              	.LCFI1326:
 31854              		.cfi_remember_state
 31855              		.cfi_def_cfa_offset 12
 31856              		@ sp needed
 31857 003a 30BD     		pop	{r4, r5, pc}
 31858              	.LVL3891:
 31859              	.L3537:
 31860              	.LCFI1327:
 31861              		.cfi_restore_state
16347:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31862              		.loc 1 16347 0 discriminator 1
 31863 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 31864 003e 012A     		cmp	r2, #1
16358:Src/bno055.c  **** 		}
 31865              		.loc 1 16358 0 discriminator 1
 31866 0040 18BF     		it	ne
 31867 0042 FF20     		movne	r0, #255
16347:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 31868              		.loc 1 16347 0 discriminator 1
 31869 0044 EDD0     		beq	.L3528
 31870              		.loc 1 16362 0
 31871 0046 40B2     		sxtb	r0, r0
 31872 0048 03B0     		add	sp, sp, #12
 31873              	.LCFI1328:
 31874              		.cfi_remember_state
 31875              		.cfi_def_cfa_offset 12
 31876              		@ sp needed
 31877 004a 30BD     		pop	{r4, r5, pc}
 31878              	.LVL3892:
 31879              	.L3530:
 31880              	.LCFI1329:
 31881              		.cfi_restore_state
16340:Src/bno055.c  **** 		} else {
 31882              		.loc 1 16340 0
ARM GAS  /tmp/ccVWLGiI.s 			page 906


 31883 004c 8120     		movs	r0, #129
 31884              	.LVL3893:
 31885 004e F2E7     		b	.L3527
 31886              	.L3539:
 31887              		.align	2
 31888              	.L3538:
 31889 0050 00000000 		.word	.LANCHOR0
 31890              		.cfi_endproc
 31891              	.LFE255:
 31893              		.section	.text.bno055_set_gyro_highrate_x_durn,"ax",%progbits
 31894              		.align	2
 31895              		.global	bno055_set_gyro_highrate_x_durn
 31896              		.thumb
 31897              		.thumb_func
 31899              	bno055_set_gyro_highrate_x_durn:
 31900              	.LFB256:
16363:Src/bno055.c  **** /*!
16364:Src/bno055.c  ****  *	@brief This API used to write gyro highrate x duration
16365:Src/bno055.c  ****  *	from page one register from 0x19 bit 0 to 7
16366:Src/bno055.c  ****  *
16367:Src/bno055.c  ****  *	@param gyro_highrate_x_durn_u8 : The value of gyro highrate x duration
16368:Src/bno055.c  ****  *
16369:Src/bno055.c  ****  *	@return results of bus communication function
16370:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16371:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16372:Src/bno055.c  ****  *
16373:Src/bno055.c  ****  *	@note Gyro highrate duration calculate by using the formula
16374:Src/bno055.c  ****  *
16375:Src/bno055.c  ****  *	(1 + gyro_highrate_x_durn_u8)*2.5ms
16376:Src/bno055.c  ****  */
16377:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_x_durn(
16378:Src/bno055.c  **** u8 gyro_highrate_x_durn_u8)
16379:Src/bno055.c  **** {
 31901              		.loc 1 16379 0
 31902              		.cfi_startproc
 31903              		@ args = 0, pretend = 0, frame = 8
 31904              		@ frame_needed = 0, uses_anonymous_args = 0
 31905              	.LVL3894:
 31906 0000 30B5     		push	{r4, r5, lr}
 31907              	.LCFI1330:
 31908              		.cfi_def_cfa_offset 12
 31909              		.cfi_offset 4, -12
 31910              		.cfi_offset 5, -8
 31911              		.cfi_offset 14, -4
16380:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16381:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16382:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16383:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
16384:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16385:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16386:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 31912              		.loc 1 16386 0
 31913 0002 234C     		ldr	r4, .L3556
16379:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 31914              		.loc 1 16379 0
 31915 0004 83B0     		sub	sp, sp, #12
 31916              	.LCFI1331:
ARM GAS  /tmp/ccVWLGiI.s 			page 907


 31917              		.cfi_def_cfa_offset 24
 31918              		.loc 1 16386 0
 31919 0006 2268     		ldr	r2, [r4]
16381:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 31920              		.loc 1 16381 0
 31921 0008 0023     		movs	r3, #0
 31922 000a 8DF80630 		strb	r3, [sp, #6]
 31923              	.LVL3895:
16383:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 31924              		.loc 1 16383 0
 31925 000e 8DF80730 		strb	r3, [sp, #7]
 31926              	.LVL3896:
 31927              		.loc 1 16386 0
 31928 0012 002A     		cmp	r2, #0
 31929 0014 39D0     		beq	.L3548
 31930 0016 0546     		mov	r5, r0
16387:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16388:Src/bno055.c  **** 	} else {
16389:Src/bno055.c  **** /* The write operation effective only if the operation
16390:Src/bno055.c  **** mode is in config mode, this part of code is checking the
16391:Src/bno055.c  **** current operation mode and set the config mode */
16392:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 31931              		.loc 1 16392 0
 31932 0018 0DF10700 		add	r0, sp, #7
 31933              	.LVL3897:
 31934 001c FFF7FEFF 		bl	bno055_get_operation_mode
 31935              	.LVL3898:
16393:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 31936              		.loc 1 16393 0
 31937 0020 38B1     		cbz	r0, .L3542
 31938              	.LVL3899:
 31939              	.L3546:
16394:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16395:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16396:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16397:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16398:Src/bno055.c  **** 			/* Write page as one */
16399:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16400:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16401:Src/bno055.c  **** 				/* Write the value
16402:Src/bno055.c  **** 				of gyro highrate x duration*/
16403:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16404:Src/bno055.c  **** 				(p_bno055->dev_addr,
16405:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_X_DURN_REG,
16406:Src/bno055.c  **** 				&data_u8r,
16407:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
16408:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16409:Src/bno055.c  **** 					data_u8r =
16410:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16411:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_DURN,
16412:Src/bno055.c  **** 					gyro_highrate_x_durn_u8);
16413:Src/bno055.c  **** 					com_rslt +=
16414:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16415:Src/bno055.c  **** 					(p_bno055->dev_addr,
16416:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_X_DURN_REG,
16417:Src/bno055.c  **** 					&data_u8r,
16418:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
ARM GAS  /tmp/ccVWLGiI.s 			page 908


16419:Src/bno055.c  **** 				}
16420:Src/bno055.c  **** 			} else {
16421:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16422:Src/bno055.c  **** 			}
16423:Src/bno055.c  **** 		} else {
16424:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16425:Src/bno055.c  **** 		}
16426:Src/bno055.c  **** 	} else {
16427:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 31940              		.loc 1 16427 0
 31941 0022 FF24     		movs	r4, #255
 31942              	.LVL3900:
 31943              	.L3543:
16428:Src/bno055.c  **** 	}
16429:Src/bno055.c  **** 	}
16430:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 31944              		.loc 1 16430 0
 31945 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 31946 0028 18BB     		cbnz	r0, .L3555
 31947 002a 2046     		mov	r0, r4
 31948              	.LVL3901:
 31949              	.L3541:
16431:Src/bno055.c  **** 		/* set the operation mode of
16432:Src/bno055.c  **** 		previous operation mode*/
16433:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
16434:Src/bno055.c  **** 		(prev_opmode_u8);
16435:Src/bno055.c  **** 	return com_rslt;
16436:Src/bno055.c  **** }
 31950              		.loc 1 16436 0
 31951 002c 40B2     		sxtb	r0, r0
 31952 002e 03B0     		add	sp, sp, #12
 31953              	.LCFI1332:
 31954              		.cfi_remember_state
 31955              		.cfi_def_cfa_offset 12
 31956              		@ sp needed
 31957 0030 30BD     		pop	{r4, r5, pc}
 31958              	.LVL3902:
 31959              	.L3542:
 31960              	.LCFI1333:
 31961              		.cfi_restore_state
16394:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 31962              		.loc 1 16394 0
 31963 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 31964 0036 1BBB     		cbnz	r3, .L3544
 31965              	.L3547:
 31966              	.LVL3903:
16399:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 31967              		.loc 1 16399 0
 31968 0038 0120     		movs	r0, #1
 31969 003a FFF7FEFF 		bl	bno055_write_page_id
 31970              	.LVL3904:
16400:Src/bno055.c  **** 				/* Write the value
 31971              		.loc 1 16400 0
 31972 003e 0028     		cmp	r0, #0
 31973 0040 EFD1     		bne	.L3546
16403:Src/bno055.c  **** 				(p_bno055->dev_addr,
 31974              		.loc 1 16403 0
ARM GAS  /tmp/ccVWLGiI.s 			page 909


 31975 0042 2368     		ldr	r3, [r4]
 31976 0044 0DF10602 		add	r2, sp, #6
 31977 0048 1C69     		ldr	r4, [r3, #16]
 31978 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31979              	.LVL3905:
 31980 004c 1921     		movs	r1, #25
 31981 004e 0123     		movs	r3, #1
 31982 0050 A047     		blx	r4
 31983              	.LVL3906:
 31984 0052 0F4B     		ldr	r3, .L3556
16408:Src/bno055.c  **** 					data_u8r =
 31985              		.loc 1 16408 0
 31986 0054 0446     		mov	r4, r0
 31987 0056 0028     		cmp	r0, #0
 31988 0058 E4D1     		bne	.L3543
16414:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31989              		.loc 1 16414 0
 31990 005a 1B68     		ldr	r3, [r3]
16409:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 31991              		.loc 1 16409 0
 31992 005c 8DF80650 		strb	r5, [sp, #6]
16414:Src/bno055.c  **** 					(p_bno055->dev_addr,
 31993              		.loc 1 16414 0
 31994 0060 DC68     		ldr	r4, [r3, #12]
 31995 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 31996              	.LVL3907:
 31997 0064 0DF10602 		add	r2, sp, #6
 31998 0068 1921     		movs	r1, #25
 31999 006a 0123     		movs	r3, #1
 32000 006c A047     		blx	r4
 32001              	.LVL3908:
 32002 006e 0446     		mov	r4, r0
 32003              	.LVL3909:
 32004 0070 D8E7     		b	.L3543
 32005              	.L3555:
16433:Src/bno055.c  **** 		(prev_opmode_u8);
 32006              		.loc 1 16433 0
 32007 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 32008              	.LVL3910:
 32009 0076 2044     		add	r0, r0, r4
 32010 0078 C0B2     		uxtb	r0, r0
 32011              	.LVL3911:
 32012              		.loc 1 16436 0
 32013 007a 40B2     		sxtb	r0, r0
 32014 007c 03B0     		add	sp, sp, #12
 32015              	.LCFI1334:
 32016              		.cfi_remember_state
 32017              		.cfi_def_cfa_offset 12
 32018              		@ sp needed
 32019 007e 30BD     		pop	{r4, r5, pc}
 32020              	.LVL3912:
 32021              	.L3544:
 32022              	.LCFI1335:
 32023              		.cfi_restore_state
16395:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 32024              		.loc 1 16395 0
 32025 0080 FFF7FEFF 		bl	bno055_set_operation_mode
ARM GAS  /tmp/ccVWLGiI.s 			page 910


 32026              	.LVL3913:
16397:Src/bno055.c  **** 			/* Write page as one */
 32027              		.loc 1 16397 0
 32028 0084 0028     		cmp	r0, #0
 32029 0086 CCD1     		bne	.L3546
 32030 0088 D6E7     		b	.L3547
 32031              	.LVL3914:
 32032              	.L3548:
16387:Src/bno055.c  **** 	} else {
 32033              		.loc 1 16387 0
 32034 008a 8120     		movs	r0, #129
 32035              	.LVL3915:
 32036 008c CEE7     		b	.L3541
 32037              	.L3557:
 32038 008e 00BF     		.align	2
 32039              	.L3556:
 32040 0090 00000000 		.word	.LANCHOR0
 32041              		.cfi_endproc
 32042              	.LFE256:
 32044              		.section	.text.bno055_get_gyro_highrate_y_thres,"ax",%progbits
 32045              		.align	2
 32046              		.global	bno055_get_gyro_highrate_y_thres
 32047              		.thumb
 32048              		.thumb_func
 32050              	bno055_get_gyro_highrate_y_thres:
 32051              	.LFB257:
16437:Src/bno055.c  **** /*!
16438:Src/bno055.c  ****  *	@brief This API used to read gyro highrate y threshold
16439:Src/bno055.c  ****  *	from page one register from 0x1A bit 0 to 4
16440:Src/bno055.c  ****  *
16441:Src/bno055.c  ****  *	@param gyro_highrate_y_thres_u8 : The value of gyro highrate y threshold
16442:Src/bno055.c  ****  *
16443:Src/bno055.c  ****  *	@return results of bus communication function
16444:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16445:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16446:Src/bno055.c  ****  *
16447:Src/bno055.c  ****  *	@note Gyro highrate threshold dependent on the
16448:Src/bno055.c  ****  *	selection of gyro range
16449:Src/bno055.c  ****  *
16450:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold		|     LSB
16451:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16452:Src/bno055.c  ****  *     2000           |    62.5dps      |   1LSB
16453:Src/bno055.c  ****  *     1000           |    31.25dps     |   1LSB
16454:Src/bno055.c  ****  *     500            |    15.625dps    |   1LSB
16455:Src/bno055.c  ****  *     125            |    7.8125dps    |   1LSB
16456:Src/bno055.c  ****  *
16457:Src/bno055.c  ****  */
16458:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_y_thres(
16459:Src/bno055.c  **** u8 *gyro_highrate_y_thres_u8)
16460:Src/bno055.c  **** {
 32052              		.loc 1 16460 0
 32053              		.cfi_startproc
 32054              		@ args = 0, pretend = 0, frame = 8
 32055              		@ frame_needed = 0, uses_anonymous_args = 0
 32056              	.LVL3916:
 32057 0000 30B5     		push	{r4, r5, lr}
 32058              	.LCFI1336:
ARM GAS  /tmp/ccVWLGiI.s 			page 911


 32059              		.cfi_def_cfa_offset 12
 32060              		.cfi_offset 4, -12
 32061              		.cfi_offset 5, -8
 32062              		.cfi_offset 14, -4
16461:Src/bno055.c  **** 	/* Variable used to return value of
16462:Src/bno055.c  **** 	communication routine*/
16463:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16464:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16465:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16466:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16467:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 32063              		.loc 1 16467 0
 32064 0002 144C     		ldr	r4, .L3570
16460:Src/bno055.c  **** 	/* Variable used to return value of
 32065              		.loc 1 16460 0
 32066 0004 83B0     		sub	sp, sp, #12
 32067              	.LCFI1337:
 32068              		.cfi_def_cfa_offset 24
 32069              		.loc 1 16467 0
 32070 0006 2368     		ldr	r3, [r4]
16464:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 32071              		.loc 1 16464 0
 32072 0008 0022     		movs	r2, #0
 32073 000a 8DF80720 		strb	r2, [sp, #7]
 32074              	.LVL3917:
 32075              		.loc 1 16467 0
 32076 000e FBB1     		cbz	r3, .L3562
16468:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16469:Src/bno055.c  **** 		} else {
16470:Src/bno055.c  **** 		/*condition check for page, gyro highrate y threshold is
16471:Src/bno055.c  **** 		available in the page one*/
16472:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 32077              		.loc 1 16472 0
 32078 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32079 0012 0546     		mov	r5, r0
 32080 0014 012A     		cmp	r2, #1
 32081 0016 04D0     		beq	.L3560
16473:Src/bno055.c  **** 			/* Write page as one */
16474:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 32082              		.loc 1 16474 0
 32083 0018 0120     		movs	r0, #1
 32084              	.LVL3918:
 32085 001a FFF7FEFF 		bl	bno055_write_page_id
 32086              	.LVL3919:
 32087 001e 2368     		ldr	r3, [r4]
16475:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 32088              		.loc 1 16475 0
 32089 0020 70B9     		cbnz	r0, .L3569
 32090              	.LVL3920:
 32091              	.L3560:
16476:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16477:Src/bno055.c  **** 			/* Read the value of gyro highrate y threshold*/
16478:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 32092              		.loc 1 16478 0
 32093 0022 1C69     		ldr	r4, [r3, #16]
 32094 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32095 0026 1A21     		movs	r1, #26
ARM GAS  /tmp/ccVWLGiI.s 			page 912


 32096 0028 0123     		movs	r3, #1
 32097 002a 0DF10702 		add	r2, sp, #7
 32098 002e A047     		blx	r4
 32099              	.LVL3921:
16479:Src/bno055.c  **** 			(p_bno055->dev_addr,
16480:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Y_THRES_REG,
16481:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16482:Src/bno055.c  **** 			*gyro_highrate_y_thres_u8 =
 32100              		.loc 1 16482 0
 32101 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32102 0034 03F01F03 		and	r3, r3, #31
 32103 0038 2B70     		strb	r3, [r5]
 32104              	.LVL3922:
 32105              	.L3559:
16483:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
16484:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Y_THRES);
16485:Src/bno055.c  **** 		} else {
16486:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16487:Src/bno055.c  **** 		}
16488:Src/bno055.c  **** 	}
16489:Src/bno055.c  **** 	return com_rslt;
16490:Src/bno055.c  **** }
 32106              		.loc 1 16490 0
 32107 003a 40B2     		sxtb	r0, r0
 32108 003c 03B0     		add	sp, sp, #12
 32109              	.LCFI1338:
 32110              		.cfi_remember_state
 32111              		.cfi_def_cfa_offset 12
 32112              		@ sp needed
 32113 003e 30BD     		pop	{r4, r5, pc}
 32114              	.LVL3923:
 32115              	.L3569:
 32116              	.LCFI1339:
 32117              		.cfi_restore_state
16475:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32118              		.loc 1 16475 0 discriminator 1
 32119 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32120 0042 012A     		cmp	r2, #1
16486:Src/bno055.c  **** 		}
 32121              		.loc 1 16486 0 discriminator 1
 32122 0044 18BF     		it	ne
 32123 0046 FF20     		movne	r0, #255
16475:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32124              		.loc 1 16475 0 discriminator 1
 32125 0048 EBD0     		beq	.L3560
 32126              		.loc 1 16490 0
 32127 004a 40B2     		sxtb	r0, r0
 32128 004c 03B0     		add	sp, sp, #12
 32129              	.LCFI1340:
 32130              		.cfi_remember_state
 32131              		.cfi_def_cfa_offset 12
 32132              		@ sp needed
 32133 004e 30BD     		pop	{r4, r5, pc}
 32134              	.LVL3924:
 32135              	.L3562:
 32136              	.LCFI1341:
 32137              		.cfi_restore_state
ARM GAS  /tmp/ccVWLGiI.s 			page 913


16468:Src/bno055.c  **** 		} else {
 32138              		.loc 1 16468 0
 32139 0050 8120     		movs	r0, #129
 32140              	.LVL3925:
 32141 0052 F2E7     		b	.L3559
 32142              	.L3571:
 32143              		.align	2
 32144              	.L3570:
 32145 0054 00000000 		.word	.LANCHOR0
 32146              		.cfi_endproc
 32147              	.LFE257:
 32149              		.section	.text.bno055_set_gyro_highrate_y_thres,"ax",%progbits
 32150              		.align	2
 32151              		.global	bno055_set_gyro_highrate_y_thres
 32152              		.thumb
 32153              		.thumb_func
 32155              	bno055_set_gyro_highrate_y_thres:
 32156              	.LFB258:
16491:Src/bno055.c  **** /*!
16492:Src/bno055.c  ****  *	@brief This API used to write gyro highrate y threshold
16493:Src/bno055.c  ****  *	from page one register from 0x1A bit 0 to 4
16494:Src/bno055.c  ****  *
16495:Src/bno055.c  ****  *	@param gyro_highrate_y_thres_u8 : The value of gyro highrate y threshold
16496:Src/bno055.c  ****  *
16497:Src/bno055.c  ****  *	@return results of bus communication function
16498:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16499:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16500:Src/bno055.c  ****  *
16501:Src/bno055.c  ****  *	@note Gyro highrate threshold dependent on the
16502:Src/bno055.c  ****  *	selection of gyro range
16503:Src/bno055.c  ****  *
16504:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold		|     LSB
16505:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16506:Src/bno055.c  ****  *     2000           |    62.5dps      |   1LSB
16507:Src/bno055.c  ****  *     1000           |    31.25dps     |   1LSB
16508:Src/bno055.c  ****  *     500            |    15.625dps    |   1LSB
16509:Src/bno055.c  ****  *     125            |    7.8125dps    |   1LSB
16510:Src/bno055.c  ****  *
16511:Src/bno055.c  ****  */
16512:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_y_thres(
16513:Src/bno055.c  **** u8 gyro_highrate_y_thres_u8)
16514:Src/bno055.c  **** {
 32157              		.loc 1 16514 0
 32158              		.cfi_startproc
 32159              		@ args = 0, pretend = 0, frame = 8
 32160              		@ frame_needed = 0, uses_anonymous_args = 0
 32161              	.LVL3926:
 32162 0000 30B5     		push	{r4, r5, lr}
 32163              	.LCFI1342:
 32164              		.cfi_def_cfa_offset 12
 32165              		.cfi_offset 4, -12
 32166              		.cfi_offset 5, -8
 32167              		.cfi_offset 14, -4
16515:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16516:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16517:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16518:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
ARM GAS  /tmp/ccVWLGiI.s 			page 914


16519:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16520:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16521:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 32168              		.loc 1 16521 0
 32169 0002 264C     		ldr	r4, .L3588
16514:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 32170              		.loc 1 16514 0
 32171 0004 83B0     		sub	sp, sp, #12
 32172              	.LCFI1343:
 32173              		.cfi_def_cfa_offset 24
 32174              		.loc 1 16521 0
 32175 0006 2268     		ldr	r2, [r4]
16516:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 32176              		.loc 1 16516 0
 32177 0008 0023     		movs	r3, #0
 32178 000a 8DF80630 		strb	r3, [sp, #6]
 32179              	.LVL3927:
16518:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 32180              		.loc 1 16518 0
 32181 000e 8DF80730 		strb	r3, [sp, #7]
 32182              	.LVL3928:
 32183              		.loc 1 16521 0
 32184 0012 002A     		cmp	r2, #0
 32185 0014 40D0     		beq	.L3580
 32186 0016 0546     		mov	r5, r0
16522:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16523:Src/bno055.c  **** } else {
16524:Src/bno055.c  **** /* The write operation effective only if the operation
16525:Src/bno055.c  **** mode is in config mode, this part of code is checking the
16526:Src/bno055.c  **** current operation mode and set the config mode */
16527:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 32187              		.loc 1 16527 0
 32188 0018 0DF10700 		add	r0, sp, #7
 32189              	.LVL3929:
 32190 001c FFF7FEFF 		bl	bno055_get_operation_mode
 32191              	.LVL3930:
16528:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 32192              		.loc 1 16528 0
 32193 0020 38B1     		cbz	r0, .L3574
 32194              	.LVL3931:
 32195              	.L3578:
16529:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16530:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16531:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16532:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16533:Src/bno055.c  **** 			/* Write page as one */
16534:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16535:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16536:Src/bno055.c  **** 				/* Write the value
16537:Src/bno055.c  **** 				of gyro highrate y threshold*/
16538:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16539:Src/bno055.c  **** 				(p_bno055->dev_addr,
16540:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_THRES_REG,
16541:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16542:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16543:Src/bno055.c  **** 					data_u8r =
16544:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 915


16545:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_THRES,
16546:Src/bno055.c  **** 					gyro_highrate_y_thres_u8);
16547:Src/bno055.c  **** 					com_rslt +=
16548:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16549:Src/bno055.c  **** 					(p_bno055->dev_addr,
16550:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_THRES_REG,
16551:Src/bno055.c  **** 					&data_u8r,
16552:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16553:Src/bno055.c  **** 				}
16554:Src/bno055.c  **** 			} else {
16555:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16556:Src/bno055.c  **** 			}
16557:Src/bno055.c  **** 		} else {
16558:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16559:Src/bno055.c  **** 		}
16560:Src/bno055.c  **** 	} else {
16561:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 32196              		.loc 1 16561 0
 32197 0022 FF24     		movs	r4, #255
 32198              	.LVL3932:
 32199              	.L3575:
16562:Src/bno055.c  **** 	}
16563:Src/bno055.c  **** }
16564:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 32200              		.loc 1 16564 0
 32201 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 32202 0028 50BB     		cbnz	r0, .L3587
 32203 002a 2046     		mov	r0, r4
 32204              	.LVL3933:
 32205              	.L3573:
16565:Src/bno055.c  **** 	/* set the operation mode of
16566:Src/bno055.c  **** 	previous operation mode*/
16567:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
16568:Src/bno055.c  **** 	(prev_opmode_u8);
16569:Src/bno055.c  **** return com_rslt;
16570:Src/bno055.c  **** }
 32206              		.loc 1 16570 0
 32207 002c 40B2     		sxtb	r0, r0
 32208 002e 03B0     		add	sp, sp, #12
 32209              	.LCFI1344:
 32210              		.cfi_remember_state
 32211              		.cfi_def_cfa_offset 12
 32212              		@ sp needed
 32213 0030 30BD     		pop	{r4, r5, pc}
 32214              	.LVL3934:
 32215              	.L3574:
 32216              	.LCFI1345:
 32217              		.cfi_restore_state
16529:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 32218              		.loc 1 16529 0
 32219 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32220 0036 53BB     		cbnz	r3, .L3576
 32221              	.L3579:
 32222              	.LVL3935:
16534:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 32223              		.loc 1 16534 0
 32224 0038 0120     		movs	r0, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 916


 32225 003a FFF7FEFF 		bl	bno055_write_page_id
 32226              	.LVL3936:
16535:Src/bno055.c  **** 				/* Write the value
 32227              		.loc 1 16535 0
 32228 003e 0028     		cmp	r0, #0
 32229 0040 EFD1     		bne	.L3578
16538:Src/bno055.c  **** 				(p_bno055->dev_addr,
 32230              		.loc 1 16538 0
 32231 0042 2368     		ldr	r3, [r4]
 32232 0044 0DF10602 		add	r2, sp, #6
 32233 0048 1C69     		ldr	r4, [r3, #16]
 32234 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32235              	.LVL3937:
 32236 004c 1A21     		movs	r1, #26
 32237 004e 0123     		movs	r3, #1
 32238 0050 A047     		blx	r4
 32239              	.LVL3938:
 32240 0052 124A     		ldr	r2, .L3588
16542:Src/bno055.c  **** 					data_u8r =
 32241              		.loc 1 16542 0
 32242 0054 0446     		mov	r4, r0
 32243 0056 0028     		cmp	r0, #0
 32244 0058 E4D1     		bne	.L3575
16543:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32245              		.loc 1 16543 0
 32246 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
16548:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32247              		.loc 1 16548 0
 32248 005e 1168     		ldr	r1, [r2]
16543:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32249              		.loc 1 16543 0
 32250 0060 23F01F03 		bic	r3, r3, #31
 32251 0064 05F01F00 		and	r0, r5, #31
 32252              	.LVL3939:
 32253 0068 1843     		orrs	r0, r0, r3
16548:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32254              		.loc 1 16548 0
 32255 006a CC68     		ldr	r4, [r1, #12]
16543:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32256              		.loc 1 16543 0
 32257 006c 8DF80600 		strb	r0, [sp, #6]
16548:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32258              		.loc 1 16548 0
 32259 0070 0DF10602 		add	r2, sp, #6
 32260 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 32261 0076 0123     		movs	r3, #1
 32262 0078 1A21     		movs	r1, #26
 32263 007a A047     		blx	r4
 32264              	.LVL3940:
 32265 007c 0446     		mov	r4, r0
 32266              	.LVL3941:
 32267 007e D1E7     		b	.L3575
 32268              	.L3587:
16567:Src/bno055.c  **** 	(prev_opmode_u8);
 32269              		.loc 1 16567 0
 32270 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 32271              	.LVL3942:
ARM GAS  /tmp/ccVWLGiI.s 			page 917


 32272 0084 2044     		add	r0, r0, r4
 32273 0086 C0B2     		uxtb	r0, r0
 32274              	.LVL3943:
 32275              		.loc 1 16570 0
 32276 0088 40B2     		sxtb	r0, r0
 32277 008a 03B0     		add	sp, sp, #12
 32278              	.LCFI1346:
 32279              		.cfi_remember_state
 32280              		.cfi_def_cfa_offset 12
 32281              		@ sp needed
 32282 008c 30BD     		pop	{r4, r5, pc}
 32283              	.LVL3944:
 32284              	.L3576:
 32285              	.LCFI1347:
 32286              		.cfi_restore_state
16530:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 32287              		.loc 1 16530 0
 32288 008e FFF7FEFF 		bl	bno055_set_operation_mode
 32289              	.LVL3945:
16532:Src/bno055.c  **** 			/* Write page as one */
 32290              		.loc 1 16532 0
 32291 0092 0028     		cmp	r0, #0
 32292 0094 C5D1     		bne	.L3578
 32293 0096 CFE7     		b	.L3579
 32294              	.LVL3946:
 32295              	.L3580:
16522:Src/bno055.c  **** } else {
 32296              		.loc 1 16522 0
 32297 0098 8120     		movs	r0, #129
 32298              	.LVL3947:
 32299 009a C7E7     		b	.L3573
 32300              	.L3589:
 32301              		.align	2
 32302              	.L3588:
 32303 009c 00000000 		.word	.LANCHOR0
 32304              		.cfi_endproc
 32305              	.LFE258:
 32307              		.section	.text.bno055_get_gyro_highrate_y_hyst,"ax",%progbits
 32308              		.align	2
 32309              		.global	bno055_get_gyro_highrate_y_hyst
 32310              		.thumb
 32311              		.thumb_func
 32313              	bno055_get_gyro_highrate_y_hyst:
 32314              	.LFB259:
16571:Src/bno055.c  **** /*!
16572:Src/bno055.c  ****  *	@brief This API used to read gyro highrate y hysteresis
16573:Src/bno055.c  ****  *	from page one register from 0x1A bit 5 to 6
16574:Src/bno055.c  ****  *
16575:Src/bno055.c  ****  *	@param gyro_highrate_y_hyst_u8 : The value of gyro highrate y hysteresis
16576:Src/bno055.c  ****  *
16577:Src/bno055.c  ****  *	@return results of bus communication function
16578:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16579:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16580:Src/bno055.c  ****  *
16581:Src/bno055.c  ****  *	@note Gyro high rate hysteresis calculated by
16582:Src/bno055.c  ****  *
16583:Src/bno055.c  ****  *	using this (255 + 256 * gyro_highrate_y_hyst_u8) *4 LSB
ARM GAS  /tmp/ccVWLGiI.s 			page 918


16584:Src/bno055.c  ****  *
16585:Src/bno055.c  ****  *	The high rate value scales with the range setting
16586:Src/bno055.c  ****  *
16587:Src/bno055.c  ****  *  gyro_range_u8	  |	hysteresis		|     LSB
16588:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16589:Src/bno055.c  ****  *     2000           |    62.26dps     |   1LSB
16590:Src/bno055.c  ****  *     1000           |    31.13dps     |   1LSB
16591:Src/bno055.c  ****  *     500            |    15.56dps     |   1LSB
16592:Src/bno055.c  ****  */
16593:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_y_hyst(
16594:Src/bno055.c  **** u8 *gyro_highrate_y_hyst_u8)
16595:Src/bno055.c  **** {
 32315              		.loc 1 16595 0
 32316              		.cfi_startproc
 32317              		@ args = 0, pretend = 0, frame = 8
 32318              		@ frame_needed = 0, uses_anonymous_args = 0
 32319              	.LVL3948:
 32320 0000 30B5     		push	{r4, r5, lr}
 32321              	.LCFI1348:
 32322              		.cfi_def_cfa_offset 12
 32323              		.cfi_offset 4, -12
 32324              		.cfi_offset 5, -8
 32325              		.cfi_offset 14, -4
16596:Src/bno055.c  **** 	/* Variable used to return value of
16597:Src/bno055.c  **** 	communication routine*/
16598:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16599:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16600:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16601:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16602:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 32326              		.loc 1 16602 0
 32327 0002 144C     		ldr	r4, .L3602
16595:Src/bno055.c  **** 	/* Variable used to return value of
 32328              		.loc 1 16595 0
 32329 0004 83B0     		sub	sp, sp, #12
 32330              	.LCFI1349:
 32331              		.cfi_def_cfa_offset 24
 32332              		.loc 1 16602 0
 32333 0006 2368     		ldr	r3, [r4]
16599:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 32334              		.loc 1 16599 0
 32335 0008 0022     		movs	r2, #0
 32336 000a 8DF80720 		strb	r2, [sp, #7]
 32337              	.LVL3949:
 32338              		.loc 1 16602 0
 32339 000e FBB1     		cbz	r3, .L3594
16603:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16604:Src/bno055.c  **** 		} else {
16605:Src/bno055.c  **** 		/*condition check for page, gyro highrate y hysteresis is
16606:Src/bno055.c  **** 		available in the page one*/
16607:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 32340              		.loc 1 16607 0
 32341 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32342 0012 0546     		mov	r5, r0
 32343 0014 012A     		cmp	r2, #1
 32344 0016 04D0     		beq	.L3592
16608:Src/bno055.c  **** 			/* Write page as one */
ARM GAS  /tmp/ccVWLGiI.s 			page 919


16609:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 32345              		.loc 1 16609 0
 32346 0018 0120     		movs	r0, #1
 32347              	.LVL3950:
 32348 001a FFF7FEFF 		bl	bno055_write_page_id
 32349              	.LVL3951:
 32350 001e 2368     		ldr	r3, [r4]
16610:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 32351              		.loc 1 16610 0
 32352 0020 70B9     		cbnz	r0, .L3601
 32353              	.LVL3952:
 32354              	.L3592:
16611:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16612:Src/bno055.c  **** 			/* Read the value of gyro highrate y hysteresis*/
16613:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 32355              		.loc 1 16613 0
 32356 0022 1C69     		ldr	r4, [r3, #16]
 32357 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32358 0026 1A21     		movs	r1, #26
 32359 0028 0123     		movs	r3, #1
 32360 002a 0DF10702 		add	r2, sp, #7
 32361 002e A047     		blx	r4
 32362              	.LVL3953:
16614:Src/bno055.c  **** 			(p_bno055->dev_addr,
16615:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Y_HYST_REG,
16616:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16617:Src/bno055.c  **** 			*gyro_highrate_y_hyst_u8 =
16618:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 32363              		.loc 1 16618 0
 32364 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32365 0034 C3F34113 		ubfx	r3, r3, #5, #2
16617:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 32366              		.loc 1 16617 0
 32367 0038 2B70     		strb	r3, [r5]
 32368              	.LVL3954:
 32369              	.L3591:
16619:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Y_HYST);
16620:Src/bno055.c  **** 		} else {
16621:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16622:Src/bno055.c  **** 		}
16623:Src/bno055.c  **** 	}
16624:Src/bno055.c  **** 	return com_rslt;
16625:Src/bno055.c  **** }
 32370              		.loc 1 16625 0
 32371 003a 40B2     		sxtb	r0, r0
 32372 003c 03B0     		add	sp, sp, #12
 32373              	.LCFI1350:
 32374              		.cfi_remember_state
 32375              		.cfi_def_cfa_offset 12
 32376              		@ sp needed
 32377 003e 30BD     		pop	{r4, r5, pc}
 32378              	.LVL3955:
 32379              	.L3601:
 32380              	.LCFI1351:
 32381              		.cfi_restore_state
16610:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32382              		.loc 1 16610 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 920


 32383 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32384 0042 012A     		cmp	r2, #1
16621:Src/bno055.c  **** 		}
 32385              		.loc 1 16621 0 discriminator 1
 32386 0044 18BF     		it	ne
 32387 0046 FF20     		movne	r0, #255
16610:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32388              		.loc 1 16610 0 discriminator 1
 32389 0048 EBD0     		beq	.L3592
 32390              		.loc 1 16625 0
 32391 004a 40B2     		sxtb	r0, r0
 32392 004c 03B0     		add	sp, sp, #12
 32393              	.LCFI1352:
 32394              		.cfi_remember_state
 32395              		.cfi_def_cfa_offset 12
 32396              		@ sp needed
 32397 004e 30BD     		pop	{r4, r5, pc}
 32398              	.LVL3956:
 32399              	.L3594:
 32400              	.LCFI1353:
 32401              		.cfi_restore_state
16603:Src/bno055.c  **** 		} else {
 32402              		.loc 1 16603 0
 32403 0050 8120     		movs	r0, #129
 32404              	.LVL3957:
 32405 0052 F2E7     		b	.L3591
 32406              	.L3603:
 32407              		.align	2
 32408              	.L3602:
 32409 0054 00000000 		.word	.LANCHOR0
 32410              		.cfi_endproc
 32411              	.LFE259:
 32413              		.section	.text.bno055_set_gyro_highrate_y_hyst,"ax",%progbits
 32414              		.align	2
 32415              		.global	bno055_set_gyro_highrate_y_hyst
 32416              		.thumb
 32417              		.thumb_func
 32419              	bno055_set_gyro_highrate_y_hyst:
 32420              	.LFB260:
16626:Src/bno055.c  **** /*!
16627:Src/bno055.c  ****  *	@brief This API used to write gyro highrate y hysteresis
16628:Src/bno055.c  ****  *	from page one register from 0x1A bit 5 to 6
16629:Src/bno055.c  ****  *
16630:Src/bno055.c  ****  *	@param gyro_highrate_y_hyst_u8 : The value of gyro highrate y hysteresis
16631:Src/bno055.c  ****  *
16632:Src/bno055.c  ****  *	@return results of bus communication function
16633:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16634:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16635:Src/bno055.c  ****  *
16636:Src/bno055.c  ****  *	@note Gyro high rate hysteresis calculated by
16637:Src/bno055.c  ****  *
16638:Src/bno055.c  ****  *	using this (255 + 256 * gyro_highrate_y_hyst_u8) *4 LSB
16639:Src/bno055.c  ****  *
16640:Src/bno055.c  ****  *	The high rate value scales with the range setting
16641:Src/bno055.c  ****  *
16642:Src/bno055.c  ****  *  gyro_range_u8	  |	hysteresis		|     LSB
16643:Src/bno055.c  ****  * -----------------  | -------------   | ---------
ARM GAS  /tmp/ccVWLGiI.s 			page 921


16644:Src/bno055.c  ****  *     2000           |    62.26dps     |   1LSB
16645:Src/bno055.c  ****  *     1000           |    31.13dps     |   1LSB
16646:Src/bno055.c  ****  *     500            |    15.56dps     |   1LSB
16647:Src/bno055.c  ****  */
16648:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_y_hyst(
16649:Src/bno055.c  **** u8 gyro_highrate_y_hyst_u8)
16650:Src/bno055.c  **** {
 32421              		.loc 1 16650 0
 32422              		.cfi_startproc
 32423              		@ args = 0, pretend = 0, frame = 8
 32424              		@ frame_needed = 0, uses_anonymous_args = 0
 32425              	.LVL3958:
 32426 0000 30B5     		push	{r4, r5, lr}
 32427              	.LCFI1354:
 32428              		.cfi_def_cfa_offset 12
 32429              		.cfi_offset 4, -12
 32430              		.cfi_offset 5, -8
 32431              		.cfi_offset 14, -4
16651:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16652:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16653:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16654:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
16655:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16656:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16657:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 32432              		.loc 1 16657 0
 32433 0002 274C     		ldr	r4, .L3620
16650:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 32434              		.loc 1 16650 0
 32435 0004 83B0     		sub	sp, sp, #12
 32436              	.LCFI1355:
 32437              		.cfi_def_cfa_offset 24
 32438              		.loc 1 16657 0
 32439 0006 2268     		ldr	r2, [r4]
16652:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 32440              		.loc 1 16652 0
 32441 0008 0023     		movs	r3, #0
 32442 000a 8DF80630 		strb	r3, [sp, #6]
 32443              	.LVL3959:
16654:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 32444              		.loc 1 16654 0
 32445 000e 8DF80730 		strb	r3, [sp, #7]
 32446              	.LVL3960:
 32447              		.loc 1 16657 0
 32448 0012 002A     		cmp	r2, #0
 32449 0014 41D0     		beq	.L3612
 32450 0016 0546     		mov	r5, r0
16658:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16659:Src/bno055.c  **** } else {
16660:Src/bno055.c  **** /* The write operation effective only if the operation
16661:Src/bno055.c  **** mode is in config mode, this part of code is checking the
16662:Src/bno055.c  **** current operation mode and set the config mode */
16663:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 32451              		.loc 1 16663 0
 32452 0018 0DF10700 		add	r0, sp, #7
 32453              	.LVL3961:
 32454 001c FFF7FEFF 		bl	bno055_get_operation_mode
ARM GAS  /tmp/ccVWLGiI.s 			page 922


 32455              	.LVL3962:
16664:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 32456              		.loc 1 16664 0
 32457 0020 38B1     		cbz	r0, .L3606
 32458              	.LVL3963:
 32459              	.L3610:
16665:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16666:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16667:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16668:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16669:Src/bno055.c  **** 			/* Write page as one */
16670:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16671:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16672:Src/bno055.c  **** 				/* Write the value of
16673:Src/bno055.c  **** 				gyro highrate y hysteresis*/
16674:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16675:Src/bno055.c  **** 				(p_bno055->dev_addr,
16676:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_HYST_REG,
16677:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16678:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16679:Src/bno055.c  **** 					data_u8r =
16680:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16681:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_HYST,
16682:Src/bno055.c  **** 					gyro_highrate_y_hyst_u8);
16683:Src/bno055.c  **** 					com_rslt +=
16684:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16685:Src/bno055.c  **** 					(p_bno055->dev_addr,
16686:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_HYST_REG,
16687:Src/bno055.c  **** 					&data_u8r,
16688:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16689:Src/bno055.c  **** 				}
16690:Src/bno055.c  **** 			} else {
16691:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16692:Src/bno055.c  **** 			}
16693:Src/bno055.c  **** 		} else {
16694:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16695:Src/bno055.c  **** 		}
16696:Src/bno055.c  **** 	} else {
16697:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 32460              		.loc 1 16697 0
 32461 0022 FF24     		movs	r4, #255
 32462              	.LVL3964:
 32463              	.L3607:
16698:Src/bno055.c  **** 	}
16699:Src/bno055.c  **** }
16700:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 32464              		.loc 1 16700 0
 32465 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 32466 0028 58BB     		cbnz	r0, .L3619
 32467 002a 2046     		mov	r0, r4
 32468              	.LVL3965:
 32469              	.L3605:
16701:Src/bno055.c  **** 	/* set the operation mode of
16702:Src/bno055.c  **** 	previous operation mode*/
16703:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
16704:Src/bno055.c  **** 	(prev_opmode_u8);
16705:Src/bno055.c  **** return com_rslt;
ARM GAS  /tmp/ccVWLGiI.s 			page 923


16706:Src/bno055.c  **** }
 32470              		.loc 1 16706 0
 32471 002c 40B2     		sxtb	r0, r0
 32472 002e 03B0     		add	sp, sp, #12
 32473              	.LCFI1356:
 32474              		.cfi_remember_state
 32475              		.cfi_def_cfa_offset 12
 32476              		@ sp needed
 32477 0030 30BD     		pop	{r4, r5, pc}
 32478              	.LVL3966:
 32479              	.L3606:
 32480              	.LCFI1357:
 32481              		.cfi_restore_state
16665:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 32482              		.loc 1 16665 0
 32483 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32484 0036 5BBB     		cbnz	r3, .L3608
 32485              	.L3611:
 32486              	.LVL3967:
16670:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 32487              		.loc 1 16670 0
 32488 0038 0120     		movs	r0, #1
 32489 003a FFF7FEFF 		bl	bno055_write_page_id
 32490              	.LVL3968:
16671:Src/bno055.c  **** 				/* Write the value of
 32491              		.loc 1 16671 0
 32492 003e 0028     		cmp	r0, #0
 32493 0040 EFD1     		bne	.L3610
16674:Src/bno055.c  **** 				(p_bno055->dev_addr,
 32494              		.loc 1 16674 0
 32495 0042 2368     		ldr	r3, [r4]
 32496 0044 1A21     		movs	r1, #26
 32497 0046 1C69     		ldr	r4, [r3, #16]
 32498 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32499              	.LVL3969:
 32500 004a 0DF10602 		add	r2, sp, #6
 32501 004e 0123     		movs	r3, #1
 32502 0050 A047     		blx	r4
 32503              	.LVL3970:
 32504 0052 1349     		ldr	r1, .L3620
16678:Src/bno055.c  **** 					data_u8r =
 32505              		.loc 1 16678 0
 32506 0054 0446     		mov	r4, r0
 32507 0056 0028     		cmp	r0, #0
 32508 0058 E4D1     		bne	.L3607
16679:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32509              		.loc 1 16679 0
 32510 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
16680:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_HYST,
 32511              		.loc 1 16680 0
 32512 005e 6B01     		lsls	r3, r5, #5
16684:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32513              		.loc 1 16684 0
 32514 0060 0968     		ldr	r1, [r1]
16679:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32515              		.loc 1 16679 0
 32516 0062 22F06002 		bic	r2, r2, #96
ARM GAS  /tmp/ccVWLGiI.s 			page 924


 32517 0066 03F06003 		and	r3, r3, #96
 32518 006a 1343     		orrs	r3, r3, r2
16684:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32519              		.loc 1 16684 0
 32520 006c CC68     		ldr	r4, [r1, #12]
16679:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32521              		.loc 1 16679 0
 32522 006e 8DF80630 		strb	r3, [sp, #6]
16684:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32523              		.loc 1 16684 0
 32524 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 32525              	.LVL3971:
 32526 0074 0DF10602 		add	r2, sp, #6
 32527 0078 1A21     		movs	r1, #26
 32528 007a 0123     		movs	r3, #1
 32529 007c A047     		blx	r4
 32530              	.LVL3972:
 32531 007e 0446     		mov	r4, r0
 32532              	.LVL3973:
 32533 0080 D0E7     		b	.L3607
 32534              	.L3619:
16703:Src/bno055.c  **** 	(prev_opmode_u8);
 32535              		.loc 1 16703 0
 32536 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 32537              	.LVL3974:
 32538 0086 2044     		add	r0, r0, r4
 32539 0088 C0B2     		uxtb	r0, r0
 32540              	.LVL3975:
 32541              		.loc 1 16706 0
 32542 008a 40B2     		sxtb	r0, r0
 32543 008c 03B0     		add	sp, sp, #12
 32544              	.LCFI1358:
 32545              		.cfi_remember_state
 32546              		.cfi_def_cfa_offset 12
 32547              		@ sp needed
 32548 008e 30BD     		pop	{r4, r5, pc}
 32549              	.LVL3976:
 32550              	.L3608:
 32551              	.LCFI1359:
 32552              		.cfi_restore_state
16666:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 32553              		.loc 1 16666 0
 32554 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 32555              	.LVL3977:
16668:Src/bno055.c  **** 			/* Write page as one */
 32556              		.loc 1 16668 0
 32557 0094 0028     		cmp	r0, #0
 32558 0096 C4D1     		bne	.L3610
 32559 0098 CEE7     		b	.L3611
 32560              	.LVL3978:
 32561              	.L3612:
16658:Src/bno055.c  **** } else {
 32562              		.loc 1 16658 0
 32563 009a 8120     		movs	r0, #129
 32564              	.LVL3979:
 32565 009c C6E7     		b	.L3605
 32566              	.L3621:
ARM GAS  /tmp/ccVWLGiI.s 			page 925


 32567 009e 00BF     		.align	2
 32568              	.L3620:
 32569 00a0 00000000 		.word	.LANCHOR0
 32570              		.cfi_endproc
 32571              	.LFE260:
 32573              		.section	.text.bno055_get_gyro_highrate_y_durn,"ax",%progbits
 32574              		.align	2
 32575              		.global	bno055_get_gyro_highrate_y_durn
 32576              		.thumb
 32577              		.thumb_func
 32579              	bno055_get_gyro_highrate_y_durn:
 32580              	.LFB261:
16707:Src/bno055.c  **** /*!
16708:Src/bno055.c  ****  *	@brief This API used to read gyro highrate y duration
16709:Src/bno055.c  ****  *	from page one register from 0x1B bit 0 to 7
16710:Src/bno055.c  ****  *
16711:Src/bno055.c  ****  *	@param gyro_highrate_y_durn_u8 : The value of gyro highrate y duration
16712:Src/bno055.c  ****  *
16713:Src/bno055.c  ****  *	@return results of bus communication function
16714:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16715:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16716:Src/bno055.c  ****  *
16717:Src/bno055.c  ****  *	@note Gyro highrate duration calculate by using the formula
16718:Src/bno055.c  ****  *
16719:Src/bno055.c  ****  *	(1 + gyro_highrate_y_durn_u8)*2.5ms
16720:Src/bno055.c  ****  */
16721:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_y_durn(
16722:Src/bno055.c  **** u8 *gyro_highrate_y_durn_u8)
16723:Src/bno055.c  **** {
 32581              		.loc 1 16723 0
 32582              		.cfi_startproc
 32583              		@ args = 0, pretend = 0, frame = 8
 32584              		@ frame_needed = 0, uses_anonymous_args = 0
 32585              	.LVL3980:
 32586 0000 30B5     		push	{r4, r5, lr}
 32587              	.LCFI1360:
 32588              		.cfi_def_cfa_offset 12
 32589              		.cfi_offset 4, -12
 32590              		.cfi_offset 5, -8
 32591              		.cfi_offset 14, -4
16724:Src/bno055.c  **** 	/* Variable used to return value of
16725:Src/bno055.c  **** 	communication routine*/
16726:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16727:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16728:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16729:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16730:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 32592              		.loc 1 16730 0
 32593 0002 134D     		ldr	r5, .L3634
16723:Src/bno055.c  **** 	/* Variable used to return value of
 32594              		.loc 1 16723 0
 32595 0004 83B0     		sub	sp, sp, #12
 32596              	.LCFI1361:
 32597              		.cfi_def_cfa_offset 24
 32598              		.loc 1 16730 0
 32599 0006 2B68     		ldr	r3, [r5]
16727:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 926


 32600              		.loc 1 16727 0
 32601 0008 0022     		movs	r2, #0
 32602 000a 8DF80720 		strb	r2, [sp, #7]
 32603              	.LVL3981:
 32604              		.loc 1 16730 0
 32605 000e EBB1     		cbz	r3, .L3626
16731:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16732:Src/bno055.c  **** 		} else {
16733:Src/bno055.c  **** 		/*condition check for page, gyro highrate y duration is
16734:Src/bno055.c  **** 		available in the page one*/
16735:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 32606              		.loc 1 16735 0
 32607 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32608 0012 0446     		mov	r4, r0
 32609 0014 012A     		cmp	r2, #1
 32610 0016 04D0     		beq	.L3624
16736:Src/bno055.c  **** 			/* Write page as one */
16737:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 32611              		.loc 1 16737 0
 32612 0018 0120     		movs	r0, #1
 32613              	.LVL3982:
 32614 001a FFF7FEFF 		bl	bno055_write_page_id
 32615              	.LVL3983:
 32616 001e 2B68     		ldr	r3, [r5]
16738:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 32617              		.loc 1 16738 0
 32618 0020 60B9     		cbnz	r0, .L3633
 32619              	.LVL3984:
 32620              	.L3624:
16739:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16740:Src/bno055.c  **** 			/* Read the value of gyro highrate y duration*/
16741:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 32621              		.loc 1 16741 0
 32622 0022 1D69     		ldr	r5, [r3, #16]
 32623 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32624 0026 1B21     		movs	r1, #27
 32625 0028 0123     		movs	r3, #1
 32626 002a 0DF10702 		add	r2, sp, #7
 32627 002e A847     		blx	r5
 32628              	.LVL3985:
16742:Src/bno055.c  **** 			(p_bno055->dev_addr,
16743:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Y_DURN_REG,
16744:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16745:Src/bno055.c  **** 			*gyro_highrate_y_durn_u8 =
 32629              		.loc 1 16745 0
 32630 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32631 0034 2370     		strb	r3, [r4]
 32632              	.LVL3986:
 32633              	.L3623:
16746:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
16747:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Y_DURN);
16748:Src/bno055.c  **** 		} else {
16749:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16750:Src/bno055.c  **** 		}
16751:Src/bno055.c  **** 	}
16752:Src/bno055.c  **** 	return com_rslt;
16753:Src/bno055.c  **** }
ARM GAS  /tmp/ccVWLGiI.s 			page 927


 32634              		.loc 1 16753 0
 32635 0036 40B2     		sxtb	r0, r0
 32636 0038 03B0     		add	sp, sp, #12
 32637              	.LCFI1362:
 32638              		.cfi_remember_state
 32639              		.cfi_def_cfa_offset 12
 32640              		@ sp needed
 32641 003a 30BD     		pop	{r4, r5, pc}
 32642              	.LVL3987:
 32643              	.L3633:
 32644              	.LCFI1363:
 32645              		.cfi_restore_state
16738:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32646              		.loc 1 16738 0 discriminator 1
 32647 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32648 003e 012A     		cmp	r2, #1
16749:Src/bno055.c  **** 		}
 32649              		.loc 1 16749 0 discriminator 1
 32650 0040 18BF     		it	ne
 32651 0042 FF20     		movne	r0, #255
16738:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32652              		.loc 1 16738 0 discriminator 1
 32653 0044 EDD0     		beq	.L3624
 32654              		.loc 1 16753 0
 32655 0046 40B2     		sxtb	r0, r0
 32656 0048 03B0     		add	sp, sp, #12
 32657              	.LCFI1364:
 32658              		.cfi_remember_state
 32659              		.cfi_def_cfa_offset 12
 32660              		@ sp needed
 32661 004a 30BD     		pop	{r4, r5, pc}
 32662              	.LVL3988:
 32663              	.L3626:
 32664              	.LCFI1365:
 32665              		.cfi_restore_state
16731:Src/bno055.c  **** 		} else {
 32666              		.loc 1 16731 0
 32667 004c 8120     		movs	r0, #129
 32668              	.LVL3989:
 32669 004e F2E7     		b	.L3623
 32670              	.L3635:
 32671              		.align	2
 32672              	.L3634:
 32673 0050 00000000 		.word	.LANCHOR0
 32674              		.cfi_endproc
 32675              	.LFE261:
 32677              		.section	.text.bno055_set_gyro_highrate_y_durn,"ax",%progbits
 32678              		.align	2
 32679              		.global	bno055_set_gyro_highrate_y_durn
 32680              		.thumb
 32681              		.thumb_func
 32683              	bno055_set_gyro_highrate_y_durn:
 32684              	.LFB262:
16754:Src/bno055.c  **** /*!
16755:Src/bno055.c  ****  *	@brief This API used to write gyro highrate y duration
16756:Src/bno055.c  ****  *	from page one register from 0x1B bit 0 to 7
16757:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 928


16758:Src/bno055.c  ****  *	@param gyro_highrate_y_durn_u8 : The value of gyro highrate y duration
16759:Src/bno055.c  ****  *
16760:Src/bno055.c  ****  *	@return results of bus communication function
16761:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16762:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16763:Src/bno055.c  ****  *
16764:Src/bno055.c  ****  *	@note Gyro highrate duration calculate by using the formula
16765:Src/bno055.c  ****  *
16766:Src/bno055.c  ****  *	(1 + gyro_highrate_y_durn_u8)*2.5ms
16767:Src/bno055.c  ****  */
16768:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_y_durn(
16769:Src/bno055.c  **** u8 gyro_highrate_y_durn_u8)
16770:Src/bno055.c  **** {
 32685              		.loc 1 16770 0
 32686              		.cfi_startproc
 32687              		@ args = 0, pretend = 0, frame = 8
 32688              		@ frame_needed = 0, uses_anonymous_args = 0
 32689              	.LVL3990:
 32690 0000 30B5     		push	{r4, r5, lr}
 32691              	.LCFI1366:
 32692              		.cfi_def_cfa_offset 12
 32693              		.cfi_offset 4, -12
 32694              		.cfi_offset 5, -8
 32695              		.cfi_offset 14, -4
16771:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16772:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16773:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16774:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
16775:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16776:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16777:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 32696              		.loc 1 16777 0
 32697 0002 234C     		ldr	r4, .L3652
16770:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 32698              		.loc 1 16770 0
 32699 0004 83B0     		sub	sp, sp, #12
 32700              	.LCFI1367:
 32701              		.cfi_def_cfa_offset 24
 32702              		.loc 1 16777 0
 32703 0006 2268     		ldr	r2, [r4]
16772:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 32704              		.loc 1 16772 0
 32705 0008 0023     		movs	r3, #0
 32706 000a 8DF80630 		strb	r3, [sp, #6]
 32707              	.LVL3991:
16774:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 32708              		.loc 1 16774 0
 32709 000e 8DF80730 		strb	r3, [sp, #7]
 32710              	.LVL3992:
 32711              		.loc 1 16777 0
 32712 0012 002A     		cmp	r2, #0
 32713 0014 39D0     		beq	.L3644
 32714 0016 0546     		mov	r5, r0
16778:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16779:Src/bno055.c  **** 	} else {
16780:Src/bno055.c  **** /* The write operation effective only if the operation
16781:Src/bno055.c  **** mode is in config mode, this part of code is checking the
ARM GAS  /tmp/ccVWLGiI.s 			page 929


16782:Src/bno055.c  **** current operation mode and set the config mode */
16783:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 32715              		.loc 1 16783 0
 32716 0018 0DF10700 		add	r0, sp, #7
 32717              	.LVL3993:
 32718 001c FFF7FEFF 		bl	bno055_get_operation_mode
 32719              	.LVL3994:
16784:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 32720              		.loc 1 16784 0
 32721 0020 38B1     		cbz	r0, .L3638
 32722              	.LVL3995:
 32723              	.L3642:
16785:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16786:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16787:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16788:Src/bno055.c  **** 
16789:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16790:Src/bno055.c  **** 			/* Write page as one */
16791:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16792:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16793:Src/bno055.c  **** 				/* Write the value
16794:Src/bno055.c  **** 				of gyro highrate y duration*/
16795:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16796:Src/bno055.c  **** 				(p_bno055->dev_addr,
16797:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Y_DURN_REG,
16798:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16799:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16800:Src/bno055.c  **** 					data_u8r =
16801:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16802:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_DURN,
16803:Src/bno055.c  **** 					gyro_highrate_y_durn_u8);
16804:Src/bno055.c  **** 					com_rslt +=
16805:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16806:Src/bno055.c  **** 					(p_bno055->dev_addr,
16807:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Y_DURN_REG,
16808:Src/bno055.c  **** 					&data_u8r,
16809:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16810:Src/bno055.c  **** 				}
16811:Src/bno055.c  **** 			} else {
16812:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16813:Src/bno055.c  **** 			}
16814:Src/bno055.c  **** 		} else {
16815:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16816:Src/bno055.c  **** 		}
16817:Src/bno055.c  **** 	} else {
16818:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 32724              		.loc 1 16818 0
 32725 0022 FF24     		movs	r4, #255
 32726              	.LVL3996:
 32727              	.L3639:
16819:Src/bno055.c  **** 	}
16820:Src/bno055.c  **** 	}
16821:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 32728              		.loc 1 16821 0
 32729 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 32730 0028 18BB     		cbnz	r0, .L3651
 32731 002a 2046     		mov	r0, r4
ARM GAS  /tmp/ccVWLGiI.s 			page 930


 32732              	.LVL3997:
 32733              	.L3637:
16822:Src/bno055.c  **** 		/* set the operation mode of
16823:Src/bno055.c  **** 		previous operation mode*/
16824:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
16825:Src/bno055.c  **** 		(prev_opmode_u8);
16826:Src/bno055.c  **** 	return com_rslt;
16827:Src/bno055.c  **** }
 32734              		.loc 1 16827 0
 32735 002c 40B2     		sxtb	r0, r0
 32736 002e 03B0     		add	sp, sp, #12
 32737              	.LCFI1368:
 32738              		.cfi_remember_state
 32739              		.cfi_def_cfa_offset 12
 32740              		@ sp needed
 32741 0030 30BD     		pop	{r4, r5, pc}
 32742              	.LVL3998:
 32743              	.L3638:
 32744              	.LCFI1369:
 32745              		.cfi_restore_state
16785:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 32746              		.loc 1 16785 0
 32747 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32748 0036 1BBB     		cbnz	r3, .L3640
 32749              	.L3643:
 32750              	.LVL3999:
16791:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 32751              		.loc 1 16791 0
 32752 0038 0120     		movs	r0, #1
 32753 003a FFF7FEFF 		bl	bno055_write_page_id
 32754              	.LVL4000:
16792:Src/bno055.c  **** 				/* Write the value
 32755              		.loc 1 16792 0
 32756 003e 0028     		cmp	r0, #0
 32757 0040 EFD1     		bne	.L3642
16795:Src/bno055.c  **** 				(p_bno055->dev_addr,
 32758              		.loc 1 16795 0
 32759 0042 2368     		ldr	r3, [r4]
 32760 0044 0DF10602 		add	r2, sp, #6
 32761 0048 1C69     		ldr	r4, [r3, #16]
 32762 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32763              	.LVL4001:
 32764 004c 1B21     		movs	r1, #27
 32765 004e 0123     		movs	r3, #1
 32766 0050 A047     		blx	r4
 32767              	.LVL4002:
 32768 0052 0F4B     		ldr	r3, .L3652
16799:Src/bno055.c  **** 					data_u8r =
 32769              		.loc 1 16799 0
 32770 0054 0446     		mov	r4, r0
 32771 0056 0028     		cmp	r0, #0
 32772 0058 E4D1     		bne	.L3639
16805:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32773              		.loc 1 16805 0
 32774 005a 1B68     		ldr	r3, [r3]
16800:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 32775              		.loc 1 16800 0
ARM GAS  /tmp/ccVWLGiI.s 			page 931


 32776 005c 8DF80650 		strb	r5, [sp, #6]
16805:Src/bno055.c  **** 					(p_bno055->dev_addr,
 32777              		.loc 1 16805 0
 32778 0060 DC68     		ldr	r4, [r3, #12]
 32779 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32780              	.LVL4003:
 32781 0064 0DF10602 		add	r2, sp, #6
 32782 0068 1B21     		movs	r1, #27
 32783 006a 0123     		movs	r3, #1
 32784 006c A047     		blx	r4
 32785              	.LVL4004:
 32786 006e 0446     		mov	r4, r0
 32787              	.LVL4005:
 32788 0070 D8E7     		b	.L3639
 32789              	.L3651:
16824:Src/bno055.c  **** 		(prev_opmode_u8);
 32790              		.loc 1 16824 0
 32791 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 32792              	.LVL4006:
 32793 0076 2044     		add	r0, r0, r4
 32794 0078 C0B2     		uxtb	r0, r0
 32795              	.LVL4007:
 32796              		.loc 1 16827 0
 32797 007a 40B2     		sxtb	r0, r0
 32798 007c 03B0     		add	sp, sp, #12
 32799              	.LCFI1370:
 32800              		.cfi_remember_state
 32801              		.cfi_def_cfa_offset 12
 32802              		@ sp needed
 32803 007e 30BD     		pop	{r4, r5, pc}
 32804              	.LVL4008:
 32805              	.L3640:
 32806              	.LCFI1371:
 32807              		.cfi_restore_state
16786:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 32808              		.loc 1 16786 0
 32809 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 32810              	.LVL4009:
16789:Src/bno055.c  **** 			/* Write page as one */
 32811              		.loc 1 16789 0
 32812 0084 0028     		cmp	r0, #0
 32813 0086 CCD1     		bne	.L3642
 32814 0088 D6E7     		b	.L3643
 32815              	.LVL4010:
 32816              	.L3644:
16778:Src/bno055.c  **** 	} else {
 32817              		.loc 1 16778 0
 32818 008a 8120     		movs	r0, #129
 32819              	.LVL4011:
 32820 008c CEE7     		b	.L3637
 32821              	.L3653:
 32822 008e 00BF     		.align	2
 32823              	.L3652:
 32824 0090 00000000 		.word	.LANCHOR0
 32825              		.cfi_endproc
 32826              	.LFE262:
 32828              		.section	.text.bno055_get_gyro_highrate_z_thres,"ax",%progbits
ARM GAS  /tmp/ccVWLGiI.s 			page 932


 32829              		.align	2
 32830              		.global	bno055_get_gyro_highrate_z_thres
 32831              		.thumb
 32832              		.thumb_func
 32834              	bno055_get_gyro_highrate_z_thres:
 32835              	.LFB263:
16828:Src/bno055.c  **** /*!
16829:Src/bno055.c  ****  *	@brief This API used to read gyro highrate z threshold
16830:Src/bno055.c  ****  *	from page one register from 0x1C bit 0 to 4
16831:Src/bno055.c  ****  *
16832:Src/bno055.c  ****  *	@param gyro_highrate_z_thres_u8 : The value of gyro highrate z threshold
16833:Src/bno055.c  ****  *
16834:Src/bno055.c  ****  *	@return results of bus communication function
16835:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16836:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16837:Src/bno055.c  ****  *
16838:Src/bno055.c  ****  *	@note Gyro highrate threshold dependent on the
16839:Src/bno055.c  ****  *	selection of gyro range
16840:Src/bno055.c  ****  *
16841:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold		|     LSB
16842:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16843:Src/bno055.c  ****  *     2000           |    62.5dps      |   1LSB
16844:Src/bno055.c  ****  *     1000           |    31.25dps     |   1LSB
16845:Src/bno055.c  ****  *     500            |    15.625dps    |   1LSB
16846:Src/bno055.c  ****  *     125            |    7.8125dps    |   1LSB
16847:Src/bno055.c  ****  *
16848:Src/bno055.c  ****  */
16849:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_z_thres(
16850:Src/bno055.c  **** u8 *gyro_highrate_z_thres_u8)
16851:Src/bno055.c  **** {
 32836              		.loc 1 16851 0
 32837              		.cfi_startproc
 32838              		@ args = 0, pretend = 0, frame = 8
 32839              		@ frame_needed = 0, uses_anonymous_args = 0
 32840              	.LVL4012:
 32841 0000 30B5     		push	{r4, r5, lr}
 32842              	.LCFI1372:
 32843              		.cfi_def_cfa_offset 12
 32844              		.cfi_offset 4, -12
 32845              		.cfi_offset 5, -8
 32846              		.cfi_offset 14, -4
16852:Src/bno055.c  **** 	/* Variable used to return value of
16853:Src/bno055.c  **** 	communication routine*/
16854:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16855:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16856:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16857:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16858:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 32847              		.loc 1 16858 0
 32848 0002 144C     		ldr	r4, .L3666
16851:Src/bno055.c  **** 	/* Variable used to return value of
 32849              		.loc 1 16851 0
 32850 0004 83B0     		sub	sp, sp, #12
 32851              	.LCFI1373:
 32852              		.cfi_def_cfa_offset 24
 32853              		.loc 1 16858 0
 32854 0006 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccVWLGiI.s 			page 933


16855:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 32855              		.loc 1 16855 0
 32856 0008 0022     		movs	r2, #0
 32857 000a 8DF80720 		strb	r2, [sp, #7]
 32858              	.LVL4013:
 32859              		.loc 1 16858 0
 32860 000e FBB1     		cbz	r3, .L3658
16859:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16860:Src/bno055.c  **** 		} else {
16861:Src/bno055.c  **** 		/*condition check for page, gyro highrate z threshold is
16862:Src/bno055.c  **** 		available in the page one*/
16863:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 32861              		.loc 1 16863 0
 32862 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32863 0012 0546     		mov	r5, r0
 32864 0014 012A     		cmp	r2, #1
 32865 0016 04D0     		beq	.L3656
16864:Src/bno055.c  **** 			/* Write page as one */
16865:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 32866              		.loc 1 16865 0
 32867 0018 0120     		movs	r0, #1
 32868              	.LVL4014:
 32869 001a FFF7FEFF 		bl	bno055_write_page_id
 32870              	.LVL4015:
 32871 001e 2368     		ldr	r3, [r4]
16866:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 32872              		.loc 1 16866 0
 32873 0020 70B9     		cbnz	r0, .L3665
 32874              	.LVL4016:
 32875              	.L3656:
16867:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
16868:Src/bno055.c  **** 			/* Read the value of gyro highrate z threshold*/
16869:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 32876              		.loc 1 16869 0
 32877 0022 1C69     		ldr	r4, [r3, #16]
 32878 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 32879 0026 1C21     		movs	r1, #28
 32880 0028 0123     		movs	r3, #1
 32881 002a 0DF10702 		add	r2, sp, #7
 32882 002e A047     		blx	r4
 32883              	.LVL4017:
16870:Src/bno055.c  **** 			(p_bno055->dev_addr,
16871:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Z_THRES_REG,
16872:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16873:Src/bno055.c  **** 			*gyro_highrate_z_thres_u8 =
 32884              		.loc 1 16873 0
 32885 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 32886 0034 03F01F03 		and	r3, r3, #31
 32887 0038 2B70     		strb	r3, [r5]
 32888              	.LVL4018:
 32889              	.L3655:
16874:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
16875:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Z_THRES);
16876:Src/bno055.c  **** 		} else {
16877:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16878:Src/bno055.c  **** 		}
16879:Src/bno055.c  **** 	}
ARM GAS  /tmp/ccVWLGiI.s 			page 934


16880:Src/bno055.c  **** 	return com_rslt;
16881:Src/bno055.c  **** }
 32890              		.loc 1 16881 0
 32891 003a 40B2     		sxtb	r0, r0
 32892 003c 03B0     		add	sp, sp, #12
 32893              	.LCFI1374:
 32894              		.cfi_remember_state
 32895              		.cfi_def_cfa_offset 12
 32896              		@ sp needed
 32897 003e 30BD     		pop	{r4, r5, pc}
 32898              	.LVL4019:
 32899              	.L3665:
 32900              	.LCFI1375:
 32901              		.cfi_restore_state
16866:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32902              		.loc 1 16866 0 discriminator 1
 32903 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 32904 0042 012A     		cmp	r2, #1
16877:Src/bno055.c  **** 		}
 32905              		.loc 1 16877 0 discriminator 1
 32906 0044 18BF     		it	ne
 32907 0046 FF20     		movne	r0, #255
16866:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 32908              		.loc 1 16866 0 discriminator 1
 32909 0048 EBD0     		beq	.L3656
 32910              		.loc 1 16881 0
 32911 004a 40B2     		sxtb	r0, r0
 32912 004c 03B0     		add	sp, sp, #12
 32913              	.LCFI1376:
 32914              		.cfi_remember_state
 32915              		.cfi_def_cfa_offset 12
 32916              		@ sp needed
 32917 004e 30BD     		pop	{r4, r5, pc}
 32918              	.LVL4020:
 32919              	.L3658:
 32920              	.LCFI1377:
 32921              		.cfi_restore_state
16859:Src/bno055.c  **** 		} else {
 32922              		.loc 1 16859 0
 32923 0050 8120     		movs	r0, #129
 32924              	.LVL4021:
 32925 0052 F2E7     		b	.L3655
 32926              	.L3667:
 32927              		.align	2
 32928              	.L3666:
 32929 0054 00000000 		.word	.LANCHOR0
 32930              		.cfi_endproc
 32931              	.LFE263:
 32933              		.section	.text.bno055_set_gyro_highrate_z_thres,"ax",%progbits
 32934              		.align	2
 32935              		.global	bno055_set_gyro_highrate_z_thres
 32936              		.thumb
 32937              		.thumb_func
 32939              	bno055_set_gyro_highrate_z_thres:
 32940              	.LFB264:
16882:Src/bno055.c  **** /*!
16883:Src/bno055.c  ****  *	@brief This API used to write gyro highrate z threshold
ARM GAS  /tmp/ccVWLGiI.s 			page 935


16884:Src/bno055.c  ****  *	from page one register from 0x1C bit 0 to 4
16885:Src/bno055.c  ****  *
16886:Src/bno055.c  ****  *	@param gyro_highrate_z_thres_u8 : The value of gyro highrate z threshold
16887:Src/bno055.c  ****  *
16888:Src/bno055.c  ****  *	@return results of bus communication function
16889:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16890:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16891:Src/bno055.c  ****  *
16892:Src/bno055.c  ****  *	@note Gyro highrate threshold dependent on the
16893:Src/bno055.c  ****  *	selection of gyro range
16894:Src/bno055.c  ****  *
16895:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold		|     LSB
16896:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16897:Src/bno055.c  ****  *     2000           |    62.5dps      |   1LSB
16898:Src/bno055.c  ****  *     1000           |    31.25dps     |   1LSB
16899:Src/bno055.c  ****  *     500            |    15.625dps    |   1LSB
16900:Src/bno055.c  ****  *     125            |    7.8125dps    |   1LSB
16901:Src/bno055.c  ****  *
16902:Src/bno055.c  ****  */
16903:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_z_thres(
16904:Src/bno055.c  **** u8 gyro_highrate_z_thres_u8)
16905:Src/bno055.c  **** {
 32941              		.loc 1 16905 0
 32942              		.cfi_startproc
 32943              		@ args = 0, pretend = 0, frame = 8
 32944              		@ frame_needed = 0, uses_anonymous_args = 0
 32945              	.LVL4022:
 32946 0000 30B5     		push	{r4, r5, lr}
 32947              	.LCFI1378:
 32948              		.cfi_def_cfa_offset 12
 32949              		.cfi_offset 4, -12
 32950              		.cfi_offset 5, -8
 32951              		.cfi_offset 14, -4
16906:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16907:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
16908:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
16909:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
16910:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
16911:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
16912:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 32952              		.loc 1 16912 0
 32953 0002 264C     		ldr	r4, .L3684
16905:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 32954              		.loc 1 16905 0
 32955 0004 83B0     		sub	sp, sp, #12
 32956              	.LCFI1379:
 32957              		.cfi_def_cfa_offset 24
 32958              		.loc 1 16912 0
 32959 0006 2268     		ldr	r2, [r4]
16907:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 32960              		.loc 1 16907 0
 32961 0008 0023     		movs	r3, #0
 32962 000a 8DF80630 		strb	r3, [sp, #6]
 32963              	.LVL4023:
16909:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 32964              		.loc 1 16909 0
 32965 000e 8DF80730 		strb	r3, [sp, #7]
ARM GAS  /tmp/ccVWLGiI.s 			page 936


 32966              	.LVL4024:
 32967              		.loc 1 16912 0
 32968 0012 002A     		cmp	r2, #0
 32969 0014 40D0     		beq	.L3676
 32970 0016 0546     		mov	r5, r0
16913:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
16914:Src/bno055.c  **** } else {
16915:Src/bno055.c  **** /* The write operation effective only if the operation
16916:Src/bno055.c  **** mode is in config mode, this part of code is checking the
16917:Src/bno055.c  **** current operation mode and set the config mode */
16918:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 32971              		.loc 1 16918 0
 32972 0018 0DF10700 		add	r0, sp, #7
 32973              	.LVL4025:
 32974 001c FFF7FEFF 		bl	bno055_get_operation_mode
 32975              	.LVL4026:
16919:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 32976              		.loc 1 16919 0
 32977 0020 38B1     		cbz	r0, .L3670
 32978              	.LVL4027:
 32979              	.L3674:
16920:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
16921:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
16922:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
16923:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
16924:Src/bno055.c  **** 			/* Write page as one */
16925:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
16926:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
16927:Src/bno055.c  **** 				/* Write the value
16928:Src/bno055.c  **** 				of gyro highrate z threshold*/
16929:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
16930:Src/bno055.c  **** 				(p_bno055->dev_addr,
16931:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Z_THRES_REG,
16932:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
16933:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
16934:Src/bno055.c  **** 					data_u8r =
16935:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
16936:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_THRES,
16937:Src/bno055.c  **** 					gyro_highrate_z_thres_u8);
16938:Src/bno055.c  **** 					com_rslt +=
16939:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
16940:Src/bno055.c  **** 					(p_bno055->dev_addr,
16941:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_THRES_REG,
16942:Src/bno055.c  **** 					&data_u8r,
16943:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
16944:Src/bno055.c  **** 				}
16945:Src/bno055.c  **** 			} else {
16946:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
16947:Src/bno055.c  **** 			}
16948:Src/bno055.c  **** 		} else {
16949:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
16950:Src/bno055.c  **** 		}
16951:Src/bno055.c  **** 	} else {
16952:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 32980              		.loc 1 16952 0
 32981 0022 FF24     		movs	r4, #255
 32982              	.LVL4028:
ARM GAS  /tmp/ccVWLGiI.s 			page 937


 32983              	.L3671:
16953:Src/bno055.c  **** 	}
16954:Src/bno055.c  **** }
16955:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 32984              		.loc 1 16955 0
 32985 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 32986 0028 50BB     		cbnz	r0, .L3683
 32987 002a 2046     		mov	r0, r4
 32988              	.LVL4029:
 32989              	.L3669:
16956:Src/bno055.c  **** 	/* set the operation mode of
16957:Src/bno055.c  **** 	previous operation mode*/
16958:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
16959:Src/bno055.c  **** 	(prev_opmode_u8);
16960:Src/bno055.c  **** return com_rslt;
16961:Src/bno055.c  **** }
 32990              		.loc 1 16961 0
 32991 002c 40B2     		sxtb	r0, r0
 32992 002e 03B0     		add	sp, sp, #12
 32993              	.LCFI1380:
 32994              		.cfi_remember_state
 32995              		.cfi_def_cfa_offset 12
 32996              		@ sp needed
 32997 0030 30BD     		pop	{r4, r5, pc}
 32998              	.LVL4030:
 32999              	.L3670:
 33000              	.LCFI1381:
 33001              		.cfi_restore_state
16920:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 33002              		.loc 1 16920 0
 33003 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33004 0036 53BB     		cbnz	r3, .L3672
 33005              	.L3675:
 33006              	.LVL4031:
16925:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 33007              		.loc 1 16925 0
 33008 0038 0120     		movs	r0, #1
 33009 003a FFF7FEFF 		bl	bno055_write_page_id
 33010              	.LVL4032:
16926:Src/bno055.c  **** 				/* Write the value
 33011              		.loc 1 16926 0
 33012 003e 0028     		cmp	r0, #0
 33013 0040 EFD1     		bne	.L3674
16929:Src/bno055.c  **** 				(p_bno055->dev_addr,
 33014              		.loc 1 16929 0
 33015 0042 2368     		ldr	r3, [r4]
 33016 0044 0DF10602 		add	r2, sp, #6
 33017 0048 1C69     		ldr	r4, [r3, #16]
 33018 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33019              	.LVL4033:
 33020 004c 1C21     		movs	r1, #28
 33021 004e 0123     		movs	r3, #1
 33022 0050 A047     		blx	r4
 33023              	.LVL4034:
 33024 0052 124A     		ldr	r2, .L3684
16933:Src/bno055.c  **** 					data_u8r =
 33025              		.loc 1 16933 0
ARM GAS  /tmp/ccVWLGiI.s 			page 938


 33026 0054 0446     		mov	r4, r0
 33027 0056 0028     		cmp	r0, #0
 33028 0058 E4D1     		bne	.L3671
16934:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33029              		.loc 1 16934 0
 33030 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
16939:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33031              		.loc 1 16939 0
 33032 005e 1168     		ldr	r1, [r2]
16934:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33033              		.loc 1 16934 0
 33034 0060 23F01F03 		bic	r3, r3, #31
 33035 0064 05F01F00 		and	r0, r5, #31
 33036              	.LVL4035:
 33037 0068 1843     		orrs	r0, r0, r3
16939:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33038              		.loc 1 16939 0
 33039 006a CC68     		ldr	r4, [r1, #12]
16934:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33040              		.loc 1 16934 0
 33041 006c 8DF80600 		strb	r0, [sp, #6]
16939:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33042              		.loc 1 16939 0
 33043 0070 0DF10602 		add	r2, sp, #6
 33044 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 33045 0076 0123     		movs	r3, #1
 33046 0078 1C21     		movs	r1, #28
 33047 007a A047     		blx	r4
 33048              	.LVL4036:
 33049 007c 0446     		mov	r4, r0
 33050              	.LVL4037:
 33051 007e D1E7     		b	.L3671
 33052              	.L3683:
16958:Src/bno055.c  **** 	(prev_opmode_u8);
 33053              		.loc 1 16958 0
 33054 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 33055              	.LVL4038:
 33056 0084 2044     		add	r0, r0, r4
 33057 0086 C0B2     		uxtb	r0, r0
 33058              	.LVL4039:
 33059              		.loc 1 16961 0
 33060 0088 40B2     		sxtb	r0, r0
 33061 008a 03B0     		add	sp, sp, #12
 33062              	.LCFI1382:
 33063              		.cfi_remember_state
 33064              		.cfi_def_cfa_offset 12
 33065              		@ sp needed
 33066 008c 30BD     		pop	{r4, r5, pc}
 33067              	.LVL4040:
 33068              	.L3672:
 33069              	.LCFI1383:
 33070              		.cfi_restore_state
16921:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 33071              		.loc 1 16921 0
 33072 008e FFF7FEFF 		bl	bno055_set_operation_mode
 33073              	.LVL4041:
16923:Src/bno055.c  **** 			/* Write page as one */
ARM GAS  /tmp/ccVWLGiI.s 			page 939


 33074              		.loc 1 16923 0
 33075 0092 0028     		cmp	r0, #0
 33076 0094 C5D1     		bne	.L3674
 33077 0096 CFE7     		b	.L3675
 33078              	.LVL4042:
 33079              	.L3676:
16913:Src/bno055.c  **** } else {
 33080              		.loc 1 16913 0
 33081 0098 8120     		movs	r0, #129
 33082              	.LVL4043:
 33083 009a C7E7     		b	.L3669
 33084              	.L3685:
 33085              		.align	2
 33086              	.L3684:
 33087 009c 00000000 		.word	.LANCHOR0
 33088              		.cfi_endproc
 33089              	.LFE264:
 33091              		.section	.text.bno055_get_gyro_highrate_z_hyst,"ax",%progbits
 33092              		.align	2
 33093              		.global	bno055_get_gyro_highrate_z_hyst
 33094              		.thumb
 33095              		.thumb_func
 33097              	bno055_get_gyro_highrate_z_hyst:
 33098              	.LFB265:
16962:Src/bno055.c  **** /*!
16963:Src/bno055.c  ****  *	@brief This API used to read gyro highrate z hysteresis
16964:Src/bno055.c  ****  *	from page one register from 0x1C bit 5 to 6
16965:Src/bno055.c  ****  *
16966:Src/bno055.c  ****  *	@param gyro_highrate_z_hyst_u8 : The value of gyro highrate z hysteresis
16967:Src/bno055.c  ****  *
16968:Src/bno055.c  ****  *	@return results of bus communication function
16969:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
16970:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
16971:Src/bno055.c  ****  *
16972:Src/bno055.c  ****  *	@note Gyro high rate hysteresis calculated by
16973:Src/bno055.c  ****  *
16974:Src/bno055.c  ****  *	using this (255 + 256 * gyro_highrate_z_hyst_u8) *4 LSB
16975:Src/bno055.c  ****  *
16976:Src/bno055.c  ****  *	The high rate value scales with the range setting
16977:Src/bno055.c  ****  *
16978:Src/bno055.c  ****  *  gyro_range_u8	  |	 hysteresis		|     LSB
16979:Src/bno055.c  ****  * -----------------  | -------------   | ---------
16980:Src/bno055.c  ****  *     2000           |    62.26dps     |   1LSB
16981:Src/bno055.c  ****  *     1000           |    31.13dps     |   1LSB
16982:Src/bno055.c  ****  *     500            |    15.56dps     |   1LSB
16983:Src/bno055.c  ****  */
16984:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_z_hyst(
16985:Src/bno055.c  **** u8 *gyro_highrate_z_hyst_u8)
16986:Src/bno055.c  **** {
 33099              		.loc 1 16986 0
 33100              		.cfi_startproc
 33101              		@ args = 0, pretend = 0, frame = 8
 33102              		@ frame_needed = 0, uses_anonymous_args = 0
 33103              	.LVL4044:
 33104 0000 30B5     		push	{r4, r5, lr}
 33105              	.LCFI1384:
 33106              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccVWLGiI.s 			page 940


 33107              		.cfi_offset 4, -12
 33108              		.cfi_offset 5, -8
 33109              		.cfi_offset 14, -4
16987:Src/bno055.c  **** 	/* Variable used to return value of
16988:Src/bno055.c  **** 	communication routine*/
16989:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
16990:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
16991:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
16992:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
16993:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 33110              		.loc 1 16993 0
 33111 0002 144C     		ldr	r4, .L3698
16986:Src/bno055.c  **** 	/* Variable used to return value of
 33112              		.loc 1 16986 0
 33113 0004 83B0     		sub	sp, sp, #12
 33114              	.LCFI1385:
 33115              		.cfi_def_cfa_offset 24
 33116              		.loc 1 16993 0
 33117 0006 2368     		ldr	r3, [r4]
16990:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 33118              		.loc 1 16990 0
 33119 0008 0022     		movs	r2, #0
 33120 000a 8DF80720 		strb	r2, [sp, #7]
 33121              	.LVL4045:
 33122              		.loc 1 16993 0
 33123 000e FBB1     		cbz	r3, .L3690
16994:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
16995:Src/bno055.c  **** 		} else {
16996:Src/bno055.c  **** 		/*condition check for page, gyro highrate z hysteresis is
16997:Src/bno055.c  **** 		available in the page one*/
16998:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 33124              		.loc 1 16998 0
 33125 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33126 0012 0546     		mov	r5, r0
 33127 0014 012A     		cmp	r2, #1
 33128 0016 04D0     		beq	.L3688
16999:Src/bno055.c  **** 			/* Write page as one */
17000:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 33129              		.loc 1 17000 0
 33130 0018 0120     		movs	r0, #1
 33131              	.LVL4046:
 33132 001a FFF7FEFF 		bl	bno055_write_page_id
 33133              	.LVL4047:
 33134 001e 2368     		ldr	r3, [r4]
17001:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 33135              		.loc 1 17001 0
 33136 0020 70B9     		cbnz	r0, .L3697
 33137              	.LVL4048:
 33138              	.L3688:
17002:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
17003:Src/bno055.c  **** 			/* Read the value of gyro highrate z hysteresis*/
17004:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 33139              		.loc 1 17004 0
 33140 0022 1C69     		ldr	r4, [r3, #16]
 33141 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33142 0026 1C21     		movs	r1, #28
 33143 0028 0123     		movs	r3, #1
ARM GAS  /tmp/ccVWLGiI.s 			page 941


 33144 002a 0DF10702 		add	r2, sp, #7
 33145 002e A047     		blx	r4
 33146              	.LVL4049:
17005:Src/bno055.c  **** 			(p_bno055->dev_addr,
17006:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Z_HYST_REG,
17007:Src/bno055.c  **** 			&data_u8r,
17008:Src/bno055.c  **** 			BNO055_GEN_READ_WRITE_LENGTH);
17009:Src/bno055.c  **** 			*gyro_highrate_z_hyst_u8 =
17010:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 33147              		.loc 1 17010 0
 33148 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33149 0034 C3F34113 		ubfx	r3, r3, #5, #2
17009:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
 33150              		.loc 1 17009 0
 33151 0038 2B70     		strb	r3, [r5]
 33152              	.LVL4050:
 33153              	.L3687:
17011:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Z_HYST);
17012:Src/bno055.c  **** 		} else {
17013:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17014:Src/bno055.c  **** 		}
17015:Src/bno055.c  **** 	}
17016:Src/bno055.c  **** 	return com_rslt;
17017:Src/bno055.c  **** }
 33154              		.loc 1 17017 0
 33155 003a 40B2     		sxtb	r0, r0
 33156 003c 03B0     		add	sp, sp, #12
 33157              	.LCFI1386:
 33158              		.cfi_remember_state
 33159              		.cfi_def_cfa_offset 12
 33160              		@ sp needed
 33161 003e 30BD     		pop	{r4, r5, pc}
 33162              	.LVL4051:
 33163              	.L3697:
 33164              	.LCFI1387:
 33165              		.cfi_restore_state
17001:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33166              		.loc 1 17001 0 discriminator 1
 33167 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33168 0042 012A     		cmp	r2, #1
17013:Src/bno055.c  **** 		}
 33169              		.loc 1 17013 0 discriminator 1
 33170 0044 18BF     		it	ne
 33171 0046 FF20     		movne	r0, #255
17001:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33172              		.loc 1 17001 0 discriminator 1
 33173 0048 EBD0     		beq	.L3688
 33174              		.loc 1 17017 0
 33175 004a 40B2     		sxtb	r0, r0
 33176 004c 03B0     		add	sp, sp, #12
 33177              	.LCFI1388:
 33178              		.cfi_remember_state
 33179              		.cfi_def_cfa_offset 12
 33180              		@ sp needed
 33181 004e 30BD     		pop	{r4, r5, pc}
 33182              	.LVL4052:
 33183              	.L3690:
ARM GAS  /tmp/ccVWLGiI.s 			page 942


 33184              	.LCFI1389:
 33185              		.cfi_restore_state
16994:Src/bno055.c  **** 		} else {
 33186              		.loc 1 16994 0
 33187 0050 8120     		movs	r0, #129
 33188              	.LVL4053:
 33189 0052 F2E7     		b	.L3687
 33190              	.L3699:
 33191              		.align	2
 33192              	.L3698:
 33193 0054 00000000 		.word	.LANCHOR0
 33194              		.cfi_endproc
 33195              	.LFE265:
 33197              		.section	.text.bno055_set_gyro_highrate_z_hyst,"ax",%progbits
 33198              		.align	2
 33199              		.global	bno055_set_gyro_highrate_z_hyst
 33200              		.thumb
 33201              		.thumb_func
 33203              	bno055_set_gyro_highrate_z_hyst:
 33204              	.LFB266:
17018:Src/bno055.c  **** /*!
17019:Src/bno055.c  ****  *	@brief This API used to write gyro highrate z hysteresis
17020:Src/bno055.c  ****  *	from page one register from 0x1C bit 5 to 6
17021:Src/bno055.c  ****  *
17022:Src/bno055.c  ****  *	@param gyro_highrate_z_hyst_u8 : The value of gyro highrate z hysteresis
17023:Src/bno055.c  ****  *
17024:Src/bno055.c  ****  *	@return results of bus communication function
17025:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17026:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17027:Src/bno055.c  ****  *
17028:Src/bno055.c  ****  *	@note Gyro high rate hysteresis calculated by
17029:Src/bno055.c  ****  *
17030:Src/bno055.c  ****  *	using this (255 + 256 * gyro_highrate_z_hyst_u8) *4 LSB
17031:Src/bno055.c  ****  *
17032:Src/bno055.c  ****  *	The high rate value scales with the range setting
17033:Src/bno055.c  ****  *
17034:Src/bno055.c  ****  *  gyro_range_u8	  |	 hysteresis		|     LSB
17035:Src/bno055.c  ****  * -----------------  | -------------   | ---------
17036:Src/bno055.c  ****  *     2000           |    62.26dps     |   1LSB
17037:Src/bno055.c  ****  *     1000           |    31.13dps     |   1LSB
17038:Src/bno055.c  ****  *     500            |    15.56dps     |   1LSB
17039:Src/bno055.c  ****  */
17040:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_z_hyst(
17041:Src/bno055.c  **** u8 gyro_highrate_z_hyst_u8)
17042:Src/bno055.c  **** {
 33205              		.loc 1 17042 0
 33206              		.cfi_startproc
 33207              		@ args = 0, pretend = 0, frame = 8
 33208              		@ frame_needed = 0, uses_anonymous_args = 0
 33209              	.LVL4054:
 33210 0000 30B5     		push	{r4, r5, lr}
 33211              	.LCFI1390:
 33212              		.cfi_def_cfa_offset 12
 33213              		.cfi_offset 4, -12
 33214              		.cfi_offset 5, -8
 33215              		.cfi_offset 14, -4
17043:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 943


17044:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
17045:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
17046:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
17047:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
17048:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
17049:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 33216              		.loc 1 17049 0
 33217 0002 274C     		ldr	r4, .L3716
17042:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 33218              		.loc 1 17042 0
 33219 0004 83B0     		sub	sp, sp, #12
 33220              	.LCFI1391:
 33221              		.cfi_def_cfa_offset 24
 33222              		.loc 1 17049 0
 33223 0006 2268     		ldr	r2, [r4]
17044:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 33224              		.loc 1 17044 0
 33225 0008 0023     		movs	r3, #0
 33226 000a 8DF80630 		strb	r3, [sp, #6]
 33227              	.LVL4055:
17046:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 33228              		.loc 1 17046 0
 33229 000e 8DF80730 		strb	r3, [sp, #7]
 33230              	.LVL4056:
 33231              		.loc 1 17049 0
 33232 0012 002A     		cmp	r2, #0
 33233 0014 41D0     		beq	.L3708
 33234 0016 0546     		mov	r5, r0
17050:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
17051:Src/bno055.c  **** } else {
17052:Src/bno055.c  **** /* The write operation effective only if the operation
17053:Src/bno055.c  **** mode is in config mode, this part of code is checking the
17054:Src/bno055.c  **** current operation mode and set the config mode */
17055:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 33235              		.loc 1 17055 0
 33236 0018 0DF10700 		add	r0, sp, #7
 33237              	.LVL4057:
 33238 001c FFF7FEFF 		bl	bno055_get_operation_mode
 33239              	.LVL4058:
17056:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 33240              		.loc 1 17056 0
 33241 0020 38B1     		cbz	r0, .L3702
 33242              	.LVL4059:
 33243              	.L3706:
17057:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
17058:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
17059:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
17060:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
17061:Src/bno055.c  **** 			/* Write page as one */
17062:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
17063:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
17064:Src/bno055.c  **** 				/* Write the value
17065:Src/bno055.c  **** 				of gyro highrate z hysteresis*/
17066:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
17067:Src/bno055.c  **** 				(p_bno055->dev_addr,
17068:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Z_HYST_REG,
17069:Src/bno055.c  **** 				&data_u8r,
ARM GAS  /tmp/ccVWLGiI.s 			page 944


17070:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
17071:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
17072:Src/bno055.c  **** 					data_u8r =
17073:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
17074:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_HYST,
17075:Src/bno055.c  **** 					gyro_highrate_z_hyst_u8);
17076:Src/bno055.c  **** 					com_rslt +=
17077:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
17078:Src/bno055.c  **** 					(p_bno055->dev_addr,
17079:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_HYST_REG,
17080:Src/bno055.c  **** 					&data_u8r,
17081:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
17082:Src/bno055.c  **** 				}
17083:Src/bno055.c  **** 			} else {
17084:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
17085:Src/bno055.c  **** 			}
17086:Src/bno055.c  **** 		} else {
17087:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17088:Src/bno055.c  **** 		}
17089:Src/bno055.c  **** 	} else {
17090:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 33244              		.loc 1 17090 0
 33245 0022 FF24     		movs	r4, #255
 33246              	.LVL4060:
 33247              	.L3703:
17091:Src/bno055.c  **** 	}
17092:Src/bno055.c  **** }
17093:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 33248              		.loc 1 17093 0
 33249 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 33250 0028 58BB     		cbnz	r0, .L3715
 33251 002a 2046     		mov	r0, r4
 33252              	.LVL4061:
 33253              	.L3701:
17094:Src/bno055.c  **** 	/* set the operation mode of
17095:Src/bno055.c  **** 	previous operation mode*/
17096:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
17097:Src/bno055.c  **** 	(prev_opmode_u8);
17098:Src/bno055.c  **** return com_rslt;
17099:Src/bno055.c  **** }
 33254              		.loc 1 17099 0
 33255 002c 40B2     		sxtb	r0, r0
 33256 002e 03B0     		add	sp, sp, #12
 33257              	.LCFI1392:
 33258              		.cfi_remember_state
 33259              		.cfi_def_cfa_offset 12
 33260              		@ sp needed
 33261 0030 30BD     		pop	{r4, r5, pc}
 33262              	.LVL4062:
 33263              	.L3702:
 33264              	.LCFI1393:
 33265              		.cfi_restore_state
17057:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 33266              		.loc 1 17057 0
 33267 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33268 0036 5BBB     		cbnz	r3, .L3704
 33269              	.L3707:
ARM GAS  /tmp/ccVWLGiI.s 			page 945


 33270              	.LVL4063:
17062:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 33271              		.loc 1 17062 0
 33272 0038 0120     		movs	r0, #1
 33273 003a FFF7FEFF 		bl	bno055_write_page_id
 33274              	.LVL4064:
17063:Src/bno055.c  **** 				/* Write the value
 33275              		.loc 1 17063 0
 33276 003e 0028     		cmp	r0, #0
 33277 0040 EFD1     		bne	.L3706
17066:Src/bno055.c  **** 				(p_bno055->dev_addr,
 33278              		.loc 1 17066 0
 33279 0042 2368     		ldr	r3, [r4]
 33280 0044 1C21     		movs	r1, #28
 33281 0046 1C69     		ldr	r4, [r3, #16]
 33282 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33283              	.LVL4065:
 33284 004a 0DF10602 		add	r2, sp, #6
 33285 004e 0123     		movs	r3, #1
 33286 0050 A047     		blx	r4
 33287              	.LVL4066:
 33288 0052 1349     		ldr	r1, .L3716
17071:Src/bno055.c  **** 					data_u8r =
 33289              		.loc 1 17071 0
 33290 0054 0446     		mov	r4, r0
 33291 0056 0028     		cmp	r0, #0
 33292 0058 E4D1     		bne	.L3703
17072:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33293              		.loc 1 17072 0
 33294 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
17073:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_HYST,
 33295              		.loc 1 17073 0
 33296 005e 6B01     		lsls	r3, r5, #5
17077:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33297              		.loc 1 17077 0
 33298 0060 0968     		ldr	r1, [r1]
17072:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33299              		.loc 1 17072 0
 33300 0062 22F06002 		bic	r2, r2, #96
 33301 0066 03F06003 		and	r3, r3, #96
 33302 006a 1343     		orrs	r3, r3, r2
17077:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33303              		.loc 1 17077 0
 33304 006c CC68     		ldr	r4, [r1, #12]
17072:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33305              		.loc 1 17072 0
 33306 006e 8DF80630 		strb	r3, [sp, #6]
17077:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33307              		.loc 1 17077 0
 33308 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 33309              	.LVL4067:
 33310 0074 0DF10602 		add	r2, sp, #6
 33311 0078 1C21     		movs	r1, #28
 33312 007a 0123     		movs	r3, #1
 33313 007c A047     		blx	r4
 33314              	.LVL4068:
 33315 007e 0446     		mov	r4, r0
ARM GAS  /tmp/ccVWLGiI.s 			page 946


 33316              	.LVL4069:
 33317 0080 D0E7     		b	.L3703
 33318              	.L3715:
17096:Src/bno055.c  **** 	(prev_opmode_u8);
 33319              		.loc 1 17096 0
 33320 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 33321              	.LVL4070:
 33322 0086 2044     		add	r0, r0, r4
 33323 0088 C0B2     		uxtb	r0, r0
 33324              	.LVL4071:
 33325              		.loc 1 17099 0
 33326 008a 40B2     		sxtb	r0, r0
 33327 008c 03B0     		add	sp, sp, #12
 33328              	.LCFI1394:
 33329              		.cfi_remember_state
 33330              		.cfi_def_cfa_offset 12
 33331              		@ sp needed
 33332 008e 30BD     		pop	{r4, r5, pc}
 33333              	.LVL4072:
 33334              	.L3704:
 33335              	.LCFI1395:
 33336              		.cfi_restore_state
17058:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 33337              		.loc 1 17058 0
 33338 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 33339              	.LVL4073:
17060:Src/bno055.c  **** 			/* Write page as one */
 33340              		.loc 1 17060 0
 33341 0094 0028     		cmp	r0, #0
 33342 0096 C4D1     		bne	.L3706
 33343 0098 CEE7     		b	.L3707
 33344              	.LVL4074:
 33345              	.L3708:
17050:Src/bno055.c  **** } else {
 33346              		.loc 1 17050 0
 33347 009a 8120     		movs	r0, #129
 33348              	.LVL4075:
 33349 009c C6E7     		b	.L3701
 33350              	.L3717:
 33351 009e 00BF     		.align	2
 33352              	.L3716:
 33353 00a0 00000000 		.word	.LANCHOR0
 33354              		.cfi_endproc
 33355              	.LFE266:
 33357              		.section	.text.bno055_get_gyro_highrate_z_durn,"ax",%progbits
 33358              		.align	2
 33359              		.global	bno055_get_gyro_highrate_z_durn
 33360              		.thumb
 33361              		.thumb_func
 33363              	bno055_get_gyro_highrate_z_durn:
 33364              	.LFB267:
17100:Src/bno055.c  **** /*!
17101:Src/bno055.c  ****  *	@brief This API used to read gyro highrate z duration
17102:Src/bno055.c  ****  *	from page one register from 0x1D bit 0 to 7
17103:Src/bno055.c  ****  *
17104:Src/bno055.c  ****  *	@param gyro_highrate_z_durn_u8 : The value of gyro highrate z duration
17105:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 947


17106:Src/bno055.c  ****  *	@return results of bus communication function
17107:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17108:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17109:Src/bno055.c  ****  *
17110:Src/bno055.c  ****  *	@note Gyro highrate duration calculate by using the formula
17111:Src/bno055.c  ****  *
17112:Src/bno055.c  ****  *	(1 + gyro_highrate_z_durn_u8)*2.5ms
17113:Src/bno055.c  ****  */
17114:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_highrate_z_durn(
17115:Src/bno055.c  **** u8 *gyro_highrate_z_durn_u8)
17116:Src/bno055.c  **** {
 33365              		.loc 1 17116 0
 33366              		.cfi_startproc
 33367              		@ args = 0, pretend = 0, frame = 8
 33368              		@ frame_needed = 0, uses_anonymous_args = 0
 33369              	.LVL4076:
 33370 0000 30B5     		push	{r4, r5, lr}
 33371              	.LCFI1396:
 33372              		.cfi_def_cfa_offset 12
 33373              		.cfi_offset 4, -12
 33374              		.cfi_offset 5, -8
 33375              		.cfi_offset 14, -4
17117:Src/bno055.c  **** 	/* Variable used to return value of
17118:Src/bno055.c  **** 	communication routine*/
17119:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17120:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
17121:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
17122:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
17123:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 33376              		.loc 1 17123 0
 33377 0002 134D     		ldr	r5, .L3730
17116:Src/bno055.c  **** 	/* Variable used to return value of
 33378              		.loc 1 17116 0
 33379 0004 83B0     		sub	sp, sp, #12
 33380              	.LCFI1397:
 33381              		.cfi_def_cfa_offset 24
 33382              		.loc 1 17123 0
 33383 0006 2B68     		ldr	r3, [r5]
17120:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 33384              		.loc 1 17120 0
 33385 0008 0022     		movs	r2, #0
 33386 000a 8DF80720 		strb	r2, [sp, #7]
 33387              	.LVL4077:
 33388              		.loc 1 17123 0
 33389 000e EBB1     		cbz	r3, .L3722
17124:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
17125:Src/bno055.c  **** 		} else {
17126:Src/bno055.c  **** 		/*condition check for page, gyro highrate z duration is
17127:Src/bno055.c  **** 		available in the page one*/
17128:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 33390              		.loc 1 17128 0
 33391 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33392 0012 0446     		mov	r4, r0
 33393 0014 012A     		cmp	r2, #1
 33394 0016 04D0     		beq	.L3720
17129:Src/bno055.c  **** 			/* Write page as one */
17130:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
ARM GAS  /tmp/ccVWLGiI.s 			page 948


 33395              		.loc 1 17130 0
 33396 0018 0120     		movs	r0, #1
 33397              	.LVL4078:
 33398 001a FFF7FEFF 		bl	bno055_write_page_id
 33399              	.LVL4079:
 33400 001e 2B68     		ldr	r3, [r5]
17131:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 33401              		.loc 1 17131 0
 33402 0020 60B9     		cbnz	r0, .L3729
 33403              	.LVL4080:
 33404              	.L3720:
17132:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
17133:Src/bno055.c  **** 			/* Read the value of gyro highrate z duration*/
17134:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 33405              		.loc 1 17134 0
 33406 0022 1D69     		ldr	r5, [r3, #16]
 33407 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33408 0026 1D21     		movs	r1, #29
 33409 0028 0123     		movs	r3, #1
 33410 002a 0DF10702 		add	r2, sp, #7
 33411 002e A847     		blx	r5
 33412              	.LVL4081:
17135:Src/bno055.c  **** 			(p_bno055->dev_addr,
17136:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Z_DURN_REG,
17137:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
17138:Src/bno055.c  **** 			*gyro_highrate_z_durn_u8 =
 33413              		.loc 1 17138 0
 33414 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33415 0034 2370     		strb	r3, [r4]
 33416              	.LVL4082:
 33417              	.L3719:
17139:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
17140:Src/bno055.c  **** 			BNO055_GYRO_HIGHRATE_Z_DURN);
17141:Src/bno055.c  **** 		} else {
17142:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17143:Src/bno055.c  **** 		}
17144:Src/bno055.c  **** 	}
17145:Src/bno055.c  **** 	return com_rslt;
17146:Src/bno055.c  **** }
 33418              		.loc 1 17146 0
 33419 0036 40B2     		sxtb	r0, r0
 33420 0038 03B0     		add	sp, sp, #12
 33421              	.LCFI1398:
 33422              		.cfi_remember_state
 33423              		.cfi_def_cfa_offset 12
 33424              		@ sp needed
 33425 003a 30BD     		pop	{r4, r5, pc}
 33426              	.LVL4083:
 33427              	.L3729:
 33428              	.LCFI1399:
 33429              		.cfi_restore_state
17131:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33430              		.loc 1 17131 0 discriminator 1
 33431 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33432 003e 012A     		cmp	r2, #1
17142:Src/bno055.c  **** 		}
 33433              		.loc 1 17142 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 949


 33434 0040 18BF     		it	ne
 33435 0042 FF20     		movne	r0, #255
17131:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33436              		.loc 1 17131 0 discriminator 1
 33437 0044 EDD0     		beq	.L3720
 33438              		.loc 1 17146 0
 33439 0046 40B2     		sxtb	r0, r0
 33440 0048 03B0     		add	sp, sp, #12
 33441              	.LCFI1400:
 33442              		.cfi_remember_state
 33443              		.cfi_def_cfa_offset 12
 33444              		@ sp needed
 33445 004a 30BD     		pop	{r4, r5, pc}
 33446              	.LVL4084:
 33447              	.L3722:
 33448              	.LCFI1401:
 33449              		.cfi_restore_state
17124:Src/bno055.c  **** 		} else {
 33450              		.loc 1 17124 0
 33451 004c 8120     		movs	r0, #129
 33452              	.LVL4085:
 33453 004e F2E7     		b	.L3719
 33454              	.L3731:
 33455              		.align	2
 33456              	.L3730:
 33457 0050 00000000 		.word	.LANCHOR0
 33458              		.cfi_endproc
 33459              	.LFE267:
 33461              		.section	.text.bno055_set_gyro_highrate_z_durn,"ax",%progbits
 33462              		.align	2
 33463              		.global	bno055_set_gyro_highrate_z_durn
 33464              		.thumb
 33465              		.thumb_func
 33467              	bno055_set_gyro_highrate_z_durn:
 33468              	.LFB268:
17147:Src/bno055.c  **** /*!
17148:Src/bno055.c  ****  *	@brief This API used to write gyro highrate z duration
17149:Src/bno055.c  ****  *	from page one register from 0x1D bit 0 to 7
17150:Src/bno055.c  ****  *
17151:Src/bno055.c  ****  *	@param gyro_highrate_z_durn_u8 : The value of gyro highrate z duration
17152:Src/bno055.c  ****  *
17153:Src/bno055.c  ****  *	@return results of bus communication function
17154:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17155:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17156:Src/bno055.c  ****  *
17157:Src/bno055.c  ****  *	@note Gyro highrate duration calculate by using the formula
17158:Src/bno055.c  ****  *
17159:Src/bno055.c  ****  *	(1 + gyro_highrate_z_durn_u8)*2.5ms
17160:Src/bno055.c  ****  */
17161:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_highrate_z_durn(
17162:Src/bno055.c  **** u8 gyro_highrate_z_durn_u8)
17163:Src/bno055.c  **** {
 33469              		.loc 1 17163 0
 33470              		.cfi_startproc
 33471              		@ args = 0, pretend = 0, frame = 8
 33472              		@ frame_needed = 0, uses_anonymous_args = 0
 33473              	.LVL4086:
ARM GAS  /tmp/ccVWLGiI.s 			page 950


 33474 0000 30B5     		push	{r4, r5, lr}
 33475              	.LCFI1402:
 33476              		.cfi_def_cfa_offset 12
 33477              		.cfi_offset 4, -12
 33478              		.cfi_offset 5, -8
 33479              		.cfi_offset 14, -4
17164:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17165:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
17166:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
17167:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
17168:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
17169:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
17170:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 33480              		.loc 1 17170 0
 33481 0002 234C     		ldr	r4, .L3748
17163:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 33482              		.loc 1 17163 0
 33483 0004 83B0     		sub	sp, sp, #12
 33484              	.LCFI1403:
 33485              		.cfi_def_cfa_offset 24
 33486              		.loc 1 17170 0
 33487 0006 2268     		ldr	r2, [r4]
17165:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 33488              		.loc 1 17165 0
 33489 0008 0023     		movs	r3, #0
 33490 000a 8DF80630 		strb	r3, [sp, #6]
 33491              	.LVL4087:
17168:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 33492              		.loc 1 17168 0
 33493 000e 8DF80730 		strb	r3, [sp, #7]
 33494              		.loc 1 17170 0
 33495 0012 002A     		cmp	r2, #0
 33496 0014 39D0     		beq	.L3740
 33497 0016 0546     		mov	r5, r0
17171:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
17172:Src/bno055.c  **** } else {
17173:Src/bno055.c  **** /* The write operation effective only if the operation
17174:Src/bno055.c  **** mode is in config mode, this part of code is checking the
17175:Src/bno055.c  **** current operation mode and set the config mode */
17176:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 33498              		.loc 1 17176 0
 33499 0018 0DF10700 		add	r0, sp, #7
 33500              	.LVL4088:
 33501 001c FFF7FEFF 		bl	bno055_get_operation_mode
 33502              	.LVL4089:
17177:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 33503              		.loc 1 17177 0
 33504 0020 38B1     		cbz	r0, .L3734
 33505              	.LVL4090:
 33506              	.L3738:
17178:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
17179:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
17180:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
17181:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
17182:Src/bno055.c  **** 			/* Write page as one */
17183:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
17184:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
ARM GAS  /tmp/ccVWLGiI.s 			page 951


17185:Src/bno055.c  **** 				/* Write the value of
17186:Src/bno055.c  **** 				gyro highrate z duration*/
17187:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
17188:Src/bno055.c  **** 				(p_bno055->dev_addr,
17189:Src/bno055.c  **** 				BNO055_GYRO_HIGHRATE_Z_DURN_REG,
17190:Src/bno055.c  **** 				&data_u8r,
17191:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
17192:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
17193:Src/bno055.c  **** 					data_u8r =
17194:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
17195:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_DURN,
17196:Src/bno055.c  **** 					gyro_highrate_z_durn_u8);
17197:Src/bno055.c  **** 					com_rslt +=
17198:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
17199:Src/bno055.c  **** 					(p_bno055->dev_addr,
17200:Src/bno055.c  **** 					BNO055_GYRO_HIGHRATE_Z_DURN_REG,
17201:Src/bno055.c  **** 					&data_u8r,
17202:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
17203:Src/bno055.c  **** 				}
17204:Src/bno055.c  **** 			} else {
17205:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
17206:Src/bno055.c  **** 			}
17207:Src/bno055.c  **** 		} else {
17208:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17209:Src/bno055.c  **** 		}
17210:Src/bno055.c  **** 	} else {
17211:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 33507              		.loc 1 17211 0
 33508 0022 FF24     		movs	r4, #255
 33509              	.LVL4091:
 33510              	.L3735:
17212:Src/bno055.c  **** 	}
17213:Src/bno055.c  **** 	}
17214:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 33511              		.loc 1 17214 0
 33512 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 33513 0028 18BB     		cbnz	r0, .L3747
 33514 002a 2046     		mov	r0, r4
 33515              	.LVL4092:
 33516              	.L3733:
17215:Src/bno055.c  **** 		/* set the operation mode of
17216:Src/bno055.c  **** 		previous operation mode*/
17217:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
17218:Src/bno055.c  **** 		(prev_opmode_u8);
17219:Src/bno055.c  **** 	return com_rslt;
17220:Src/bno055.c  **** }
 33517              		.loc 1 17220 0
 33518 002c 40B2     		sxtb	r0, r0
 33519 002e 03B0     		add	sp, sp, #12
 33520              	.LCFI1404:
 33521              		.cfi_remember_state
 33522              		.cfi_def_cfa_offset 12
 33523              		@ sp needed
 33524 0030 30BD     		pop	{r4, r5, pc}
 33525              	.LVL4093:
 33526              	.L3734:
 33527              	.LCFI1405:
ARM GAS  /tmp/ccVWLGiI.s 			page 952


 33528              		.cfi_restore_state
17178:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 33529              		.loc 1 17178 0
 33530 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33531 0036 1BBB     		cbnz	r3, .L3736
 33532              	.L3739:
 33533              	.LVL4094:
17183:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 33534              		.loc 1 17183 0
 33535 0038 0120     		movs	r0, #1
 33536 003a FFF7FEFF 		bl	bno055_write_page_id
 33537              	.LVL4095:
17184:Src/bno055.c  **** 				/* Write the value of
 33538              		.loc 1 17184 0
 33539 003e 0028     		cmp	r0, #0
 33540 0040 EFD1     		bne	.L3738
17187:Src/bno055.c  **** 				(p_bno055->dev_addr,
 33541              		.loc 1 17187 0
 33542 0042 2368     		ldr	r3, [r4]
 33543 0044 0DF10602 		add	r2, sp, #6
 33544 0048 1C69     		ldr	r4, [r3, #16]
 33545 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33546              	.LVL4096:
 33547 004c 1D21     		movs	r1, #29
 33548 004e 0123     		movs	r3, #1
 33549 0050 A047     		blx	r4
 33550              	.LVL4097:
 33551 0052 0F4B     		ldr	r3, .L3748
17192:Src/bno055.c  **** 					data_u8r =
 33552              		.loc 1 17192 0
 33553 0054 0446     		mov	r4, r0
 33554 0056 0028     		cmp	r0, #0
 33555 0058 E4D1     		bne	.L3735
17198:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33556              		.loc 1 17198 0
 33557 005a 1B68     		ldr	r3, [r3]
17193:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33558              		.loc 1 17193 0
 33559 005c 8DF80650 		strb	r5, [sp, #6]
17198:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33560              		.loc 1 17198 0
 33561 0060 DC68     		ldr	r4, [r3, #12]
 33562 0062 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33563              	.LVL4098:
 33564 0064 0DF10602 		add	r2, sp, #6
 33565 0068 1D21     		movs	r1, #29
 33566 006a 0123     		movs	r3, #1
 33567 006c A047     		blx	r4
 33568              	.LVL4099:
 33569 006e 0446     		mov	r4, r0
 33570              	.LVL4100:
 33571 0070 D8E7     		b	.L3735
 33572              	.L3747:
17217:Src/bno055.c  **** 		(prev_opmode_u8);
 33573              		.loc 1 17217 0
 33574 0072 FFF7FEFF 		bl	bno055_set_operation_mode
 33575              	.LVL4101:
ARM GAS  /tmp/ccVWLGiI.s 			page 953


 33576 0076 2044     		add	r0, r0, r4
 33577 0078 C0B2     		uxtb	r0, r0
 33578              	.LVL4102:
 33579              		.loc 1 17220 0
 33580 007a 40B2     		sxtb	r0, r0
 33581 007c 03B0     		add	sp, sp, #12
 33582              	.LCFI1406:
 33583              		.cfi_remember_state
 33584              		.cfi_def_cfa_offset 12
 33585              		@ sp needed
 33586 007e 30BD     		pop	{r4, r5, pc}
 33587              	.LVL4103:
 33588              	.L3736:
 33589              	.LCFI1407:
 33590              		.cfi_restore_state
17179:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 33591              		.loc 1 17179 0
 33592 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 33593              	.LVL4104:
17181:Src/bno055.c  **** 			/* Write page as one */
 33594              		.loc 1 17181 0
 33595 0084 0028     		cmp	r0, #0
 33596 0086 CCD1     		bne	.L3738
 33597 0088 D6E7     		b	.L3739
 33598              	.LVL4105:
 33599              	.L3740:
17171:Src/bno055.c  **** } else {
 33600              		.loc 1 17171 0
 33601 008a 8120     		movs	r0, #129
 33602              	.LVL4106:
 33603 008c CEE7     		b	.L3733
 33604              	.L3749:
 33605 008e 00BF     		.align	2
 33606              	.L3748:
 33607 0090 00000000 		.word	.LANCHOR0
 33608              		.cfi_endproc
 33609              	.LFE268:
 33611              		.section	.text.bno055_get_gyro_any_motion_thres,"ax",%progbits
 33612              		.align	2
 33613              		.global	bno055_get_gyro_any_motion_thres
 33614              		.thumb
 33615              		.thumb_func
 33617              	bno055_get_gyro_any_motion_thres:
 33618              	.LFB269:
17221:Src/bno055.c  **** /*!
17222:Src/bno055.c  ****  *	@brief This API used to read gyro anymotion threshold
17223:Src/bno055.c  ****  *	from page one register from 0x1E bit 0 to 6
17224:Src/bno055.c  ****  *
17225:Src/bno055.c  ****  *	@param gyro_any_motion_thres_u8 : The value of gyro anymotion threshold
17226:Src/bno055.c  ****  *
17227:Src/bno055.c  ****  *	@return results of bus communication function
17228:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17229:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17230:Src/bno055.c  ****  *
17231:Src/bno055.c  ****  *	@note Gyro anymotion interrupt threshold dependent
17232:Src/bno055.c  ****  *	on the selection of gyro range
17233:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 954


17234:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold	  |	   LSB
17235:Src/bno055.c  ****  * -----------------  | ------------- | ---------
17236:Src/bno055.c  ****  *     2000           |    1dps       |   1LSB
17237:Src/bno055.c  ****  *     1000           |    0.5dps     |   1LSB
17238:Src/bno055.c  ****  *     500            |    0.25dps    |   1LSB
17239:Src/bno055.c  ****  *
17240:Src/bno055.c  ****  */
17241:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_any_motion_thres(
17242:Src/bno055.c  **** u8 *gyro_any_motion_thres_u8)
17243:Src/bno055.c  **** {
 33619              		.loc 1 17243 0
 33620              		.cfi_startproc
 33621              		@ args = 0, pretend = 0, frame = 8
 33622              		@ frame_needed = 0, uses_anonymous_args = 0
 33623              	.LVL4107:
 33624 0000 30B5     		push	{r4, r5, lr}
 33625              	.LCFI1408:
 33626              		.cfi_def_cfa_offset 12
 33627              		.cfi_offset 4, -12
 33628              		.cfi_offset 5, -8
 33629              		.cfi_offset 14, -4
17244:Src/bno055.c  **** 	/* Variable used to return value of
17245:Src/bno055.c  **** 	communication routine*/
17246:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17247:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
17248:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
17249:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
17250:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 33630              		.loc 1 17250 0
 33631 0002 144C     		ldr	r4, .L3762
17243:Src/bno055.c  **** 	/* Variable used to return value of
 33632              		.loc 1 17243 0
 33633 0004 83B0     		sub	sp, sp, #12
 33634              	.LCFI1409:
 33635              		.cfi_def_cfa_offset 24
 33636              		.loc 1 17250 0
 33637 0006 2368     		ldr	r3, [r4]
17247:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 33638              		.loc 1 17247 0
 33639 0008 0022     		movs	r2, #0
 33640 000a 8DF80720 		strb	r2, [sp, #7]
 33641              	.LVL4108:
 33642              		.loc 1 17250 0
 33643 000e FBB1     		cbz	r3, .L3754
17251:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
17252:Src/bno055.c  **** 		} else {
17253:Src/bno055.c  **** 		/*condition check for page,gyro anymotion threshold is
17254:Src/bno055.c  **** 		available in the page one*/
17255:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 33644              		.loc 1 17255 0
 33645 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33646 0012 0546     		mov	r5, r0
 33647 0014 012A     		cmp	r2, #1
 33648 0016 04D0     		beq	.L3752
17256:Src/bno055.c  **** 			/* Write page as one */
17257:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 33649              		.loc 1 17257 0
ARM GAS  /tmp/ccVWLGiI.s 			page 955


 33650 0018 0120     		movs	r0, #1
 33651              	.LVL4109:
 33652 001a FFF7FEFF 		bl	bno055_write_page_id
 33653              	.LVL4110:
 33654 001e 2368     		ldr	r3, [r4]
17258:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 33655              		.loc 1 17258 0
 33656 0020 70B9     		cbnz	r0, .L3761
 33657              	.LVL4111:
 33658              	.L3752:
17259:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
17260:Src/bno055.c  **** 			/* Read the value of gyro anymotion threshold*/
17261:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 33659              		.loc 1 17261 0
 33660 0022 1C69     		ldr	r4, [r3, #16]
 33661 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33662 0026 1E21     		movs	r1, #30
 33663 0028 0123     		movs	r3, #1
 33664 002a 0DF10702 		add	r2, sp, #7
 33665 002e A047     		blx	r4
 33666              	.LVL4112:
17262:Src/bno055.c  **** 			(p_bno055->dev_addr,
17263:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_THRES_REG,
17264:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
17265:Src/bno055.c  **** 			*gyro_any_motion_thres_u8 =
 33667              		.loc 1 17265 0
 33668 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33669 0034 03F07F03 		and	r3, r3, #127
 33670 0038 2B70     		strb	r3, [r5]
 33671              	.LVL4113:
 33672              	.L3751:
17266:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
17267:Src/bno055.c  **** 			BNO055_GYRO_ANY_MOTION_THRES);
17268:Src/bno055.c  **** 		} else {
17269:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17270:Src/bno055.c  **** 		}
17271:Src/bno055.c  **** 	}
17272:Src/bno055.c  **** 	return com_rslt;
17273:Src/bno055.c  **** }
 33673              		.loc 1 17273 0
 33674 003a 40B2     		sxtb	r0, r0
 33675 003c 03B0     		add	sp, sp, #12
 33676              	.LCFI1410:
 33677              		.cfi_remember_state
 33678              		.cfi_def_cfa_offset 12
 33679              		@ sp needed
 33680 003e 30BD     		pop	{r4, r5, pc}
 33681              	.LVL4114:
 33682              	.L3761:
 33683              	.LCFI1411:
 33684              		.cfi_restore_state
17258:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33685              		.loc 1 17258 0 discriminator 1
 33686 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33687 0042 012A     		cmp	r2, #1
17269:Src/bno055.c  **** 		}
 33688              		.loc 1 17269 0 discriminator 1
ARM GAS  /tmp/ccVWLGiI.s 			page 956


 33689 0044 18BF     		it	ne
 33690 0046 FF20     		movne	r0, #255
17258:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33691              		.loc 1 17258 0 discriminator 1
 33692 0048 EBD0     		beq	.L3752
 33693              		.loc 1 17273 0
 33694 004a 40B2     		sxtb	r0, r0
 33695 004c 03B0     		add	sp, sp, #12
 33696              	.LCFI1412:
 33697              		.cfi_remember_state
 33698              		.cfi_def_cfa_offset 12
 33699              		@ sp needed
 33700 004e 30BD     		pop	{r4, r5, pc}
 33701              	.LVL4115:
 33702              	.L3754:
 33703              	.LCFI1413:
 33704              		.cfi_restore_state
17251:Src/bno055.c  **** 		} else {
 33705              		.loc 1 17251 0
 33706 0050 8120     		movs	r0, #129
 33707              	.LVL4116:
 33708 0052 F2E7     		b	.L3751
 33709              	.L3763:
 33710              		.align	2
 33711              	.L3762:
 33712 0054 00000000 		.word	.LANCHOR0
 33713              		.cfi_endproc
 33714              	.LFE269:
 33716              		.section	.text.bno055_set_gyro_any_motion_thres,"ax",%progbits
 33717              		.align	2
 33718              		.global	bno055_set_gyro_any_motion_thres
 33719              		.thumb
 33720              		.thumb_func
 33722              	bno055_set_gyro_any_motion_thres:
 33723              	.LFB270:
17274:Src/bno055.c  **** /*!
17275:Src/bno055.c  ****  *	@brief This API used to write gyro anymotion threshold
17276:Src/bno055.c  ****  *	from page one register from 0x1E bit 0 to 6
17277:Src/bno055.c  ****  *
17278:Src/bno055.c  ****  *	@param gyro_any_motion_thres_u8 : The value of gyro anymotion threshold
17279:Src/bno055.c  ****  *
17280:Src/bno055.c  ****  *	@return results of bus communication function
17281:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17282:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17283:Src/bno055.c  ****  *
17284:Src/bno055.c  ****  *	@note Gyro anymotion interrupt threshold dependent
17285:Src/bno055.c  ****  *	on the selection of gyro range
17286:Src/bno055.c  ****  *
17287:Src/bno055.c  ****  *  gyro_range_u8	  |	threshold	  |	   LSB
17288:Src/bno055.c  ****  * -----------------  | ------------- | ---------
17289:Src/bno055.c  ****  *     2000           |    1dps       |   1LSB
17290:Src/bno055.c  ****  *     1000           |    0.5dps     |   1LSB
17291:Src/bno055.c  ****  *     500            |    0.25dps    |   1LSB
17292:Src/bno055.c  ****  *
17293:Src/bno055.c  ****  */
17294:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_any_motion_thres(
17295:Src/bno055.c  **** u8 gyro_any_motion_thres_u8)
ARM GAS  /tmp/ccVWLGiI.s 			page 957


17296:Src/bno055.c  **** {
 33724              		.loc 1 17296 0
 33725              		.cfi_startproc
 33726              		@ args = 0, pretend = 0, frame = 8
 33727              		@ frame_needed = 0, uses_anonymous_args = 0
 33728              	.LVL4117:
 33729 0000 30B5     		push	{r4, r5, lr}
 33730              	.LCFI1414:
 33731              		.cfi_def_cfa_offset 12
 33732              		.cfi_offset 4, -12
 33733              		.cfi_offset 5, -8
 33734              		.cfi_offset 14, -4
17297:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17298:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
17299:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
17300:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
17301:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
17302:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
17303:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 33735              		.loc 1 17303 0
 33736 0002 264C     		ldr	r4, .L3780
17296:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 33737              		.loc 1 17296 0
 33738 0004 83B0     		sub	sp, sp, #12
 33739              	.LCFI1415:
 33740              		.cfi_def_cfa_offset 24
 33741              		.loc 1 17303 0
 33742 0006 2268     		ldr	r2, [r4]
17298:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 33743              		.loc 1 17298 0
 33744 0008 0023     		movs	r3, #0
 33745 000a 8DF80630 		strb	r3, [sp, #6]
 33746              	.LVL4118:
17300:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
 33747              		.loc 1 17300 0
 33748 000e 8DF80730 		strb	r3, [sp, #7]
 33749              	.LVL4119:
 33750              		.loc 1 17303 0
 33751 0012 002A     		cmp	r2, #0
 33752 0014 40D0     		beq	.L3772
 33753 0016 0546     		mov	r5, r0
17304:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
17305:Src/bno055.c  **** } else {
17306:Src/bno055.c  **** /* The write operation effective only if the operation
17307:Src/bno055.c  **** mode is in config mode, this part of code is checking the
17308:Src/bno055.c  **** current operation mode and set the config mode */
17309:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 33754              		.loc 1 17309 0
 33755 0018 0DF10700 		add	r0, sp, #7
 33756              	.LVL4120:
 33757 001c FFF7FEFF 		bl	bno055_get_operation_mode
 33758              	.LVL4121:
17310:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 33759              		.loc 1 17310 0
 33760 0020 38B1     		cbz	r0, .L3766
 33761              	.LVL4122:
 33762              	.L3770:
ARM GAS  /tmp/ccVWLGiI.s 			page 958


17311:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
17312:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
17313:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
17314:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
17315:Src/bno055.c  **** 			/* Write page as one */
17316:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
17317:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
17318:Src/bno055.c  **** 				/* Write the value
17319:Src/bno055.c  **** 				of gyro anymotion threshold*/
17320:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
17321:Src/bno055.c  **** 				(p_bno055->dev_addr,
17322:Src/bno055.c  **** 				BNO055_GYRO_ANY_MOTION_THRES_REG,
17323:Src/bno055.c  **** 				&data_u8r,
17324:Src/bno055.c  **** 				BNO055_GEN_READ_WRITE_LENGTH);
17325:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
17326:Src/bno055.c  **** 					data_u8r =
17327:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
17328:Src/bno055.c  **** 					BNO055_GYRO_ANY_MOTION_THRES,
17329:Src/bno055.c  **** 					gyro_any_motion_thres_u8);
17330:Src/bno055.c  **** 					com_rslt +=
17331:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
17332:Src/bno055.c  **** 					(p_bno055->dev_addr,
17333:Src/bno055.c  **** 					BNO055_GYRO_ANY_MOTION_THRES_REG,
17334:Src/bno055.c  **** 					&data_u8r,
17335:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
17336:Src/bno055.c  **** 				}
17337:Src/bno055.c  **** 			} else {
17338:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
17339:Src/bno055.c  **** 			}
17340:Src/bno055.c  **** 		} else {
17341:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17342:Src/bno055.c  **** 		}
17343:Src/bno055.c  **** 	} else {
17344:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 33763              		.loc 1 17344 0
 33764 0022 FF24     		movs	r4, #255
 33765              	.LVL4123:
 33766              	.L3767:
17345:Src/bno055.c  **** 	}
17346:Src/bno055.c  **** }
17347:Src/bno055.c  **** if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 33767              		.loc 1 17347 0
 33768 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 33769 0028 50BB     		cbnz	r0, .L3779
 33770 002a 2046     		mov	r0, r4
 33771              	.LVL4124:
 33772              	.L3765:
17348:Src/bno055.c  **** 	/* set the operation mode of
17349:Src/bno055.c  **** 	previous operation mode*/
17350:Src/bno055.c  **** 	com_rslt += bno055_set_operation_mode
17351:Src/bno055.c  **** 	(prev_opmode_u8);
17352:Src/bno055.c  **** return com_rslt;
17353:Src/bno055.c  **** }
 33773              		.loc 1 17353 0
 33774 002c 40B2     		sxtb	r0, r0
 33775 002e 03B0     		add	sp, sp, #12
 33776              	.LCFI1416:
ARM GAS  /tmp/ccVWLGiI.s 			page 959


 33777              		.cfi_remember_state
 33778              		.cfi_def_cfa_offset 12
 33779              		@ sp needed
 33780 0030 30BD     		pop	{r4, r5, pc}
 33781              	.LVL4125:
 33782              	.L3766:
 33783              	.LCFI1417:
 33784              		.cfi_restore_state
17311:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 33785              		.loc 1 17311 0
 33786 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33787 0036 53BB     		cbnz	r3, .L3768
 33788              	.L3771:
 33789              	.LVL4126:
17316:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 33790              		.loc 1 17316 0
 33791 0038 0120     		movs	r0, #1
 33792 003a FFF7FEFF 		bl	bno055_write_page_id
 33793              	.LVL4127:
17317:Src/bno055.c  **** 				/* Write the value
 33794              		.loc 1 17317 0
 33795 003e 0028     		cmp	r0, #0
 33796 0040 EFD1     		bne	.L3770
17320:Src/bno055.c  **** 				(p_bno055->dev_addr,
 33797              		.loc 1 17320 0
 33798 0042 2368     		ldr	r3, [r4]
 33799 0044 0DF10602 		add	r2, sp, #6
 33800 0048 1C69     		ldr	r4, [r3, #16]
 33801 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33802              	.LVL4128:
 33803 004c 1E21     		movs	r1, #30
 33804 004e 0123     		movs	r3, #1
 33805 0050 A047     		blx	r4
 33806              	.LVL4129:
 33807 0052 124A     		ldr	r2, .L3780
17325:Src/bno055.c  **** 					data_u8r =
 33808              		.loc 1 17325 0
 33809 0054 0446     		mov	r4, r0
 33810 0056 0028     		cmp	r0, #0
 33811 0058 E4D1     		bne	.L3767
17326:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33812              		.loc 1 17326 0
 33813 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
17331:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33814              		.loc 1 17331 0
 33815 005e 1168     		ldr	r1, [r2]
17326:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33816              		.loc 1 17326 0
 33817 0060 23F07F03 		bic	r3, r3, #127
 33818 0064 05F07F00 		and	r0, r5, #127
 33819              	.LVL4130:
 33820 0068 1843     		orrs	r0, r0, r3
17331:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33821              		.loc 1 17331 0
 33822 006a CC68     		ldr	r4, [r1, #12]
17326:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 33823              		.loc 1 17326 0
ARM GAS  /tmp/ccVWLGiI.s 			page 960


 33824 006c 8DF80600 		strb	r0, [sp, #6]
17331:Src/bno055.c  **** 					(p_bno055->dev_addr,
 33825              		.loc 1 17331 0
 33826 0070 0DF10602 		add	r2, sp, #6
 33827 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 33828 0076 0123     		movs	r3, #1
 33829 0078 1E21     		movs	r1, #30
 33830 007a A047     		blx	r4
 33831              	.LVL4131:
 33832 007c 0446     		mov	r4, r0
 33833              	.LVL4132:
 33834 007e D1E7     		b	.L3767
 33835              	.L3779:
17350:Src/bno055.c  **** 	(prev_opmode_u8);
 33836              		.loc 1 17350 0
 33837 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 33838              	.LVL4133:
 33839 0084 2044     		add	r0, r0, r4
 33840 0086 C0B2     		uxtb	r0, r0
 33841              	.LVL4134:
 33842              		.loc 1 17353 0
 33843 0088 40B2     		sxtb	r0, r0
 33844 008a 03B0     		add	sp, sp, #12
 33845              	.LCFI1418:
 33846              		.cfi_remember_state
 33847              		.cfi_def_cfa_offset 12
 33848              		@ sp needed
 33849 008c 30BD     		pop	{r4, r5, pc}
 33850              	.LVL4135:
 33851              	.L3768:
 33852              	.LCFI1419:
 33853              		.cfi_restore_state
17312:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 33854              		.loc 1 17312 0
 33855 008e FFF7FEFF 		bl	bno055_set_operation_mode
 33856              	.LVL4136:
17314:Src/bno055.c  **** 			/* Write page as one */
 33857              		.loc 1 17314 0
 33858 0092 0028     		cmp	r0, #0
 33859 0094 C5D1     		bne	.L3770
 33860 0096 CFE7     		b	.L3771
 33861              	.LVL4137:
 33862              	.L3772:
17304:Src/bno055.c  **** } else {
 33863              		.loc 1 17304 0
 33864 0098 8120     		movs	r0, #129
 33865              	.LVL4138:
 33866 009a C7E7     		b	.L3765
 33867              	.L3781:
 33868              		.align	2
 33869              	.L3780:
 33870 009c 00000000 		.word	.LANCHOR0
 33871              		.cfi_endproc
 33872              	.LFE270:
 33874              		.section	.text.bno055_get_gyro_any_motion_slope_samples,"ax",%progbits
 33875              		.align	2
 33876              		.global	bno055_get_gyro_any_motion_slope_samples
ARM GAS  /tmp/ccVWLGiI.s 			page 961


 33877              		.thumb
 33878              		.thumb_func
 33880              	bno055_get_gyro_any_motion_slope_samples:
 33881              	.LFB271:
17354:Src/bno055.c  **** /*!
17355:Src/bno055.c  ****  *	@brief This API used to read gyro anymotion slope samples
17356:Src/bno055.c  ****  *	from page one register from 0x1F bit 0 to 1
17357:Src/bno055.c  ****  *
17358:Src/bno055.c  ****  *	@param gyro_any_motion_slope_samples_u8 :
17359:Src/bno055.c  ****  *	The value of gyro anymotion slope samples
17360:Src/bno055.c  ****  *  gyro_any_motion_slope_samples_u8   |   result
17361:Src/bno055.c  ****  *  ----------------------------------   | -----------
17362:Src/bno055.c  ****  *            0                          |    8 samples
17363:Src/bno055.c  ****  *            1                          |    16 samples
17364:Src/bno055.c  ****  *            2                          |    32 samples
17365:Src/bno055.c  ****  *            3                          |    64 samples
17366:Src/bno055.c  ****  *
17367:Src/bno055.c  ****  *	@return results of bus communication function
17368:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17369:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17370:Src/bno055.c  ****  *
17371:Src/bno055.c  ****  */
17372:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_any_motion_slope_samples(
17373:Src/bno055.c  **** u8 *gyro_any_motion_slope_samples_u8)
17374:Src/bno055.c  **** {
 33882              		.loc 1 17374 0
 33883              		.cfi_startproc
 33884              		@ args = 0, pretend = 0, frame = 8
 33885              		@ frame_needed = 0, uses_anonymous_args = 0
 33886              	.LVL4139:
 33887 0000 30B5     		push	{r4, r5, lr}
 33888              	.LCFI1420:
 33889              		.cfi_def_cfa_offset 12
 33890              		.cfi_offset 4, -12
 33891              		.cfi_offset 5, -8
 33892              		.cfi_offset 14, -4
17375:Src/bno055.c  **** 	/* Variable used to return value of
17376:Src/bno055.c  **** 	communication routine*/
17377:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17378:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
17379:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
17380:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
17381:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 33893              		.loc 1 17381 0
 33894 0002 144C     		ldr	r4, .L3794
17374:Src/bno055.c  **** 	/* Variable used to return value of
 33895              		.loc 1 17374 0
 33896 0004 83B0     		sub	sp, sp, #12
 33897              	.LCFI1421:
 33898              		.cfi_def_cfa_offset 24
 33899              		.loc 1 17381 0
 33900 0006 2368     		ldr	r3, [r4]
17378:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
 33901              		.loc 1 17378 0
 33902 0008 0022     		movs	r2, #0
 33903 000a 8DF80720 		strb	r2, [sp, #7]
 33904              	.LVL4140:
ARM GAS  /tmp/ccVWLGiI.s 			page 962


 33905              		.loc 1 17381 0
 33906 000e FBB1     		cbz	r3, .L3786
17382:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
17383:Src/bno055.c  **** 		} else {
17384:Src/bno055.c  **** 		/*condition check for page, gyro anymotion slope samples is
17385:Src/bno055.c  **** 		available in the page one*/
17386:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 33907              		.loc 1 17386 0
 33908 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33909 0012 0546     		mov	r5, r0
 33910 0014 012A     		cmp	r2, #1
 33911 0016 04D0     		beq	.L3784
17387:Src/bno055.c  **** 			/* Write page as one */
17388:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 33912              		.loc 1 17388 0
 33913 0018 0120     		movs	r0, #1
 33914              	.LVL4141:
 33915 001a FFF7FEFF 		bl	bno055_write_page_id
 33916              	.LVL4142:
 33917 001e 2368     		ldr	r3, [r4]
17389:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 33918              		.loc 1 17389 0
 33919 0020 70B9     		cbnz	r0, .L3793
 33920              	.LVL4143:
 33921              	.L3784:
17390:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
17391:Src/bno055.c  **** 			/*Read the value of gyro anymotion slope samples*/
17392:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 33922              		.loc 1 17392 0
 33923 0022 1C69     		ldr	r4, [r3, #16]
 33924 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 33925 0026 1F21     		movs	r1, #31
 33926 0028 0123     		movs	r3, #1
 33927 002a 0DF10702 		add	r2, sp, #7
 33928 002e A047     		blx	r4
 33929              	.LVL4144:
17393:Src/bno055.c  **** 			(p_bno055->dev_addr,
17394:Src/bno055.c  **** 			BNO055_GYRO_SLOPE_SAMPLES_REG,
17395:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
17396:Src/bno055.c  **** 			*gyro_any_motion_slope_samples_u8 =
 33930              		.loc 1 17396 0
 33931 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 33932 0034 03F00303 		and	r3, r3, #3
 33933 0038 2B70     		strb	r3, [r5]
 33934              	.LVL4145:
 33935              	.L3783:
17397:Src/bno055.c  **** 			BNO055_GET_BITSLICE(data_u8r,
17398:Src/bno055.c  **** 			BNO055_GYRO_SLOPE_SAMPLES);
17399:Src/bno055.c  **** 		} else {
17400:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17401:Src/bno055.c  **** 		}
17402:Src/bno055.c  **** 	}
17403:Src/bno055.c  **** 	return com_rslt;
17404:Src/bno055.c  **** }
 33936              		.loc 1 17404 0
 33937 003a 40B2     		sxtb	r0, r0
 33938 003c 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccVWLGiI.s 			page 963


 33939              	.LCFI1422:
 33940              		.cfi_remember_state
 33941              		.cfi_def_cfa_offset 12
 33942              		@ sp needed
 33943 003e 30BD     		pop	{r4, r5, pc}
 33944              	.LVL4146:
 33945              	.L3793:
 33946              	.LCFI1423:
 33947              		.cfi_restore_state
17389:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33948              		.loc 1 17389 0 discriminator 1
 33949 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 33950 0042 012A     		cmp	r2, #1
17400:Src/bno055.c  **** 		}
 33951              		.loc 1 17400 0 discriminator 1
 33952 0044 18BF     		it	ne
 33953 0046 FF20     		movne	r0, #255
17389:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 33954              		.loc 1 17389 0 discriminator 1
 33955 0048 EBD0     		beq	.L3784
 33956              		.loc 1 17404 0
 33957 004a 40B2     		sxtb	r0, r0
 33958 004c 03B0     		add	sp, sp, #12
 33959              	.LCFI1424:
 33960              		.cfi_remember_state
 33961              		.cfi_def_cfa_offset 12
 33962              		@ sp needed
 33963 004e 30BD     		pop	{r4, r5, pc}
 33964              	.LVL4147:
 33965              	.L3786:
 33966              	.LCFI1425:
 33967              		.cfi_restore_state
17382:Src/bno055.c  **** 		} else {
 33968              		.loc 1 17382 0
 33969 0050 8120     		movs	r0, #129
 33970              	.LVL4148:
 33971 0052 F2E7     		b	.L3783
 33972              	.L3795:
 33973              		.align	2
 33974              	.L3794:
 33975 0054 00000000 		.word	.LANCHOR0
 33976              		.cfi_endproc
 33977              	.LFE271:
 33979              		.section	.text.bno055_set_gyro_any_motion_slope_samples,"ax",%progbits
 33980              		.align	2
 33981              		.global	bno055_set_gyro_any_motion_slope_samples
 33982              		.thumb
 33983              		.thumb_func
 33985              	bno055_set_gyro_any_motion_slope_samples:
 33986              	.LFB272:
17405:Src/bno055.c  **** /*!
17406:Src/bno055.c  ****  *	@brief This API used to write gyro anymotion slope samples
17407:Src/bno055.c  ****  *	from page one register from 0x1F bit 0 to 1
17408:Src/bno055.c  ****  *
17409:Src/bno055.c  ****  *	@param gyro_any_motion_slope_samples_u8 :
17410:Src/bno055.c  ****  *	The value of gyro anymotion slope samples
17411:Src/bno055.c  ****  *  gyro_any_motion_slope_samples_u8   |   result
ARM GAS  /tmp/ccVWLGiI.s 			page 964


17412:Src/bno055.c  ****  *  ----------------------------------   | -----------
17413:Src/bno055.c  ****  *            0                          |    8 samples
17414:Src/bno055.c  ****  *            1                          |    16 samples
17415:Src/bno055.c  ****  *            2                          |    32 samples
17416:Src/bno055.c  ****  *            3                          |    64 samples
17417:Src/bno055.c  ****  *
17418:Src/bno055.c  ****  *	@return results of bus communication function
17419:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17420:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17421:Src/bno055.c  ****  *
17422:Src/bno055.c  ****  */
17423:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_any_motion_slope_samples(
17424:Src/bno055.c  **** u8 gyro_any_motion_slope_samples_u8)
17425:Src/bno055.c  **** {
 33987              		.loc 1 17425 0
 33988              		.cfi_startproc
 33989              		@ args = 0, pretend = 0, frame = 8
 33990              		@ frame_needed = 0, uses_anonymous_args = 0
 33991              	.LVL4149:
 33992 0000 30B5     		push	{r4, r5, lr}
 33993              	.LCFI1426:
 33994              		.cfi_def_cfa_offset 12
 33995              		.cfi_offset 4, -12
 33996              		.cfi_offset 5, -8
 33997              		.cfi_offset 14, -4
17426:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17427:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
17428:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
17429:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
17430:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
17431:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
17432:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 33998              		.loc 1 17432 0
 33999 0002 264C     		ldr	r4, .L3812
17425:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 34000              		.loc 1 17425 0
 34001 0004 83B0     		sub	sp, sp, #12
 34002              	.LCFI1427:
 34003              		.cfi_def_cfa_offset 24
 34004              		.loc 1 17432 0
 34005 0006 2268     		ldr	r2, [r4]
17427:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 34006              		.loc 1 17427 0
 34007 0008 0023     		movs	r3, #0
 34008 000a 8DF80630 		strb	r3, [sp, #6]
 34009              	.LVL4150:
17430:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 34010              		.loc 1 17430 0
 34011 000e 8DF80730 		strb	r3, [sp, #7]
 34012              		.loc 1 17432 0
 34013 0012 002A     		cmp	r2, #0
 34014 0014 40D0     		beq	.L3804
 34015 0016 0546     		mov	r5, r0
17433:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
17434:Src/bno055.c  **** } else {
17435:Src/bno055.c  **** /* The write operation effective only if the operation
17436:Src/bno055.c  **** mode is in config mode, this part of code is checking the
ARM GAS  /tmp/ccVWLGiI.s 			page 965


17437:Src/bno055.c  **** current operation mode and set the config mode */
17438:Src/bno055.c  **** stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 34016              		.loc 1 17438 0
 34017 0018 0DF10700 		add	r0, sp, #7
 34018              	.LVL4151:
 34019 001c FFF7FEFF 		bl	bno055_get_operation_mode
 34020              	.LVL4152:
17439:Src/bno055.c  **** if (stat_s8 == BNO055_SUCCESS) {
 34021              		.loc 1 17439 0
 34022 0020 38B1     		cbz	r0, .L3798
 34023              	.LVL4153:
 34024              	.L3802:
17440:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
17441:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
17442:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
17443:Src/bno055.c  **** 		if (stat_s8 == BNO055_SUCCESS) {
17444:Src/bno055.c  **** 			/* Write page as one */
17445:Src/bno055.c  **** 			pg_stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
17446:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
17447:Src/bno055.c  **** 				/* Write the value of
17448:Src/bno055.c  **** 				gyro anymotion slope samples*/
17449:Src/bno055.c  **** 				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
17450:Src/bno055.c  **** 				(p_bno055->dev_addr,
17451:Src/bno055.c  **** 				BNO055_GYRO_SLOPE_SAMPLES_REG,
17452:Src/bno055.c  **** 				&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
17453:Src/bno055.c  **** 				if (com_rslt == BNO055_SUCCESS) {
17454:Src/bno055.c  **** 					data_u8r =
17455:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
17456:Src/bno055.c  **** 					BNO055_GYRO_SLOPE_SAMPLES,
17457:Src/bno055.c  **** 					gyro_any_motion_slope_samples_u8);
17458:Src/bno055.c  **** 					com_rslt +=
17459:Src/bno055.c  **** 					p_bno055->BNO055_BUS_WRITE_FUNC
17460:Src/bno055.c  **** 					(p_bno055->dev_addr,
17461:Src/bno055.c  **** 					BNO055_GYRO_SLOPE_SAMPLES_REG,
17462:Src/bno055.c  **** 					&data_u8r,
17463:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
17464:Src/bno055.c  **** 				}
17465:Src/bno055.c  **** 			} else {
17466:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
17467:Src/bno055.c  **** 			}
17468:Src/bno055.c  **** 		} else {
17469:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17470:Src/bno055.c  **** 		}
17471:Src/bno055.c  **** 	} else {
17472:Src/bno055.c  **** 	com_rslt = BNO055_ERROR;
 34025              		.loc 1 17472 0
 34026 0022 FF24     		movs	r4, #255
 34027              	.LVL4154:
 34028              	.L3799:
17473:Src/bno055.c  **** 	}
17474:Src/bno055.c  **** 	}
17475:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 34029              		.loc 1 17475 0
 34030 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 34031 0028 50BB     		cbnz	r0, .L3811
 34032 002a 2046     		mov	r0, r4
 34033              	.LVL4155:
ARM GAS  /tmp/ccVWLGiI.s 			page 966


 34034              	.L3797:
17476:Src/bno055.c  **** 		/* set the operation mode of
17477:Src/bno055.c  **** 		previous operation mode*/
17478:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
17479:Src/bno055.c  **** 		(prev_opmode_u8);
17480:Src/bno055.c  **** 	return com_rslt;
17481:Src/bno055.c  **** }
 34035              		.loc 1 17481 0
 34036 002c 40B2     		sxtb	r0, r0
 34037 002e 03B0     		add	sp, sp, #12
 34038              	.LCFI1428:
 34039              		.cfi_remember_state
 34040              		.cfi_def_cfa_offset 12
 34041              		@ sp needed
 34042 0030 30BD     		pop	{r4, r5, pc}
 34043              	.LVL4156:
 34044              	.L3798:
 34045              	.LCFI1429:
 34046              		.cfi_restore_state
17440:Src/bno055.c  **** 		stat_s8 += bno055_set_operation_mode
 34047              		.loc 1 17440 0
 34048 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 34049 0036 53BB     		cbnz	r3, .L3800
 34050              	.L3803:
 34051              	.LVL4157:
17445:Src/bno055.c  **** 			if (pg_stat_s8 == BNO055_SUCCESS) {
 34052              		.loc 1 17445 0
 34053 0038 0120     		movs	r0, #1
 34054 003a FFF7FEFF 		bl	bno055_write_page_id
 34055              	.LVL4158:
17446:Src/bno055.c  **** 				/* Write the value of
 34056              		.loc 1 17446 0
 34057 003e 0028     		cmp	r0, #0
 34058 0040 EFD1     		bne	.L3802
17449:Src/bno055.c  **** 				(p_bno055->dev_addr,
 34059              		.loc 1 17449 0
 34060 0042 2368     		ldr	r3, [r4]
 34061 0044 0DF10602 		add	r2, sp, #6
 34062 0048 1C69     		ldr	r4, [r3, #16]
 34063 004a 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 34064              	.LVL4159:
 34065 004c 1F21     		movs	r1, #31
 34066 004e 0123     		movs	r3, #1
 34067 0050 A047     		blx	r4
 34068              	.LVL4160:
 34069 0052 124A     		ldr	r2, .L3812
17453:Src/bno055.c  **** 					data_u8r =
 34070              		.loc 1 17453 0
 34071 0054 0446     		mov	r4, r0
 34072 0056 0028     		cmp	r0, #0
 34073 0058 E4D1     		bne	.L3799
17454:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 34074              		.loc 1 17454 0
 34075 005a 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
17459:Src/bno055.c  **** 					(p_bno055->dev_addr,
 34076              		.loc 1 17459 0
 34077 005e 1168     		ldr	r1, [r2]
ARM GAS  /tmp/ccVWLGiI.s 			page 967


17454:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 34078              		.loc 1 17454 0
 34079 0060 23F00303 		bic	r3, r3, #3
 34080 0064 05F00300 		and	r0, r5, #3
 34081              	.LVL4161:
 34082 0068 1843     		orrs	r0, r0, r3
17459:Src/bno055.c  **** 					(p_bno055->dev_addr,
 34083              		.loc 1 17459 0
 34084 006a CC68     		ldr	r4, [r1, #12]
17454:Src/bno055.c  **** 					BNO055_SET_BITSLICE(data_u8r,
 34085              		.loc 1 17454 0
 34086 006c 8DF80600 		strb	r0, [sp, #6]
17459:Src/bno055.c  **** 					(p_bno055->dev_addr,
 34087              		.loc 1 17459 0
 34088 0070 0DF10602 		add	r2, sp, #6
 34089 0074 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 34090 0076 0123     		movs	r3, #1
 34091 0078 1F21     		movs	r1, #31
 34092 007a A047     		blx	r4
 34093              	.LVL4162:
 34094 007c 0446     		mov	r4, r0
 34095              	.LVL4163:
 34096 007e D1E7     		b	.L3799
 34097              	.L3811:
17478:Src/bno055.c  **** 		(prev_opmode_u8);
 34098              		.loc 1 17478 0
 34099 0080 FFF7FEFF 		bl	bno055_set_operation_mode
 34100              	.LVL4164:
 34101 0084 2044     		add	r0, r0, r4
 34102 0086 C0B2     		uxtb	r0, r0
 34103              	.LVL4165:
 34104              		.loc 1 17481 0
 34105 0088 40B2     		sxtb	r0, r0
 34106 008a 03B0     		add	sp, sp, #12
 34107              	.LCFI1430:
 34108              		.cfi_remember_state
 34109              		.cfi_def_cfa_offset 12
 34110              		@ sp needed
 34111 008c 30BD     		pop	{r4, r5, pc}
 34112              	.LVL4166:
 34113              	.L3800:
 34114              	.LCFI1431:
 34115              		.cfi_restore_state
17441:Src/bno055.c  **** 		(BNO055_OPERATION_MODE_CONFIG);
 34116              		.loc 1 17441 0
 34117 008e FFF7FEFF 		bl	bno055_set_operation_mode
 34118              	.LVL4167:
17443:Src/bno055.c  **** 			/* Write page as one */
 34119              		.loc 1 17443 0
 34120 0092 0028     		cmp	r0, #0
 34121 0094 C5D1     		bne	.L3802
 34122 0096 CFE7     		b	.L3803
 34123              	.LVL4168:
 34124              	.L3804:
17433:Src/bno055.c  **** } else {
 34125              		.loc 1 17433 0
 34126 0098 8120     		movs	r0, #129
ARM GAS  /tmp/ccVWLGiI.s 			page 968


 34127              	.LVL4169:
 34128 009a C7E7     		b	.L3797
 34129              	.L3813:
 34130              		.align	2
 34131              	.L3812:
 34132 009c 00000000 		.word	.LANCHOR0
 34133              		.cfi_endproc
 34134              	.LFE272:
 34136              		.section	.text.bno055_get_gyro_any_motion_awake_durn,"ax",%progbits
 34137              		.align	2
 34138              		.global	bno055_get_gyro_any_motion_awake_durn
 34139              		.thumb
 34140              		.thumb_func
 34142              	bno055_get_gyro_any_motion_awake_durn:
 34143              	.LFB273:
17482:Src/bno055.c  **** /*!
17483:Src/bno055.c  ****  *	@brief This API used to read gyro anymotion awake duration
17484:Src/bno055.c  ****  *	from page one register from 0x1F bit 2 to 3
17485:Src/bno055.c  ****  *
17486:Src/bno055.c  ****  *	@param gyro_awake_durn_u8 : The value of gyro anymotion awake duration
17487:Src/bno055.c  ****  *
17488:Src/bno055.c  ****  *	@return results of bus communication function
17489:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17490:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17491:Src/bno055.c  ****  *
17492:Src/bno055.c  ****  */
17493:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_get_gyro_any_motion_awake_durn(
17494:Src/bno055.c  **** u8 *gyro_awake_durn_u8)
17495:Src/bno055.c  **** {
 34144              		.loc 1 17495 0
 34145              		.cfi_startproc
 34146              		@ args = 0, pretend = 0, frame = 8
 34147              		@ frame_needed = 0, uses_anonymous_args = 0
 34148              	.LVL4170:
 34149 0000 30B5     		push	{r4, r5, lr}
 34150              	.LCFI1432:
 34151              		.cfi_def_cfa_offset 12
 34152              		.cfi_offset 4, -12
 34153              		.cfi_offset 5, -8
 34154              		.cfi_offset 14, -4
17496:Src/bno055.c  **** 	/* Variable used to return value of
17497:Src/bno055.c  **** 	communication routine*/
17498:Src/bno055.c  **** 	BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17499:Src/bno055.c  **** 	u8 data_u8r = BNO055_INIT_VALUE;
17500:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
17501:Src/bno055.c  **** 	/* Check the struct p_bno055 is empty */
17502:Src/bno055.c  **** 	if (p_bno055 == BNO055_INIT_VALUE)  {
 34155              		.loc 1 17502 0
 34156 0002 144C     		ldr	r4, .L3826
17495:Src/bno055.c  **** 	/* Variable used to return value of
 34157              		.loc 1 17495 0
 34158 0004 83B0     		sub	sp, sp, #12
 34159              	.LCFI1433:
 34160              		.cfi_def_cfa_offset 24
 34161              		.loc 1 17502 0
 34162 0006 2368     		ldr	r3, [r4]
17499:Src/bno055.c  **** 	s8 stat_s8 = BNO055_ERROR;
ARM GAS  /tmp/ccVWLGiI.s 			page 969


 34163              		.loc 1 17499 0
 34164 0008 0022     		movs	r2, #0
 34165 000a 8DF80720 		strb	r2, [sp, #7]
 34166              	.LVL4171:
 34167              		.loc 1 17502 0
 34168 000e FBB1     		cbz	r3, .L3818
17503:Src/bno055.c  **** 		return BNO055_E_NULL_PTR;
17504:Src/bno055.c  **** 		} else {
17505:Src/bno055.c  **** 		/*condition check for page, gyro anymotion awake duration is
17506:Src/bno055.c  **** 		available in the page one*/
17507:Src/bno055.c  **** 		if (p_bno055->page_id != BNO055_PAGE_ONE)
 34169              		.loc 1 17507 0
 34170 0010 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 34171 0012 0546     		mov	r5, r0
 34172 0014 012A     		cmp	r2, #1
 34173 0016 04D0     		beq	.L3816
17508:Src/bno055.c  **** 			/* Write page as one */
17509:Src/bno055.c  **** 			stat_s8 = bno055_write_page_id(BNO055_PAGE_ONE);
 34174              		.loc 1 17509 0
 34175 0018 0120     		movs	r0, #1
 34176              	.LVL4172:
 34177 001a FFF7FEFF 		bl	bno055_write_page_id
 34178              	.LVL4173:
 34179 001e 2368     		ldr	r3, [r4]
17510:Src/bno055.c  **** 		if ((stat_s8 == BNO055_SUCCESS) ||
 34180              		.loc 1 17510 0
 34181 0020 70B9     		cbnz	r0, .L3825
 34182              	.LVL4174:
 34183              	.L3816:
17511:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
17512:Src/bno055.c  **** 			/* Read the value of gyro anymotion awake duration*/
17513:Src/bno055.c  **** 			com_rslt = p_bno055->BNO055_BUS_READ_FUNC
 34184              		.loc 1 17513 0
 34185 0022 1C69     		ldr	r4, [r3, #16]
 34186 0024 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 34187 0026 1F21     		movs	r1, #31
 34188 0028 0123     		movs	r3, #1
 34189 002a 0DF10702 		add	r2, sp, #7
 34190 002e A047     		blx	r4
 34191              	.LVL4175:
17514:Src/bno055.c  **** 			(p_bno055->dev_addr,
17515:Src/bno055.c  **** 			BNO055_GYRO_AWAKE_DURN_REG,
17516:Src/bno055.c  **** 			&data_u8r, BNO055_GEN_READ_WRITE_LENGTH);
17517:Src/bno055.c  **** 			*gyro_awake_durn_u8 = BNO055_GET_BITSLICE(data_u8r,
 34192              		.loc 1 17517 0
 34193 0030 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 34194 0034 C3F38103 		ubfx	r3, r3, #2, #2
 34195 0038 2B70     		strb	r3, [r5]
 34196              	.LVL4176:
 34197              	.L3815:
17518:Src/bno055.c  **** 			BNO055_GYRO_AWAKE_DURN);
17519:Src/bno055.c  **** 		} else {
17520:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
17521:Src/bno055.c  **** 		}
17522:Src/bno055.c  **** 	}
17523:Src/bno055.c  **** 	return com_rslt;
17524:Src/bno055.c  **** }
ARM GAS  /tmp/ccVWLGiI.s 			page 970


 34198              		.loc 1 17524 0
 34199 003a 40B2     		sxtb	r0, r0
 34200 003c 03B0     		add	sp, sp, #12
 34201              	.LCFI1434:
 34202              		.cfi_remember_state
 34203              		.cfi_def_cfa_offset 12
 34204              		@ sp needed
 34205 003e 30BD     		pop	{r4, r5, pc}
 34206              	.LVL4177:
 34207              	.L3825:
 34208              	.LCFI1435:
 34209              		.cfi_restore_state
17510:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 34210              		.loc 1 17510 0 discriminator 1
 34211 0040 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 34212 0042 012A     		cmp	r2, #1
17520:Src/bno055.c  **** 		}
 34213              		.loc 1 17520 0 discriminator 1
 34214 0044 18BF     		it	ne
 34215 0046 FF20     		movne	r0, #255
17510:Src/bno055.c  **** 		(p_bno055->page_id == BNO055_PAGE_ONE)) {
 34216              		.loc 1 17510 0 discriminator 1
 34217 0048 EBD0     		beq	.L3816
 34218              		.loc 1 17524 0
 34219 004a 40B2     		sxtb	r0, r0
 34220 004c 03B0     		add	sp, sp, #12
 34221              	.LCFI1436:
 34222              		.cfi_remember_state
 34223              		.cfi_def_cfa_offset 12
 34224              		@ sp needed
 34225 004e 30BD     		pop	{r4, r5, pc}
 34226              	.LVL4178:
 34227              	.L3818:
 34228              	.LCFI1437:
 34229              		.cfi_restore_state
17503:Src/bno055.c  **** 		} else {
 34230              		.loc 1 17503 0
 34231 0050 8120     		movs	r0, #129
 34232              	.LVL4179:
 34233 0052 F2E7     		b	.L3815
 34234              	.L3827:
 34235              		.align	2
 34236              	.L3826:
 34237 0054 00000000 		.word	.LANCHOR0
 34238              		.cfi_endproc
 34239              	.LFE273:
 34241              		.section	.text.bno055_set_gyro_any_motion_awake_durn,"ax",%progbits
 34242              		.align	2
 34243              		.global	bno055_set_gyro_any_motion_awake_durn
 34244              		.thumb
 34245              		.thumb_func
 34247              	bno055_set_gyro_any_motion_awake_durn:
 34248              	.LFB274:
17525:Src/bno055.c  **** /*!
17526:Src/bno055.c  ****  *	@brief This API used to write gyro anymotion awake duration
17527:Src/bno055.c  ****  *	from page one register from 0x1F bit 2 to 3
17528:Src/bno055.c  ****  *
ARM GAS  /tmp/ccVWLGiI.s 			page 971


17529:Src/bno055.c  ****  *	@param gyro_awake_durn_u8 : The value of gyro anymotion awake duration
17530:Src/bno055.c  ****  *
17531:Src/bno055.c  ****  *	@return results of bus communication function
17532:Src/bno055.c  ****  *	@retval 0 -> BNO055_SUCCESS
17533:Src/bno055.c  ****  *	@retval 1 -> BNO055_ERROR
17534:Src/bno055.c  ****  *
17535:Src/bno055.c  ****  */
17536:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE bno055_set_gyro_any_motion_awake_durn(
17537:Src/bno055.c  **** u8 gyro_awake_durn_u8)
17538:Src/bno055.c  **** {
 34249              		.loc 1 17538 0
 34250              		.cfi_startproc
 34251              		@ args = 0, pretend = 0, frame = 8
 34252              		@ frame_needed = 0, uses_anonymous_args = 0
 34253              	.LVL4180:
 34254 0000 30B5     		push	{r4, r5, lr}
 34255              	.LCFI1438:
 34256              		.cfi_def_cfa_offset 12
 34257              		.cfi_offset 4, -12
 34258              		.cfi_offset 5, -8
 34259              		.cfi_offset 14, -4
17539:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
17540:Src/bno055.c  **** u8 data_u8r = BNO055_INIT_VALUE;
17541:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
17542:Src/bno055.c  **** s8 pg_stat_s8 = BNO055_ERROR;
17543:Src/bno055.c  **** u8 prev_opmode_u8 = BNO055_OPERATION_MODE_CONFIG;
17544:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
17545:Src/bno055.c  **** if (p_bno055 == BNO055_INIT_VALUE)  {
 34260              		.loc 1 17545 0
 34261 0002 274C     		ldr	r4, .L3844
17538:Src/bno055.c  **** BNO055_RETURN_FUNCTION_TYPE com_rslt = BNO055_ERROR;
 34262              		.loc 1 17538 0
 34263 0004 83B0     		sub	sp, sp, #12
 34264              	.LCFI1439:
 34265              		.cfi_def_cfa_offset 24
 34266              		.loc 1 17545 0
 34267 0006 2268     		ldr	r2, [r4]
17540:Src/bno055.c  **** s8 stat_s8 = BNO055_ERROR;
 34268              		.loc 1 17540 0
 34269 0008 0023     		movs	r3, #0
 34270 000a 8DF80630 		strb	r3, [sp, #6]
 34271              	.LVL4181:
17543:Src/bno055.c  **** /* Check the struct p_bno055 is empty */
 34272              		.loc 1 17543 0
 34273 000e 8DF80730 		strb	r3, [sp, #7]
 34274              		.loc 1 17545 0
 34275 0012 002A     		cmp	r2, #0
 34276 0014 41D0     		beq	.L3836
 34277 0016 0546     		mov	r5, r0
17546:Src/bno055.c  **** 	return BNO055_E_NULL_PTR;
17547:Src/bno055.c  **** 	} else {
17548:Src/bno055.c  **** 	/* The write operation effective only if the operation
17549:Src/bno055.c  **** 	mode is in config mode, this part of code is checking the
17550:Src/bno055.c  **** 	current operation mode and set the config mode */
17551:Src/bno055.c  **** 	stat_s8 = bno055_get_operation_mode(&prev_opmode_u8);
 34278              		.loc 1 17551 0
 34279 0018 0DF10700 		add	r0, sp, #7
ARM GAS  /tmp/ccVWLGiI.s 			page 972


 34280              	.LVL4182:
 34281 001c FFF7FEFF 		bl	bno055_get_operation_mode
 34282              	.LVL4183:
17552:Src/bno055.c  **** 	if (stat_s8 == BNO055_SUCCESS) {
 34283              		.loc 1 17552 0
 34284 0020 38B1     		cbz	r0, .L3830
 34285              	.LVL4184:
 34286              	.L3834:
17553:Src/bno055.c  **** 		if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
17554:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
17555:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
17556:Src/bno055.c  **** 			if (stat_s8 == BNO055_SUCCESS) {
17557:Src/bno055.c  **** 				/* Write page as one */
17558:Src/bno055.c  **** 				pg_stat_s8 = bno055_write_page_id(
17559:Src/bno055.c  **** 					BNO055_PAGE_ONE);
17560:Src/bno055.c  **** 				if (pg_stat_s8 == BNO055_SUCCESS) {
17561:Src/bno055.c  **** 					/* Write the value of gyro
17562:Src/bno055.c  **** 					anymotion awake duration*/
17563:Src/bno055.c  **** 					com_rslt =
17564:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
17565:Src/bno055.c  **** 					(p_bno055->dev_addr,
17566:Src/bno055.c  **** 					BNO055_GYRO_AWAKE_DURN_REG,
17567:Src/bno055.c  **** 					&data_u8r,
17568:Src/bno055.c  **** 					BNO055_GEN_READ_WRITE_LENGTH);
17569:Src/bno055.c  **** 					if (com_rslt == BNO055_SUCCESS) {
17570:Src/bno055.c  **** 						data_u8r =
17571:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
17572:Src/bno055.c  **** 						BNO055_GYRO_AWAKE_DURN,
17573:Src/bno055.c  **** 						gyro_awake_durn_u8);
17574:Src/bno055.c  **** 						com_rslt +=
17575:Src/bno055.c  **** 						p_bno055->BNO055_BUS_WRITE_FUNC
17576:Src/bno055.c  **** 						(p_bno055->dev_addr,
17577:Src/bno055.c  **** 						BNO055_GYRO_AWAKE_DURN_REG,
17578:Src/bno055.c  **** 						&data_u8r,
17579:Src/bno055.c  **** 						BNO055_GEN_READ_WRITE_LENGTH);
17580:Src/bno055.c  **** 					}
17581:Src/bno055.c  **** 				} else {
17582:Src/bno055.c  **** 				com_rslt = BNO055_ERROR;
17583:Src/bno055.c  **** 				}
17584:Src/bno055.c  **** 			} else {
17585:Src/bno055.c  **** 			com_rslt = BNO055_ERROR;
17586:Src/bno055.c  **** 			}
17587:Src/bno055.c  **** 		} else {
17588:Src/bno055.c  **** 		com_rslt = BNO055_ERROR;
 34287              		.loc 1 17588 0
 34288 0022 FF24     		movs	r4, #255
 34289              	.LVL4185:
 34290              	.L3831:
17589:Src/bno055.c  **** 		}
17590:Src/bno055.c  **** 	}
17591:Src/bno055.c  **** 	if (prev_opmode_u8 != BNO055_OPERATION_MODE_CONFIG)
 34291              		.loc 1 17591 0
 34292 0024 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 34293 0028 58BB     		cbnz	r0, .L3843
 34294 002a 2046     		mov	r0, r4
 34295              	.LVL4186:
 34296              	.L3829:
ARM GAS  /tmp/ccVWLGiI.s 			page 973


17592:Src/bno055.c  **** 		/* set the operation mode
17593:Src/bno055.c  **** 		of previous operation mode*/
17594:Src/bno055.c  **** 		com_rslt += bno055_set_operation_mode
17595:Src/bno055.c  **** 		(prev_opmode_u8);
17596:Src/bno055.c  **** 	return com_rslt;
17597:Src/bno055.c  **** }
 34297              		.loc 1 17597 0
 34298 002c 40B2     		sxtb	r0, r0
 34299 002e 03B0     		add	sp, sp, #12
 34300              	.LCFI1440:
 34301              		.cfi_remember_state
 34302              		.cfi_def_cfa_offset 12
 34303              		@ sp needed
 34304 0030 30BD     		pop	{r4, r5, pc}
 34305              	.LVL4187:
 34306              	.L3830:
 34307              	.LCFI1441:
 34308              		.cfi_restore_state
17553:Src/bno055.c  **** 			stat_s8 += bno055_set_operation_mode
 34309              		.loc 1 17553 0
 34310 0032 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 34311 0036 5BBB     		cbnz	r3, .L3832
 34312              	.L3835:
 34313              	.LVL4188:
17558:Src/bno055.c  **** 					BNO055_PAGE_ONE);
 34314              		.loc 1 17558 0
 34315 0038 0120     		movs	r0, #1
 34316 003a FFF7FEFF 		bl	bno055_write_page_id
 34317              	.LVL4189:
17560:Src/bno055.c  **** 					/* Write the value of gyro
 34318              		.loc 1 17560 0
 34319 003e 0028     		cmp	r0, #0
 34320 0040 EFD1     		bne	.L3834
17564:Src/bno055.c  **** 					(p_bno055->dev_addr,
 34321              		.loc 1 17564 0
 34322 0042 2368     		ldr	r3, [r4]
17563:Src/bno055.c  **** 					p_bno055->BNO055_BUS_READ_FUNC
 34323              		.loc 1 17563 0
 34324 0044 1F21     		movs	r1, #31
 34325 0046 1C69     		ldr	r4, [r3, #16]
 34326 0048 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 34327              	.LVL4190:
 34328 004a 0DF10602 		add	r2, sp, #6
 34329 004e 0123     		movs	r3, #1
 34330 0050 A047     		blx	r4
 34331              	.LVL4191:
17564:Src/bno055.c  **** 					(p_bno055->dev_addr,
 34332              		.loc 1 17564 0
 34333 0052 1349     		ldr	r1, .L3844
17569:Src/bno055.c  **** 						data_u8r =
 34334              		.loc 1 17569 0
 34335 0054 0446     		mov	r4, r0
 34336 0056 0028     		cmp	r0, #0
 34337 0058 E4D1     		bne	.L3831
17570:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 34338              		.loc 1 17570 0
 34339 005a 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
ARM GAS  /tmp/ccVWLGiI.s 			page 974


17571:Src/bno055.c  **** 						BNO055_GYRO_AWAKE_DURN,
 34340              		.loc 1 17571 0
 34341 005e AB00     		lsls	r3, r5, #2
17575:Src/bno055.c  **** 						(p_bno055->dev_addr,
 34342              		.loc 1 17575 0
 34343 0060 0968     		ldr	r1, [r1]
17570:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 34344              		.loc 1 17570 0
 34345 0062 22F00C02 		bic	r2, r2, #12
 34346 0066 03F00C03 		and	r3, r3, #12
 34347 006a 1343     		orrs	r3, r3, r2
17575:Src/bno055.c  **** 						(p_bno055->dev_addr,
 34348              		.loc 1 17575 0
 34349 006c CC68     		ldr	r4, [r1, #12]
17570:Src/bno055.c  **** 						BNO055_SET_BITSLICE(data_u8r,
 34350              		.loc 1 17570 0
 34351 006e 8DF80630 		strb	r3, [sp, #6]
17575:Src/bno055.c  **** 						(p_bno055->dev_addr,
 34352              		.loc 1 17575 0
 34353 0072 487A     		ldrb	r0, [r1, #9]	@ zero_extendqisi2
 34354              	.LVL4192:
 34355 0074 0DF10602 		add	r2, sp, #6
 34356 0078 1F21     		movs	r1, #31
 34357 007a 0123     		movs	r3, #1
 34358 007c A047     		blx	r4
 34359              	.LVL4193:
 34360 007e 0446     		mov	r4, r0
 34361              	.LVL4194:
 34362 0080 D0E7     		b	.L3831
 34363              	.L3843:
17594:Src/bno055.c  **** 		(prev_opmode_u8);
 34364              		.loc 1 17594 0
 34365 0082 FFF7FEFF 		bl	bno055_set_operation_mode
 34366              	.LVL4195:
 34367 0086 2044     		add	r0, r0, r4
 34368 0088 C0B2     		uxtb	r0, r0
 34369              	.LVL4196:
 34370              		.loc 1 17597 0
 34371 008a 40B2     		sxtb	r0, r0
 34372 008c 03B0     		add	sp, sp, #12
 34373              	.LCFI1442:
 34374              		.cfi_remember_state
 34375              		.cfi_def_cfa_offset 12
 34376              		@ sp needed
 34377 008e 30BD     		pop	{r4, r5, pc}
 34378              	.LVL4197:
 34379              	.L3832:
 34380              	.LCFI1443:
 34381              		.cfi_restore_state
17554:Src/bno055.c  **** 			(BNO055_OPERATION_MODE_CONFIG);
 34382              		.loc 1 17554 0
 34383 0090 FFF7FEFF 		bl	bno055_set_operation_mode
 34384              	.LVL4198:
17556:Src/bno055.c  **** 				/* Write page as one */
 34385              		.loc 1 17556 0
 34386 0094 0028     		cmp	r0, #0
 34387 0096 C4D1     		bne	.L3834
ARM GAS  /tmp/ccVWLGiI.s 			page 975


 34388 0098 CEE7     		b	.L3835
 34389              	.LVL4199:
 34390              	.L3836:
17546:Src/bno055.c  **** 	} else {
 34391              		.loc 1 17546 0
 34392 009a 8120     		movs	r0, #129
 34393              	.LVL4200:
 34394 009c C6E7     		b	.L3829
 34395              	.L3845:
 34396 009e 00BF     		.align	2
 34397              	.L3844:
 34398 00a0 00000000 		.word	.LANCHOR0
 34399              		.cfi_endproc
 34400              	.LFE274:
 34402              		.section	.bss.p_bno055,"aw",%nobits
 34403              		.align	2
 34404              		.set	.LANCHOR0,. + 0
 34407              	p_bno055:
 34408 0000 00000000 		.space	4
 34409              		.text
 34410              	.Letext0:
 34411              		.file 2 "Inc/bno055.h"
ARM GAS  /tmp/ccVWLGiI.s 			page 976


DEFINED SYMBOLS
                            *ABS*:0000000000000000 bno055.c
     /tmp/ccVWLGiI.s:19     .text.bno055_init:0000000000000000 $t
     /tmp/ccVWLGiI.s:24     .text.bno055_init:0000000000000000 bno055_init
     /tmp/ccVWLGiI.s:225    .text.bno055_init:00000000000000f0 $d
     /tmp/ccVWLGiI.s:230    .text.bno055_write_register:0000000000000000 $t
     /tmp/ccVWLGiI.s:235    .text.bno055_write_register:0000000000000000 bno055_write_register
     /tmp/ccVWLGiI.s:290    .text.bno055_write_register:0000000000000024 $d
     /tmp/ccVWLGiI.s:295    .text.bno055_read_register:0000000000000000 $t
     /tmp/ccVWLGiI.s:300    .text.bno055_read_register:0000000000000000 bno055_read_register
     /tmp/ccVWLGiI.s:355    .text.bno055_read_register:0000000000000024 $d
     /tmp/ccVWLGiI.s:360    .text.bno055_read_page_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:365    .text.bno055_read_page_id:0000000000000000 bno055_read_page_id
     /tmp/ccVWLGiI.s:448    .text.bno055_read_page_id:0000000000000040 $d
     /tmp/ccVWLGiI.s:453    .text.bno055_write_page_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:458    .text.bno055_write_page_id:0000000000000000 bno055_write_page_id
     /tmp/ccVWLGiI.s:553    .text.bno055_write_page_id:0000000000000050 $d
     /tmp/ccVWLGiI.s:558    .text.bno055_read_chip_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:563    .text.bno055_read_chip_id:0000000000000000 bno055_read_chip_id
     /tmp/ccVWLGiI.s:648    .text.bno055_read_chip_id:000000000000004c $d
     /tmp/ccVWLGiI.s:653    .text.bno055_read_sw_rev_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:658    .text.bno055_read_sw_rev_id:0000000000000000 bno055_read_sw_rev_id
     /tmp/ccVWLGiI.s:746    .text.bno055_read_sw_rev_id:0000000000000058 $d
     /tmp/ccVWLGiI.s:751    .text.bno055_read_accel_rev_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:756    .text.bno055_read_accel_rev_id:0000000000000000 bno055_read_accel_rev_id
     /tmp/ccVWLGiI.s:841    .text.bno055_read_accel_rev_id:000000000000004c $d
     /tmp/ccVWLGiI.s:846    .text.bno055_read_mag_rev_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:851    .text.bno055_read_mag_rev_id:0000000000000000 bno055_read_mag_rev_id
     /tmp/ccVWLGiI.s:936    .text.bno055_read_mag_rev_id:000000000000004c $d
     /tmp/ccVWLGiI.s:941    .text.bno055_read_gyro_rev_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:946    .text.bno055_read_gyro_rev_id:0000000000000000 bno055_read_gyro_rev_id
     /tmp/ccVWLGiI.s:1031   .text.bno055_read_gyro_rev_id:000000000000004c $d
     /tmp/ccVWLGiI.s:1036   .text.bno055_read_bl_rev_id:0000000000000000 $t
     /tmp/ccVWLGiI.s:1041   .text.bno055_read_bl_rev_id:0000000000000000 bno055_read_bl_rev_id
     /tmp/ccVWLGiI.s:1126   .text.bno055_read_bl_rev_id:000000000000004c $d
     /tmp/ccVWLGiI.s:1131   .text.bno055_read_accel_x:0000000000000000 $t
     /tmp/ccVWLGiI.s:1136   .text.bno055_read_accel_x:0000000000000000 bno055_read_accel_x
     /tmp/ccVWLGiI.s:1224   .text.bno055_read_accel_x:0000000000000054 $d
     /tmp/ccVWLGiI.s:1229   .text.bno055_read_accel_y:0000000000000000 $t
     /tmp/ccVWLGiI.s:1234   .text.bno055_read_accel_y:0000000000000000 bno055_read_accel_y
     /tmp/ccVWLGiI.s:1322   .text.bno055_read_accel_y:0000000000000054 $d
     /tmp/ccVWLGiI.s:1327   .text.bno055_read_accel_z:0000000000000000 $t
     /tmp/ccVWLGiI.s:1332   .text.bno055_read_accel_z:0000000000000000 bno055_read_accel_z
     /tmp/ccVWLGiI.s:1420   .text.bno055_read_accel_z:0000000000000054 $d
     /tmp/ccVWLGiI.s:1425   .text.bno055_read_accel_xyz:0000000000000000 $t
     /tmp/ccVWLGiI.s:1430   .text.bno055_read_accel_xyz:0000000000000000 bno055_read_accel_xyz
     /tmp/ccVWLGiI.s:1540   .text.bno055_read_accel_xyz:0000000000000080 $d
     /tmp/ccVWLGiI.s:1545   .text.bno055_read_mag_x:0000000000000000 $t
     /tmp/ccVWLGiI.s:1550   .text.bno055_read_mag_x:0000000000000000 bno055_read_mag_x
     /tmp/ccVWLGiI.s:1638   .text.bno055_read_mag_x:0000000000000054 $d
     /tmp/ccVWLGiI.s:1643   .text.bno055_read_mag_y:0000000000000000 $t
     /tmp/ccVWLGiI.s:1648   .text.bno055_read_mag_y:0000000000000000 bno055_read_mag_y
     /tmp/ccVWLGiI.s:1736   .text.bno055_read_mag_y:0000000000000054 $d
     /tmp/ccVWLGiI.s:1741   .text.bno055_read_mag_z:0000000000000000 $t
     /tmp/ccVWLGiI.s:1746   .text.bno055_read_mag_z:0000000000000000 bno055_read_mag_z
     /tmp/ccVWLGiI.s:1834   .text.bno055_read_mag_z:0000000000000054 $d
     /tmp/ccVWLGiI.s:1839   .text.bno055_read_mag_xyz:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 977


     /tmp/ccVWLGiI.s:1844   .text.bno055_read_mag_xyz:0000000000000000 bno055_read_mag_xyz
     /tmp/ccVWLGiI.s:1954   .text.bno055_read_mag_xyz:0000000000000080 $d
     /tmp/ccVWLGiI.s:1959   .text.bno055_read_gyro_x:0000000000000000 $t
     /tmp/ccVWLGiI.s:1964   .text.bno055_read_gyro_x:0000000000000000 bno055_read_gyro_x
     /tmp/ccVWLGiI.s:2052   .text.bno055_read_gyro_x:0000000000000054 $d
     /tmp/ccVWLGiI.s:2057   .text.bno055_read_gyro_y:0000000000000000 $t
     /tmp/ccVWLGiI.s:2062   .text.bno055_read_gyro_y:0000000000000000 bno055_read_gyro_y
     /tmp/ccVWLGiI.s:2150   .text.bno055_read_gyro_y:0000000000000054 $d
     /tmp/ccVWLGiI.s:2155   .text.bno055_read_gyro_z:0000000000000000 $t
     /tmp/ccVWLGiI.s:2160   .text.bno055_read_gyro_z:0000000000000000 bno055_read_gyro_z
     /tmp/ccVWLGiI.s:2248   .text.bno055_read_gyro_z:0000000000000054 $d
     /tmp/ccVWLGiI.s:2253   .text.bno055_read_gyro_xyz:0000000000000000 $t
     /tmp/ccVWLGiI.s:2258   .text.bno055_read_gyro_xyz:0000000000000000 bno055_read_gyro_xyz
     /tmp/ccVWLGiI.s:2368   .text.bno055_read_gyro_xyz:0000000000000080 $d
     /tmp/ccVWLGiI.s:2373   .text.bno055_read_euler_h:0000000000000000 $t
     /tmp/ccVWLGiI.s:2378   .text.bno055_read_euler_h:0000000000000000 bno055_read_euler_h
     /tmp/ccVWLGiI.s:2466   .text.bno055_read_euler_h:0000000000000054 $d
     /tmp/ccVWLGiI.s:2471   .text.bno055_read_euler_r:0000000000000000 $t
     /tmp/ccVWLGiI.s:2476   .text.bno055_read_euler_r:0000000000000000 bno055_read_euler_r
     /tmp/ccVWLGiI.s:2564   .text.bno055_read_euler_r:0000000000000054 $d
     /tmp/ccVWLGiI.s:2569   .text.bno055_read_euler_p:0000000000000000 $t
     /tmp/ccVWLGiI.s:2574   .text.bno055_read_euler_p:0000000000000000 bno055_read_euler_p
     /tmp/ccVWLGiI.s:2662   .text.bno055_read_euler_p:0000000000000054 $d
     /tmp/ccVWLGiI.s:2667   .text.bno055_read_euler_hrp:0000000000000000 $t
     /tmp/ccVWLGiI.s:2672   .text.bno055_read_euler_hrp:0000000000000000 bno055_read_euler_hrp
     /tmp/ccVWLGiI.s:2782   .text.bno055_read_euler_hrp:0000000000000080 $d
     /tmp/ccVWLGiI.s:2787   .text.bno055_read_quaternion_w:0000000000000000 $t
     /tmp/ccVWLGiI.s:2792   .text.bno055_read_quaternion_w:0000000000000000 bno055_read_quaternion_w
     /tmp/ccVWLGiI.s:2880   .text.bno055_read_quaternion_w:0000000000000054 $d
     /tmp/ccVWLGiI.s:2885   .text.bno055_read_quaternion_x:0000000000000000 $t
     /tmp/ccVWLGiI.s:2890   .text.bno055_read_quaternion_x:0000000000000000 bno055_read_quaternion_x
     /tmp/ccVWLGiI.s:2978   .text.bno055_read_quaternion_x:0000000000000054 $d
     /tmp/ccVWLGiI.s:2983   .text.bno055_read_quaternion_y:0000000000000000 $t
     /tmp/ccVWLGiI.s:2988   .text.bno055_read_quaternion_y:0000000000000000 bno055_read_quaternion_y
     /tmp/ccVWLGiI.s:3076   .text.bno055_read_quaternion_y:0000000000000054 $d
     /tmp/ccVWLGiI.s:3081   .text.bno055_read_quaternion_z:0000000000000000 $t
     /tmp/ccVWLGiI.s:3086   .text.bno055_read_quaternion_z:0000000000000000 bno055_read_quaternion_z
     /tmp/ccVWLGiI.s:3174   .text.bno055_read_quaternion_z:0000000000000054 $d
     /tmp/ccVWLGiI.s:3179   .text.bno055_read_quaternion_wxyz:0000000000000000 $t
     /tmp/ccVWLGiI.s:3184   .text.bno055_read_quaternion_wxyz:0000000000000000 bno055_read_quaternion_wxyz
     /tmp/ccVWLGiI.s:3304   .text.bno055_read_quaternion_wxyz:0000000000000098 $d
     /tmp/ccVWLGiI.s:3309   .text.bno055_read_linear_accel_x:0000000000000000 $t
     /tmp/ccVWLGiI.s:3314   .text.bno055_read_linear_accel_x:0000000000000000 bno055_read_linear_accel_x
     /tmp/ccVWLGiI.s:3402   .text.bno055_read_linear_accel_x:0000000000000054 $d
     /tmp/ccVWLGiI.s:3407   .text.bno055_read_linear_accel_y:0000000000000000 $t
     /tmp/ccVWLGiI.s:3412   .text.bno055_read_linear_accel_y:0000000000000000 bno055_read_linear_accel_y
     /tmp/ccVWLGiI.s:3500   .text.bno055_read_linear_accel_y:0000000000000054 $d
     /tmp/ccVWLGiI.s:3505   .text.bno055_read_linear_accel_z:0000000000000000 $t
     /tmp/ccVWLGiI.s:3510   .text.bno055_read_linear_accel_z:0000000000000000 bno055_read_linear_accel_z
     /tmp/ccVWLGiI.s:3598   .text.bno055_read_linear_accel_z:0000000000000054 $d
     /tmp/ccVWLGiI.s:3603   .text.bno055_read_linear_accel_xyz:0000000000000000 $t
     /tmp/ccVWLGiI.s:3608   .text.bno055_read_linear_accel_xyz:0000000000000000 bno055_read_linear_accel_xyz
     /tmp/ccVWLGiI.s:3718   .text.bno055_read_linear_accel_xyz:0000000000000080 $d
     /tmp/ccVWLGiI.s:3723   .text.bno055_read_gravity_x:0000000000000000 $t
     /tmp/ccVWLGiI.s:3728   .text.bno055_read_gravity_x:0000000000000000 bno055_read_gravity_x
     /tmp/ccVWLGiI.s:3816   .text.bno055_read_gravity_x:0000000000000054 $d
     /tmp/ccVWLGiI.s:3821   .text.bno055_read_gravity_y:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 978


     /tmp/ccVWLGiI.s:3826   .text.bno055_read_gravity_y:0000000000000000 bno055_read_gravity_y
     /tmp/ccVWLGiI.s:3914   .text.bno055_read_gravity_y:0000000000000054 $d
     /tmp/ccVWLGiI.s:3919   .text.bno055_read_gravity_z:0000000000000000 $t
     /tmp/ccVWLGiI.s:3924   .text.bno055_read_gravity_z:0000000000000000 bno055_read_gravity_z
     /tmp/ccVWLGiI.s:4012   .text.bno055_read_gravity_z:0000000000000054 $d
     /tmp/ccVWLGiI.s:4017   .text.bno055_read_gravity_xyz:0000000000000000 $t
     /tmp/ccVWLGiI.s:4022   .text.bno055_read_gravity_xyz:0000000000000000 bno055_read_gravity_xyz
     /tmp/ccVWLGiI.s:4132   .text.bno055_read_gravity_xyz:0000000000000080 $d
     /tmp/ccVWLGiI.s:4137   .text.bno055_read_temp_data:0000000000000000 $t
     /tmp/ccVWLGiI.s:4142   .text.bno055_read_temp_data:0000000000000000 bno055_read_temp_data
     /tmp/ccVWLGiI.s:4227   .text.bno055_read_temp_data:000000000000004c $d
     /tmp/ccVWLGiI.s:4235   .text.bno055_convert_float_mag_x_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:4240   .text.bno055_convert_float_mag_x_uT:0000000000000000 bno055_convert_float_mag_x_uT
     /tmp/ccVWLGiI.s:4304   .text.bno055_convert_float_mag_x_uT:0000000000000038 $d
     /tmp/ccVWLGiI.s:4309   .text.bno055_convert_float_mag_y_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:4314   .text.bno055_convert_float_mag_y_uT:0000000000000000 bno055_convert_float_mag_y_uT
     /tmp/ccVWLGiI.s:4378   .text.bno055_convert_float_mag_y_uT:0000000000000038 $d
     /tmp/ccVWLGiI.s:4383   .text.bno055_convert_float_mag_z_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:4388   .text.bno055_convert_float_mag_z_uT:0000000000000000 bno055_convert_float_mag_z_uT
     /tmp/ccVWLGiI.s:4452   .text.bno055_convert_float_mag_z_uT:0000000000000038 $d
     /tmp/ccVWLGiI.s:4457   .text.bno055_convert_float_mag_xyz_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:4462   .text.bno055_convert_float_mag_xyz_uT:0000000000000000 bno055_convert_float_mag_xyz_uT
     /tmp/ccVWLGiI.s:4549   .text.bno055_convert_float_mag_xyz_uT:000000000000006c $d
     /tmp/ccVWLGiI.s:4555   .text.bno055_convert_float_linear_accel_x_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:4560   .text.bno055_convert_float_linear_accel_x_msq:0000000000000000 bno055_convert_float_linear_accel_x_msq
     /tmp/ccVWLGiI.s:4625   .text.bno055_convert_float_linear_accel_x_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:4630   .text.bno055_convert_float_linear_accel_y_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:4635   .text.bno055_convert_float_linear_accel_y_msq:0000000000000000 bno055_convert_float_linear_accel_y_msq
     /tmp/ccVWLGiI.s:4700   .text.bno055_convert_float_linear_accel_y_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:4705   .text.bno055_convert_float_linear_accel_z_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:4710   .text.bno055_convert_float_linear_accel_z_msq:0000000000000000 bno055_convert_float_linear_accel_z_msq
     /tmp/ccVWLGiI.s:4775   .text.bno055_convert_float_linear_accel_z_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:4780   .text.bno055_convert_float_linear_accel_xyz_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:4785   .text.bno055_convert_float_linear_accel_xyz_msq:0000000000000000 bno055_convert_float_linear_accel_xyz_msq
     /tmp/ccVWLGiI.s:4872   .text.bno055_convert_float_linear_accel_xyz_msq:000000000000006c $d
     /tmp/ccVWLGiI.s:4877   .text.bno055_convert_gravity_float_x_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:4882   .text.bno055_convert_gravity_float_x_msq:0000000000000000 bno055_convert_gravity_float_x_msq
     /tmp/ccVWLGiI.s:4946   .text.bno055_convert_gravity_float_x_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:4951   .text.bno055_convert_gravity_float_y_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:4956   .text.bno055_convert_gravity_float_y_msq:0000000000000000 bno055_convert_gravity_float_y_msq
     /tmp/ccVWLGiI.s:5020   .text.bno055_convert_gravity_float_y_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:5025   .text.bno055_convert_gravity_float_z_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5030   .text.bno055_convert_gravity_float_z_msq:0000000000000000 bno055_convert_gravity_float_z_msq
     /tmp/ccVWLGiI.s:5094   .text.bno055_convert_gravity_float_z_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:5099   .text.bno055_convert_float_gravity_xyz_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5104   .text.bno055_convert_float_gravity_xyz_msq:0000000000000000 bno055_convert_float_gravity_xyz_msq
     /tmp/ccVWLGiI.s:5191   .text.bno055_convert_float_gravity_xyz_msq:000000000000006c $d
     /tmp/ccVWLGiI.s:5196   .text.bno055_convert_double_mag_x_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:5201   .text.bno055_convert_double_mag_x_uT:0000000000000000 bno055_convert_double_mag_x_uT
     /tmp/ccVWLGiI.s:5264   .text.bno055_convert_double_mag_x_uT:0000000000000038 $d
     /tmp/ccVWLGiI.s:5269   .text.bno055_convert_double_mag_y_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:5274   .text.bno055_convert_double_mag_y_uT:0000000000000000 bno055_convert_double_mag_y_uT
     /tmp/ccVWLGiI.s:5337   .text.bno055_convert_double_mag_y_uT:0000000000000038 $d
     /tmp/ccVWLGiI.s:5342   .text.bno055_convert_double_mag_z_uT:0000000000000000 $t
     /tmp/ccVWLGiI.s:5347   .text.bno055_convert_double_mag_z_uT:0000000000000000 bno055_convert_double_mag_z_uT
     /tmp/ccVWLGiI.s:5410   .text.bno055_convert_double_mag_z_uT:0000000000000038 $d
     /tmp/ccVWLGiI.s:5415   .text.bno055_convert_double_mag_xyz_uT:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 979


     /tmp/ccVWLGiI.s:5420   .text.bno055_convert_double_mag_xyz_uT:0000000000000000 bno055_convert_double_mag_xyz_uT
     /tmp/ccVWLGiI.s:5504   .text.bno055_convert_double_mag_xyz_uT:0000000000000064 $d
     /tmp/ccVWLGiI.s:5509   .text.bno055_convert_double_linear_accel_x_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5514   .text.bno055_convert_double_linear_accel_x_msq:0000000000000000 bno055_convert_double_linear_accel_x_msq
     /tmp/ccVWLGiI.s:5577   .text.bno055_convert_double_linear_accel_x_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:5582   .text.bno055_convert_double_linear_accel_y_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5587   .text.bno055_convert_double_linear_accel_y_msq:0000000000000000 bno055_convert_double_linear_accel_y_msq
     /tmp/ccVWLGiI.s:5650   .text.bno055_convert_double_linear_accel_y_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:5655   .text.bno055_convert_double_linear_accel_z_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5660   .text.bno055_convert_double_linear_accel_z_msq:0000000000000000 bno055_convert_double_linear_accel_z_msq
     /tmp/ccVWLGiI.s:5724   .text.bno055_convert_double_linear_accel_z_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:5729   .text.bno055_convert_double_linear_accel_xyz_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5734   .text.bno055_convert_double_linear_accel_xyz_msq:0000000000000000 bno055_convert_double_linear_accel_xyz_msq
     /tmp/ccVWLGiI.s:5818   .text.bno055_convert_double_linear_accel_xyz_msq:0000000000000064 $d
     /tmp/ccVWLGiI.s:5823   .text.bno055_convert_gravity_double_x_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5828   .text.bno055_convert_gravity_double_x_msq:0000000000000000 bno055_convert_gravity_double_x_msq
     /tmp/ccVWLGiI.s:5892   .text.bno055_convert_gravity_double_x_msq:0000000000000038 $d
     /tmp/ccVWLGiI.s:5897   .text.bno055_convert_gravity_double_y_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5902   .text.bno055_convert_gravity_double_y_msq:0000000000000000 bno055_convert_gravity_double_y_msq
     /tmp/ccVWLGiI.s:5973   .text.bno055_convert_gravity_double_y_msq:000000000000003c $d
     /tmp/ccVWLGiI.s:5978   .text.bno055_convert_gravity_double_z_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:5983   .text.bno055_convert_gravity_double_z_msq:0000000000000000 bno055_convert_gravity_double_z_msq
     /tmp/ccVWLGiI.s:6054   .text.bno055_convert_gravity_double_z_msq:000000000000003c $d
     /tmp/ccVWLGiI.s:6059   .text.bno055_convert_double_gravity_xyz_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:6064   .text.bno055_convert_double_gravity_xyz_msq:0000000000000000 bno055_convert_double_gravity_xyz_msq
     /tmp/ccVWLGiI.s:6156   .text.bno055_convert_double_gravity_xyz_msq:000000000000006c $d
     /tmp/ccVWLGiI.s:6161   .text.bno055_get_mag_calib_stat:0000000000000000 $t
     /tmp/ccVWLGiI.s:6166   .text.bno055_get_mag_calib_stat:0000000000000000 bno055_get_mag_calib_stat
     /tmp/ccVWLGiI.s:6252   .text.bno055_get_mag_calib_stat:0000000000000050 $d
     /tmp/ccVWLGiI.s:6257   .text.bno055_get_accel_calib_stat:0000000000000000 $t
     /tmp/ccVWLGiI.s:6262   .text.bno055_get_accel_calib_stat:0000000000000000 bno055_get_accel_calib_stat
     /tmp/ccVWLGiI.s:6349   .text.bno055_get_accel_calib_stat:0000000000000050 $d
     /tmp/ccVWLGiI.s:6354   .text.bno055_get_gyro_calib_stat:0000000000000000 $t
     /tmp/ccVWLGiI.s:6359   .text.bno055_get_gyro_calib_stat:0000000000000000 bno055_get_gyro_calib_stat
     /tmp/ccVWLGiI.s:6446   .text.bno055_get_gyro_calib_stat:0000000000000050 $d
     /tmp/ccVWLGiI.s:6451   .text.bno055_get_sys_calib_stat:0000000000000000 $t
     /tmp/ccVWLGiI.s:6456   .text.bno055_get_sys_calib_stat:0000000000000000 bno055_get_sys_calib_stat
     /tmp/ccVWLGiI.s:6543   .text.bno055_get_sys_calib_stat:000000000000004c $d
     /tmp/ccVWLGiI.s:6548   .text.bno055_get_selftest_accel:0000000000000000 $t
     /tmp/ccVWLGiI.s:6553   .text.bno055_get_selftest_accel:0000000000000000 bno055_get_selftest_accel
     /tmp/ccVWLGiI.s:6639   .text.bno055_get_selftest_accel:0000000000000050 $d
     /tmp/ccVWLGiI.s:6644   .text.bno055_get_selftest_mag:0000000000000000 $t
     /tmp/ccVWLGiI.s:6649   .text.bno055_get_selftest_mag:0000000000000000 bno055_get_selftest_mag
     /tmp/ccVWLGiI.s:6736   .text.bno055_get_selftest_mag:0000000000000050 $d
     /tmp/ccVWLGiI.s:6741   .text.bno055_get_selftest_gyro:0000000000000000 $t
     /tmp/ccVWLGiI.s:6746   .text.bno055_get_selftest_gyro:0000000000000000 bno055_get_selftest_gyro
     /tmp/ccVWLGiI.s:6833   .text.bno055_get_selftest_gyro:0000000000000050 $d
     /tmp/ccVWLGiI.s:6838   .text.bno055_get_selftest_mcu:0000000000000000 $t
     /tmp/ccVWLGiI.s:6843   .text.bno055_get_selftest_mcu:0000000000000000 bno055_get_selftest_mcu
     /tmp/ccVWLGiI.s:6930   .text.bno055_get_selftest_mcu:0000000000000050 $d
     /tmp/ccVWLGiI.s:6935   .text.bno055_get_intr_stat_gyro_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:6940   .text.bno055_get_intr_stat_gyro_any_motion:0000000000000000 bno055_get_intr_stat_gyro_any_motion
     /tmp/ccVWLGiI.s:7027   .text.bno055_get_intr_stat_gyro_any_motion:0000000000000050 $d
     /tmp/ccVWLGiI.s:7032   .text.bno055_get_intr_stat_gyro_highrate:0000000000000000 $t
     /tmp/ccVWLGiI.s:7037   .text.bno055_get_intr_stat_gyro_highrate:0000000000000000 bno055_get_intr_stat_gyro_highrate
     /tmp/ccVWLGiI.s:7124   .text.bno055_get_intr_stat_gyro_highrate:0000000000000050 $d
     /tmp/ccVWLGiI.s:7129   .text.bno055_get_intr_stat_accel_high_g:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 980


     /tmp/ccVWLGiI.s:7134   .text.bno055_get_intr_stat_accel_high_g:0000000000000000 bno055_get_intr_stat_accel_high_g
     /tmp/ccVWLGiI.s:7221   .text.bno055_get_intr_stat_accel_high_g:0000000000000050 $d
     /tmp/ccVWLGiI.s:7226   .text.bno055_get_intr_stat_accel_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:7231   .text.bno055_get_intr_stat_accel_any_motion:0000000000000000 bno055_get_intr_stat_accel_any_motion
     /tmp/ccVWLGiI.s:7318   .text.bno055_get_intr_stat_accel_any_motion:0000000000000050 $d
     /tmp/ccVWLGiI.s:7323   .text.bno055_get_intr_stat_accel_no_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:7328   .text.bno055_get_intr_stat_accel_no_motion:0000000000000000 bno055_get_intr_stat_accel_no_motion
     /tmp/ccVWLGiI.s:7415   .text.bno055_get_intr_stat_accel_no_motion:000000000000004c $d
     /tmp/ccVWLGiI.s:7420   .text.bno055_get_stat_main_clk:0000000000000000 $t
     /tmp/ccVWLGiI.s:7425   .text.bno055_get_stat_main_clk:0000000000000000 bno055_get_stat_main_clk
     /tmp/ccVWLGiI.s:7511   .text.bno055_get_stat_main_clk:0000000000000050 $d
     /tmp/ccVWLGiI.s:7516   .text.bno055_get_sys_stat_code:0000000000000000 $t
     /tmp/ccVWLGiI.s:7521   .text.bno055_get_sys_stat_code:0000000000000000 bno055_get_sys_stat_code
     /tmp/ccVWLGiI.s:7606   .text.bno055_get_sys_stat_code:000000000000004c $d
     /tmp/ccVWLGiI.s:7611   .text.bno055_get_sys_error_code:0000000000000000 $t
     /tmp/ccVWLGiI.s:7616   .text.bno055_get_sys_error_code:0000000000000000 bno055_get_sys_error_code
     /tmp/ccVWLGiI.s:7701   .text.bno055_get_sys_error_code:000000000000004c $d
     /tmp/ccVWLGiI.s:7706   .text.bno055_get_accel_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:7711   .text.bno055_get_accel_unit:0000000000000000 bno055_get_accel_unit
     /tmp/ccVWLGiI.s:7797   .text.bno055_get_accel_unit:0000000000000050 $d
     /tmp/ccVWLGiI.s:7802   .text.bno055_get_gyro_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:7807   .text.bno055_get_gyro_unit:0000000000000000 bno055_get_gyro_unit
     /tmp/ccVWLGiI.s:7894   .text.bno055_get_gyro_unit:0000000000000050 $d
     /tmp/ccVWLGiI.s:7899   .text.bno055_get_euler_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:7904   .text.bno055_get_euler_unit:0000000000000000 bno055_get_euler_unit
     /tmp/ccVWLGiI.s:7991   .text.bno055_get_euler_unit:0000000000000050 $d
     /tmp/ccVWLGiI.s:7996   .text.bno055_get_tilt_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:8001   .text.bno055_get_tilt_unit:0000000000000000 bno055_get_tilt_unit
     /tmp/ccVWLGiI.s:8088   .text.bno055_get_tilt_unit:0000000000000050 $d
     /tmp/ccVWLGiI.s:8093   .text.bno055_get_temp_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:8098   .text.bno055_get_temp_unit:0000000000000000 bno055_get_temp_unit
     /tmp/ccVWLGiI.s:8185   .text.bno055_get_temp_unit:0000000000000050 $d
     /tmp/ccVWLGiI.s:8190   .text.bno055_get_data_output_format:0000000000000000 $t
     /tmp/ccVWLGiI.s:8195   .text.bno055_get_data_output_format:0000000000000000 bno055_get_data_output_format
     /tmp/ccVWLGiI.s:8282   .text.bno055_get_data_output_format:000000000000004c $d
     /tmp/ccVWLGiI.s:8287   .text.bno055_get_operation_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:8292   .text.bno055_get_operation_mode:0000000000000000 bno055_get_operation_mode
     /tmp/ccVWLGiI.s:8378   .text.bno055_get_operation_mode:0000000000000050 $d
     /tmp/ccVWLGiI.s:8383   .text.bno055_set_operation_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:8388   .text.bno055_set_operation_mode:0000000000000000 bno055_set_operation_mode
     /tmp/ccVWLGiI.s:8611   .text.bno055_set_operation_mode:00000000000000fc $d
     /tmp/ccVWLGiI.s:8616   .text.bno055_set_accel_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:8621   .text.bno055_set_accel_unit:0000000000000000 bno055_set_accel_unit
     /tmp/ccVWLGiI.s:8759   .text.bno055_set_accel_unit:0000000000000094 $d
     /tmp/ccVWLGiI.s:8764   .text.bno055_convert_float_accel_x_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:8769   .text.bno055_convert_float_accel_x_msq:0000000000000000 bno055_convert_float_accel_x_msq
     /tmp/ccVWLGiI.s:8877   .text.bno055_convert_float_accel_x_msq:0000000000000068 $d
     /tmp/ccVWLGiI.s:8884   .text.bno055_convert_float_accel_x_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:8889   .text.bno055_convert_float_accel_x_mg:0000000000000000 bno055_convert_float_accel_x_mg
     /tmp/ccVWLGiI.s:8979   .text.bno055_convert_float_accel_y_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:8984   .text.bno055_convert_float_accel_y_msq:0000000000000000 bno055_convert_float_accel_y_msq
     /tmp/ccVWLGiI.s:9092   .text.bno055_convert_float_accel_y_msq:0000000000000068 $d
     /tmp/ccVWLGiI.s:9098   .text.bno055_convert_float_accel_y_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:9103   .text.bno055_convert_float_accel_y_mg:0000000000000000 bno055_convert_float_accel_y_mg
     /tmp/ccVWLGiI.s:9193   .text.bno055_convert_float_accel_z_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:9198   .text.bno055_convert_float_accel_z_msq:0000000000000000 bno055_convert_float_accel_z_msq
     /tmp/ccVWLGiI.s:9306   .text.bno055_convert_float_accel_z_msq:0000000000000068 $d
ARM GAS  /tmp/ccVWLGiI.s 			page 981


     /tmp/ccVWLGiI.s:9312   .text.bno055_convert_float_accel_z_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:9317   .text.bno055_convert_float_accel_z_mg:0000000000000000 bno055_convert_float_accel_z_mg
     /tmp/ccVWLGiI.s:9407   .text.bno055_convert_float_accel_xyz_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:9412   .text.bno055_convert_float_accel_xyz_msq:0000000000000000 bno055_convert_float_accel_xyz_msq
     /tmp/ccVWLGiI.s:9533   .text.bno055_convert_float_accel_xyz_msq:0000000000000090 $d
     /tmp/ccVWLGiI.s:9538   .text.bno055_convert_float_accel_xyz_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:9543   .text.bno055_convert_float_accel_xyz_mg:0000000000000000 bno055_convert_float_accel_xyz_mg
     /tmp/ccVWLGiI.s:9642   .text.bno055_convert_double_accel_x_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:9647   .text.bno055_convert_double_accel_x_msq:0000000000000000 bno055_convert_double_accel_x_msq
     /tmp/ccVWLGiI.s:9746   .text.bno055_convert_double_accel_x_msq:000000000000005c $d
     /tmp/ccVWLGiI.s:9751   .text.bno055_convert_double_accel_x_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:9756   .text.bno055_convert_double_accel_x_mg:0000000000000000 bno055_convert_double_accel_x_mg
     /tmp/ccVWLGiI.s:9846   .text.bno055_convert_double_accel_y_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:9851   .text.bno055_convert_double_accel_y_msq:0000000000000000 bno055_convert_double_accel_y_msq
     /tmp/ccVWLGiI.s:9950   .text.bno055_convert_double_accel_y_msq:000000000000005c $d
     /tmp/ccVWLGiI.s:9955   .text.bno055_convert_double_accel_y_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:9960   .text.bno055_convert_double_accel_y_mg:0000000000000000 bno055_convert_double_accel_y_mg
     /tmp/ccVWLGiI.s:10050  .text.bno055_convert_double_accel_z_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:10055  .text.bno055_convert_double_accel_z_msq:0000000000000000 bno055_convert_double_accel_z_msq
     /tmp/ccVWLGiI.s:10154  .text.bno055_convert_double_accel_z_msq:000000000000005c $d
     /tmp/ccVWLGiI.s:10159  .text.bno055_convert_double_accel_z_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:10164  .text.bno055_convert_double_accel_z_mg:0000000000000000 bno055_convert_double_accel_z_mg
     /tmp/ccVWLGiI.s:10254  .text.bno055_convert_double_accel_xyz_msq:0000000000000000 $t
     /tmp/ccVWLGiI.s:10259  .text.bno055_convert_double_accel_xyz_msq:0000000000000000 bno055_convert_double_accel_xyz_msq
     /tmp/ccVWLGiI.s:10377  .text.bno055_convert_double_accel_xyz_msq:0000000000000088 $d
     /tmp/ccVWLGiI.s:10382  .text.bno055_convert_double_accel_xyz_mg:0000000000000000 $t
     /tmp/ccVWLGiI.s:10387  .text.bno055_convert_double_accel_xyz_mg:0000000000000000 bno055_convert_double_accel_xyz_mg
     /tmp/ccVWLGiI.s:10486  .text.bno055_set_gyro_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:10491  .text.bno055_set_gyro_unit:0000000000000000 bno055_set_gyro_unit
     /tmp/ccVWLGiI.s:10631  .text.bno055_set_gyro_unit:0000000000000094 $d
     /tmp/ccVWLGiI.s:10636  .text.bno055_convert_float_gyro_x_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:10641  .text.bno055_convert_float_gyro_x_dps:0000000000000000 bno055_convert_float_gyro_x_dps
     /tmp/ccVWLGiI.s:10741  .text.bno055_convert_float_gyro_x_dps:000000000000005c $d
     /tmp/ccVWLGiI.s:10746  .text.bno055_convert_float_gyro_x_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:10751  .text.bno055_convert_float_gyro_x_rps:0000000000000000 bno055_convert_float_gyro_x_rps
     /tmp/ccVWLGiI.s:10848  .text.bno055_convert_float_gyro_x_rps:000000000000005c $d
     /tmp/ccVWLGiI.s:10853  .text.bno055_convert_float_gyro_y_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:10858  .text.bno055_convert_float_gyro_y_dps:0000000000000000 bno055_convert_float_gyro_y_dps
     /tmp/ccVWLGiI.s:10958  .text.bno055_convert_float_gyro_y_dps:000000000000005c $d
     /tmp/ccVWLGiI.s:10963  .text.bno055_convert_float_gyro_y_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:10968  .text.bno055_convert_float_gyro_y_rps:0000000000000000 bno055_convert_float_gyro_y_rps
     /tmp/ccVWLGiI.s:11065  .text.bno055_convert_float_gyro_y_rps:000000000000005c $d
     /tmp/ccVWLGiI.s:11070  .text.bno055_convert_float_gyro_z_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11075  .text.bno055_convert_float_gyro_z_dps:0000000000000000 bno055_convert_float_gyro_z_dps
     /tmp/ccVWLGiI.s:11175  .text.bno055_convert_float_gyro_z_dps:000000000000005c $d
     /tmp/ccVWLGiI.s:11180  .text.bno055_convert_float_gyro_z_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11185  .text.bno055_convert_float_gyro_z_rps:0000000000000000 bno055_convert_float_gyro_z_rps
     /tmp/ccVWLGiI.s:11282  .text.bno055_convert_float_gyro_z_rps:000000000000005c $d
     /tmp/ccVWLGiI.s:11287  .text.bno055_convert_float_gyro_xyz_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11292  .text.bno055_convert_float_gyro_xyz_dps:0000000000000000 bno055_convert_float_gyro_xyz_dps
     /tmp/ccVWLGiI.s:11413  .text.bno055_convert_float_gyro_xyz_dps:0000000000000090 $d
     /tmp/ccVWLGiI.s:11418  .text.bno055_convert_float_gyro_xyz_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11423  .text.bno055_convert_float_gyro_xyz_rps:0000000000000000 bno055_convert_float_gyro_xyz_rps
     /tmp/ccVWLGiI.s:11540  .text.bno055_convert_float_gyro_xyz_rps:0000000000000090 $d
     /tmp/ccVWLGiI.s:11545  .text.bno055_convert_double_gyro_x_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11550  .text.bno055_convert_double_gyro_x_dps:0000000000000000 bno055_convert_double_gyro_x_dps
     /tmp/ccVWLGiI.s:11649  .text.bno055_convert_double_gyro_x_dps:000000000000005c $d
ARM GAS  /tmp/ccVWLGiI.s 			page 982


     /tmp/ccVWLGiI.s:11654  .text.bno055_convert_double_gyro_x_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11659  .text.bno055_convert_double_gyro_x_rps:0000000000000000 bno055_convert_double_gyro_x_rps
     /tmp/ccVWLGiI.s:11755  .text.bno055_convert_double_gyro_x_rps:000000000000005c $d
     /tmp/ccVWLGiI.s:11760  .text.bno055_convert_double_gyro_y_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11765  .text.bno055_convert_double_gyro_y_dps:0000000000000000 bno055_convert_double_gyro_y_dps
     /tmp/ccVWLGiI.s:11864  .text.bno055_convert_double_gyro_y_dps:000000000000005c $d
     /tmp/ccVWLGiI.s:11869  .text.bno055_convert_double_gyro_y_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11874  .text.bno055_convert_double_gyro_y_rps:0000000000000000 bno055_convert_double_gyro_y_rps
     /tmp/ccVWLGiI.s:11970  .text.bno055_convert_double_gyro_y_rps:000000000000005c $d
     /tmp/ccVWLGiI.s:11975  .text.bno055_convert_double_gyro_z_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:11980  .text.bno055_convert_double_gyro_z_dps:0000000000000000 bno055_convert_double_gyro_z_dps
     /tmp/ccVWLGiI.s:12079  .text.bno055_convert_double_gyro_z_dps:000000000000005c $d
     /tmp/ccVWLGiI.s:12084  .text.bno055_convert_double_gyro_z_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:12089  .text.bno055_convert_double_gyro_z_rps:0000000000000000 bno055_convert_double_gyro_z_rps
     /tmp/ccVWLGiI.s:12185  .text.bno055_convert_double_gyro_z_rps:000000000000005c $d
     /tmp/ccVWLGiI.s:12190  .text.bno055_convert_double_gyro_xyz_dps:0000000000000000 $t
     /tmp/ccVWLGiI.s:12195  .text.bno055_convert_double_gyro_xyz_dps:0000000000000000 bno055_convert_double_gyro_xyz_dps
     /tmp/ccVWLGiI.s:12313  .text.bno055_convert_double_gyro_xyz_dps:0000000000000088 $d
     /tmp/ccVWLGiI.s:12318  .text.bno055_convert_double_gyro_xyz_rps:0000000000000000 $t
     /tmp/ccVWLGiI.s:12323  .text.bno055_convert_double_gyro_xyz_rps:0000000000000000 bno055_convert_double_gyro_xyz_rps
     /tmp/ccVWLGiI.s:12437  .text.bno055_convert_double_gyro_xyz_rps:0000000000000088 $d
     /tmp/ccVWLGiI.s:12442  .text.bno055_set_euler_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:12447  .text.bno055_set_euler_unit:0000000000000000 bno055_set_euler_unit
     /tmp/ccVWLGiI.s:12587  .text.bno055_set_euler_unit:0000000000000094 $d
     /tmp/ccVWLGiI.s:12592  .text.bno055_convert_float_euler_h_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:12597  .text.bno055_convert_float_euler_h_deg:0000000000000000 bno055_convert_float_euler_h_deg
     /tmp/ccVWLGiI.s:12697  .text.bno055_convert_float_euler_h_deg:000000000000005c $d
     /tmp/ccVWLGiI.s:12702  .text.bno055_convert_float_euler_h_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:12707  .text.bno055_convert_float_euler_h_rad:0000000000000000 bno055_convert_float_euler_h_rad
     /tmp/ccVWLGiI.s:12804  .text.bno055_convert_float_euler_h_rad:000000000000005c $d
     /tmp/ccVWLGiI.s:12809  .text.bno055_convert_float_euler_r_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:12814  .text.bno055_convert_float_euler_r_deg:0000000000000000 bno055_convert_float_euler_r_deg
     /tmp/ccVWLGiI.s:12914  .text.bno055_convert_float_euler_r_deg:000000000000005c $d
     /tmp/ccVWLGiI.s:12919  .text.bno055_convert_float_euler_r_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:12924  .text.bno055_convert_float_euler_r_rad:0000000000000000 bno055_convert_float_euler_r_rad
     /tmp/ccVWLGiI.s:13021  .text.bno055_convert_float_euler_r_rad:000000000000005c $d
     /tmp/ccVWLGiI.s:13026  .text.bno055_convert_float_euler_p_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:13031  .text.bno055_convert_float_euler_p_deg:0000000000000000 bno055_convert_float_euler_p_deg
     /tmp/ccVWLGiI.s:13131  .text.bno055_convert_float_euler_p_deg:000000000000005c $d
     /tmp/ccVWLGiI.s:13136  .text.bno055_convert_float_euler_p_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:13141  .text.bno055_convert_float_euler_p_rad:0000000000000000 bno055_convert_float_euler_p_rad
     /tmp/ccVWLGiI.s:13238  .text.bno055_convert_float_euler_p_rad:000000000000005c $d
     /tmp/ccVWLGiI.s:13243  .text.bno055_convert_float_euler_hpr_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:13248  .text.bno055_convert_float_euler_hpr_deg:0000000000000000 bno055_convert_float_euler_hpr_deg
     /tmp/ccVWLGiI.s:13369  .text.bno055_convert_float_euler_hpr_deg:0000000000000090 $d
     /tmp/ccVWLGiI.s:13374  .text.bno055_convert_float_euler_hpr_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:13379  .text.bno055_convert_float_euler_hpr_rad:0000000000000000 bno055_convert_float_euler_hpr_rad
     /tmp/ccVWLGiI.s:13496  .text.bno055_convert_float_euler_hpr_rad:0000000000000090 $d
     /tmp/ccVWLGiI.s:13501  .text.bno055_convert_double_euler_h_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:13506  .text.bno055_convert_double_euler_h_deg:0000000000000000 bno055_convert_double_euler_h_deg
     /tmp/ccVWLGiI.s:13605  .text.bno055_convert_double_euler_h_deg:000000000000005c $d
     /tmp/ccVWLGiI.s:13610  .text.bno055_convert_double_euler_h_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:13615  .text.bno055_convert_double_euler_h_rad:0000000000000000 bno055_convert_double_euler_h_rad
     /tmp/ccVWLGiI.s:13711  .text.bno055_convert_double_euler_h_rad:000000000000005c $d
     /tmp/ccVWLGiI.s:13716  .text.bno055_convert_double_euler_r_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:13721  .text.bno055_convert_double_euler_r_deg:0000000000000000 bno055_convert_double_euler_r_deg
     /tmp/ccVWLGiI.s:13820  .text.bno055_convert_double_euler_r_deg:000000000000005c $d
ARM GAS  /tmp/ccVWLGiI.s 			page 983


     /tmp/ccVWLGiI.s:13825  .text.bno055_convert_double_euler_r_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:13830  .text.bno055_convert_double_euler_r_rad:0000000000000000 bno055_convert_double_euler_r_rad
     /tmp/ccVWLGiI.s:13926  .text.bno055_convert_double_euler_r_rad:000000000000005c $d
     /tmp/ccVWLGiI.s:13931  .text.bno055_convert_double_euler_p_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:13936  .text.bno055_convert_double_euler_p_deg:0000000000000000 bno055_convert_double_euler_p_deg
     /tmp/ccVWLGiI.s:14035  .text.bno055_convert_double_euler_p_deg:000000000000005c $d
     /tmp/ccVWLGiI.s:14040  .text.bno055_convert_double_euler_p_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:14045  .text.bno055_convert_double_euler_p_rad:0000000000000000 bno055_convert_double_euler_p_rad
     /tmp/ccVWLGiI.s:14141  .text.bno055_convert_double_euler_p_rad:000000000000005c $d
     /tmp/ccVWLGiI.s:14146  .text.bno055_convert_double_euler_hpr_deg:0000000000000000 $t
     /tmp/ccVWLGiI.s:14151  .text.bno055_convert_double_euler_hpr_deg:0000000000000000 bno055_convert_double_euler_hpr_deg
     /tmp/ccVWLGiI.s:14269  .text.bno055_convert_double_euler_hpr_deg:0000000000000088 $d
     /tmp/ccVWLGiI.s:14274  .text.bno055_convert_double_euler_hpr_rad:0000000000000000 $t
     /tmp/ccVWLGiI.s:14279  .text.bno055_convert_double_euler_hpr_rad:0000000000000000 bno055_convert_double_euler_hpr_rad
     /tmp/ccVWLGiI.s:14389  .text.bno055_convert_double_euler_hpr_rad:0000000000000084 $d
     /tmp/ccVWLGiI.s:14394  .text.bno055_set_tilt_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:14399  .text.bno055_set_tilt_unit:0000000000000000 bno055_set_tilt_unit
     /tmp/ccVWLGiI.s:14539  .text.bno055_set_tilt_unit:0000000000000094 $d
     /tmp/ccVWLGiI.s:14544  .text.bno055_set_temp_unit:0000000000000000 $t
     /tmp/ccVWLGiI.s:14549  .text.bno055_set_temp_unit:0000000000000000 bno055_set_temp_unit
     /tmp/ccVWLGiI.s:14689  .text.bno055_set_temp_unit:0000000000000094 $d
     /tmp/ccVWLGiI.s:14695  .text.bno055_convert_float_temp_fahrenheit:0000000000000000 $t
     /tmp/ccVWLGiI.s:14700  .text.bno055_convert_float_temp_fahrenheit:0000000000000000 bno055_convert_float_temp_fahrenheit
     /tmp/ccVWLGiI.s:14797  .text.bno055_convert_float_temp_celsius:0000000000000000 $t
     /tmp/ccVWLGiI.s:14802  .text.bno055_convert_float_temp_celsius:0000000000000000 bno055_convert_float_temp_celsius
     /tmp/ccVWLGiI.s:14895  .text.bno055_convert_double_temp_fahrenheit:0000000000000000 $t
     /tmp/ccVWLGiI.s:14900  .text.bno055_convert_double_temp_fahrenheit:0000000000000000 bno055_convert_double_temp_fahrenheit
     /tmp/ccVWLGiI.s:15015  .text.bno055_convert_double_temp_celsius:0000000000000000 $t
     /tmp/ccVWLGiI.s:15020  .text.bno055_convert_double_temp_celsius:0000000000000000 bno055_convert_double_temp_celsius
     /tmp/ccVWLGiI.s:15134  .text.bno055_set_data_output_format:0000000000000000 $t
     /tmp/ccVWLGiI.s:15139  .text.bno055_set_data_output_format:0000000000000000 bno055_set_data_output_format
     /tmp/ccVWLGiI.s:15276  .text.bno055_set_data_output_format:0000000000000090 $d
     /tmp/ccVWLGiI.s:15281  .text.bno055_get_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:15286  .text.bno055_get_power_mode:0000000000000000 bno055_get_power_mode
     /tmp/ccVWLGiI.s:15372  .text.bno055_get_power_mode:0000000000000050 $d
     /tmp/ccVWLGiI.s:15377  .text.bno055_set_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:15382  .text.bno055_set_power_mode:0000000000000000 bno055_set_power_mode
     /tmp/ccVWLGiI.s:15520  .text.bno055_set_power_mode:0000000000000094 $d
     /tmp/ccVWLGiI.s:15525  .text.bno055_get_intr_rst:0000000000000000 $t
     /tmp/ccVWLGiI.s:15530  .text.bno055_get_intr_rst:0000000000000000 bno055_get_intr_rst
     /tmp/ccVWLGiI.s:15617  .text.bno055_get_intr_rst:0000000000000050 $d
     /tmp/ccVWLGiI.s:15622  .text.bno055_set_intr_rst:0000000000000000 $t
     /tmp/ccVWLGiI.s:15627  .text.bno055_set_intr_rst:0000000000000000 bno055_set_intr_rst
     /tmp/ccVWLGiI.s:15745  .text.bno055_set_intr_rst:0000000000000074 $d
     /tmp/ccVWLGiI.s:15750  .text.bno055_get_clk_src:0000000000000000 $t
     /tmp/ccVWLGiI.s:15755  .text.bno055_get_clk_src:0000000000000000 bno055_get_clk_src
     /tmp/ccVWLGiI.s:15842  .text.bno055_get_clk_src:000000000000004c $d
     /tmp/ccVWLGiI.s:15847  .text.bno055_set_clk_src:0000000000000000 $t
     /tmp/ccVWLGiI.s:15852  .text.bno055_set_clk_src:0000000000000000 bno055_set_clk_src
     /tmp/ccVWLGiI.s:15966  .text.bno055_set_clk_src:000000000000006c $d
     /tmp/ccVWLGiI.s:15971  .text.bno055_get_sys_rst:0000000000000000 $t
     /tmp/ccVWLGiI.s:15976  .text.bno055_get_sys_rst:0000000000000000 bno055_get_sys_rst
     /tmp/ccVWLGiI.s:16063  .text.bno055_get_sys_rst:0000000000000050 $d
     /tmp/ccVWLGiI.s:16068  .text.bno055_set_sys_rst:0000000000000000 $t
     /tmp/ccVWLGiI.s:16073  .text.bno055_set_sys_rst:0000000000000000 bno055_set_sys_rst
     /tmp/ccVWLGiI.s:16192  .text.bno055_set_sys_rst:0000000000000074 $d
     /tmp/ccVWLGiI.s:16197  .text.bno055_get_selftest:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 984


     /tmp/ccVWLGiI.s:16202  .text.bno055_get_selftest:0000000000000000 bno055_get_selftest
     /tmp/ccVWLGiI.s:16288  .text.bno055_get_selftest:0000000000000050 $d
     /tmp/ccVWLGiI.s:16293  .text.bno055_set_selftest:0000000000000000 $t
     /tmp/ccVWLGiI.s:16298  .text.bno055_set_selftest:0000000000000000 bno055_set_selftest
     /tmp/ccVWLGiI.s:16436  .text.bno055_set_selftest:0000000000000094 $d
     /tmp/ccVWLGiI.s:16441  .text.bno055_get_temp_source:0000000000000000 $t
     /tmp/ccVWLGiI.s:16446  .text.bno055_get_temp_source:0000000000000000 bno055_get_temp_source
     /tmp/ccVWLGiI.s:16532  .text.bno055_get_temp_source:0000000000000050 $d
     /tmp/ccVWLGiI.s:16537  .text.bno055_set_temp_source:0000000000000000 $t
     /tmp/ccVWLGiI.s:16542  .text.bno055_set_temp_source:0000000000000000 bno055_set_temp_source
     /tmp/ccVWLGiI.s:16680  .text.bno055_set_temp_source:0000000000000094 $d
     /tmp/ccVWLGiI.s:16685  .text.bno055_get_axis_remap_value:0000000000000000 $t
     /tmp/ccVWLGiI.s:16690  .text.bno055_get_axis_remap_value:0000000000000000 bno055_get_axis_remap_value
     /tmp/ccVWLGiI.s:16776  .text.bno055_get_axis_remap_value:0000000000000050 $d
     /tmp/ccVWLGiI.s:16781  .text.bno055_set_axis_remap_value:0000000000000000 $t
     /tmp/ccVWLGiI.s:16786  .text.bno055_set_axis_remap_value:0000000000000000 bno055_set_axis_remap_value
     /tmp/ccVWLGiI.s:16976  .text.bno055_set_axis_remap_value:00000000000000e0 $d
     /tmp/ccVWLGiI.s:16982  .text.bno055_get_remap_x_sign:0000000000000000 $t
     /tmp/ccVWLGiI.s:16987  .text.bno055_get_remap_x_sign:0000000000000000 bno055_get_remap_x_sign
     /tmp/ccVWLGiI.s:17074  .text.bno055_get_remap_x_sign:0000000000000050 $d
     /tmp/ccVWLGiI.s:17079  .text.bno055_set_remap_x_sign:0000000000000000 $t
     /tmp/ccVWLGiI.s:17084  .text.bno055_set_remap_x_sign:0000000000000000 bno055_set_remap_x_sign
     /tmp/ccVWLGiI.s:17224  .text.bno055_set_remap_x_sign:0000000000000094 $d
     /tmp/ccVWLGiI.s:17229  .text.bno055_get_remap_y_sign:0000000000000000 $t
     /tmp/ccVWLGiI.s:17234  .text.bno055_get_remap_y_sign:0000000000000000 bno055_get_remap_y_sign
     /tmp/ccVWLGiI.s:17321  .text.bno055_get_remap_y_sign:0000000000000050 $d
     /tmp/ccVWLGiI.s:17326  .text.bno055_set_remap_y_sign:0000000000000000 $t
     /tmp/ccVWLGiI.s:17331  .text.bno055_set_remap_y_sign:0000000000000000 bno055_set_remap_y_sign
     /tmp/ccVWLGiI.s:17471  .text.bno055_set_remap_y_sign:0000000000000094 $d
     /tmp/ccVWLGiI.s:17476  .text.bno055_get_remap_z_sign:0000000000000000 $t
     /tmp/ccVWLGiI.s:17481  .text.bno055_get_remap_z_sign:0000000000000000 bno055_get_remap_z_sign
     /tmp/ccVWLGiI.s:17567  .text.bno055_get_remap_z_sign:0000000000000050 $d
     /tmp/ccVWLGiI.s:17572  .text.bno055_set_remap_z_sign:0000000000000000 $t
     /tmp/ccVWLGiI.s:17577  .text.bno055_set_remap_z_sign:0000000000000000 bno055_set_remap_z_sign
     /tmp/ccVWLGiI.s:17715  .text.bno055_set_remap_z_sign:0000000000000094 $d
     /tmp/ccVWLGiI.s:17720  .text.bno055_read_sic_matrix:0000000000000000 $t
     /tmp/ccVWLGiI.s:17725  .text.bno055_read_sic_matrix:0000000000000000 bno055_read_sic_matrix
     /tmp/ccVWLGiI.s:17904  .text.bno055_read_sic_matrix:00000000000000e0 $d
     /tmp/ccVWLGiI.s:17909  .text.bno055_write_sic_matrix:0000000000000000 $t
     /tmp/ccVWLGiI.s:17914  .text.bno055_write_sic_matrix:0000000000000000 bno055_write_sic_matrix
     /tmp/ccVWLGiI.s:18424  .text.bno055_write_sic_matrix:00000000000002b0 $d
     /tmp/ccVWLGiI.s:18428  .text.bno055_write_sic_matrix:00000000000002b4 $t
     /tmp/ccVWLGiI.s:18808  .text.bno055_read_accel_offset:0000000000000000 $t
     /tmp/ccVWLGiI.s:18813  .text.bno055_read_accel_offset:0000000000000000 bno055_read_accel_offset
     /tmp/ccVWLGiI.s:18950  .text.bno055_read_accel_offset:00000000000000a8 $d
     /tmp/ccVWLGiI.s:18955  .text.bno055_write_accel_offset:0000000000000000 $t
     /tmp/ccVWLGiI.s:18960  .text.bno055_write_accel_offset:0000000000000000 bno055_write_accel_offset
     /tmp/ccVWLGiI.s:19403  .text.bno055_write_accel_offset:0000000000000230 $d
     /tmp/ccVWLGiI.s:19408  .text.bno055_read_mag_offset:0000000000000000 $t
     /tmp/ccVWLGiI.s:19413  .text.bno055_read_mag_offset:0000000000000000 bno055_read_mag_offset
     /tmp/ccVWLGiI.s:19550  .text.bno055_read_mag_offset:00000000000000a8 $d
     /tmp/ccVWLGiI.s:19555  .text.bno055_write_mag_offset:0000000000000000 $t
     /tmp/ccVWLGiI.s:19560  .text.bno055_write_mag_offset:0000000000000000 bno055_write_mag_offset
     /tmp/ccVWLGiI.s:20009  .text.bno055_write_mag_offset:000000000000023c $d
     /tmp/ccVWLGiI.s:20014  .text.bno055_read_gyro_offset:0000000000000000 $t
     /tmp/ccVWLGiI.s:20019  .text.bno055_read_gyro_offset:0000000000000000 bno055_read_gyro_offset
     /tmp/ccVWLGiI.s:20146  .text.bno055_read_gyro_offset:000000000000008c $d
ARM GAS  /tmp/ccVWLGiI.s 			page 985


     /tmp/ccVWLGiI.s:20151  .text.bno055_write_gyro_offset:0000000000000000 $t
     /tmp/ccVWLGiI.s:20156  .text.bno055_write_gyro_offset:0000000000000000 bno055_write_gyro_offset
     /tmp/ccVWLGiI.s:20517  .text.bno055_write_gyro_offset:00000000000001b8 $d
     /tmp/ccVWLGiI.s:20522  .text.bno055_get_accel_range:0000000000000000 $t
     /tmp/ccVWLGiI.s:20527  .text.bno055_get_accel_range:0000000000000000 bno055_get_accel_range
     /tmp/ccVWLGiI.s:20622  .text.bno055_get_accel_range:0000000000000054 $d
     /tmp/ccVWLGiI.s:20627  .text.bno055_set_accel_range:0000000000000000 $t
     /tmp/ccVWLGiI.s:20632  .text.bno055_set_accel_range:0000000000000000 bno055_set_accel_range
     /tmp/ccVWLGiI.s:20791  .text.bno055_set_accel_range:00000000000000a4 $d
     /tmp/ccVWLGiI.s:20796  .text.bno055_get_accel_bw:0000000000000000 $t
     /tmp/ccVWLGiI.s:20801  .text.bno055_get_accel_bw:0000000000000000 bno055_get_accel_bw
     /tmp/ccVWLGiI.s:20897  .text.bno055_get_accel_bw:0000000000000054 $d
     /tmp/ccVWLGiI.s:20902  .text.bno055_set_accel_bw:0000000000000000 $t
     /tmp/ccVWLGiI.s:20907  .text.bno055_set_accel_bw:0000000000000000 bno055_set_accel_bw
     /tmp/ccVWLGiI.s:21067  .text.bno055_set_accel_bw:00000000000000a8 $d
     /tmp/ccVWLGiI.s:21072  .text.bno055_get_accel_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:21077  .text.bno055_get_accel_power_mode:0000000000000000 bno055_get_accel_power_mode
     /tmp/ccVWLGiI.s:21173  .text.bno055_get_accel_power_mode:0000000000000054 $d
     /tmp/ccVWLGiI.s:21178  .text.bno055_set_accel_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:21183  .text.bno055_set_accel_power_mode:0000000000000000 bno055_set_accel_power_mode
     /tmp/ccVWLGiI.s:21341  .text.bno055_set_accel_power_mode:00000000000000a4 $d
     /tmp/ccVWLGiI.s:21346  .text.bno055_get_mag_data_output_rate:0000000000000000 $t
     /tmp/ccVWLGiI.s:21351  .text.bno055_get_mag_data_output_rate:0000000000000000 bno055_get_mag_data_output_rate
     /tmp/ccVWLGiI.s:21446  .text.bno055_get_mag_data_output_rate:0000000000000054 $d
     /tmp/ccVWLGiI.s:21451  .text.bno055_set_mag_data_output_rate:0000000000000000 $t
     /tmp/ccVWLGiI.s:21456  .text.bno055_set_mag_data_output_rate:0000000000000000 bno055_set_mag_data_output_rate
     /tmp/ccVWLGiI.s:21613  .text.bno055_set_mag_data_output_rate:00000000000000a0 $d
     /tmp/ccVWLGiI.s:21618  .text.bno055_get_mag_operation_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:21623  .text.bno055_get_mag_operation_mode:0000000000000000 bno055_get_mag_operation_mode
     /tmp/ccVWLGiI.s:21719  .text.bno055_get_mag_operation_mode:0000000000000054 $d
     /tmp/ccVWLGiI.s:21724  .text.bno055_set_mag_operation_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:21729  .text.bno055_set_mag_operation_mode:0000000000000000 bno055_set_mag_operation_mode
     /tmp/ccVWLGiI.s:21888  .text.bno055_set_mag_operation_mode:00000000000000a8 $d
     /tmp/ccVWLGiI.s:21893  .text.bno055_get_mag_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:21898  .text.bno055_get_mag_power_mode:0000000000000000 bno055_get_mag_power_mode
     /tmp/ccVWLGiI.s:21994  .text.bno055_get_mag_power_mode:0000000000000054 $d
     /tmp/ccVWLGiI.s:21999  .text.bno055_set_mag_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:22004  .text.bno055_set_mag_power_mode:0000000000000000 bno055_set_mag_power_mode
     /tmp/ccVWLGiI.s:22163  .text.bno055_set_mag_power_mode:00000000000000a8 $d
     /tmp/ccVWLGiI.s:22168  .text.bno055_get_gyro_range:0000000000000000 $t
     /tmp/ccVWLGiI.s:22173  .text.bno055_get_gyro_range:0000000000000000 bno055_get_gyro_range
     /tmp/ccVWLGiI.s:22268  .text.bno055_get_gyro_range:0000000000000054 $d
     /tmp/ccVWLGiI.s:22273  .text.bno055_set_gyro_range:0000000000000000 $t
     /tmp/ccVWLGiI.s:22278  .text.bno055_set_gyro_range:0000000000000000 bno055_set_gyro_range
     /tmp/ccVWLGiI.s:22435  .text.bno055_set_gyro_range:00000000000000a0 $d
     /tmp/ccVWLGiI.s:22440  .text.bno055_get_gyro_bw:0000000000000000 $t
     /tmp/ccVWLGiI.s:22445  .text.bno055_get_gyro_bw:0000000000000000 bno055_get_gyro_bw
     /tmp/ccVWLGiI.s:22541  .text.bno055_get_gyro_bw:0000000000000054 $d
     /tmp/ccVWLGiI.s:22546  .text.bno055_get_gyro_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:22551  .text.bno055_get_gyro_power_mode:0000000000000000 bno055_get_gyro_power_mode
     /tmp/ccVWLGiI.s:22646  .text.bno055_get_gyro_power_mode:0000000000000054 $d
     /tmp/ccVWLGiI.s:22651  .text.bno055_get_accel_sleep_tmr_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:22656  .text.bno055_get_accel_sleep_tmr_mode:0000000000000000 bno055_get_accel_sleep_tmr_mode
     /tmp/ccVWLGiI.s:22751  .text.bno055_get_accel_sleep_tmr_mode:0000000000000054 $d
     /tmp/ccVWLGiI.s:22756  .text.bno055_set_accel_sleep_tmr_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:22761  .text.bno055_set_accel_sleep_tmr_mode:0000000000000000 bno055_set_accel_sleep_tmr_mode
     /tmp/ccVWLGiI.s:22918  .text.bno055_set_accel_sleep_tmr_mode:00000000000000a0 $d
ARM GAS  /tmp/ccVWLGiI.s 			page 986


     /tmp/ccVWLGiI.s:22923  .text.bno055_get_accel_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:22928  .text.bno055_get_accel_sleep_durn:0000000000000000 bno055_get_accel_sleep_durn
     /tmp/ccVWLGiI.s:23024  .text.bno055_get_accel_sleep_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:23029  .text.bno055_set_accel_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:23034  .text.bno055_set_accel_sleep_durn:0000000000000000 bno055_set_accel_sleep_durn
     /tmp/ccVWLGiI.s:23194  .text.bno055_set_accel_sleep_durn:00000000000000a8 $d
     /tmp/ccVWLGiI.s:23199  .text.bno055_get_gyro_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:23204  .text.bno055_get_gyro_sleep_durn:0000000000000000 bno055_get_gyro_sleep_durn
     /tmp/ccVWLGiI.s:23299  .text.bno055_get_gyro_sleep_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:23304  .text.bno055_set_gyro_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:23309  .text.bno055_set_gyro_sleep_durn:0000000000000000 bno055_set_gyro_sleep_durn
     /tmp/ccVWLGiI.s:23466  .text.bno055_set_gyro_sleep_durn:00000000000000a0 $d
     /tmp/ccVWLGiI.s:23471  .text.bno055_get_gyro_auto_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:23476  .text.bno055_get_gyro_auto_sleep_durn:0000000000000000 bno055_get_gyro_auto_sleep_durn
     /tmp/ccVWLGiI.s:23572  .text.bno055_get_gyro_auto_sleep_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:23577  .text.bno055_gyro_set_auto_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:23582  .text.bno055_gyro_set_auto_sleep_durn:0000000000000000 bno055_gyro_set_auto_sleep_durn
     /tmp/ccVWLGiI.s:23682  .text.bno055_gyro_set_auto_sleep_durn:0000000000000062 $d
     /tmp/ccVWLGiI.s:23690  .text.bno055_gyro_set_auto_sleep_durn:000000000000006a $t
     /tmp/ccVWLGiI.s:23785  .text.bno055_gyro_set_auto_sleep_durn:00000000000000dc $d
     /tmp/ccVWLGiI.s:23790  .text.bno055_set_gyro_bw:0000000000000000 $t
     /tmp/ccVWLGiI.s:23795  .text.bno055_set_gyro_bw:0000000000000000 bno055_set_gyro_bw
     /tmp/ccVWLGiI.s:23884  .text.bno055_set_gyro_bw:0000000000000058 $d
     /tmp/ccVWLGiI.s:24006  .text.bno055_set_gyro_bw:00000000000000ec $d
     /tmp/ccVWLGiI.s:24011  .text.bno055_set_gyro_power_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:24016  .text.bno055_set_gyro_power_mode:0000000000000000 bno055_set_gyro_power_mode
     /tmp/ccVWLGiI.s:24105  .text.bno055_set_gyro_power_mode:0000000000000058 $d
     /tmp/ccVWLGiI.s:24110  .text.bno055_set_gyro_power_mode:000000000000005c $t
     /tmp/ccVWLGiI.s:24226  .text.bno055_set_gyro_power_mode:00000000000000e4 $d
     /tmp/ccVWLGiI.s:24231  .text.bno055_get_mag_sleep_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:24236  .text.bno055_get_mag_sleep_mode:0000000000000000 bno055_get_mag_sleep_mode
     /tmp/ccVWLGiI.s:24331  .text.bno055_get_mag_sleep_mode:0000000000000054 $d
     /tmp/ccVWLGiI.s:24336  .text.bno055_set_mag_sleep_mode:0000000000000000 $t
     /tmp/ccVWLGiI.s:24341  .text.bno055_set_mag_sleep_mode:0000000000000000 bno055_set_mag_sleep_mode
     /tmp/ccVWLGiI.s:24490  .text.bno055_set_mag_sleep_mode:000000000000009c $d
     /tmp/ccVWLGiI.s:24495  .text.bno055_get_mag_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:24500  .text.bno055_get_mag_sleep_durn:0000000000000000 bno055_get_mag_sleep_durn
     /tmp/ccVWLGiI.s:24596  .text.bno055_get_mag_sleep_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:24601  .text.bno055_set_mag_sleep_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:24606  .text.bno055_set_mag_sleep_durn:0000000000000000 bno055_set_mag_sleep_durn
     /tmp/ccVWLGiI.s:24757  .text.bno055_set_mag_sleep_durn:00000000000000a0 $d
     /tmp/ccVWLGiI.s:24762  .text.bno055_get_intr_mask_gyro_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:24767  .text.bno055_get_intr_mask_gyro_any_motion:0000000000000000 bno055_get_intr_mask_gyro_any_motion
     /tmp/ccVWLGiI.s:24863  .text.bno055_get_intr_mask_gyro_any_motion:0000000000000054 $d
     /tmp/ccVWLGiI.s:24868  .text.bno055_set_intr_mask_gyro_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:24873  .text.bno055_set_intr_mask_gyro_any_motion:0000000000000000 bno055_set_intr_mask_gyro_any_motion
     /tmp/ccVWLGiI.s:25000  .text.bno055_set_intr_mask_gyro_any_motion:0000000000000078 $d
     /tmp/ccVWLGiI.s:25005  .text.bno055_get_intr_mask_gyro_highrate:0000000000000000 $t
     /tmp/ccVWLGiI.s:25010  .text.bno055_get_intr_mask_gyro_highrate:0000000000000000 bno055_get_intr_mask_gyro_highrate
     /tmp/ccVWLGiI.s:25106  .text.bno055_get_intr_mask_gyro_highrate:0000000000000054 $d
     /tmp/ccVWLGiI.s:25111  .text.bno055_set_intr_mask_gyro_highrate:0000000000000000 $t
     /tmp/ccVWLGiI.s:25116  .text.bno055_set_intr_mask_gyro_highrate:0000000000000000 bno055_set_intr_mask_gyro_highrate
     /tmp/ccVWLGiI.s:25243  .text.bno055_set_intr_mask_gyro_highrate:0000000000000078 $d
     /tmp/ccVWLGiI.s:25248  .text.bno055_get_intr_mask_accel_high_g:0000000000000000 $t
     /tmp/ccVWLGiI.s:25253  .text.bno055_get_intr_mask_accel_high_g:0000000000000000 bno055_get_intr_mask_accel_high_g
     /tmp/ccVWLGiI.s:25349  .text.bno055_get_intr_mask_accel_high_g:0000000000000054 $d
     /tmp/ccVWLGiI.s:25354  .text.bno055_set_intr_mask_accel_high_g:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 987


     /tmp/ccVWLGiI.s:25359  .text.bno055_set_intr_mask_accel_high_g:0000000000000000 bno055_set_intr_mask_accel_high_g
     /tmp/ccVWLGiI.s:25486  .text.bno055_set_intr_mask_accel_high_g:0000000000000078 $d
     /tmp/ccVWLGiI.s:25491  .text.bno055_get_intr_mask_accel_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:25496  .text.bno055_get_intr_mask_accel_any_motion:0000000000000000 bno055_get_intr_mask_accel_any_motion
     /tmp/ccVWLGiI.s:25592  .text.bno055_get_intr_mask_accel_any_motion:0000000000000054 $d
     /tmp/ccVWLGiI.s:25597  .text.bno055_set_intr_mask_accel_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:25602  .text.bno055_set_intr_mask_accel_any_motion:0000000000000000 bno055_set_intr_mask_accel_any_motion
     /tmp/ccVWLGiI.s:25729  .text.bno055_set_intr_mask_accel_any_motion:0000000000000078 $d
     /tmp/ccVWLGiI.s:25734  .text.bno055_get_intr_mask_accel_no_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:25739  .text.bno055_get_intr_mask_accel_no_motion:0000000000000000 bno055_get_intr_mask_accel_no_motion
     /tmp/ccVWLGiI.s:25835  .text.bno055_get_intr_mask_accel_no_motion:0000000000000054 $d
     /tmp/ccVWLGiI.s:25840  .text.bno055_set_intr_mask_accel_no_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:25845  .text.bno055_set_intr_mask_accel_no_motion:0000000000000000 bno055_set_intr_mask_accel_no_motion
     /tmp/ccVWLGiI.s:25969  .text.bno055_set_intr_mask_accel_no_motion:0000000000000074 $d
     /tmp/ccVWLGiI.s:25974  .text.bno055_get_intr_gyro_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:25979  .text.bno055_get_intr_gyro_any_motion:0000000000000000 bno055_get_intr_gyro_any_motion
     /tmp/ccVWLGiI.s:26075  .text.bno055_get_intr_gyro_any_motion:0000000000000054 $d
     /tmp/ccVWLGiI.s:26080  .text.bno055_set_intr_gyro_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:26085  .text.bno055_set_intr_gyro_any_motion:0000000000000000 bno055_set_intr_gyro_any_motion
     /tmp/ccVWLGiI.s:26212  .text.bno055_set_intr_gyro_any_motion:0000000000000078 $d
     /tmp/ccVWLGiI.s:26217  .text.bno055_get_intr_gyro_highrate:0000000000000000 $t
     /tmp/ccVWLGiI.s:26222  .text.bno055_get_intr_gyro_highrate:0000000000000000 bno055_get_intr_gyro_highrate
     /tmp/ccVWLGiI.s:26318  .text.bno055_get_intr_gyro_highrate:0000000000000054 $d
     /tmp/ccVWLGiI.s:26323  .text.bno055_set_intr_gyro_highrate:0000000000000000 $t
     /tmp/ccVWLGiI.s:26328  .text.bno055_set_intr_gyro_highrate:0000000000000000 bno055_set_intr_gyro_highrate
     /tmp/ccVWLGiI.s:26455  .text.bno055_set_intr_gyro_highrate:0000000000000078 $d
     /tmp/ccVWLGiI.s:26460  .text.bno055_get_intr_accel_high_g:0000000000000000 $t
     /tmp/ccVWLGiI.s:26465  .text.bno055_get_intr_accel_high_g:0000000000000000 bno055_get_intr_accel_high_g
     /tmp/ccVWLGiI.s:26561  .text.bno055_get_intr_accel_high_g:0000000000000054 $d
     /tmp/ccVWLGiI.s:26566  .text.bno055_set_intr_accel_high_g:0000000000000000 $t
     /tmp/ccVWLGiI.s:26571  .text.bno055_set_intr_accel_high_g:0000000000000000 bno055_set_intr_accel_high_g
     /tmp/ccVWLGiI.s:26698  .text.bno055_set_intr_accel_high_g:0000000000000078 $d
     /tmp/ccVWLGiI.s:26703  .text.bno055_get_intr_accel_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:26708  .text.bno055_get_intr_accel_any_motion:0000000000000000 bno055_get_intr_accel_any_motion
     /tmp/ccVWLGiI.s:26804  .text.bno055_get_intr_accel_any_motion:0000000000000054 $d
     /tmp/ccVWLGiI.s:26809  .text.bno055_set_intr_accel_any_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:26814  .text.bno055_set_intr_accel_any_motion:0000000000000000 bno055_set_intr_accel_any_motion
     /tmp/ccVWLGiI.s:26941  .text.bno055_set_intr_accel_any_motion:0000000000000078 $d
     /tmp/ccVWLGiI.s:26946  .text.bno055_get_intr_accel_no_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:26951  .text.bno055_get_intr_accel_no_motion:0000000000000000 bno055_get_intr_accel_no_motion
     /tmp/ccVWLGiI.s:27047  .text.bno055_get_intr_accel_no_motion:0000000000000054 $d
     /tmp/ccVWLGiI.s:27052  .text.bno055_set_intr_accel_no_motion:0000000000000000 $t
     /tmp/ccVWLGiI.s:27057  .text.bno055_set_intr_accel_no_motion:0000000000000000 bno055_set_intr_accel_no_motion
     /tmp/ccVWLGiI.s:27181  .text.bno055_set_intr_accel_no_motion:0000000000000074 $d
     /tmp/ccVWLGiI.s:27186  .text.bno055_get_accel_any_motion_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:27191  .text.bno055_get_accel_any_motion_thres:0000000000000000 bno055_get_accel_any_motion_thres
     /tmp/ccVWLGiI.s:27285  .text.bno055_get_accel_any_motion_thres:0000000000000050 $d
     /tmp/ccVWLGiI.s:27290  .text.bno055_set_accel_any_motion_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:27295  .text.bno055_set_accel_any_motion_thres:0000000000000000 bno055_set_accel_any_motion_thres
     /tmp/ccVWLGiI.s:27435  .text.bno055_set_accel_any_motion_thres:0000000000000090 $d
     /tmp/ccVWLGiI.s:27440  .text.bno055_get_accel_any_motion_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:27445  .text.bno055_get_accel_any_motion_durn:0000000000000000 bno055_get_accel_any_motion_durn
     /tmp/ccVWLGiI.s:27540  .text.bno055_get_accel_any_motion_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:27545  .text.bno055_set_accel_any_motion_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:27550  .text.bno055_set_accel_any_motion_durn:0000000000000000 bno055_set_accel_any_motion_durn
     /tmp/ccVWLGiI.s:27697  .text.bno055_set_accel_any_motion_durn:000000000000009c $d
     /tmp/ccVWLGiI.s:27702  .text.bno055_get_accel_any_motion_no_motion_axis_enable:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 988


     /tmp/ccVWLGiI.s:27707  .text.bno055_get_accel_any_motion_no_motion_axis_enable:0000000000000000 bno055_get_accel_any_motion_no_motion_axis_enable
     /tmp/ccVWLGiI.s:27874  .text.bno055_get_accel_any_motion_no_motion_axis_enable:00000000000000a8 $d
     /tmp/ccVWLGiI.s:27879  .text.bno055_set_accel_any_motion_no_motion_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:27884  .text.bno055_set_accel_any_motion_no_motion_axis_enable:0000000000000000 bno055_set_accel_any_motion_no_motion_axis_enable
     /tmp/ccVWLGiI.s:28128  .text.bno055_set_accel_any_motion_no_motion_axis_enable:0000000000000134 $d
     /tmp/ccVWLGiI.s:28133  .text.bno055_get_accel_high_g_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:28138  .text.bno055_get_accel_high_g_axis_enable:0000000000000000 bno055_get_accel_high_g_axis_enable
     /tmp/ccVWLGiI.s:28305  .text.bno055_get_accel_high_g_axis_enable:00000000000000a8 $d
     /tmp/ccVWLGiI.s:28310  .text.bno055_set_accel_high_g_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:28315  .text.bno055_set_accel_high_g_axis_enable:0000000000000000 bno055_set_accel_high_g_axis_enable
     /tmp/ccVWLGiI.s:28557  .text.bno055_set_accel_high_g_axis_enable:000000000000012c $d
     /tmp/ccVWLGiI.s:28562  .text.bno055_get_accel_high_g_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:28567  .text.bno055_get_accel_high_g_durn:0000000000000000 bno055_get_accel_high_g_durn
     /tmp/ccVWLGiI.s:28661  .text.bno055_get_accel_high_g_durn:0000000000000050 $d
     /tmp/ccVWLGiI.s:28666  .text.bno055_set_accel_high_g_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:28671  .text.bno055_set_accel_high_g_durn:0000000000000000 bno055_set_accel_high_g_durn
     /tmp/ccVWLGiI.s:28814  .text.bno055_set_accel_high_g_durn:0000000000000090 $d
     /tmp/ccVWLGiI.s:28819  .text.bno055_get_accel_high_g_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:28824  .text.bno055_get_accel_high_g_thres:0000000000000000 bno055_get_accel_high_g_thres
     /tmp/ccVWLGiI.s:28918  .text.bno055_get_accel_high_g_thres:0000000000000050 $d
     /tmp/ccVWLGiI.s:28923  .text.bno055_set_accel_high_g_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:28928  .text.bno055_set_accel_high_g_thres:0000000000000000 bno055_set_accel_high_g_thres
     /tmp/ccVWLGiI.s:29071  .text.bno055_set_accel_high_g_thres:0000000000000090 $d
     /tmp/ccVWLGiI.s:29076  .text.bno055_get_accel_slow_no_motion_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:29081  .text.bno055_get_accel_slow_no_motion_thres:0000000000000000 bno055_get_accel_slow_no_motion_thres
     /tmp/ccVWLGiI.s:29175  .text.bno055_get_accel_slow_no_motion_thres:0000000000000050 $d
     /tmp/ccVWLGiI.s:29180  .text.bno055_set_accel_slow_no_motion_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:29185  .text.bno055_set_accel_slow_no_motion_thres:0000000000000000 bno055_set_accel_slow_no_motion_thres
     /tmp/ccVWLGiI.s:29326  .text.bno055_set_accel_slow_no_motion_thres:0000000000000090 $d
     /tmp/ccVWLGiI.s:29331  .text.bno055_get_accel_slow_no_motion_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:29336  .text.bno055_get_accel_slow_no_motion_enable:0000000000000000 bno055_get_accel_slow_no_motion_enable
     /tmp/ccVWLGiI.s:29431  .text.bno055_get_accel_slow_no_motion_enable:0000000000000054 $d
     /tmp/ccVWLGiI.s:29436  .text.bno055_set_accel_slow_no_motion_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:29441  .text.bno055_set_accel_slow_no_motion_enable:0000000000000000 bno055_set_accel_slow_no_motion_enable
     /tmp/ccVWLGiI.s:29589  .text.bno055_set_accel_slow_no_motion_enable:000000000000009c $d
     /tmp/ccVWLGiI.s:29594  .text.bno055_get_accel_slow_no_motion_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:29599  .text.bno055_get_accel_slow_no_motion_durn:0000000000000000 bno055_get_accel_slow_no_motion_durn
     /tmp/ccVWLGiI.s:29695  .text.bno055_get_accel_slow_no_motion_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:29700  .text.bno055_set_accel_slow_no_motion_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:29705  .text.bno055_set_accel_slow_no_motion_durn:0000000000000000 bno055_set_accel_slow_no_motion_durn
     /tmp/ccVWLGiI.s:29855  .text.bno055_set_accel_slow_no_motion_durn:00000000000000a0 $d
     /tmp/ccVWLGiI.s:29860  .text.bno055_get_gyro_any_motion_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:29865  .text.bno055_get_gyro_any_motion_axis_enable:0000000000000000 bno055_get_gyro_any_motion_axis_enable
     /tmp/ccVWLGiI.s:30031  .text.bno055_get_gyro_any_motion_axis_enable:00000000000000a8 $d
     /tmp/ccVWLGiI.s:30036  .text.bno055_set_gyro_any_motion_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:30041  .text.bno055_set_gyro_any_motion_axis_enable:0000000000000000 bno055_set_gyro_any_motion_axis_enable
     /tmp/ccVWLGiI.s:30291  .text.bno055_set_gyro_any_motion_axis_enable:0000000000000134 $d
     /tmp/ccVWLGiI.s:30296  .text.bno055_get_gyro_highrate_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:30301  .text.bno055_get_gyro_highrate_axis_enable:0000000000000000 bno055_get_gyro_highrate_axis_enable
     /tmp/ccVWLGiI.s:30468  .text.bno055_get_gyro_highrate_axis_enable:00000000000000a8 $d
     /tmp/ccVWLGiI.s:30473  .text.bno055_set_gyro_highrate_axis_enable:0000000000000000 $t
     /tmp/ccVWLGiI.s:30478  .text.bno055_set_gyro_highrate_axis_enable:0000000000000000 bno055_set_gyro_highrate_axis_enable
     /tmp/ccVWLGiI.s:30726  .text.bno055_set_gyro_highrate_axis_enable:0000000000000134 $d
     /tmp/ccVWLGiI.s:30731  .text.bno055_get_gyro_any_motion_filter:0000000000000000 $t
     /tmp/ccVWLGiI.s:30736  .text.bno055_get_gyro_any_motion_filter:0000000000000000 bno055_get_gyro_any_motion_filter
     /tmp/ccVWLGiI.s:30832  .text.bno055_get_gyro_any_motion_filter:0000000000000054 $d
     /tmp/ccVWLGiI.s:30837  .text.bno055_set_gyro_any_motion_filter:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 989


     /tmp/ccVWLGiI.s:30842  .text.bno055_set_gyro_any_motion_filter:0000000000000000 bno055_set_gyro_any_motion_filter
     /tmp/ccVWLGiI.s:30992  .text.bno055_set_gyro_any_motion_filter:00000000000000a0 $d
     /tmp/ccVWLGiI.s:30997  .text.bno055_get_gyro_highrate_filter:0000000000000000 $t
     /tmp/ccVWLGiI.s:31002  .text.bno055_get_gyro_highrate_filter:0000000000000000 bno055_get_gyro_highrate_filter
     /tmp/ccVWLGiI.s:31098  .text.bno055_get_gyro_highrate_filter:0000000000000054 $d
     /tmp/ccVWLGiI.s:31103  .text.bno055_set_gyro_highrate_filter:0000000000000000 $t
     /tmp/ccVWLGiI.s:31108  .text.bno055_set_gyro_highrate_filter:0000000000000000 bno055_set_gyro_highrate_filter
     /tmp/ccVWLGiI.s:31256  .text.bno055_set_gyro_highrate_filter:000000000000009c $d
     /tmp/ccVWLGiI.s:31261  .text.bno055_get_gyro_highrate_x_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:31266  .text.bno055_get_gyro_highrate_x_thres:0000000000000000 bno055_get_gyro_highrate_x_thres
     /tmp/ccVWLGiI.s:31361  .text.bno055_get_gyro_highrate_x_thres:0000000000000054 $d
     /tmp/ccVWLGiI.s:31366  .text.bno055_set_gyro_highrate_x_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:31371  .text.bno055_set_gyro_highrate_x_thres:0000000000000000 bno055_set_gyro_highrate_x_thres
     /tmp/ccVWLGiI.s:31519  .text.bno055_set_gyro_highrate_x_thres:000000000000009c $d
     /tmp/ccVWLGiI.s:31524  .text.bno055_get_gyro_highrate_x_hyst:0000000000000000 $t
     /tmp/ccVWLGiI.s:31529  .text.bno055_get_gyro_highrate_x_hyst:0000000000000000 bno055_get_gyro_highrate_x_hyst
     /tmp/ccVWLGiI.s:31625  .text.bno055_get_gyro_highrate_x_hyst:0000000000000054 $d
     /tmp/ccVWLGiI.s:31630  .text.bno055_set_gyro_highrate_x_hyst:0000000000000000 $t
     /tmp/ccVWLGiI.s:31635  .text.bno055_set_gyro_highrate_x_hyst:0000000000000000 bno055_set_gyro_highrate_x_hyst
     /tmp/ccVWLGiI.s:31785  .text.bno055_set_gyro_highrate_x_hyst:00000000000000a0 $d
     /tmp/ccVWLGiI.s:31790  .text.bno055_get_gyro_highrate_x_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:31795  .text.bno055_get_gyro_highrate_x_durn:0000000000000000 bno055_get_gyro_highrate_x_durn
     /tmp/ccVWLGiI.s:31889  .text.bno055_get_gyro_highrate_x_durn:0000000000000050 $d
     /tmp/ccVWLGiI.s:31894  .text.bno055_set_gyro_highrate_x_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:31899  .text.bno055_set_gyro_highrate_x_durn:0000000000000000 bno055_set_gyro_highrate_x_durn
     /tmp/ccVWLGiI.s:32040  .text.bno055_set_gyro_highrate_x_durn:0000000000000090 $d
     /tmp/ccVWLGiI.s:32045  .text.bno055_get_gyro_highrate_y_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:32050  .text.bno055_get_gyro_highrate_y_thres:0000000000000000 bno055_get_gyro_highrate_y_thres
     /tmp/ccVWLGiI.s:32145  .text.bno055_get_gyro_highrate_y_thres:0000000000000054 $d
     /tmp/ccVWLGiI.s:32150  .text.bno055_set_gyro_highrate_y_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:32155  .text.bno055_set_gyro_highrate_y_thres:0000000000000000 bno055_set_gyro_highrate_y_thres
     /tmp/ccVWLGiI.s:32303  .text.bno055_set_gyro_highrate_y_thres:000000000000009c $d
     /tmp/ccVWLGiI.s:32308  .text.bno055_get_gyro_highrate_y_hyst:0000000000000000 $t
     /tmp/ccVWLGiI.s:32313  .text.bno055_get_gyro_highrate_y_hyst:0000000000000000 bno055_get_gyro_highrate_y_hyst
     /tmp/ccVWLGiI.s:32409  .text.bno055_get_gyro_highrate_y_hyst:0000000000000054 $d
     /tmp/ccVWLGiI.s:32414  .text.bno055_set_gyro_highrate_y_hyst:0000000000000000 $t
     /tmp/ccVWLGiI.s:32419  .text.bno055_set_gyro_highrate_y_hyst:0000000000000000 bno055_set_gyro_highrate_y_hyst
     /tmp/ccVWLGiI.s:32569  .text.bno055_set_gyro_highrate_y_hyst:00000000000000a0 $d
     /tmp/ccVWLGiI.s:32574  .text.bno055_get_gyro_highrate_y_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:32579  .text.bno055_get_gyro_highrate_y_durn:0000000000000000 bno055_get_gyro_highrate_y_durn
     /tmp/ccVWLGiI.s:32673  .text.bno055_get_gyro_highrate_y_durn:0000000000000050 $d
     /tmp/ccVWLGiI.s:32678  .text.bno055_set_gyro_highrate_y_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:32683  .text.bno055_set_gyro_highrate_y_durn:0000000000000000 bno055_set_gyro_highrate_y_durn
     /tmp/ccVWLGiI.s:32824  .text.bno055_set_gyro_highrate_y_durn:0000000000000090 $d
     /tmp/ccVWLGiI.s:32829  .text.bno055_get_gyro_highrate_z_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:32834  .text.bno055_get_gyro_highrate_z_thres:0000000000000000 bno055_get_gyro_highrate_z_thres
     /tmp/ccVWLGiI.s:32929  .text.bno055_get_gyro_highrate_z_thres:0000000000000054 $d
     /tmp/ccVWLGiI.s:32934  .text.bno055_set_gyro_highrate_z_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:32939  .text.bno055_set_gyro_highrate_z_thres:0000000000000000 bno055_set_gyro_highrate_z_thres
     /tmp/ccVWLGiI.s:33087  .text.bno055_set_gyro_highrate_z_thres:000000000000009c $d
     /tmp/ccVWLGiI.s:33092  .text.bno055_get_gyro_highrate_z_hyst:0000000000000000 $t
     /tmp/ccVWLGiI.s:33097  .text.bno055_get_gyro_highrate_z_hyst:0000000000000000 bno055_get_gyro_highrate_z_hyst
     /tmp/ccVWLGiI.s:33193  .text.bno055_get_gyro_highrate_z_hyst:0000000000000054 $d
     /tmp/ccVWLGiI.s:33198  .text.bno055_set_gyro_highrate_z_hyst:0000000000000000 $t
     /tmp/ccVWLGiI.s:33203  .text.bno055_set_gyro_highrate_z_hyst:0000000000000000 bno055_set_gyro_highrate_z_hyst
     /tmp/ccVWLGiI.s:33353  .text.bno055_set_gyro_highrate_z_hyst:00000000000000a0 $d
     /tmp/ccVWLGiI.s:33358  .text.bno055_get_gyro_highrate_z_durn:0000000000000000 $t
ARM GAS  /tmp/ccVWLGiI.s 			page 990


     /tmp/ccVWLGiI.s:33363  .text.bno055_get_gyro_highrate_z_durn:0000000000000000 bno055_get_gyro_highrate_z_durn
     /tmp/ccVWLGiI.s:33457  .text.bno055_get_gyro_highrate_z_durn:0000000000000050 $d
     /tmp/ccVWLGiI.s:33462  .text.bno055_set_gyro_highrate_z_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:33467  .text.bno055_set_gyro_highrate_z_durn:0000000000000000 bno055_set_gyro_highrate_z_durn
     /tmp/ccVWLGiI.s:33607  .text.bno055_set_gyro_highrate_z_durn:0000000000000090 $d
     /tmp/ccVWLGiI.s:33612  .text.bno055_get_gyro_any_motion_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:33617  .text.bno055_get_gyro_any_motion_thres:0000000000000000 bno055_get_gyro_any_motion_thres
     /tmp/ccVWLGiI.s:33712  .text.bno055_get_gyro_any_motion_thres:0000000000000054 $d
     /tmp/ccVWLGiI.s:33717  .text.bno055_set_gyro_any_motion_thres:0000000000000000 $t
     /tmp/ccVWLGiI.s:33722  .text.bno055_set_gyro_any_motion_thres:0000000000000000 bno055_set_gyro_any_motion_thres
     /tmp/ccVWLGiI.s:33870  .text.bno055_set_gyro_any_motion_thres:000000000000009c $d
     /tmp/ccVWLGiI.s:33875  .text.bno055_get_gyro_any_motion_slope_samples:0000000000000000 $t
     /tmp/ccVWLGiI.s:33880  .text.bno055_get_gyro_any_motion_slope_samples:0000000000000000 bno055_get_gyro_any_motion_slope_samples
     /tmp/ccVWLGiI.s:33975  .text.bno055_get_gyro_any_motion_slope_samples:0000000000000054 $d
     /tmp/ccVWLGiI.s:33980  .text.bno055_set_gyro_any_motion_slope_samples:0000000000000000 $t
     /tmp/ccVWLGiI.s:33985  .text.bno055_set_gyro_any_motion_slope_samples:0000000000000000 bno055_set_gyro_any_motion_slope_samples
     /tmp/ccVWLGiI.s:34132  .text.bno055_set_gyro_any_motion_slope_samples:000000000000009c $d
     /tmp/ccVWLGiI.s:34137  .text.bno055_get_gyro_any_motion_awake_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:34142  .text.bno055_get_gyro_any_motion_awake_durn:0000000000000000 bno055_get_gyro_any_motion_awake_durn
     /tmp/ccVWLGiI.s:34237  .text.bno055_get_gyro_any_motion_awake_durn:0000000000000054 $d
     /tmp/ccVWLGiI.s:34242  .text.bno055_set_gyro_any_motion_awake_durn:0000000000000000 $t
     /tmp/ccVWLGiI.s:34247  .text.bno055_set_gyro_any_motion_awake_durn:0000000000000000 bno055_set_gyro_any_motion_awake_durn
     /tmp/ccVWLGiI.s:34398  .text.bno055_set_gyro_any_motion_awake_durn:00000000000000a0 $d
     /tmp/ccVWLGiI.s:34403  .bss.p_bno055:0000000000000000 $d
     /tmp/ccVWLGiI.s:34407  .bss.p_bno055:0000000000000000 p_bno055
                     .debug_frame:0000000000000010 $d
     /tmp/ccVWLGiI.s:23892  .text.bno055_set_gyro_bw:000000000000005f $d
     /tmp/ccVWLGiI.s:23892  .text.bno055_set_gyro_bw:0000000000000060 $t

UNDEFINED SYMBOLS
__aeabi_i2d
__aeabi_dmul
__aeabi_d2f
__aeabi_ddiv
__aeabi_i2f
__aeabi_dadd
